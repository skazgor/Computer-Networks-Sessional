COMPLEXITY, CODE
4,public class C{  public static void main(String[] args) throws IOException {      read();  int t= RI();  while(t-->0) {  read();  int n = RI();  List<Integer> cur = new ArrayList<Integer>();  int[] lvl = new int[n+10];  while(n-->0) {   read();   int x = RI();     if (cur.size() == 0) {   cur.add(x);   lvl[cur.size()]=x;   }   else {   while (!cur.isEmpty()) {    if (x == 1+lvl[cur.size()]) {    int size = cur.size();    cur.remove(size-1);    cur.add(1+lvl[size]);    lvl[size] = x;    break;    }    else {        if (x == 1) {         cur.add(x);     lvl[cur.size()] = x;     break;    }    else {     lvl[cur.size()] = 0;     cur.remove(cur.size()-1);    }    }   }   if (cur.size() == 0) {    cur.add(x);    lvl[cur.size()]=x;   }   }        for (int i = 0; i < cur.size(); i++) {   out.print(cur.get(i));   if (i != cur.size()-1) out.print(".");   }   out.println();  }  }  out.close(); }  static BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out)); static StringTokenizer st; static void read() throws IOException{st = new StringTokenizer(br.readLine());}  static int RI() throws IOException{return Integer.parseInt(st.nextToken());} static long RL() throws IOException{return Long.parseLong(st.nextToken());} static double RD() throws IOException{return Double.parseDouble(st.nextToken());}  }
1,public class Main {  public static void main(String[] args) {  Scanner s = new Scanner(System.in);  int n = s.nextInt(), d = s.nextInt();  int[] arr = new int[n];  for(int i = 0; i < n; i++){  arr[i] = s.nextInt();  }  Arrays.sort(arr);  int count = 0;  for(int i = 1; i < n; i++){  int dist = arr[i] - arr[i - 1];  if(dist > 2 * d){   count += 2;  }else if(dist == 2 * d){   count++;  }    }  System.out.println(count + 2);  } }
4,public class CF1185G2 { static final int MD = 1000000007; static int[][] solve1(int[] aa, int t, int n) {  int[][] da = new int[t + 1][n + 1];  da[0][0] = 1;  for (int i = 0; i < n; i++) {  int a = aa[i];  for (int s = t - 1; s >= 0; s--)   for (int m = 0; m < n; m++) {   int x = da[s][m];   if (x != 0) {    int s_ = s + a;    if (s_ <= t)    da[s_][m + 1] = (da[s_][m + 1] + x) % MD;   }   }  }  return da; } static int[][][] solve2(int[] aa, int[] bb, int t, int na, int nb) {  int[][] da = solve1(aa, t, na);  int[][][] dab = new int[t + 1][na + 1][nb + 1];  for (int s = 0; s <= t; s++)  for (int ma = 0; ma <= na; ma++)   dab[s][ma][0] = da[s][ma];  for (int i = 0; i < nb; i++) {  int b = bb[i];  for (int s = t - 1; s >= 0; s--)   for (int ma = 0; ma <= na; ma++)   for (int mb = 0; mb < nb; mb++) {    int x = dab[s][ma][mb];    if (x != 0) {    int s_ = s + b;    if (s_ <= t)     dab[s_][ma][mb + 1] = (dab[s_][ma][mb + 1] + x) % MD;    }   }  }  return dab; } static long power(int a, int k) {  if (k == 0)  return 1;  long p = power(a, k / 2);  p = p * p % MD;  if (k % 2 == 1)  p = p * a % MD;  return p; } static int[] ff, gg; static int ch(int n, int k) {  return (int) ((long) ff[n] * gg[n - k] % MD * gg[k] % MD); } static int[][][] init(int n, int na, int nb, int nc) {  ff = new int[n + 1];  gg = new int[n + 1];  for (int i = 0, f = 1; i <= n; i++) {  ff[i] = f;  gg[i] = (int) power(f, MD - 2);  f = (int) ((long) f * (i + 1) % MD);  }  int[][][] dp = new int[na + 1][nb + 1][nc + 1];  for (int ma = 0; ma <= na; ma++)  for (int mb = 0; mb <= nb; mb++)   for (int mc = 0; mc <= nc; mc++) {   int x = (int) ((long) ff[ma + mb + mc] * gg[ma] % MD * gg[mb] % MD * gg[mc] % MD);   for (int ma_ = ma == 0 ? 0 : 1; ma_ <= ma; ma_++) {    int cha = ma == 0 ? 1 : ch(ma - 1, ma_ - 1);    for (int mb_ = mb == 0 ? 0 : 1; mb_ <= mb; mb_++) {    int chb = mb == 0 ? 1 : ch(mb - 1, mb_ - 1);    for (int mc_ = mc == 0 ? 0 : 1; mc_ <= mc; mc_++) {     int chc = mc == 0 ? 1 : ch(mc - 1, mc_ - 1);     int y = dp[ma_][mb_][mc_];     if (y == 0)     continue;     x = (int) ((x - (long) y * cha % MD * chb % MD * chc) % MD);    }    }   }   if (x < 0)    x += MD;   dp[ma][mb][mc] = x;   }  for (int ma = 0; ma <= na; ma++)  for (int mb = 0; mb <= nb; mb++)   for (int mc = 0; mc <= nc; mc++)   dp[ma][mb][mc] = (int) ((long) dp[ma][mb][mc] * ff[ma] % MD * ff[mb] % MD * ff[mc] % MD);  return dp; } public static void main(String[] args) throws IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer(br.readLine());  int n = Integer.parseInt(st.nextToken());  int t = Integer.parseInt(st.nextToken());  int[] aa = new int[n];  int[] bb = new int[n];  int[] cc = new int[n];  int na = 0, nb = 0, nc = 0;  for (int i = 0; i < n; i++) {  st = new StringTokenizer(br.readLine());  int a = Integer.parseInt(st.nextToken());  int g = Integer.parseInt(st.nextToken());  if (g == 1)   aa[na++] = a;  else if (g == 2)   bb[nb++] = a;  else   cc[nc++] = a;  }  int[][][] dp = init(n, na, nb, nc);  int[][][] dab = solve2(aa, bb, t, na, nb);  int[][] dc = solve1(cc, t, nc);  int ans = 0;  for (int tab = 0; tab <= t; tab++) {  int tc = t - tab;  for (int ma = 0; ma <= na; ma++)   for (int mb = 0; mb <= nb; mb++) {   int xab = dab[tab][ma][mb];   if (xab == 0)    continue;   for (int mc = 0; mc <= nc; mc++) {    int xc = dc[tc][mc];    if (xc == 0)    continue;    ans = (int) ((ans + (long) xab * xc % MD * dp[ma][mb][mc]) % MD);   }   }  }  System.out.println(ans); } }
3,public class SameSumBlocksHard {  public static void main(String[] args) {  Scanner in = new Scanner(System.in);  int n = in .nextInt();  long[] a = new long[n + 1];  long[] sum = new long[n + 1];  for (int i = 1; i <= n; i++) {  a[i] = in.nextInt();  sum[i] = sum[i - 1] + a[i];  }  Map<Long, List<int[]>> map = new HashMap<>();  for (int i = 1; i <= n; i++) {  for (int j = i; j <= n; j++) {   long x = sum[j] - sum[i - 1];   List<int[]> list = map.get(x);   if (list == null) {   list = new ArrayList<>();   map.put(x, list);   }   list.add(new int[] {i, j});  }  }  List<int[]> ans = new ArrayList<>();  for (Map.Entry<Long, List<int[]>> entry : map.entrySet()) {  List<int[]> list = entry.getValue();  List<int[]> tmp = new ArrayList<>();  calc(list, tmp);  if (tmp.size() > ans.size()) {   ans.clear();   ans.addAll(tmp);  }  }  System.out.println(ans.size());  for (int[] pair : ans) {  System.out.println(pair[0] + " " + pair[1]);  }  in.close(); }  static void calc(List<int[]> list, List<int[]> tmp) {  Collections.sort(list, new Comparator<int[]>() {  @Override  public int compare(int[] o1, int[] o2) {   if (o1[1] < o2[1]) {   return -1;   } else if (o1[1] > o2[1]) {   return 1;   } else {   return 0;   }  }  });  int last = -1;  for (int[] p : list) {  if (last == -1) {   last = p[1];   tmp.add(p);  } else if (p[0] > last) {   last = p[1];   tmp.add(p);  }  } } }
6,public class Solution {  public void doMain() throws Exception {   Scanner sc = new Scanner(System.in);   int n = sc.nextInt(), m = sc.nextInt();   boolean[][] adj = new boolean[n][n];   for (int i=0; i<m; i++) {    int a = sc.nextInt()-1, b = sc.nextInt()-1;    adj[a][b] = adj[b][a] = true;   }     long res = 0;     for (int st=0; st+1<n; st++) {       long[][] numWays = new long[1<<(n-st-1)][n-st-1];    for (int i=st+1; i<n; i++)     if (adj[st][i]) numWays[1<<(i-st-1)][i-st-1] = 1;       for (int mask=1; mask < (1<<(n-st-1)); mask++) {     boolean simple = ((mask & (mask-1)) == 0);     for (int last=0; last<n-st-1; last++) if (numWays[mask][last]!=0) {      if (adj[last+st+1][st] && !simple) res += numWays[mask][last];      for (int next=0; next<n-st-1; next++)       if (adj[last+st+1][next+st+1] && (mask & (1<<next)) == 0)        numWays[mask | (1<<next)][next] += numWays[mask][last];     }    }   }     System.out.println(res/2);  }  public static void main(String[] args) throws Exception {   (new Solution()).doMain();  } }
1,public class B14G {  public static void main(String[] args) throws IOException {   init_io();   int t = nint();   while(t-- > 0) {    int N = nint();    if (N % 2 != 0) {     out.println("NO"); continue;    }    N /= 2;    int sqrt = (int)(Math.round(Math.sqrt(N)));    int sqrt2 = (int)(Math.round(Math.sqrt(N/2)));    if (sqrt * sqrt == N || sqrt2 * sqrt2 * 2 == N) {     out.println("YES");    }    else {     out.println("NO");    }   }   out.close();  }  static StreamTokenizer in;  static PrintWriter out;  static BufferedReader br;  static int nint() throws IOException {   in.nextToken();   return (int) in.nval;  }  static void init_io() throws IOException {   br = new BufferedReader(new InputStreamReader(System.in));   in = new StreamTokenizer(br);   out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));  } }
1,public class Main {  public static void main(String[] args) {   Scanner reader = new Scanner(System.in);   int n = reader.nextInt();   long d = reader.nextLong();   int[] a = new int[n];   for(int i = 0; i < n; i++)    a[i] = reader.nextInt();   Arrays.sort(a);   int ans = 2;   for(int i = 0; i < n - 1; i++){    if(a[i + 1] - a[i] > 2 * d) {     ans += 2;    }    else if(a[i + 1] - a[i] == 2 * d)     ans++;   }   System.out.println(ans);  } }
4,public class GG {  public static void main(String[] args) {   FastScanner scanner = new FastScanner();   PrintWriter out = new PrintWriter(System.out);   int N = scanner.nextInt();   int M = scanner.nextInt();   int K = scanner.nextInt();   int C = scanner.nextInt();   int D = scanner.nextInt();   MinCostMaxFlowSolver solver = new EdmondsKarp();   int[] people = new int[K];   for(int i = 0; i < K; i++) people[i] = scanner.nextInt()-1;   Node src = solver.addNode();   Node snk = solver.addNode();   int amt = 150;   Node[][] timeNodes = new Node[N][amt];   for(int i = 0; i < N; i++) {    for(int j = 1; j < amt; j++) {     timeNodes[i][j] = solver.addNode();     if (j > 1) solver.link(timeNodes[i][j-1], timeNodes[i][j], Integer.MAX_VALUE, 0);    }   }   for(int i = 0; i < K; i++) {    solver.link(src, timeNodes[people[i]][1], 1, 0);   }   for(int i = 1; i < amt; i++) {    for(int j = 0; j < K; j++) {     solver.link(timeNodes[0][i], snk, 1, C*i-C);    }   }   for(int i =0; i < M; i++) {    int a = scanner.nextInt()-1;    int b = scanner.nextInt()-1;    for(int j = 1; j < amt-1; j++) {     int prev = 0;     for(int k = 1; k <= K; k++) {      solver.link(timeNodes[a][j], timeNodes[b][j + 1], 1, D*k*k- prev);      solver.link(timeNodes[b][j], timeNodes[a][j + 1], 1, D*k*k - prev);      prev = D * k * k;     }    }   }   long[] ret = solver.getMinCostMaxFlow(src, snk);   out.println(ret[1]);   out.flush();  }   public static class Node {     private Node() { }     List<Edge> edges = new ArrayList<Edge>();   int index;       }   public static class Edge  {   boolean forward;   Node from, to;    long flow;     final long capacity;   Edge dual;    long cost;    protected Edge(Node s, Node d, long c, boolean f)   {    forward = f;    from = s;    to = d;    capacity = c;   }   long remaining() { return capacity - flow; }   void addFlow(long amount) {    flow += amount;    dual.flow -= amount;   }  }   public static abstract class MaxFlowSolver {   List<Node> nodes = new ArrayList<Node>();    public void link(Node n1, Node n2, long capacity) {    link(n1, n2, capacity, 1);   }    public void link(Node n1, Node n2, long capacity, long cost) {    Edge e12 = new Edge(n1, n2, capacity, true);    Edge e21 = new Edge(n2, n1, 0, false);    e12.dual = e21;    e21.dual = e12;    n1.edges.add(e12);    n2.edges.add(e21);    e12.cost = cost;    e21.cost = -cost;   }   void link(int n1, int n2, long capacity) {    link(nodes.get(n1), nodes.get(n2), capacity);   }   protected MaxFlowSolver(int n) {    for (int i = 0; i < n; i++)     addNode();   }   protected MaxFlowSolver() {    this(0);   }    public abstract long getMaxFlow(Node src, Node snk);   public Node addNode() {    Node n = new Node();    n.index = nodes.size();    nodes.add(n);    return n;   }  }  static abstract class MinCostMaxFlowSolver extends MaxFlowSolver {     abstract long [] getMinCostMaxFlow(Node src, Node snk);     MinCostMaxFlowSolver ()  { this(0); }   MinCostMaxFlowSolver (int n) { super(n); }  }   static class EdmondsKarp extends MinCostMaxFlowSolver  {   EdmondsKarp ()  { this(0); }   EdmondsKarp (int n) { super(n); }   long minCost;     @Override   public long [] getMinCostMaxFlow(Node src, Node snk) {    long maxflow = getMaxFlow(src, snk);    return new long [] { maxflow, minCost };   }   static final long INF = Long.MAX_VALUE/4;     @Override   public long getMaxFlow(Node src, Node snk) {    final int n = nodes.size();    final int source = src.index;    final int sink = snk.index;    long flow = 0;    long cost = 0;    long[] potential = new long[n];    while (true) {     Edge[] parent = new Edge[n];     long[] dist = new long[n];     Arrays.fill(dist, INF);     dist[source] = 0;     PriorityQueue<Item> que = new PriorityQueue<Item>();     que.add(new Item(0, source));     while (!que.isEmpty()) {      Item item = que.poll();      if (item.dist != dist[item.v])       continue;           for (Edge e : nodes.get(item.v).edges) {       long temp = dist[item.v] + e.cost + potential[item.v] - potential[e.to.index];       if (e.capacity > e.flow && dist[e.to.index] > temp) {        dist[e.to.index] = temp;        parent[e.to.index] = e;        que.add(new Item(temp, e.to.index));       }      }     }     if (parent[sink] == null)      break;     for (int i = 0; i < n; i++)      if (parent[i] != null)       potential[i] += dist[i];     long augFlow = Long.MAX_VALUE;     for (int i = sink; i != source; i = parent[i].from.index)      augFlow = Math.min(augFlow, parent[i].capacity - parent[i].flow);     for (int i = sink; i != source; i = parent[i].from.index) {      Edge e = parent[i];      e.addFlow(augFlow);      cost += augFlow * e.cost;     }     flow += augFlow;    }       minCost = cost;    return flow;   }     static class Item implements Comparable<Item> {    long dist;    int v;       public Item(long dist, int v) {     this.dist = dist;     this.v = v;    }       public int compareTo(Item that) {     return Long.compare(this.dist, that.dist);    }   }  }   public static class FastScanner {   BufferedReader br;   StringTokenizer st;     public FastScanner(Reader in) {    br = new BufferedReader(in);   }     public FastScanner() {    this(new InputStreamReader(System.in));   }     String next() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }     int nextInt() {    return Integer.parseInt(next());   }     long nextLong() {    return Long.parseLong(next());   }     double nextDouble() {    return Double.parseDouble(next());   }     String readNextLine() {    String str = "";    try {     str = br.readLine();    } catch (IOException e) {     e.printStackTrace();    }    return str;   }     int[] readIntArray(int n) {    int[] a = new int[n];    for (int idx = 0; idx < n; idx++) {     a[idx] = nextInt();    }    return a;   }  } }
5,public class A {  private void solve() throws IOException {   int n = nextInt();   int a = nextInt();   int b = nextInt();     int[] h = new int[n];     for (int i = 0; i < n; i++)    h[i] = nextInt();     Arrays.sort(h);     int fstB = h[h.length - a];   int lstA = h[h.length - a - 1];     pl((fstB - lstA) > 0 ? (fstB - lstA) : 0);  }  public static void main(String[] args) {   new A().run();  }  BufferedReader reader;  StringTokenizer tokenizer;  PrintWriter writer;  public void run() {   try {    reader = new BufferedReader(new InputStreamReader(System.in));    tokenizer = null;    writer = new PrintWriter(System.out);    solve();    reader.close();    writer.close();   } catch (Exception e) {    e.printStackTrace();    System.exit(1);   }  }  int nextInt() throws IOException {   return Integer.parseInt(nextToken());  }  long nextLong() throws IOException {   return Long.parseLong(nextToken());  }  double nextDouble() throws IOException {   return Double.parseDouble(nextToken());  }  BigInteger nextBigInteger() throws IOException {   return new BigInteger(nextToken());  }  String nextToken() throws IOException {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    tokenizer = new StringTokenizer(reader.readLine());   }   return tokenizer.nextToken();  }  void p(Object... objects) {   for (int i = 0; i < objects.length; i++) {    if (i != 0)     writer.print(' ');    writer.flush();    writer.print(objects[i]);    writer.flush();   }  }  void pl(Object... objects) {   p(objects);   writer.flush();   writer.println();   writer.flush();  }  int cc;  void pf() {   writer.printf("Case #%d: ", ++cc);   writer.flush();  } }
6,public class cf16e { static int n; static double[][] prob; static double[] memo; public static void main(String[] args) {  Scanner in = new Scanner(System.in);  n = in.nextInt();  prob = new double[n][n];  memo = new double[1<<n];  for(int i=0; i<n; i++)  for(int j=0; j<n; j++)   prob[i][j] = in.nextDouble();  memo[(1<<n)-1] = 1;  for(int k=(1<<n)-1; k>0; k--) {  int numWays = Integer.bitCount(k);  numWays = (numWays*(numWays-1))/2;  for(int first = 0; first < n; first++) {   if(!isSet(k,first)) continue;   for(int second = first+1; second < n; second++) {   if(!isSet(k,second)) continue;   memo[reset(k,first)] += prob[second][first]*memo[k]/numWays;   memo[reset(k,second)] += prob[first][second]*memo[k]/numWays;   }  }  }  for(int i=0; i<n; i++)  System.out.printf("%.6f ", memo[set(0,i)]);  System.out.println(); } static boolean isSet(int x, int p) {  return (x&(1<<p)) != 0; } static int set(int x, int p) {  return x|(1<<p); } static int reset(int x, int p) {  return x&~(1<<p); } static boolean isDone(int x) {  return Integer.bitCount(x)==n-1; } }
2,public class B {  static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));  static MyScanner sc;  static {   try {    sc = new MyScanner();   } catch (FileNotFoundException e) {    e.printStackTrace();   }  }  public static void main(String[] args) {   doTask();   out.flush();  }  public static void doTask(){   long n = sc.nextInt();   long k = sc.nextInt();   long c = -2*(n+k);   long d = 9 - 4*c;   double result = n - (-3 + Math.sqrt(1.0*d))/2;   out.println(Math.round(result));  }  public static class MyScanner {   BufferedReader br;   StringTokenizer st;   public MyScanner() throws FileNotFoundException {    br = new BufferedReader(new InputStreamReader(System.in));   }   String next() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }   int nextInt() {    return Integer.parseInt(next());   }   long nextLong() {    return Long.parseLong(next());   }   double nextDouble() {    return Double.parseDouble(next());   }   String nextLine(){    String str = "";    try {     str = br.readLine();    } catch (IOException e) {     e.printStackTrace();    }    return str;   }  } }
2,public class MainA {  public static void main(String[] args) throws Exception {     Scanner in = new Scanner(new BufferedInputStream(System.in));   PrintStream out = new PrintStream(System.out);          Solution solution = new Solution(in, out);   solution.solve();     in.close();   out.close();  }  static private class Solution {   final int inf = (int)1e9;     int n, x, y, c;   int f(int u, int r, int sec){    if(u == 0 && r == 0)     return 0;    if(u == 0){     return r - 1;    }    if(r == 0){     return u - 1;    }    return Math.min(sec - 1, u - 1 + r - 1);   }   boolean isok(int sec){    int up = x - 1;    int down = n - x;    int right = n - y;    int left = y - 1;    int u = 0, d = 0, r = 0, l = 0;    int total = 1;    int add = 4;    for(int i = 1; i <= sec; i++){     int cc = 0;     if(i > up && ++cc > 0) u++;     if(i > down && ++cc > 0) d++;     if(i > right && ++cc > 0) r++;     if(i > left && ++cc > 0) l++;     total += add - cc;     total -= Math.max(0, f(u, r, i));     total -= Math.max(0, f(u, l, i));     total -= Math.max(0, f(d, r, i));     total -= Math.max(0, f(d, l, i));     if(total >= c) return true;     add += 4;    }    return false;   }   public void solve() {    n = in.nextInt();    x = in.nextInt();    y = in.nextInt();    c = in.nextInt();    if(c == 1){     out.println(0);     return;    }    int lo = 0, hi = 60000;    while(lo < hi){     int mid = (lo + hi)/2;     if(isok(mid)){      hi = mid;     }     else{      lo = mid + 1;     }    }    out.println(lo);   }   public Solution(Scanner in, PrintStream out) {    this.in = in;    this.out = out;   }   Scanner in;   PrintStream out;  } }
3,public class F2 {  private static int n;  private static int[] a;  private static Collection<Segment> answer;  public static void main(String[] args) {   in();   solution();   out();  }  private static void in() {   Scanner in = new Scanner(System.in);   n = in.nextInt();   a = new int[n];   for (int i = 0; i < n; i++) {    a[i] = in.nextInt();   }  }  private static void solution() {   HashMap<Long, LinkedList<Segment>> segments = new HashMap<>();   for (int i = 0; i < n; i++) {    long sum = 0;    for (int j = i; j < n; j++) {     sum += a[j];     if (segments.containsKey(sum)) {      segments.get(sum).add(new Segment(i, j));     } else {      LinkedList<Segment> toPut = new LinkedList<>();      toPut.add(new Segment(i, j));      segments.put(sum, toPut);     }    }   }   answer = null;   for (Map.Entry<Long, LinkedList<Segment>> sums : segments.entrySet()) {     LinkedList<Segment> currentSegments = sums.getValue();    Collections.sort(currentSegments);    LinkedList<Segment> segmentsWithoutCrossing = new LinkedList<>();    for (Segment segment : currentSegments) {      if ( segmentsWithoutCrossing.isEmpty() || !segmentsWithoutCrossing.getLast().isCrossingToNextSegment(segment)) {      segmentsWithoutCrossing.add(segment);     } else if (segmentsWithoutCrossing.getLast().getR() > segment.getR()) {      segmentsWithoutCrossing.removeLast();      segmentsWithoutCrossing.add(segment);     }    }    answer = segmentsWithoutCrossing.size() > (answer != null ? answer.size() : 0) ? segmentsWithoutCrossing : answer;   }  }  private static void out() {   System.out.println(answer.size());   for (Segment segment : answer) {    System.out.println( (segment.getL() + 1) + " " + (segment.getR() + 1));   }  } } class Segment implements Comparable<Segment>{  private int l, r;  Segment(int l, int r) {   this.l = l;   this.r = r;  }   int getL() {   return l;  }  int getR() {   return r;  }  @Override  public int compareTo(Segment segment) {   if (l == segment.l && r == segment.r) {    return 0;   }   return l != segment.l ? l - segment.l : r - segment.r;  }  boolean isCrossingToNextSegment(Segment segment) {   if (l == segment.l || r == segment.r) {    return true;   } else if (l < segment.l) {    return r >= segment.l;   } else if (r > segment.r) {    return l <= segment.r;   } else {    return true;   }  } }
0,public class LCMChallenge {  public static void main(String[] args) {   Scanner in = new Scanner(new BufferedInputStream(System.in));   long N = in.nextLong();   if( N == 1 || N == 2 )   {    System.out.printf("%d\n", N);    return;   }   if( (N&1) == 1 )   {    long lcm = N*(N-1)*(N-2);    System.out.printf("%d\n", lcm);   }   else   {    long lcm;    if( N%3 == 0 )    {     lcm = (N-1)*(N-2)*(N-3);    }    else    {     lcm = N*(N-1)*(N-3);    }    System.out.printf("%d\n", lcm);   }  } }
6,public class CodeJ { static class Scanner {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer("");   public String nextLine()  {  try  {   return br.readLine();  }  catch(Exception e)  {   throw(new RuntimeException());  }  }   public String next()  {  while(!st.hasMoreTokens())  {   String l = nextLine();   if(l == null)   return null;   st = new StringTokenizer(l);  }  return st.nextToken();  }   public int nextInt()  {  return Integer.parseInt(next());  }   public long nextLong()  {  return Long.parseLong(next());  }   public double nextDouble()  {  return Double.parseDouble(next());  }   public int[] nextIntArray(int n)  {  int[] res = new int[n];  for(int i = 0; i < res.length; i++)   res[i] = nextInt();  return res;  }   public long[] nextLongArray(int n)  {  long[] res = new long[n];  for(int i = 0; i < res.length; i++)   res[i] = nextLong();  return res;  }   public double[] nextDoubleArray(int n)  {  double[] res = new double[n];  for(int i = 0; i < res.length; i++)   res[i] = nextLong();  return res;  }  public void sortIntArray(int[] array)  {  Integer[] vals = new Integer[array.length];  for(int i = 0; i < array.length; i++)   vals[i] = array[i];  Arrays.sort(vals);  for(int i = 0; i < array.length; i++)   array[i] = vals[i];  }   public void sortLongArray(long[] array)  {  Long[] vals = new Long[array.length];  for(int i = 0; i < array.length; i++)   vals[i] = array[i];  Arrays.sort(vals);  for(int i = 0; i < array.length; i++)   array[i] = vals[i];  }   public void sortDoubleArray(double[] array)  {  Double[] vals = new Double[array.length];  for(int i = 0; i < array.length; i++)   vals[i] = array[i];  Arrays.sort(vals);  for(int i = 0; i < array.length; i++)   array[i] = vals[i];  } }  static int nFilas; static int nColumnas;  static byte[][][][][] dp;  static byte dp(int mascaraActual, int enviadosActual, int enviadosSiguiente, int filaActual, int columnaActual) {  if(dp[mascaraActual][enviadosActual][enviadosSiguiente][filaActual][columnaActual] != Byte.MAX_VALUE)  return dp[mascaraActual][enviadosActual][enviadosSiguiente][filaActual][columnaActual];  if(filaActual == nFilas)  return dp[mascaraActual][enviadosActual][enviadosSiguiente][filaActual][columnaActual] = 0;  if(columnaActual == nColumnas)  {  int ambos = mascaraActual & enviadosSiguiente;  int mascaraSiguiente = (1 << nColumnas) - 1;  mascaraSiguiente ^= ambos;  int mascaraEnviados = enviadosSiguiente;  mascaraEnviados ^= ambos;  return dp[mascaraActual][enviadosActual][enviadosSiguiente][filaActual][columnaActual] = (byte) (nColumnas - Integer.bitCount(mascaraActual) + dp(mascaraSiguiente, mascaraEnviados, 0, filaActual + 1, 0));  }  if(((mascaraActual & (1 << columnaActual)) == 0))  {    byte a = dp(mascaraActual | (1 << columnaActual), enviadosActual, enviadosSiguiente | (1 << columnaActual), filaActual, columnaActual + 1);    byte b = dp(mascaraActual, enviadosActual, enviadosSiguiente, filaActual, columnaActual + 1);  return dp[mascaraActual][enviadosActual][enviadosSiguiente][filaActual][columnaActual] = (byte) Math.max(a, b);  }  if((enviadosActual & (1 << columnaActual)) != 0)  {  byte a = dp(mascaraActual, enviadosActual, enviadosSiguiente | (1 << columnaActual), filaActual, columnaActual + 1);  byte b = dp(mascaraActual, enviadosActual, enviadosSiguiente, filaActual, columnaActual + 1);  return dp[mascaraActual][enviadosActual][enviadosSiguiente][filaActual][columnaActual] = (byte) Math.max(a, b);  }   byte ans = 0;  if(columnaActual != 0)  ans = (byte) Math.max(ans, dp((mascaraActual ^ (1 << columnaActual)) | (1 << (columnaActual - 1)), enviadosActual, enviadosSiguiente, filaActual, columnaActual + 1));   if(columnaActual != nColumnas - 1)   ans = (byte) Math.max(ans, dp((mascaraActual ^ (1 << columnaActual)) | (1 << (columnaActual + 1)), enviadosActual | (1 << (columnaActual + 1)), enviadosSiguiente, filaActual, columnaActual + 1));   if(filaActual != nFilas - 1)  ans = (byte) Math.max(ans, dp((mascaraActual ^ (1 << columnaActual)), enviadosActual, enviadosSiguiente | (1 << columnaActual), filaActual, columnaActual + 1));   ans = (byte) Math.max(ans, dp(mascaraActual, enviadosActual, enviadosSiguiente, filaActual, columnaActual + 1));  return dp[mascaraActual][enviadosActual][enviadosSiguiente][filaActual][columnaActual] = ans; }  public static void main(String[] args) {  Scanner sc = new Scanner();  int a = sc.nextInt();  int b = sc.nextInt();  nFilas = Math.max(a, b);  nColumnas = Math.min(a, b);  dp = new byte[1 << nColumnas][1 << nColumnas][1 << nColumnas][nFilas + 1][nColumnas + 1];  for(byte[][][][] i : dp)  for(byte[][][] j : i)   for(byte[][] k : j)   for(byte[] l : k)    Arrays.fill(l, Byte.MAX_VALUE);  System.out.println(dp((1 << nColumnas) - 1, 0, 0, 0, 0)); } }
2,public class CF817C { static long count(long x) {  return x < 10 ? x : count(x / 10) + x % 10; } static boolean check(long x, long s) {  return x - count(x) >= s; } public static void main(String[] args) throws IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer(br.readLine());  long n = Long.parseLong(st.nextToken());  long s = Long.parseLong(st.nextToken());  int d = 9 * 18;  long cnt;  if (n >= s + d) {  cnt = n - s - d;  for (long x = s; x <= s + d; x++)   if (check(x, s))   cnt++;  } else {  cnt = 0;  for (long x = s; x <= n; x++)   if (check(x, s))   cnt++;  }  System.out.println(cnt); } }
0,public class Main {  public static void main(String[] args) {   Scanner s = new Scanner(System.in);   long a=s.nextLong(), b=s.nextLong();   long c=0;   while(true) {    if(a==b ){     System.out.println(c+a);     return ;    } else if(b==a+1){     c+=1;     b=a;    } else if(b<a){     long h = a/b-1;     if(h<=0){      a-=b;c++;continue;     }     a-=b*h;     c+=h;    } else{     if(a==1){      long t = b-a;      b = t;      c+=t;      b = a;      continue;     }     long t = b-a;     long h = b/a - 1 ;     if(h<=0){      b = t;      c+=1;continue;     }     c+=h;b-=h*a;    }   }   } }
3,public class CodeforcesProblems {   static class Pair {   public Pair(int key, int val) {    this.key = key;    this.val = val;   }   int key;   int val;  }   public static void main(String[] args) throws IOException {   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));      int n = Integer.parseInt(br.readLine());   String[] strings = br.readLine().split(" ");   int[] arr = new int[n];   for(int i = 0; i<n; i++) {    arr[i] = Integer.parseInt(strings[i]);   }    HashMap<Integer, ArrayList<Pair>> segments = new HashMap<>();   for(int r = 0; r<arr.length; r++) {    int sum = 0;    for(int l = r; l>=0; l--) {     sum += arr[l];     ArrayList<Pair> pairs = segments.get(sum);     if(pairs == null) {      pairs = new ArrayList<>();      segments.put(sum, pairs);     }     pairs.add(new Pair(l, r));    }   }   int res = 0;   ArrayList<Pair> result = new ArrayList<>();   for(ArrayList<Pair> pairs: segments.values()) {    ArrayList<Pair> temp = new ArrayList<>();    int count = 0;    int r = -1;    for(Pair p : pairs) {     if(p.key>r) {      count++;      temp.add(p);      r = p.val;     }    }    if(count>res) {     res = count;     result = temp;    }   }   System.out.println(res);   StringBuilder sb = new StringBuilder();   for(Pair p : result){    sb.append(p.key+1).append(' ').append(p.val+1).append('\n');   }   System.out.print(sb);  } }
6,public class Main {  public static void main(String[] args) throws IOException {   BufferedReader in = new BufferedReader(new InputStreamReader(System.in));   String[] line = in.readLine().split(" ");   int Xs = Integer.parseInt(line[0]);   int Ys = Integer.parseInt(line[1]);   int n = Integer.parseInt(in.readLine());     int[][] points = new int[n+1][2];   points[n][0] = Xs;   points[n][1] = Ys;     for(int i=0; i< n ; i++)   {    line = in.readLine().split(" ");    points[i][0] = Integer.parseInt(line[0]);    points[i][1] = Integer.parseInt(line[1]);   }        int[][] distances = new int[n+1][n+1];   ComputeDistances(points, distances, n);     int[] dp = new int[1<<n];   int[] path = new int[1<<n];   ComputeLowestPath(dp, path, distances, n);   OutputLowestAndPath(dp, path, n);    }     private static void ComputeLowestPath(int[] dp, int[] path, int[][] distances, int n)  {   for(int i = 1; i < 1<<n; i++)   {    int j = 0;    while(true)    {     if((i&(1<<j))!=0)     {      break;     }     j++;    }       int pastEntry = i & ~(1<<j);    path[i] = pastEntry;    int distance = distances[j][n] * 2;    dp[i] = dp[pastEntry] + distance;        for(int m = j +1; m < n; m++)    {     if((i & (1<<m))!=0)     {      int entry = i & ~((1<<j)|(1<<m));      distance = distances[j][n] + distances[j][m] + distances[m][n];            if(dp[i] > dp[entry] + distance)      {       dp[i] = dp[entry] + distance;       path[i] = entry;      }     }    }      }  }   private static void OutputLowestAndPath(int[] dp, int[] path, int n)  {     StringBuilder out = new StringBuilder();   out.append(dp[(1<<n)-1]);   out.append("\n");   out.append("0 ");   int index = (1<<n)-1;   while(index != 0)   {    int j = path[index];    int k = index ^ j;    for(int m = 0; m < n; m++)    {     if((k & (1 << m)) != 0)     {      out.append(m+1);      out.append(" ");     }    }    out.append("0 ");    index = j;   }   System.out.println(out.toString());  }   private static void ComputeDistances(int[][] points, int[][] distances, int n)  {   for(int i = 0; i <= n; i++)   {    for(int j=i+1; j<=n; j++)    {     int x= points[i][0] - points[j][0];     int y= points[i][1] - points[j][1];     distances[i][j] = x*x + y*y;    }   }  }  }
6,public class Main implements Runnable {  private int n;  private int nn;  private boolean[][] gr;  private long[][] D;      private void solve() throws Throwable {   n = nextInt();   nn = 1 << n;   gr = new boolean[n][n];   int m = nextInt();   for (int i = 0; i < m; i++) {    int a = nextInt() - 1, b = nextInt() - 1;    gr[a][b] = gr[b][a] = true;   }   D = new long[n][nn];   for (int i = 0; i < n; i++) {    Arrays.fill(D[i], -1);   }   long count = 0;   for (int i = 0; i < n; i++) {    count += getD(i, i, 1, 1 << i);   }   pw.println(count / 2);  }   private long getD(int first, int last, int cnt, int mask) {   if (D[last][mask] != -1) return D[last][mask];   long ans = 0;   if (cnt >= 3 && gr[first][last])    ans++;   for (int i = first + 1; i < n; i++) {    if (gr[last][i] && (mask & (1 << i)) == 0) {     ans += getD(first, i, cnt + 1, mask | (1 << i));    }   }   D[last][mask] = ans;   return ans;  }      PrintWriter pw;  BufferedReader in;  StringTokenizer st;  void initStreams() throws FileNotFoundException {     in = new BufferedReader(new InputStreamReader(System.in));   pw = new PrintWriter(System.out);  }  String nextString() throws IOException {   while (st == null || !st.hasMoreTokens()) {    st = new StringTokenizer(in.readLine());   }   return st.nextToken();  }  int nextInt() throws NumberFormatException, IOException {   return Integer.parseInt(nextString());  }  long nextLong() throws NumberFormatException, IOException {   return Long.parseLong(nextString());  }  double nextDouble() throws NumberFormatException, IOException {   return Double.parseDouble(nextString());  }  static Throwable sError;  public static void main(String[] args) throws Throwable {   Thread t = new Thread(new Main());   t.start();   t.join();   if (sError != null) {    throw sError;   }  }  public void run() {   try {    initStreams();    solve();   } catch (Throwable e) {    sError = e;   } finally {    if (pw != null)     pw.close();   }  } }
5,public class Main{ public static void main(String[] args){  new Main().run(); }  void run(){  Scanner sc = new Scanner(System.in);  int n = sc.nextInt();  int t = sc.nextInt() * 2;  H[] tbl = new H[n];  for(int i = 0; i < n; i++)tbl[i] = new H(sc.nextInt()*2, sc.nextInt()*2);  Arrays.sort(tbl);  TreeSet<Integer> cand = new TreeSet<Integer>();   for(int i = 0; i < n; i++){  int left = tbl[i].x - tbl[i].len / 2 - t / 2;  if(!cand.contains(left)){   if(i > 0 && tbl[i-1].x + tbl[i-1].len/2 > left - t/2){      }else{   cand.add(left);   }  }  int right = tbl[i].x + tbl[i].len / 2 + t/2;  if(!cand.contains(right)){   if(i < n-1 && tbl[i+1].x - tbl[i+1].len/2 < right + t/2){      }else{   cand.add(right);   }  }  }  System.out.println(cand.size()); }  class H implements Comparable<H>{  int x, len;  H(int a, int b){  x = a;  len = b;  }  public int compareTo(H h){  return this.x - h.x;  } } }
1,public class B { public void solve() throws IOException {  int n = nextInt();  int k = nextInt();  int[] a = new int[n];  for(int i = 0; i < n; i++){  a[i] = nextInt();  }  int[] num = new int[n];  Set<Integer> set = new HashSet<Integer>();  int s = -1;  int l = -1;  for(int i = 0; i < n; i++){  set.add(a[i]);  num[i] = set.size();  if( num[i] == k ){   l = i+1;   set = new HashSet<Integer>();   for(int j = i; j >= 0; j--){   set.add(a[j]);   if( set.size() == k ){    s = j+1;    break;   }   }   break;  }  }  writer.println(s + " " + l);  }  public static void main(String[] args) throws IOException {  new B().run(); }  BufferedReader reader; StringTokenizer tokenizer; PrintWriter writer;  public void run() throws IOException {  try {  reader = new BufferedReader(new InputStreamReader(System.in));  tokenizer = null;  writer = new PrintWriter(System.out);  solve();  reader.close();  writer.close();  } catch (Exception e) {  e.printStackTrace();  System.exit(1);  } }  public int nextInt() throws IOException {  return Integer.parseInt(nextToken()); }  public double nextDouble() throws IOException {  return Double.parseDouble(nextToken()); }  public String nextToken() throws IOException {  while (tokenizer == null || !tokenizer.hasMoreTokens()) {  tokenizer = new StringTokenizer(reader.readLine());  }  return tokenizer.nextToken(); } }
1,public class Main { public static void main(String[] args) throws NumberFormatException, IOException {  BufferedReader r = new BufferedReader(new InputStreamReader(System.in));   int size= Integer.parseInt(r.readLine());  String line = r.readLine();   int counter =0;  for (int i = 0; i < line.length(); i++) {  if(line.charAt(i)=='H')counter++;  }   int minimum = Integer.MAX_VALUE;  for (int i = 0; i < line.length(); i++) {  if(line.charAt(i)=='H'){   int current = 0;   for (int j = i; j < i+counter; j++) {   if(line.charAt(j%line.length())=='T')current++;   }   minimum = Math.min(current, minimum);  }  }   System.out.println(minimum);   } }
0,public class B {  public static void main(String[] args) throws Exception {   BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));   PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));     StringTokenizer st = new StringTokenizer(bf.readLine());     int n = Integer.parseInt(st.nextToken());   int m = Integer.parseInt(st.nextToken());   StringBuilder ans1 = new StringBuilder();   StringBuilder ans2 = new StringBuilder();   for(int i=0; i<2229; i++) ans1.append('5');   ans1.append('6');   for(int i=0; i<2230; i++) ans2.append('4');   out.println(ans1.toString());   out.println(ans2.toString());   out.close(); System.exit(0);  } }
2,public class palin { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  PrintWriter out = new PrintWriter(System.out);  Scanner scan = new Scanner(System.in);  TaskC solver = new TaskC();  solver.solve(1, in, out);  out.close(); } } class TaskC { public void solve(int testNumber, InputReader in, PrintWriter out) {  long n = in.nextLong() - 1;  long k = in.nextLong() - 1;  if (n == 0) {  out.print("0");  } else {  if (k >= n) {   out.print("1");  } else {   if (k * (k + 1) / 2 < n) {   out.print("-1");   } else {   long t = binsearch(n, k, 1, k);   long ans = k - t + 1;   if (k * (k + 1) / 2 - t * (t - 1) / 2 != n)    ans++;   System.out.println(ans);   }  }  } }  public static long binsearch(long n, long k, long from, long to) {  if (from == to) {  return from;  }  long mid = (from + to) / 2;  if ((k * (k + 1)) / 2 - (mid * (mid - 1)) / 2 > n)  return binsearch(n, k, mid + 1, to);  else   return binsearch(n, k, from, mid); } } class InputReader { BufferedReader br; StringTokenizer st;  public InputReader(InputStream in) {  br = new BufferedReader(new InputStreamReader(in));  st = null; }  public String next() {  while (st == null || !st.hasMoreTokens()) {  try {   st = new StringTokenizer(br.readLine());  } catch (IOException e) {   throw new RuntimeException(e);  }  }  return st.nextToken(); }  public int nextInt() {  return Integer.parseInt(next()); }  public long nextLong() {  return Long.parseLong(next()); } }
6,public class cf1185g1_3 {  public static void main(String[] args) throws IOException {   int n = rni(), t = ni(), song[][] = new int[n][2];   for (int i = 0; i < n; ++i) {    song[i][0] = rni();    song[i][1] = ni() - 1;   }   int dp[][] = new int[1 << n][4], sum[] = new int[1 << n], ans = 0;   dp[0][3] = 1;   for (int i = 0; i < 1 << n; ++i) {    for (int j = 0; j < 4; ++j) {     for (int k = 0; k < n; ++k) {      if ((i & (1 << k)) == 0 && song[k][1] != j) {       dp[i | (1 << k)][song[k][1]] = madd(dp[i | (1 << k)][song[k][1]], dp[i][j]);       sum[i | (1 << k)] = sum[i] + song[k][0];      }     }    }   }   for (int i = 0; i < 1 << n; ++i) {    if (sum[i] == t) {     ans = madd(ans, dp[i][0], dp[i][1], dp[i][2]);    }   }   prln(ans);   close();  }  static int mmod = 1000000007;  static int madd(int a, int b) {   return (a + b) % mmod;  }  static int madd(int... a) {   int ans = a[0];   for (int i = 1; i < a.length; ++i) {    ans = madd(ans, a[i]);   }   return ans;  }  static int msub(int a, int b) {   return (a - b + mmod) % mmod;  }  static int mmul(int a, int b) {   return (int) ((long) a * b % mmod);  }  static int mmul(int... a) {   int ans = a[0];   for (int i = 1; i < a.length; ++i) {    ans = mmul(ans, a[i]);   }   return ans;  }  static int minv(int x) {     return (exgcd(x, mmod)[0] % mmod + mmod) % mmod;  }  static int mpow(int a, long b) {   if (a == 0) {    return 0;   }   int ans = 1;   while (b > 0) {    if ((b & 1) > 0) {     ans = mmul(ans, a);    }    a = mmul(a, a);    b >>= 1;   }   return ans;  }  static BufferedReader __i = new BufferedReader(new InputStreamReader(System.in));  static PrintWriter __o = new PrintWriter(new OutputStreamWriter(System.out));  static StringTokenizer input;  static Random __r = new Random();          static final int IBIG = 1000000007;  static final int IMAX = 2147483647;  static final long LMAX = 9223372036854775807L;   static int minof(int a, int b, int c) {return min(a, min(b, c));}  static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}  static long minof(long a, long b, long c) {return min(a, min(b, c));}  static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}  static int maxof(int a, int b, int c) {return max(a, max(b, c));}  static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}  static long maxof(long a, long b, long c) {return max(a, max(b, c));}  static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}  static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}  static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}  static int fli(double d) {return (int) d;}  static int cei(double d) {return (int) ceil(d);}  static long fll(double d) {return (long) d;}  static long cel(double d) {return (long) ceil(d);}  static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}  static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}  static int[] exgcd(int a, int b) {if (b == 0) return new int[] {1, 0}; int[] y = exgcd(b, a % b); return new int[] {y[1], y[0] - y[1] * (a / b)};}  static long[] exgcd(long a, long b) {if (b == 0) return new long[] {1, 0}; long[] y = exgcd(b, a % b); return new long[] {y[1], y[0] - y[1] * (a / b)};}  static int randInt(int min, int max) {return __r.nextInt(max - min + 1) + min;}  static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}   static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}  static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}  static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}  static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}  static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}  static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}  static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}  static void rsort(int[] a) {shuffle(a); sort(a);}  static void rsort(long[] a) {shuffle(a); sort(a);}  static void rsort(double[] a) {shuffle(a); sort(a);}  static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}  static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}  static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}  static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}   static void r() throws IOException {input = new StringTokenizer(rline());}  static int ri() throws IOException {return Integer.parseInt(rline());}  static long rl() throws IOException {return Long.parseLong(rline());}  static double rd() throws IOException {return Double.parseDouble(rline());}  static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}  static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}  static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}  static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}  static char[] rcha() throws IOException {return rline().toCharArray();}  static String rline() throws IOException {return __i.readLine();}  static String n() {return input.nextToken();}  static int rni() throws IOException {r(); return ni();}  static int ni() {return Integer.parseInt(n());}  static long rnl() throws IOException {r(); return nl();}  static long nl() {return Long.parseLong(n());}  static double rnd() throws IOException {r(); return nd();}  static double nd() {return Double.parseDouble(n());}   static void pr(int i) {__o.print(i);}  static void prln(int i) {__o.println(i);}  static void pr(long l) {__o.print(l);}  static void prln(long l) {__o.println(l);}  static void pr(double d) {__o.print(d);}  static void prln(double d) {__o.println(d);}  static void pr(char c) {__o.print(c);}  static void prln(char c) {__o.println(c);}  static void pr(char[] s) {__o.print(new String(s));}  static void prln(char[] s) {__o.println(new String(s));}  static void pr(String s) {__o.print(s);}  static void prln(String s) {__o.println(s);}  static void pr(Object o) {__o.print(o);}  static void prln(Object o) {__o.println(o);}  static void prln() {__o.println();}  static void pryes() {prln("yes");}  static void pry() {prln("Yes");}  static void prY() {prln("YES");}  static void prno() {prln("no");}  static void prn() {prln("No");}  static void prN() {prln("NO");}  static boolean pryesno(boolean b) {prln(b ? "yes" : "no"); return b;};  static boolean pryn(boolean b) {prln(b ? "Yes" : "No"); return b;}  static boolean prYN(boolean b) {prln(b ? "YES" : "NO"); return b;}  static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}  static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}  static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}  static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}  static void h() {prln("hlfd"); flush();}  static void flush() {__o.flush();}  static void close() {__o.close();} }
2,public class B {  static Scanner in; static int next() throws Exception {return in.nextInt();};   static PrintWriter out;  public static long count(long k, long x, long y, long n) {   long sum = 2*k*(k+1)+1;   if (k >= x-1) {    sum -= (k-x+1)*(k-x+1);   }   if (k >= y-1) {    sum -= (k-y+1)*(k-y+1);   }   if (k + x >= n) {    sum -= (k+x-n)*(k+x-n);   }   if (k + y >= n) {    sum -= (k+y-n)*(k+y-n);   }   if (k > x+y-1) {    sum += ((k+1-x-y)*(k+1-x-y+1))/2;   }   if (k > n-x+y) {    sum += ((k+x-n-y)*(k+x-n-y+1))/2;   }   if (k > n-y+x) {    sum += ((k+y-n-x)*(k+y-n-x+1))/2;   }   if (k > 2*n-x-y+1) {    sum += ((k-2*n+x+y-1)*(k-2*n+x+y))/2;   }   return sum;  }  public static void main(String[] args) throws Exception {   in = new Scanner(System.in);    out = new PrintWriter(System.out);   long n = in.nextLong(), x = in.nextLong(), y = in.nextLong(), c = in.nextLong();   long res = 0;   while (count(res, x, y, n) < c) res++;   out.println(res);    out.println();   out.close();  } }
0,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  PrintWriter out = new PrintWriter(outputStream);  TaskA solver = new TaskA();  solver.solve(1, in, out);  out.close(); } } class TaskA {  public void solve(int testNumber, InputReader in, PrintWriter out) {   long a = in.nextLong();   long b = in.nextLong();   long res = 0;   while (b > 0) {    res += a / b;    long t = a % b;    a = b;    b = t;   }   out.println(res);  } } class InputReader {  public BufferedReader reader;  public StringTokenizer tokenizer;  public InputReader(InputStream stream) {   reader = new BufferedReader(new InputStreamReader(stream));   tokenizer = null;  }  public String next() {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    try {     tokenizer = new StringTokenizer(reader.readLine());    } catch (IOException e) {     throw new RuntimeException(e);    }   }   return tokenizer.nextToken();  }  public long nextLong() {   return Long.parseLong(next());  }  }
5,public class A2 { InputStream is; PrintWriter out; String INPUT = "";  void solve() {  int n = ni();  int[] a = new int[n];  int[] b = new int[n];  for(int i = 0;i < n;i++)b[i] = a[i] = ni();   b = radixSort(b);  int ct = 0;  for(int i = 0;i < n;i++){  if(a[i] != b[i])ct++;  }  if(ct <= 2){  out.println("YES");  }else{  out.println("NO");  } }  public static int[] radixSort(int[] f) {  int[] to = new int[f.length];  {  int[] b = new int[65537];  for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;  for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];  for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];  int[] d = f; f = to;to = d;  }  {  int[] b = new int[65537];  for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;  for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];  for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];  int[] d = f; f = to;to = d;  }  return f; }  void run() throws Exception {  is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());  out = new PrintWriter(System.out);   long s = System.currentTimeMillis();  solve();  out.flush();  tr(System.currentTimeMillis()-s+"ms"); }  public static void main(String[] args) throws Exception {  new A2().run(); }  public int ni() {  try {  int num = 0;  boolean minus = false;  while((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));  if(num == '-'){   num = 0;   minus = true;  }else{   num -= '0';  }    while(true){   int b = is.read();   if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');   }else{   return minus ? -num : num;   }  }  } catch (IOException e) {  }  return -1; }  public long nl() {  try {  long num = 0;  boolean minus = false;  while((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));  if(num == '-'){   num = 0;   minus = true;  }else{   num -= '0';  }    while(true){   int b = is.read();   if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');   }else{   return minus ? -num : num;   }  }  } catch (IOException e) {  }  return -1; }  public String ns() {  try{  int b = 0;  StringBuilder sb = new StringBuilder();  while((b = is.read()) != -1 && (b == '\r' || b == '\n' || b == ' '));  if(b == -1)return "";  sb.append((char)b);  while(true){   b = is.read();   if(b == -1)return sb.toString();   if(b == '\r' || b == '\n' || b == ' ')return sb.toString();   sb.append((char)b);  }  } catch (IOException e) {  }  return ""; }  public char[] ns(int n) {  char[] buf = new char[n];  try{  int b = 0, p = 0;  while((b = is.read()) != -1 && (b == ' ' || b == '\r' || b == '\n'));  if(b == -1)return null;  buf[p++] = (char)b;  while(p < n){   b = is.read();   if(b == -1 || b == ' ' || b == '\r' || b == '\n')break;   buf[p++] = (char)b;  }  return Arrays.copyOf(buf, p);  } catch (IOException e) {  }  return null; }   double nd() { return Double.parseDouble(ns()); } boolean oj = System.getProperty("ONLINE_JUDGE") != null; void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); } }
1,public class Main implements Runnable { StreamTokenizer ST;  PrintWriter out;  BufferedReader br;  Scanner in; static final int inf = 1000000000;  int nextInt() throws IOException{   ST.nextToken();   return (int)ST.nval;  } long nextLong() throws IOException{   ST.nextToken();   return (long)ST.nval;  }  String next() throws IOException{   ST.nextToken();   return ST.sval;  }  double nextD() throws IOException{   ST.nextToken();   return ST.nval;  }  public static void main(String[] args) throws IOException {    new Thread(new Main()).start(); }  public void run() {   try {   br = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));         in = new Scanner(br);   ST = new StreamTokenizer(br);    solve();    out.close();     br.close();   }    catch (IOException e) {     e.printStackTrace();   throw new IllegalStateException(e);  }  }  public void solve() throws IOException {  int n = nextInt();  int K = nextInt();  boolean[] f = new boolean[n+1];  Arrays.fill(f, true);  Vector<Integer> P = new Vector<Integer>();  for (int i=2; i<=n; i++)   if (f[i]) {    for (int j=2*i; j<=n; j+=i)     f[j] = false;    P.add(i);   }  for (int i=0; i<P.size()-1; i++) {   int x = P.elementAt(i)+P.elementAt(i+1)+1;   if (x<=n && f[x]) K--;  }  if (K<=0) out.println("YES"); else out.println("NO");    }  }
3,public class Main {  static final long MOD = 1_000_000_007, INF = 1_000_000_000_000_000_000L;  static final int INf = 1_000_000_000;  static FastReader reader;  static PrintWriter writer;  public static void main(String[] args) {   Thread t = new Thread(null, new O(), "Integer.MAX_VALUE", 100000000);   t.start();  }  static class O implements Runnable {   public void run() {    try {     magic();    }    catch (Exception e) {     e.printStackTrace();     System.exit(1);    }   }  }  static class FastReader {   final private int BUFFER_SIZE = 1 << 16;   private DataInputStream din;   private byte[] buffer;   private int bufferPointer, bytesRead;   public FastReader() {    din = new DataInputStream(System.in);    buffer = new byte[BUFFER_SIZE];    bufferPointer = bytesRead = 0;   }   public FastReader(String file_name) throws IOException {    din = new DataInputStream(new FileInputStream(file_name));    buffer = new byte[BUFFER_SIZE];    bufferPointer = bytesRead = 0;   }   public String readLine() throws IOException {    byte[] buf = new byte[1000000];    int cnt = 0, c;    while ((c = read()) != -1) {     if (c == '\n') break;     buf[cnt++] = (byte) c;    }    return new String(buf, 0, cnt);   }   public int nextInt() throws IOException {    int ret = 0;    byte c = read();    while (c <= ' ') c = read();    boolean neg = (c == '-');    if (neg) c = read();    do {     ret = ret * 10 + c - '0';    } while ((c = read()) >= '0' && c <= '9');    if (neg) return -ret;    return ret;   }   public long nextLong() throws IOException {    long ret = 0;    byte c = read();    while (c <= ' ') c = read();    boolean neg = (c == '-');    if (neg) c = read();    do {     ret = ret * 10 + c - '0';    } while ((c = read()) >= '0' && c <= '9');    if (neg) return -ret;    return ret;   }   public double nextDouble() throws IOException {    double ret = 0, div = 1;    byte c = read();    while (c <= ' ') c = read();    boolean neg = (c == '-');    if (neg) c = read();    do {     ret = ret * 10 + c - '0';    } while ((c = read()) >= '0' && c <= '9');    if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') / (div *= 10);    if (neg) return -ret;    return ret;   }   private void fillBuffer() throws IOException {    bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);    if (bytesRead == -1) buffer[0] = -1;   }   private byte read() throws IOException {    if (bufferPointer == bytesRead) fillBuffer();    return buffer[bufferPointer++];   }   public void close() throws IOException {    if (din == null) return;    din.close();   }  }  static void magic() throws IOException {   reader = new FastReader();   writer = new PrintWriter(System.out, true);   Map<Integer, ArrayList<Pair>> map = new HashMap<>();   int n = reader.nextInt();   int arr[] = new int[n];   for(int i=0;i<n;++i) {    arr[i] = reader.nextInt();   }   for(int i=0;i<n;++i) {    int sum = 0;    for(int j=i;j<n;++j) {     sum+=arr[j];     ArrayList<Pair> list = map.get(sum);     if(list==null) {      list = new ArrayList<>();     }     list.add(new Pair(i+1,j+1));     map.put(sum, list);    }   }   int ans = 0,at = -1;   for(int e : map.keySet()) {    ArrayList<Pair> list = map.get(e);    Collections.sort(list);       int ispe = 0;    int len = list.size();    for(int i=0;i<len;++i) {     ispe++;     int r = list.get(i).y;     while(i+1<len && list.get(i+1).x<=r) {      i++;     }    }    if(ans<ispe) {     ans = ispe;     at = e;    }   }   writer.println(ans);   ArrayList<Pair> list = map.get(at);   Collections.sort(list);   int len = list.size();   for(int i=0;i<len;++i) {    writer.println(list.get(i).x+" "+list.get(i).y);    int r = list.get(i).y;    while(i+1<len && list.get(i+1).x<=r) {     i++;    }   }  }  static class Pair implements Comparable<Pair> {   int x,y;   Pair(int x, int y) {    this.x = x;    this.y = y;   }   public int compareTo(Pair other) {    if(this.y!=other.y) {     return this.y - other.y;    }    return this.x - other.x;   }   public String toString() {    return "{" + x + "," + y + "}";   }  } }
2,public class Berland{  public static void main(String[] args) throws NumberFormatException, IOException {  new Berland().run(); }  public void run() throws NumberFormatException, IOException {  BufferedReader file = new BufferedReader(new InputStreamReader(System.in));  long N = Long.parseLong(file.readLine());  long[] cutoff = new long[13];  cutoff[0] = 0;  for(int i = 1;i<=12;i++)  {  cutoff[i] = cutoff[i-1] + (long)(9*Math.pow(10,i-1))*i;  }  int dig = -1;  for(int i = 0;i<12;i++)  {  if(cutoff[i]>=N)  {   dig = i;   break;  }  }  long sub = N - cutoff[dig-1]-1;  long num = (sub)/dig;  long number = (long)Math.pow(10,dig-1)+num;  int pos = (int)(sub % dig);  System.out.println((number+"").charAt(pos)); } }
3,public class utkarsh {  InputStream is;  PrintWriter out;   double x[], y[], R;   boolean game(double x1, double y1, double x2, double y2){   double dis = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);     return dis <= 4.0 * R * R;  }   void play(int n){   double l, r, m;   double a[] = new double[n];   for(int i = 0; i < n; i++){    l = 0.0;    r = 1000000.0;    for(int j = 0; j < 50; j++){     m = (l + r) / 2;     if(game(x[i], 0, x[n], m)) l = m;     else r = m;    }    a[i] = l;   }   for(int i = 0; i < n; i++){       if(a[i] > 0.0 && (y[i] + a[i]) > y[n]) y[n] = y[i] + a[i];   }  }   void solve(){     int i, j, n;   n = ni();   R = nd();   x = new double[n];   y = new double[n];   for(i = 0; i < n; i++) x[i] = nd();   for(i = 0; i < n; i++){    play(i);   }   for(i = 0; i < n; i++) out.print((R + y[i]) +" ");  }   public static void main(String[] args) { new utkarsh().run();  }  void run(){ is = System.in; out = new PrintWriter(System.out); solve(); out.flush();  }   byte input[] = new byte[1024];  int len = 0, ptr = 0;   int readByte(){ if(ptr >= len){ ptr = 0; try{ len = is.read(input); }catch(IOException e){ throw new InputMismatchException(); } if(len <= 0){ return -1; } } return input[ptr++];  }  boolean isSpaceChar(int c){ return !( c >= 33 && c <= 126 );  }  int skip(){ int b = readByte(); while(b != -1 && isSpaceChar(b)){ b = readByte(); } return b;  }   char nc(){ return (char)skip();  }  String ns(){ int b = skip(); StringBuilder sb = new StringBuilder(); while(!isSpaceChar(b)){ sb.appendCodePoint(b); b=readByte(); } return sb.toString();  }  int ni(){ int n = 0,b = readByte(); boolean minus = false; while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')){ b = readByte(); } if(b == '-'){ minus = true; b = readByte(); } if(b == -1){ return -1; } while(b >= '0' && b <= '9'){ n = n * 10 + (b - '0'); b = readByte(); } return minus ? -n : n;  }  long nl(){ long n = 0L; int b = readByte(); boolean minus = false; while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')){ b = readByte(); } if(b == '-'){ minus = true; b = readByte(); } while(b >= '0' && b <= '9'){ n = n * 10 + (b - '0'); b = readByte(); } return minus ? -n : n;  }  double nd(){ return Double.parseDouble(ns());  }  float nf(){ return Float.parseFloat(ns());  }  int[] na(int n){ int a[] = new int[n]; for(int i = 0; i < n; i++){ a[i] = ni(); } return a;  }  char[] ns(int n){ char c[] = new char[n]; int i,b = skip(); for(i = 0; i < n; i++){ if(isSpaceChar(b)){ break; } c[i] = (char)b; b = readByte(); } return i == n ? c : Arrays.copyOf(c,i);  } }
4,public class Abra {  public static void main(String[] args) throws IOException {   new Abra().run();  }  StreamTokenizer in;  PrintWriter out;  boolean oj;  void init() throws IOException {   oj = System.getProperty("ONLINE_JUDGE") != null;   Reader reader = oj ? new InputStreamReader(System.in) : new FileReader(     "input.txt");   Writer writer = oj ? new OutputStreamWriter(System.out)     : new FileWriter("output.txt");   in = new StreamTokenizer(new BufferedReader(reader));   out = new PrintWriter(writer);  }  void run() throws IOException {   long beginTime = System.currentTimeMillis();   init();   solve();   out.flush();  }  void printMem() {   if (!oj) {    System.out.println("Memory used = "      + (Runtime.getRuntime().totalMemory() - Runtime        .getRuntime().freeMemory()));   }  }  int nextInt() throws IOException {   in.nextToken();   return (int) in.nval;  }  long nextLong() throws IOException {   in.nextToken();   return (long) in.nval;  }  String nextString() throws IOException {   in.nextToken();   return in.sval;  }  double nextDouble() throws IOException {   in.nextToken();   return in.nval;  }  long deg(long x, long y) {   long a = x;   for (long i = 2; i <= y; i++) {    a *= x;   }   return a;  }  long fact(long x) {   long a = 1;   for (long i = 2; i <= x; i++) {    a *= i;   }   return a;  }  long digitSum(String x) {   long a = 0;   for (int i = 0; i < x.length(); i++) {    a += x.codePointAt(i) - 48;   }   return a;  }  long digitSum(long x) {   long a = 0;   while (x > 0) {    a += x % 10;    x /= 10;   }   return a;  }  long digitMul(long x) {   long a = 1;   while (x > 0) {    a *= x % 10;    x /= 10;   }   return a;  }   int digitCubesSum(int x) {   int a = 0;   while (x > 0) {    a += (x % 10) * (x % 10) * (x % 10);    x /= 10;   }   return a;  }  double pif(double ax, double ay, double bx, double by) {   return Math.sqrt((ax - bx) * (ax - bx) + (ay - by) * (ay - by));  }  double getPosPart(double x) {   if (x <= 0)    return 0;   else    return x;  }  double max(double x, double y) {   if (x > y)    return x;   else    return y;  }  long gcd(long a, long b) {   if (a < b) {    long c = b;    b = a;    a = c;   }   while (a % b != 0) {    a = a % b;    if (a < b) {     long c = b;     b = a;     a = c;    }   }   return b;  }  int gcd(int a, int b) {   if (a < b) {    int c = b;    b = a;    a = c;   }   while (a % b != 0) {    a = a % b;    if (a < b) {     int c = b;     b = a;     a = c;    }   }   return b;  }  long lcm(long a, long b) throws IOException {   return a * b / gcd(a, b);  }  int lcm(int a, int b) throws IOException {   return a * b / gcd(a, b);  }  int countOccurences(String x, String y) {   int a = 0, i = 0;   while (true) {    i = y.indexOf(x);    if (i == -1)     break;    a++;    y = y.substring(i + 1);   }   return a;  }  int[] primes;  int findPrimes(int x) {   boolean[] forErato = new boolean[x];   primes = new int[x];   int l = 0, j = 0;   for (int i = 2; i < x; i++) {    if (forErato[i])     continue;    l++;    primes[l] = i;    j = i * 2;    while (j < x) {     forErato[j] = true;     j += i;    }   }   return l;  }  int rev(int x) {   int a = 0;   while (x > 0) {    a = a * 10 + x % 10;    x /= 10;   }   return a;  }  class myDate {   int d, m, y;   public myDate(int da, int ma, int ya) {    d = da;    m = ma;    y = ya;   }   int[] ml = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };   void inc() {    if ((d == 31) && (m == 12)) {     y++;     d = 1;     m = 1;    } else {     if (((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0)) {      ml[1] = 29;     }     if (d == ml[m - 1]) {      m++;      d = 1;     } else      d++;    }   }  }  int partition(int n, int l, int m) {     if (n < l)    return 0;   if (n < l + 2)    return 1;   if (l == 1)    return 1;   int c = 0;   for (int i = Math.min(n - l + 1, m); i >= (n + l - 1) / l; i--) {    c += partition(n - i, l - 1, i);   }   return c;  }   String s;  int l;   void solve() throws IOException {   s = nextString();   l = s.length();   int max = 0;   for (int i = 0; i < l - 1; i++) {    for (int j = i + 1; j < l; j++) {     if (countOccurences(s.substring(i, j), s) > 1)      if (j - i > max) max = j - i;    }   }   out.println(max);  } }
2,public class ed817Q3 { public static void main(String[] args){  InputReader in = new InputReader(System.in);  PrintWriter out = new PrintWriter(System.out);  int t = 1;  for(int zxz=0;zxz<t;zxz++){    long n = in.nextLong();  long s = in.nextLong();  long start=s,end=n;  long ans=n+1;  while(start<=end){   long mid = start+(end-start)/2;   if(mid-digitSum(mid)>=s){   ans = mid;   end = mid-1;   }   else{   start=mid+1;   }  }  System.out.println(n-ans+1);    } } static int digitSum(long n){  int sum=0;  while(n>0){  sum+=n%10;  n=n/10;  }  return sum; } static class InputReader {     private InputStream stream;   private byte[] buf = new byte[8192];   private int curChar, snumChars;   private SpaceCharFilter filter;    public InputReader(InputStream stream) {    this.stream = stream;   }    public int snext() {    if (snumChars == -1)     throw new InputMismatchException();    if (curChar >= snumChars) {     curChar = 0;     try {      snumChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (snumChars <= 0)      return -1;    }    return buf[curChar++];   }    public int nextInt() {    int c = snext();    while (isSpaceChar(c))     c = snext();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = snext();    }    int res = 0;    do {     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = snext();    } while (!isSpaceChar(c));    return res * sgn;   }    public long nextLong() {    int c = snext();    while (isSpaceChar(c))     c = snext();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = snext();    }    long res = 0;    do {     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = snext();    } while (!isSpaceChar(c));    return res * sgn;   }    public int[] nextIntArray(int n) {    int a[] = new int[n];    for (int i = 0; i < n; i++)     a[i] = nextInt();    return a;   }    public String readString() {    int c = snext();    while (isSpaceChar(c))     c = snext();    StringBuilder res = new StringBuilder();    do {     res.appendCodePoint(c);     c = snext();    } while (!isSpaceChar(c));    return res.toString();   }    public boolean isSpaceChar(int c) {    if (filter != null)     return filter.isSpaceChar(c);    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }    public interface SpaceCharFilter {    public boolean isSpaceChar(int ch);   }  } }
6,public class f {  static int n, m; static int start; static int[][] memo; static int[][] arr; static int[][] costs; static int[][] wrapCosts;  public static void main(String[] args) throws IOException {  FastScanner in = new FastScanner(System.in);  PrintWriter out = new PrintWriter(System.out);   n = in.nextInt();  m = in.nextInt();  arr = new int[n][m];  costs = new int[n][n];  wrapCosts = new int[n][n];  for (int r = 0; r < n; r++) {  for (int c = 0; c < m; c++) {   arr[r][c] = in.nextInt();  }  }  for (int i = 0; i < n; i++) {  for (int j = i + 1; j < n; j++) {   costs[i][j] = Integer.MAX_VALUE;   for (int c = 0; c < m; c++) {   costs[i][j] = Math.min(costs[i][j], Math.abs(arr[i][c] - arr[j][c]));   }   costs[j][i] = costs[i][j];  }  }  for (int i = 0; i < n; i++) {  for (int j = 0; j < n; j++) {   wrapCosts[i][j] = Integer.MAX_VALUE;   for (int c = 0; c < m - 1; c++) {   wrapCosts[i][j] = Math.min(wrapCosts[i][j], Math.abs(arr[i][c + 1] - arr[j][c]));   }  }  }  memo = new int[n][1 << n];  long best = 0;  for (start = 0; start < n; start++) {  for (int[] a : memo) Arrays.fill(a, -1);  best = Math.max(best, go(start, (1 << n) - 1 - (1 << start)));  }  out.println(best);  out.close(); } static int go(int cur, int mask) {  if (mask == 0) {  return wrapCosts[start][cur];  }  if (memo[cur][mask] != -1) return memo[cur][mask];  int ans = 0;  for (int next = 0; next < n; next++) {  int bit = 1 << next;  if ((mask & bit) == 0) continue;  ans = Math.max(ans, Math.min(costs[cur][next], go(next, mask ^ bit)));  }  return memo[cur][mask] = ans; }   static class FastScanner {  BufferedReader br;  StringTokenizer st;    public FastScanner(InputStream i) {   br = new BufferedReader(new InputStreamReader(i));   st = new StringTokenizer("");  }     public String next() throws IOException {   if(st.hasMoreTokens())    return st.nextToken();   else    st = new StringTokenizer(br.readLine());   return next();  }   public int nextInt() throws IOException {   return Integer.parseInt(next());  }    public long nextLong() throws IOException {   return Long.parseLong(next());  }  public double nextDouble() throws IOException {   return Double.parseDouble(next());  }   } }
0,public class Main {  public static void main (String[] args) {   BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));   try {    String parameterStringList[] = reader.readLine().split(" ");    int x = Integer.parseInt(parameterStringList[0]);    int y = Integer.parseInt(parameterStringList[1]);    int z = Integer.parseInt(parameterStringList[2]);    int t1 = Integer.parseInt(parameterStringList[3]);    int t2 = Integer.parseInt(parameterStringList[4]);    int t3 = Integer.parseInt(parameterStringList[5]);    int T1 = Math.abs(x-y) * t1;    int T2 = Math.abs(x-z) * t2 + 3*t3 + Math.abs(x-y) * t2;    if(T2 <= T1) System.out.println("YES");    else System.out.println("NO");   } catch (IOException e) {    e.printStackTrace();   }  } }
6,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  PrintWriter out = new PrintWriter(outputStream);  TaskE solver = new TaskE();  solver.solve(1, in, out);  out.close(); } } class TaskE {  private int n;  private double[] dp;  private double[][] p;  public void solve(int testNumber, InputReader in, PrintWriter out) {   n = in.nextInt();   p = new double[n][n];   for (int i = 0; i < n; ++i) {    for (int j = 0; j < n; ++j) {     p[i][j] = in.nextDouble();    }   }   dp = new double[1 << n];   Arrays.fill(dp, -1);   for (int i = 0; i < n; ++i) {    out.printf("%.6f ", rec(1 << i));   }   out.println();  }  private double rec(int mask) {   if (mask == (1 << n) - 1) return 1;   if (dp[mask] > -0.5) return dp[mask];   double res = 0;   int nn = Integer.bitCount(mask);   int total = (nn * (nn + 1)) / 2;   for (int i = 0; i < n; ++i) if (BitUtils.checkBit(mask, i)) for (int j = 0; j < n; ++j) if (!BitUtils.checkBit(mask, j)) {    res += rec(BitUtils.setBit(mask, j)) * p[i][j];   }   res /= total;   dp[mask] = res;   return res;  } } class InputReader {  private BufferedReader reader;  private StringTokenizer stt;  public InputReader(InputStream stream) {   reader = new BufferedReader(new InputStreamReader(stream));  }  public String nextLine() {   try {    return reader.readLine().trim();   } catch (IOException e) {    return null;   }  }  public String nextString() {   while (stt == null || !stt.hasMoreTokens()) {    stt = new StringTokenizer(nextLine());   }   return stt.nextToken();  }  public int nextInt() {   return Integer.parseInt(nextString());  }  public double nextDouble() {   return Double.parseDouble(nextString());  } } class BitUtils {  public static boolean checkBit(int mask, int bit) {   return (mask & (1 << bit)) > 0;  }  public static int setBit(int mask, int bit) {   return (mask | (1 << bit));  } }
2,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   BSportMafia solver = new BSportMafia();   solver.solve(1, in, out);   out.close();  }  static class BSportMafia {   public void solve(int testNumber, InputReader in, PrintWriter out) {    long n = in.nextInt();    long k = in.nextInt();    long d = 9 + 4 * (2 * n + 2 * k);    double smh = Math.sqrt(d);    double ans = (-3 + smh) / 2;    out.println(n - (int) ans);   }  }  static class InputReader {   private InputStream stream;   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   public InputReader(InputStream stream) {    this.stream = stream;   }   public int read() {    if (numChars == -1)     throw new InputMismatchException();    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (numChars <= 0)      return -1;    }    return buf[curChar++];   }   public int nextInt() {    int c = read();    while (isSpaceChar(c))     c = read();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   private boolean isSpaceChar(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }  } }
6,public class CFContest {  public static void main(String[] args) throws Exception {   boolean local = System.getProperty("ONLINE_JUDGE") == null;   boolean async = true;   Charset charset = Charset.forName("ascii");   FastIO io = local ? new FastIO(new FileInputStream("D:\\DATABASE\\TESTCASE\\Code.in"), System.out, charset) : new FastIO(System.in, System.out, charset);   Task task = new Task(io, new Debug(local));   if (async) {    Thread t = new Thread(null, task, "dalt", 1 << 27);    t.setPriority(Thread.MAX_PRIORITY);    t.start();    t.join();   } else {    task.run();   }   if (local) {    io.cache.append("\n\n--memory -- \n" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + "M");   }   io.flush();  }  public static class Task implements Runnable {   final FastIO io;   final Debug debug;   int inf = (int) 1e8;   long lInf = (long) 1e18;   public Task(FastIO io, Debug debug) {    this.io = io;    this.debug = debug;   }   @Override   public void run() {    int t = io.readInt();    while (t-- > 0)     solve1();   }    public void solve1() {    cache.clear();    int n = io.readInt();    int m = io.readInt();    Col[] mat = new Col[m];    for (int i = 0; i < m; i++) {     mat[i] = new Col();     mat[i].data = new int[n];    }    for (int i = 0; i < n; i++) {     for (int j = 0; j < m; j++) {      int v = io.readInt();      mat[j].data[i] = v;      mat[j].max = Math.max(mat[j].max, v);     }    }    Arrays.sort(mat, (a, b) -> -(a.max - b.max));    mat = Arrays.copyOf(mat, Math.min(n, m));    io.cache.append(bf(mat, getCol(n), n, 0)).append('\n');   }   public void enhance(Col mask, Col c, Col ans, int n) {    for (int i = 0; i < n; i++) {     ans.data[i] = Math.max(mask.get(i), c.get(i));    }   }   Deque<Col> cache = new ArrayDeque<>();   public Col getCol(int n) {    if (cache.isEmpty()) {     Col col = new Col();     col.data = new int[n];     return col;    }    return cache.removeFirst();   }   public void destroy(Col c) {    c.offset = 0;    c.max = 0;    cache.addLast(c);   }   public int bf(Col[] cols, Col mask, int n, int k) {    if (k >= cols.length) {     int sum = 0;     for (int i = 0; i < n; i++) {      sum += mask.data[i];     }     return sum;    }    int max = 0;    cols[k].offset = 0;    for (int i = 0; i < n; i++) {     Col c = getCol(n);     enhance(mask, cols[k], c, n);     max = Math.max(max, bf(cols, c, n, k + 1));     destroy(c);     cols[k].turn();    }    return max;   }  }  public static class Col {   int[] data;   int offset;   public int get(int i) {    return data[(i + offset) % data.length];   }   public void turn() {    offset++;   }   int max;  }   public static class FastIO {   public final StringBuilder cache = new StringBuilder(20 << 20);   private final InputStream is;   private final OutputStream os;   private final Charset charset;   private StringBuilder defaultStringBuf = new StringBuilder(1 << 8);   private byte[] buf = new byte[1 << 20];   private int bufLen;   private int bufOffset;   private int next;   public FastIO(InputStream is, OutputStream os, Charset charset) {    this.is = is;    this.os = os;    this.charset = charset;   }   public FastIO(InputStream is, OutputStream os) {    this(is, os, Charset.forName("ascii"));   }   private int read() {    while (bufLen == bufOffset) {     bufOffset = 0;     try {      bufLen = is.read(buf);     } catch (IOException e) {      throw new RuntimeException(e);     }     if (bufLen == -1) {      return -1;     }    }    return buf[bufOffset++];   }   public void skipBlank() {    while (next >= 0 && next <= 32) {     next = read();    }   }   public int readInt() {    int sign = 1;    skipBlank();    if (next == '+' || next == '-') {     sign = next == '+' ? 1 : -1;     next = read();    }    int val = 0;    if (sign == 1) {     while (next >= '0' && next <= '9') {      val = val * 10 + next - '0';      next = read();     }    } else {     while (next >= '0' && next <= '9') {      val = val * 10 - next + '0';      next = read();     }    }    return val;   }   public long readLong() {    int sign = 1;    skipBlank();    if (next == '+' || next == '-') {     sign = next == '+' ? 1 : -1;     next = read();    }    long val = 0;    if (sign == 1) {     while (next >= '0' && next <= '9') {      val = val * 10 + next - '0';      next = read();     }    } else {     while (next >= '0' && next <= '9') {      val = val * 10 - next + '0';      next = read();     }    }    return val;   }   public double readDouble() {    boolean sign = true;    skipBlank();    if (next == '+' || next == '-') {     sign = next == '+';     next = read();    }    long val = 0;    while (next >= '0' && next <= '9') {     val = val * 10 + next - '0';     next = read();    }    if (next != '.') {     return sign ? val : -val;    }    next = read();    long radix = 1;    long point = 0;    while (next >= '0' && next <= '9') {     point = point * 10 + next - '0';     radix = radix * 10;     next = read();    }    double result = val + (double) point / radix;    return sign ? result : -result;   }   public String readString(StringBuilder builder) {    skipBlank();    while (next > 32) {     builder.append((char) next);     next = read();    }    return builder.toString();   }   public String readString() {    defaultStringBuf.setLength(0);    return readString(defaultStringBuf);   }   public int readLine(char[] data, int offset) {    int originalOffset = offset;    while (next != -1 && next != '\n') {     data[offset++] = (char) next;     next = read();    }    return offset - originalOffset;   }   public int readString(char[] data, int offset) {    skipBlank();    int originalOffset = offset;    while (next > 32) {     data[offset++] = (char) next;     next = read();    }    return offset - originalOffset;   }   public int readString(byte[] data, int offset) {    skipBlank();    int originalOffset = offset;    while (next > 32) {     data[offset++] = (byte) next;     next = read();    }    return offset - originalOffset;   }   public char readChar() {    skipBlank();    char c = (char) next;    next = read();    return c;   }   public void flush() {    try {     os.write(cache.toString().getBytes(charset));     os.flush();     cache.setLength(0);    } catch (IOException e) {     throw new RuntimeException(e);    }   }   public boolean hasMore() {    skipBlank();    return next != -1;   }  }  public static class Debug {   private boolean allowDebug;   public Debug(boolean allowDebug) {    this.allowDebug = allowDebug;   }   public void assertTrue(boolean flag) {    if (!allowDebug) {     return;    }    if (!flag) {     fail();    }   }   public void fail() {    throw new RuntimeException();   }   public void assertFalse(boolean flag) {    if (!allowDebug) {     return;    }    if (flag) {     fail();    }   }   private void outputName(String name) {    System.out.print(name + " = ");   }   public void debug(String name, int x) {    if (!allowDebug) {     return;    }    outputName(name);    System.out.println("" + x);   }   public void debug(String name, long x) {    if (!allowDebug) {     return;    }    outputName(name);    System.out.println("" + x);   }   public void debug(String name, double x) {    if (!allowDebug) {     return;    }    outputName(name);    System.out.println("" + x);   }   public void debug(String name, int[] x) {    if (!allowDebug) {     return;    }    outputName(name);    System.out.println(Arrays.toString(x));   }   public void debug(String name, long[] x) {    if (!allowDebug) {     return;    }    outputName(name);    System.out.println(Arrays.toString(x));   }   public void debug(String name, double[] x) {    if (!allowDebug) {     return;    }    outputName(name);    System.out.println(Arrays.toString(x));   }   public void debug(String name, Object x) {    if (!allowDebug) {     return;    }    outputName(name);    System.out.println("" + x);   }   public void debug(String name, Object... x) {    if (!allowDebug) {     return;    }    outputName(name);    System.out.println(Arrays.deepToString(x));   }  } }
2,public class Main {  static class Task {   int NN = 500005;  int MOD = 1000000007;  int INF = 2000000000;  long INFINITY = 2000000000000000000L;   public void solve(InputReader in, PrintWriter out) {  int t = in.nextInt();  while(t-->0) {   long n = in.nextLong();   long k = in.nextLong();   if(n < 32 && k > ((1L<<(2L*n))-1L)/3L) {   out.println("NO");continue;   }   if(n == 2 && k == 3) {   out.println("NO");continue;   }   if(n >= 32) {   out.println("YES "+ (n-1));continue;   }   boolean done = false;   for(long i=1;i<=n;++i) {   if(k < (1L<<(i+2L))-i-3L) {    done = true;    out.println("YES " + (n - i));break;   }   }   if(!done) {   out.println("YES 0");   }  }  }   }  static void prepareIO(boolean isFileIO) {   Task solver = new Task();   if(!isFileIO) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   solver.solve(in, out);      out.close();  }    else {  String IPfilePath = System.getProperty("user.home") + "/Downloads/ip.in";   String OPfilePath = System.getProperty("user.home") + "/Downloads/op.out";   InputReader fin = new InputReader(IPfilePath);   PrintWriter fout = null;   try {   fout = new PrintWriter(new File(OPfilePath));  } catch (FileNotFoundException e) {   e.printStackTrace();  }   solver.solve(fin, fout);      fout.close();  } }  public static void main(String[] args) {   prepareIO(false); }  static class InputReader {   public BufferedReader reader;   public StringTokenizer tokenizer;   public InputReader(InputStream stream) {    reader = new BufferedReader(new InputStreamReader(stream), 32768);    tokenizer = null;   }     public InputReader(String filePath) {   File file = new File(filePath);    try {   reader = new BufferedReader(new FileReader(file));  } catch (FileNotFoundException e) {     e.printStackTrace();  }    tokenizer = null;   }     public String nextLine() {   String str = "";   try {   str = reader.readLine();  } catch (IOException e) {     e.printStackTrace();  }   return str;   }     public String next() {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      tokenizer = new StringTokenizer(reader.readLine());     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return tokenizer.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }   public long nextLong() {    return Long.parseLong(next());   }   public double nextDouble() {   return Double.parseDouble(next());   }    } }
1,public class Main {     public static void main(String[] args) {        Scanner in=new Scanner(System.in);   int n=in.nextInt();      if(n>=3&&n<=100)   {   int num[]=new int[n];   for(int i=0;i<n;i++)   {    num[i]=in.nextInt();   }   int even=0,odd=0,ceven=0,codd=0;   for(int i=0;i<n;i++)   {    if(num[i]%2==0)    {     even++;     ceven=i+1;        }    else    {     odd++;     codd=i+1;    }   }   if(odd==1)   {    System.out.println(""+codd);   }   else   {    System.out.println(""+ceven);   }   }  } }
3,public class DivRound584ProblemA { static FastReader sc=new FastReader();  public static void main(String args[]) throws IOException {  int n = sc.nextInt();   int a[]=new int[n];   for(int i=0;i<n;i++)  a[i]=sc.nextInt();   Arrays.sort(a);  int c=0;  for(int i=0;i<n;i++) {  if(a[i]<0) continue;  c=c-1;  for(int j=i+1;j<n;j++) {   if(a[j]<0) continue;   if(a[j]%a[i]==0) {      a[j]=c;   }  }    }  System.out.println(Math.abs(c)); }  static class FastReader  {   BufferedReader br;   StringTokenizer st;    public FastReader()   {    br = new BufferedReader(new      InputStreamReader(System.in));   }    String next()   {    while (st == null || !st.hasMoreElements())    {     try     {      st = new StringTokenizer(br.readLine());     }     catch (IOException e)     {      e.printStackTrace();     }    }    return st.nextToken();   }    int nextInt()   {    return Integer.parseInt(next());   }    long nextLong()   {    return Long.parseLong(next());   }    double nextDouble()   {    return Double.parseDouble(next());   }    String nextLine()   {    String str = "";    try    {     str = br.readLine();    }    catch (IOException e)    {     e.printStackTrace();    }    return str;   }  } }
3,public class p4 {    static int N, M, K;  static String s;  static StringTokenizer st;  static int[] d;  public static void main(String[] args) throws Exception {   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));      int N = Integer.parseInt(br.readLine());   int[] d = new int[N];   st = new StringTokenizer(br.readLine());   for (int i = 0; i < N; i++) {    d[i] = Integer.parseInt(st.nextToken());   }   boolean cur = ((inv(d)) % 2) == 1;     int Q = Integer.parseInt(br.readLine());   for (int i = 0; i < Q; i++) {    st = new StringTokenizer(br.readLine());    int a = Integer.parseInt(st.nextToken());    int b = Integer.parseInt(st.nextToken());    int dif = b - a + 1;    if (dif / 2 % 2 == 1) {     cur = !cur;    }    System.out.println((cur) ? "odd" : "even");   }         }  static class BIT {   int[] tree;   int N;   public BIT(int N) {    this.N = N;    tree = new int[N + 1];   }   public BIT(int N, int[] d) {    this.N = N;    tree = new int[N + 1];    for (int i = 1; i < d.length; i++) {     update(i, d[i]);    }   }   public int query(int K) {    int sum = 0;    for (int i = K; i > 0; i -= (i & -i)) {     sum += tree[i];    }    return sum;   }   public void update(int K, int val) {    for (int i = K; i <= N; i += (i & -i)) {     tree[i] += val;    }   }  }  public static int[] toRel(int[] d) {   pair[] p = new pair[d.length];   for (int i = 0; i < d.length; i++) {    p[i] = new pair(d[i], i + 1);   }   Arrays.sort(p);   int[] fin = new int[d.length];   for (int i = 0; i < d.length; i++) {    fin[i] = p[i].b;   }   return fin;  }  public static int inv(int[] d) {   int ans = 0;   int N = d.length;   int[] x = toRel(d);   BIT b = new BIT(N + 1);   for (int i = N - 1; i >= 0; i--) {    ans += b.query(x[i]);    b.update(x[i], 1);   }   return ans;  } } class pair implements Comparable<pair> {  int a, b;  public pair(int _a, int _b) {   this.a = _a;   this.b = _b;  }  @Override  public int compareTo(pair t) {   return (a == t.a) ? b - t.b : a - t.a;  } }
0,public class Solution {  public static void main(String [] args){   Scanner stdin = new Scanner(System.in);   long n = stdin.nextLong();   if(n<3) System.out.println(n);   else {    if(n%2==0){     long a=0,b=0;     if(n%3!=0) a = (n*(n-1)*(n-3));      n--;     b = (n*(n-1)*(n-2));     System.out.println(Math.max(a, b));    }    else System.out.println(n*(n-1)*(n-2));   }  } }
1,public class A{  void exe(){   LinkedList<Integer> list=new LinkedList<Integer>();   for(int i=2;i<=1000;i++)    if(isPrime(i))     list.add(i);   Object[] primes=list.toArray();     Scanner sc=new Scanner(System.in);   int n=sc.nextInt();   int k=sc.nextInt();   int cnt=0;   for(int c=2;c<=n;c++){    if(!isPrime(c))     continue;    for(int i=0;i<primes.length-1;i++){     int p1=(Integer)primes[i];     int p2=(Integer)primes[i+1];     if(c==1+p1+p2){      cnt++;     }    }   }   if(cnt>=k){    System.out.println("YES");   }else{    System.out.println("NO");   }  }  boolean isPrime(int n){   if(n<=1)return false;   if(n==2)return true;   if(n%2==0)return false;   int m=(int)Math.sqrt(n)+1;   for(int i=3;i<=m;i+=2)    if(n%i==0)     return false;   return true;  }   public static void main(String[] args){   Locale.setDefault(Locale.US);   new A().exe();  } }
1,public class Naldbah implements Runnable {  boolean isLocalMode = false;  public static void main(String[] args) {   new Naldbah().run();  }  BufferedReader reader;  StringTokenizer tokenizer;  PrintWriter writer;  public void run() {   try {    reader = new BufferedReader(getReader());    tokenizer = null;    writer = new PrintWriter(System.out);       doJob();    reader.close();    writer.close();   } catch (Exception e) {    e.printStackTrace();    System.exit(1);   }  }  private void doJob() throws IOException {   int n = nextInt();   int k = nextInt();   boolean[] primes = sieve(n + 1);   for(int i=n;i>=2;i--){    if(primes[i]){     int solve = i-1;     int sn=getNextD(primes,solve);     int en = getNextD(primes,n);     while(en!=-1&&sn+en>=solve){      if((sn+en)==solve)k--;      sn=en;      en=getNextD(primes,en);     }    }   }   writer.write(k<=0?"YES":"NO");  }  private int getNextD(boolean[] primes, int i) {   for(int p = i-1;p>=2;p--){    if(primes[p])return p;   }   return -1;  }  public boolean[] sieve(int n)  {   boolean[] prime=new boolean[n+1];   Arrays.fill(prime,true);   prime[0]=false;   prime[1]=false;   int m= (int) Math.sqrt(n);   for (int i=2; i<=m; i++)   if (prime[i])    for (int k=i*i; k<=n; k+=i)     prime[k]=false;   return prime;  }   int nextInt() throws IOException {   return Integer.parseInt(nextToken());  }  long nextLong() throws IOException {   return Long.parseLong(nextToken());  }  double nextDouble() throws IOException {   return Double.parseDouble(nextToken());  }  String nextToken() throws IOException {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    tokenizer = new StringTokenizer(reader.readLine());   }   return tokenizer.nextToken();  }  public Reader getReader() throws FileNotFoundException {   if (isLocalMode) {    return new FileReader("input.txt");   } else {    return new InputStreamReader(System.in);   }  } }
4,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   Scanner in = new Scanner(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskD solver = new TaskD();   solver.solve(1, in, out);   out.close();  }  static class TaskD {   Scanner in;   PrintWriter out;   public void solve(int testNumber, Scanner in, PrintWriter out) {    this.in = in;    this.out = out;    run();   }   void run() {    int n = in.nextInt();    int m = in.nextInt();    int k = in.nextInt();    int[][][] dis = new int[n][m][4];    int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};    int tmp;    final int M = (int) (1e8);    Algo.fill(dis, M);    for (int i = 0; i < n; i++) {     for (int j = 0; j < m - 1; j++) {      tmp = in.nextInt();      dis[i][j][0] = tmp;      dis[i][j + 1][1] = tmp;     }    }    for (int i = 0; i < n - 1; i++) {     for (int j = 0; j < m; j++) {      tmp = in.nextInt();      dis[i][j][2] = tmp;      dis[i + 1][j][3] = tmp;     }    }    int[][] ans = new int[n][m];    if (k % 2 == 1) {     Algo.fill(ans, -1);    } else {     int halfK = k / 2;     int[][][] dp = new int[halfK + 1][n][m];     Algo.fill(dp, M);     for (int i = 0; i < n; i++) {      for (int j = 0; j < m; j++) {       dp[0][i][j] = 0;      }     }     for (int step = 1; step <= halfK; step++) {      for (int i = 0; i < n; i++) {       for (int j = 0; j < m; j++) {        for (int d = 0; d < dir.length; d++) {         int toX = i + dir[d][0];         int toY = j + dir[d][1];         if (toX < 0 || toY < 0 || toX >= n || toY >= m) continue;         dp[step][i][j] = Math.min(dp[step - 1][toX][toY] + 2 * dis[i][j][d], dp[step][i][j]);        }       }      }     }     ans = dp[halfK];    }     for (int i = 0; i < n; i++) {     for (int j = 0; j < m; j++) {      out.print(ans[i][j]);      out.print(' ');     }     out.println("");    }    }  }  static class Algo {   public static void fill(int[][] iss, int v) {    for (int[] is : iss) Arrays.fill(is, v);   }   public static void fill(int[][][] isss, int v) {    for (int[][] iss : isss) Algo.fill(iss, v);   }  }  static class Scanner {   BufferedReader br;   StringTokenizer st;   public Scanner(InputStream in) {    br = new BufferedReader(new InputStreamReader(in));    eat("");   }   private void eat(String s) {    st = new StringTokenizer(s);   }   public String nextLine() {    try {     return br.readLine();    } catch (IOException e) {     return null;    }   }   public boolean hasNext() {    while (!st.hasMoreTokens()) {     String s = nextLine();     if (s == null)      return false;     eat(s);    }    return true;   }   public String next() {    hasNext();    return st.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }  } }
5,public class A { Scanner in = new Scanner(System.in);  public class Houses implements Comparable<Houses>{  double x;  double a;   public Houses(double xVal, double aVal){  x = xVal-aVal/2;  a = aVal;  }  @Override  public int compareTo(Houses o) {  return (int) (x - o.x);  }  }  public void solve2(ArrayList<Houses> list,int t){  Collections.sort(list);  int count = 2;    for(int f = 0; f < list.size()-1; f++){   if(list.get(f+1).x-list.get(f).x-list.get(f).a > t){   count+=2;  }  else if(list.get(f+1).x-list.get(f).x-list.get(f).a == t){   count++;  }    }   System.out.println(count); }  public void solve(){  ArrayList<Houses> list = new ArrayList<Houses>();  int n = in.nextInt();  int t = in.nextInt();  for(int i = 0; i < n; i++){  list.add(new Houses(in.nextDouble(),in.nextDouble()));  }   solve2(list,t); }  public static void main(String[] args){  A p = new A();  p.solve(); } }
2,public class ehsan { public static BigInteger f(BigInteger m,BigInteger n){  BigInteger s,l;  s=n.multiply(m.add(BigInteger.valueOf(1)));  l=m.multiply(m.add(BigInteger.valueOf(1)));  l=l.divide(BigInteger.valueOf(2));  s=s.subtract(l);  s=s.subtract(m);  return s; } public static BigInteger bs(BigInteger a,BigInteger b,BigInteger n,BigInteger d){  BigInteger c,e;  c=a.add(b);  c=c.divide(BigInteger.valueOf(2));  e=f(c,n);  if(e.equals(d))  return c.add(BigInteger.valueOf(1));  if(a.equals(b.add(BigInteger.valueOf(-1))))  return b.add(BigInteger.valueOf(1));  if(e.compareTo(d)>0)  return bs(a,c,n,d);  return bs(c,b,n,d); } public static void main(String[] args)  {  Scanner sc = new Scanner(System.in);  BigInteger bi1 = sc.nextBigInteger();  BigInteger bi2 = sc.nextBigInteger();  BigInteger i,n=bi2;  BigInteger i2=BigInteger.valueOf(1);  BigInteger sum=BigInteger.valueOf(0);  if(bi1.compareTo(bi2)<0){  System.out.println(0);  return;  }  else if( bi1.compareTo(bi2) == 0 )  {  System.out.println(1);  return;  }  bi2=((n.multiply(n.add(BigInteger.valueOf(1)))).divide(BigInteger.valueOf(2))).subtract(n.subtract(BigInteger.valueOf(1)));  if(bi1.compareTo(bi2)>0)  System.out.println(-1);  else{  System.out.println(bs(BigInteger.valueOf(0),n.add(BigInteger.valueOf(-2)),n,bi1));  } } }
4,public class CF387D { static class A {  ArrayList<Integer> list = new ArrayList<>();  int u, v, d; } static final int INF = Integer.MAX_VALUE; static boolean bfs(A[] aa, int n) {  ArrayDeque<Integer> q = new ArrayDeque<>();  for (int u = 1; u <= n; u++)  if (aa[u].v > 0)   aa[u].d = INF;  else {   aa[u].d = 0;   q.addLast(u);  }  aa[0].d = INF;  while (!q.isEmpty()) {  int u = q.removeFirst();  for (int v : aa[u].list) {   int w = aa[v].u;   if (aa[w].d == INF) {   aa[w].d = aa[u].d + 1;   if (w == 0)    return true;   q.addLast(w);   }  }  }  return false; } static boolean dfs(A[] aa, int n, int u) {  if (u == 0)  return true;  for (int v : aa[u].list) {  int w = aa[v].u;  if (aa[w].d == aa[u].d + 1 && dfs(aa, n, w)) {   aa[u].v = v;   aa[v].u = u;   return true;  }  }  aa[u].d = INF;  return false; } static int matchings(A[] aa, int n) {  int cnt = 0;  while (bfs(aa, n))  for (int u = 1; u <= n; u++)   if (aa[u].v == 0 && dfs(aa, n, u))   cnt++;  return cnt; } public static void main(String[] args) throws IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer(br.readLine());  int n = Integer.parseInt(st.nextToken());  int m = Integer.parseInt(st.nextToken());  int[] eu = new int[m];  int[] ev = new int[m];  for (int j = 0; j < m; j++) {  st = new StringTokenizer(br.readLine());  eu[j] = Integer.parseInt(st.nextToken());  ev[j] = Integer.parseInt(st.nextToken());  }  A[] aa = new A[n + 1];  int min = m + n * 3;  for (int ctr = 1; ctr <= n; ctr++) {  boolean loop = false;  boolean[] ci = new boolean[n + 1];  boolean[] co = new boolean[n + 1];  for (int i = 0; i <= n; i++)   aa[i] = new A();  int m_ = 0;  for (int j = 0; j < m; j++) {   int u = eu[j];   int v = ev[j];   if (u == ctr && v == ctr)   loop = true;   else if (u == ctr && v != ctr)   ci[v] = true;   else if (u != ctr && v == ctr)   co[u] = true;   else {   aa[u].list.add(v);   m_++;   }  }  int cnt = loop ? 0 : 1;  for (int i = 1; i <= n; i++)   if (i != ctr) {   if (!ci[i])    cnt++;   if (!co[i])    cnt++;   }  int m2 = matchings(aa, n);  cnt += (m_ - m2) + (n - 1 - m2);  if (min > cnt)   min = cnt;  }  System.out.println(min); } }
3,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   FastReader in = new FastReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskC solver = new TaskC();   solver.solve(1, in, out);   out.close();  }  static class TaskC {   static final long MODULO = (long) (1e9 + 7);   public void solve(int testNumber, FastReader in, PrintWriter out) {    int n = in.nextInt();    long[][] dp = new long[n + 100][n + 100];    dp[0][0] = 1;    for (int i = 0; i < n; ++i) {     char current = in.nextCharacter();     if (current == 'f') {      for (int j = 0; j < n; ++j) {             dp[i + 1][j + 1] += dp[i][j];       dp[i + 1][j + 1] %= MODULO;      }     } else {      long runningSum = 0;      for (int j = n; j >= 0; --j) {                          runningSum += dp[i][j];       runningSum %= MODULO;       dp[i + 1][j] += runningSum;       dp[i + 1][j] %= MODULO;      }     }    }    out.println(dp[n][0]);   }  }  static class FastReader {   private InputStream stream;   private byte[] buf = new byte[8192];   private int curChar;   private int pnumChars;   public FastReader(InputStream stream) {    this.stream = stream;   }   private int pread() {    if (pnumChars == -1) {     throw new InputMismatchException();    }    if (curChar >= pnumChars) {     curChar = 0;     try {      pnumChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (pnumChars <= 0) {      return -1;     }    }    return buf[curChar++];   }   public int nextInt() {    int c = pread();    while (isSpaceChar(c))     c = pread();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = pread();    }    int res = 0;    do {     if (c == ',') {      c = pread();     }     if (c < '0' || c > '9') {      throw new InputMismatchException();     }     res *= 10;     res += c - '0';     c = pread();    } while (!isSpaceChar(c));    return res * sgn;   }   private boolean isSpaceChar(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   public char nextCharacter() {    int c = pread();    while (isSpaceChar(c))     c = pread();    return (char) c;   }  } }
4,public class A implements Runnable { public static void main(String[] args) {  new A().run(); }  class FastScanner {  BufferedReader br;  StringTokenizer st;  boolean eof;  String buf;  public FastScanner(String fileName) throws FileNotFoundException {  br = new BufferedReader(new FileReader(fileName));  nextToken();  }  public FastScanner(InputStream stream) {  br = new BufferedReader(new InputStreamReader(stream));  nextToken();  }  String nextToken() {  while (st == null || !st.hasMoreTokens()) {   try {   st = new StringTokenizer(br.readLine());   } catch (Exception e) {   eof = true;   break;   }  }  String ret = buf;  buf = eof ? "-1" : st.nextToken();  return ret;  }  int nextInt() {  return Integer.parseInt(nextToken());  }  long nextLong() {  return Long.parseLong(nextToken());  }  double nextDouble() {  return Double.parseDouble(nextToken());  }  void close() {  try {   br.close();  } catch (Exception e) {   }  }  boolean isEOF() {  return eof;  } }  FastScanner sc; PrintWriter out;  public void run() {  Locale.setDefault(Locale.US);  try {  sc = new FastScanner(System.in);  out = new PrintWriter(System.out);  solve();  sc.close();  out.close();  } catch (Throwable e) {  e.printStackTrace();  System.exit(1);  } }  int nextInt() {  return sc.nextInt(); }  String nextToken() {  return sc.nextToken(); }  long nextLong() {  return sc.nextLong(); }  double nextDouble() {  return sc.nextDouble(); }  void solve() {  String s = nextToken();  for (int len = s.length(); len >= 1; len--) {  for (int i = 0; i + len <= s.length(); i++) {   int cnt = 0;   for (int j = 0; j + len <= s.length(); j++) {   boolean ok = true;   for (int k = 0; k < len; k++) {    if (s.charAt(i + k) != s.charAt(j + k)) {    ok = false;    break;    }   }   if (ok) {    cnt++;   }   }   if (cnt > 1) {   out.println(len);   return;   }  }  }  out.println(0); } }
6,public class F {  public static void main(String[] args) {   FastScanner scanner = new FastScanner();   int N = scanner.nextInt();   int M = scanner.nextInt();   int[][] matrix = new int[N][M];   for(int i = 0; i < N; i++) {    for(int j = 0; j < M; j++) {     matrix[i][j] = scanner.nextInt();    }   }   int[][] maxDist = new int[N][N];   for(int i = 0; i < N; i++) {    Arrays.fill(maxDist[i], Integer.MAX_VALUE);   }   for(int i = 0; i < M; i++) {    for(int j = 0; j < N; j++) {     for(int k = j+1; k < N; k++) {      maxDist[j][k] = Math.min(maxDist[j][k], Math.abs(matrix[k][i] - matrix[j][i]));      maxDist[k][j] = maxDist[j][k];     }    }   }   int[][] distTop = new int[N][N];   for(int i = 0; i < N; i++) {    Arrays.fill(distTop[i], Integer.MAX_VALUE);   }   for(int i = 0; i < M-1; i++) {    for(int j = 0; j < N; j++) {     for(int k = 0; k < N; k++) {      distTop[j][k] = Math.min(distTop[j][k], Math.abs(matrix[j][i] - matrix[k][i+1]));     }    }   }   if (N == 1) {    System.out.println(distTop[0][0]);    System.exit(0);   }   int[] bitLoc = new int[1<<N];   for(int i = 0; i < N; i++) {    bitLoc[1 << i] = i;   }   int[][][] dp = new int[1<<N][N][N];     for(int mask = 1; mask < (1 << N); mask++) {    for(int smask = mask; smask > 0; smask &= (smask-1)) {     int i = bitLoc[Integer.lowestOneBit(smask)];     for (int ss = mask ^ 1 << i; ss > 0; ss &= ss - 1) {      int j = bitLoc[Integer.lowestOneBit(ss)];      if (mask == (1 << i ^ 1 << j))       dp[mask][i][j] = maxDist[i][j];      else {       int x = 0;       for (int sss = mask ^ 1 << i ^ 1 << j; sss > 0; sss &= sss - 1) {        int k = bitLoc[sss & -sss];        x = Math.max(x, Math.min(dp[mask ^ 1 << j][i][k], maxDist[k][j]));       }       dp[mask][i][j] = x;      }     }    }   }   int mxMsk = (1 << N) -1;   int max = 0;   for(int i = 0; i < N; i++) {    for(int j = 0; j < N; j++) {     if (i==j) continue;     max = Math.max(max, Math.min(dp[mxMsk][i][j], distTop[i][j]));    }   }   System.out.println(max);  }  public static class FastScanner {   BufferedReader br;   StringTokenizer st;   public FastScanner(Reader in) {    br = new BufferedReader(in);   }   public FastScanner() {    this(new InputStreamReader(System.in));   }   String next() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }   int nextInt() {    return Integer.parseInt(next());   }   long nextLong() {    return Long.parseLong(next());   }   double nextDouble() {    return Double.parseDouble(next());   }   String readNextLine() {    String str = "";    try {     str = br.readLine();    } catch (IOException e) {     e.printStackTrace();    }    return str;   }   int[] readIntArray(int n) {    int[] a = new int[n];    for (int idx = 0; idx < n; idx++) {     a[idx] = nextInt();    }    return a;   }  } }
3,public class C {  static ArrayList<Integer> statements; static final int MOD = (int) 1e9 + 7;  static int[][] memo;  static int solve(int i, int c) {  if(i == statements.size())  return 1;  if(memo[i][c] != -1)  return memo[i][c];  long ans = solve(i + 1, c + statements.get(i));  if(c > 0)  ans += solve(i, c - 1);  return memo[i][c] = (int) (ans % MOD);  }  public static void main(String[] args) throws IOException {  Scanner sc = new Scanner(System.in);  PrintWriter out = new PrintWriter(System.out);  int n = sc.nextInt();  statements = new ArrayList<>();  char[] c = new char[n];  for (int i = 0; i < n; i++) {  c[i] = sc.next().charAt(0);  }  if(c[0] == 's')  statements.add(0);  else  statements.add(1);  for (int i = 1; i < n; i++) {  if(c[i - 1] == 'f') {   if(c[i] == 'f')   statements.set(statements.size() - 1, statements.get(statements.size() - 1) + 1);  }else {   if(c[i] == 's')   statements.add(0);   else   statements.add(1);  }  }   memo = new int[statements.size()][n + 1];  for(int[] a : memo)  Arrays.fill(a, -1);  out.println(solve(0, 0));  out.flush();  out.close(); }  static class Scanner {  StringTokenizer st;  BufferedReader br;  public Scanner(InputStream s) {  br = new BufferedReader(new InputStreamReader(s));  }  public Scanner(String file) throws FileNotFoundException {  br = new BufferedReader(new FileReader(file));  }  public String next() throws IOException {  while (st == null || !st.hasMoreTokens())   st = new StringTokenizer(br.readLine());  return st.nextToken();  }  public int nextInt() throws IOException {  return Integer.parseInt(next());  }  public long nextLong() throws IOException {  return Long.parseLong(next());  }  public String nextLine() throws IOException {  return br.readLine();  }  public double nextDouble() throws IOException {  String x = next();  StringBuilder sb = new StringBuilder("0");  double res = 0, f = 1;  boolean dec = false, neg = false;  int start = 0;  if (x.charAt(0) == '-') {   neg = true;   start++;  }  for (int i = start; i < x.length(); i++)   if (x.charAt(i) == '.') {   res = Long.parseLong(sb.toString());   sb = new StringBuilder("0");   dec = true;   } else {   sb.append(x.charAt(i));   if (dec)    f *= 10;   }  res += Long.parseLong(sb.toString()) / f;  return res * (neg ? -1 : 1);  }  public boolean ready() throws IOException {  return br.ready();  }  } }
6,public class Problem {  public static void main(String[] arg){  FastScanner scan = new FastScanner(System.in);  PrintWriter out = new PrintWriter(System.out);  int n = scan.nextInt();   double ncr[][] = new double[n+1][n+1];  ncr[1][0] = ncr[0][1] = ncr[1][1] = 1.0;  for(int i = 2; i <= n; i++){  for(int j = 0; j <= i; j++){   if(j == 0 || j == i) ncr[i][j] = 1.0;   else ncr[i][j] = ncr[i-1][j] + ncr[i-1][j-1];     }    }   double a[][] = new double[n+1][n+1];  for(int i = 0; i < n; i++)  for(int j = 0; j < n; j++)   a[i][j] = scan.nextDouble();   double dp[] = new double[1<<19];  dp[(1<<n) - 1] = 1.0;  for(int state = (1 << n) - 1; state >= 0; state--){  int len = 0;  for(int i = 0; i < n; i++)   if((state & (1 << i)) > 0) len++;    for(int i = 0; i < n; i++){   if(((1 << i) & state) == 0) continue;   for(int j = 0; j < i; j++){   if(((1 << j) & state) == 0) continue;   dp[state & (~(1<<i))] += (dp[state] * a[j][i] / ncr[len][2]);   dp[state & (~(1<<j))] += (dp[state] * a[i][j] / ncr[len][2]);            }  }  }  for(int i = 0; i < n; i++)  System.out.print(String.format("%.6f", dp[1<<i]) + " ");  out.close(); } public static long gcd(long a, long b){  if(b == 0) return a;  if(a < b) return gcd(b, a);  return gcd(b, a % b); } static class FastScanner {  BufferedReader br;  StringTokenizer st;  FastScanner(InputStream is) {  try {   br = new BufferedReader(new InputStreamReader(is));  } catch (Exception e) {   e.printStackTrace();  }  }  String next() {  while (st == null || !st.hasMoreTokens()) {   try {   st = new StringTokenizer(br.readLine());   } catch (Exception e) {   return null;   }  }  return st.nextToken();  }  int nextInt() {  return Integer.parseInt(next());  }  long nextLong() {  return Long.parseLong(next());  }  double nextDouble() {  return Double.valueOf(next());  } } }
6,public class TaskB {  int[] levels;  int[] loyalty;  int n, k, A;  double ans = Double.NEGATIVE_INFINITY;  void rec(int ix, int sweets, int[] loyalty) {   if (ix == n) {    double nres = 0.0;    for(int mask = 0; mask < (1<<n); mask++) {     double res = 1.0, totalStrength = 0;     for (int i = 0; i < n; i++) {      if ((mask & (1 << i)) > 0) {       res *= loyalty[i] / 100.0;      } else {       res *= 1.0 - (loyalty[i]/ 100.0);       totalStrength += levels[i];      }     }     int bitCount = Integer.bitCount(mask);     if(bitCount > n / 2) {      nres += res;     }     else {      nres += res * (A) / (A + totalStrength);     }    }    ans = Math.max(ans, nres);    return;   }   for (int j = 0; j <= sweets; j++) {    if (loyalty[ix] + 10 * j > 100) break;    int[] nloyalty = loyalty.clone();    nloyalty[ix] += 10 * j;    rec(ix + 1, sweets - j, nloyalty);   }  }  void run() {   n = nextInt();   k = nextInt();   A = nextInt();   levels = new int[n];   loyalty = new int[n];   for (int i = 0; i < n; i++) {    levels[i] = nextInt();    loyalty[i] = nextInt();   }   rec(0, k, loyalty);   System.out.println(ans);  }  int nextInt() {   try {    int c = System.in.read();    if (c == -1) return c;    while (c != '-' && (c < '0' || '9' < c)) {     c = System.in.read();     if (c == -1) return c;    }    if (c == '-') return -nextInt();    int res = 0;    do {     res *= 10;     res += c - '0';     c = System.in.read();    } while ('0' <= c && c <= '9');    return res;   } catch (Exception e) {    return -1;   }  }  long nextLong() {   try {    int c = System.in.read();    if (c == -1) return -1;    while (c != '-' && (c < '0' || '9' < c)) {     c = System.in.read();     if (c == -1) return -1;    }    if (c == '-') return -nextLong();    long res = 0;    do {     res *= 10;     res += c - '0';     c = System.in.read();    } while ('0' <= c && c <= '9');    return res;   } catch (Exception e) {    return -1;   }  }  double nextDouble() {   return Double.parseDouble(next());  }  String next() {   try {    StringBuilder res = new StringBuilder("");    int c = System.in.read();    while (Character.isWhitespace(c))     c = System.in.read();    do {     res.append((char) c);    } while (!Character.isWhitespace(c = System.in.read()));    return res.toString();   } catch (Exception e) {    return null;   }  }  String nextLine() {   try {    StringBuilder res = new StringBuilder("");    int c = System.in.read();    while (c == '\r' || c == '\n')     c = System.in.read();    do {     res.append((char) c);     c = System.in.read();    } while (c != '\r' && c != '\n');    return res.toString();   } catch (Exception e) {    return null;   }  }  public static void main(String[] args) {   new TaskB().run();  } }
1,public class Main {  public static void main(String[] args) {  Scanner in = new Scanner(new BufferedInputStream(System.in));  PrintWriter out = new PrintWriter(new BufferedWriter(   new OutputStreamWriter(System.out)));  while (in.hasNext()) {  int n = in.nextInt(), a = in.nextInt(), b = in.nextInt(), c = 0;  int[] p = new int[n];   TreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();  for (int i = 0; i < n; i++) {   p[i] = in.nextInt();   map.put(p[i], i);  }    if (a > b) {   int t = b;   b = a;   a = t;   c = 1;  }   boolean ok = true;  int[] cls = new int[n];  while (ok && map.size() > 0) {   Entry<Integer, Integer> last = map.lastEntry();   int v = last.getKey();   int idx = last.getValue();   if (map.containsKey(a - v)) {   cls[idx] = 0;   cls[map.get(a - v)] = 0;   map.remove(v);   map.remove(a -v);   } else if (map.containsKey(b - v)) {   cls[idx] = 1;   cls[map.get(b - v)] = 1;   map.remove(v);   map.remove(b -v);   } else    ok = false;  }   if (!ok)   System.out.println("NO");  else {   System.out.println("YES");   for (int j = 0; j < cls.length; j++) {   if (j != 0)    System.out.print(" ");   System.out.print(c ^ cls[j]);   }   System.out.println();  }  out.flush();  }  in.close(); } }
4,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  PrintWriter out = new PrintWriter(outputStream);  CCompressionAndExpansion solver = new CCompressionAndExpansion();  int testCount = Integer.parseInt(in.next());  for (int i = 1; i <= testCount; i++)  solver.solve(i, in, out);  out.close(); }  static class CCompressionAndExpansion {  public final void solve(int testNumber, InputReader in, PrintWriter out) {  int n = in.nextInt();   ArrayList<ArrayList<Integer>> ans = new ArrayList<>();  ArrayList<Integer> start = new ArrayList<>();  start.add(in.nextInt());  ans.add(start);  out.println("1");  for (int i = 1; i < n; i++) {   ArrayList<Integer> lastList = ans.get(ans.size() - 1);   ArrayList<Integer> curList = (ArrayList<Integer>) lastList.clone();   ans.add(curList);   int curLast = in.nextInt();   for (int j = lastList.size() - 1; j >= 0; j--) {   int last = lastList.get(j);   if (curLast == 1) {    curList.add(1);    break;   } else if (curLast == last + 1) {    curList.set(j, curLast);    break;   } else {    curList.remove(j);   }   }   for (int j = 0; j < curList.size(); j++) {   if (j > 0) out.print(".");   out.print(curList.get(j));   }   out.println();  }  }  }  static final class InputReader {  private final InputStream stream;  private final byte[] buf = new byte[1 << 18];  private int curChar;  private int numChars;  public InputReader() {  this.stream = System.in;  }  public InputReader(final InputStream stream) {  this.stream = stream;  }  private int read() {  if (this.numChars == -1) {   throw new UnknownError();  } else {   if (this.curChar >= this.numChars) {   this.curChar = 0;    try {    this.numChars = this.stream.read(this.buf);   } catch (IOException ex) {    throw new InputMismatchException();   }    if (this.numChars <= 0) {    return -1;   }   }   return this.buf[this.curChar++];  }  }  public final int nextInt() {  int c;  for (c = this.read(); isSpaceChar(c); c = this.read()) {  }   byte sgn = 1;  if (c == 45) {   sgn = -1;   c = this.read();  }   int res = 0;   while (c >= 48 && c <= 57) {   res *= 10;   res += c - 48;   c = this.read();   if (isSpaceChar(c)) {   return res * sgn;   }  }   throw new InputMismatchException();  }  public final String next() {  int c;  while (isSpaceChar(c = this.read())) {  }   StringBuilder result = new StringBuilder();  result.appendCodePoint(c);   while (!isSpaceChar(c = this.read())) {   result.appendCodePoint(c);  }   return result.toString();  }  private static boolean isSpaceChar(final int c) {  return c == 32 || c == 10 || c == 13 || c == 9   || c == -1;  }  } }
6,public class E implements Runnable { public static void main (String[] args) {new Thread(null, new E(), "_cf", 1 << 28).start();}  int n, m; char[] str; int[][] occs, cost; int[] dp;  public void run() {  FastScanner fs = new FastScanner();  PrintWriter out = new PrintWriter(System.out);  System.err.println("");    long tot = 0;  for(int i = 0; i < 19000; i++) tot += i;  System.err.println(tot);   n = fs.nextInt(); m = fs.nextInt();  byte[] str = fs.next().getBytes();  int[] occs = new int[1<<m];  for(int i = 0; i < n-1; i++) {  int l1 = str[i] - 'a';  int l2 = str[i+1] - 'a';  occs[(1<<l1) | (1<<l2)]++;  occs[(1<<l2) | (1<<l1)]++;  }   int all = (1<<m)-1;  cost = new int[m][1<<m];  for(int i = 0; i < m; i++) {  for(int mask = 1; mask < all; mask++) {   if(((1<<i)&mask) > 0) continue;   int lb = mask & (-mask);   int trail = Integer.numberOfTrailingZeros(lb);   int nmask = mask ^ lb;   cost[i][mask] = cost[i][nmask]+occs[1<<i | 1<<trail];  }  }   dp = new int[1<<m];  for(int mask = dp.length-2; mask >= 0; mask--) {  int addOn = 0;  for(int nxt = 0; nxt < m; nxt++) {   if(((1<<nxt)&mask) > 0) continue;   addOn += cost[nxt][mask];  }  int res = oo;  for(int nxt = 0; nxt < m; nxt++) {   if(((1<<nxt)&mask) > 0) continue;   int ret = addOn+dp[mask | (1<<nxt)];   res = min(res, ret);  }  dp[mask] = res;  }   System.out.println(dp[0]>>1);   out.close(); }  int oo = (int)1e9; int min(int a, int b) {  if(a < b) return a;  return b; }  class FastScanner {  public int BS = 1<<16;  public char NC = (char)0;  byte[] buf = new byte[BS];  int bId = 0, size = 0;  char c = NC;  double num = 1;  BufferedInputStream in;  public FastScanner() {  in = new BufferedInputStream(System.in, BS);  }  public FastScanner(String s) {  try {   in = new BufferedInputStream(new FileInputStream(new File(s)), BS);  }  catch (Exception e) {   in = new BufferedInputStream(System.in, BS);  }  }  public char nextChar(){  while(bId==size) {   try {   size = in.read(buf);   }catch(Exception e) {   return NC;   }       if(size==-1)return NC;   bId=0;  }  return (char)buf[bId++];  }  public int nextInt() {  return (int)nextLong();  }  public long nextLong() {  num=1;  boolean neg = false;  if(c==NC)c=nextChar();  for(;(c<'0' || c>'9'); c = nextChar()) {   if(c=='-')neg=true;  }  long res = 0;  for(; c>='0' && c <='9'; c=nextChar()) {   res = (res<<3)+(res<<1)+c-'0';   num*=10;  }  return neg?-res:res;  }  public double nextDouble() {  double cur = nextLong();  return c!='.' ? cur:cur+nextLong()/num;  }  public String next() {  StringBuilder res = new StringBuilder();  while(c<=32)c=nextChar();  while(c>32) {   res.append(c);   c=nextChar();  }  return res.toString();  }  public String nextLine() {  StringBuilder res = new StringBuilder();  while(c<=32)c=nextChar();  while(c!='\n') {   res.append(c);   c=nextChar();  }  return res.toString();  }  public boolean hasNext() {  if(c>32)return true;  while(true) {   c=nextChar();   if(c==NC)return false;   else if(c>32)return true;  }  }   public int[] nextIntArray(int n) {  int[] res = new int[n];  for(int i = 0; i < n; i++) res[i] = nextInt();  return res;  }   } }
2,public class SportMafia { public static void main(String[] args) {  Scanner sc = new Scanner(System.in);   int n = sc.nextInt();  int k = sc.nextInt();   int next = 1;  int current = 0;  int result = 0;   for(int i = 0; i < n; i++) {  if(current < k) {   current += next++;  } else {   current--;   result++;  }  }   System.out.println(result);   sc.close(); } }
4,public class E { FastScanner in; PrintWriter out; boolean systemIO = true;  public class DSU {  int[] sz;  int[] p;  public DSU(int n) {  sz = new int[n];  p = new int[n];  for (int i = 0; i < p.length; i++) {   p[i] = i;   sz[i] = 1;  }  }  public int get(int x) {  if (x == p[x]) {   return x;  }  int par = get(p[x]);  p[x] = par;  return par;  }  public boolean unite(int a, int b) {  int pa = get(a);  int pb = get(b);  if (pa == pb) {   return false;  }  if (sz[pa] < sz[pb]) {   p[pa] = pb;   sz[pb] += sz[pa];  } else {   p[pb] = pa;   sz[pa] += sz[pb];  }  return true;  } }  public class SegmentTreeAdd {  int pow;  long[] min;  long[] delta;  boolean[] flag;  public SegmentTreeAdd(long[] a) {  pow = 1;  while (pow < a.length) {   pow *= 2;  }  flag = new boolean[2 * pow];  min = new long[2 * pow];  delta = new long[2 * pow];  for (int i = 0; i < min.length; i++) {   min[i] = Long.MAX_VALUE / 2;  }  for (int i = 0; i < a.length; i++) {   min[pow + i] = a[i];  }  for (int i = pow - 1; i > 0; i--) {   min[i] = f(min[2 * i], min[2 * i + 1]);  }  }  public long get(int l, int r) {  return get(1, 0, pow, l, r);  }  private long get(int v, int tl, int tr, int l, int r) {  push(v, tl, tr);  if (l >= tr || r <= tl) {   return Long.MAX_VALUE / 2;  }  if (l <= tl && r >= tr) {   return min[v];  }  int tm = (tl + tr) / 2;  return f(get(2 * v, tl, tm, l, r), get(2 * v + 1, tm, tr, l, r));  }  public void set(int l, int r, long x) {  set(1, 0, pow, l, r, x);  }  private void set(int v, int tl, int tr, int l, int r, long x) {  push(v, tl, tr);  if (l >= tr || r <= tl) {   return;  }  if (l <= tl && r >= tr) {   delta[v] += x;   flag[v] = true;   push(v, tl, tr);   return;  }  int tm = (tl + tr) / 2;  set(2 * v, tl, tm, l, r, x);  set(2 * v + 1, tm, tr, l, r, x);  min[v] = f(min[2 * v], min[2 * v + 1]);  }  public void push(int v, int tl, int tr) {  if (flag[v]) {   if (v < pow) {   flag[2 * v] = true;   flag[2 * v + 1] = true;   delta[2 * v] += delta[v];   delta[2 * v + 1] += delta[v];   }   flag[v] = false;   min[v] += delta[v];   delta[v] = 0;  }  }  public long f(long a, long b) {  return Math.min(a, b);  } }  public class SegmentTreeSet {  int pow;  int[] sum;  int[] delta;  boolean[] flag;  public SegmentTreeSet(int[] a) {  pow = 1;  while (pow < a.length) {   pow *= 2;  }  flag = new boolean[2 * pow];  sum = new int[2 * pow];  delta = new int[2 * pow];  for (int i = 0; i < a.length; i++) {   sum[pow + i] = a[i];  }  }  public int get(int v, int tl, int tr, int l, int r) {  push(v, tl, tr);  if (l > r) {   return 0;  }  if (l == tl && r == tr) {   return sum[v];  }  int tm = (tl + tr) / 2;  return f(get(2 * v, tl, tm, l, Math.min(r, tm)), get(2 * v + 1, tm + 1, tr, Math.max(l, tm + 1), r));  }  public void set(int v, int tl, int tr, int l, int r, int x) {  push(v, tl, tr);  if (l > tr || r < tl) {   return;  }  if (l <= tl && r >= tr) {   delta[v] = x;   flag[v] = true;   push(v, tl, tr);   return;  }  int tm = (tl + tr) / 2;  set(2 * v, tl, tm, l, r, x);  set(2 * v + 1, tm + 1, tr, l, r, x);  sum[v] = f(sum[2 * v], sum[2 * v + 1]);  }  public void push(int v, int tl, int tr) {  if (flag[v]) {   if (v < pow) {   flag[2 * v] = true;   flag[2 * v + 1] = true;   delta[2 * v] = delta[v];   delta[2 * v + 1] = delta[v];   }   flag[v] = false;   sum[v] = delta[v] * (tr - tl + 1);  }  }  public int f(int a, int b) {  return a + b;  } }  Random random = new Random();  public void shuffle(Pair[] a) {  for (int i = 0; i < a.length; i++) {  int x = random.nextInt(i + 1);  Pair t = a[x];  a[x] = a[i];  a[i] = t;  } }  public void sort(int[][] a) {  for (int i = 0; i < a.length; i++) {  Arrays.sort(a[i]);  } }  public void add(HashMap<Long, Integer> map, long l) {  if (map.containsKey(l)) {  map.put(l, map.get(l) + 1);  } else {  map.put(l, 1);  } }  public void remove(TreeMap<Integer, Integer> map, Integer s) {  if (map.get(s) > 1) {  map.put(s, map.get(s) - 1);  } else {  map.remove(s);  } }  double eps = 1e-10;  public int signum(double x) {  if (x > eps) {  return 1;  }  if (x < -eps) {  return -1;  }  return 0; }  public long abs(long x) {  return x < 0 ? -x : x; }  public long min(long x, long y) {  return x < y ? x : y; }  public long max(long x, long y) {  return x > y ? x : y; }  public long gcd(long x, long y) {  while (y > 0) {  long c = y;  y = x % y;  x = c;  }  return x; }                                                                                                                                                                                                   public class Rect {  long x1;  long x2;  long y1;  long y2;  int number;  public Rect(long x1, long x2, long y1, long y2, int number) {  this.x1 = x1;  this.x2 = x2;  this.y1 = y1;  this.y2 = y2;  this.number = number;  } }  public static class Fenvik {  int[] t;  public Fenvik(int n) {  t = new int[n];  }  public void add(int x, int delta) {  for (int i = x; i < t.length; i = (i | (i + 1))) {   t[i] += delta;  }  }  private int sum(int r) {  int ans = 0;  int x = r;  while (x >= 0) {   ans += t[x];   x = (x & (x + 1)) - 1;  }  return ans;  }  public int sum(int l, int r) {  return sum(r) - sum(l - 1);  } }  public class SegmentTreeMaxSum {  int pow;  int[] sum;  int[] maxPrefSum;  int[] maxSufSum;  int[] maxSum;  public SegmentTreeMaxSum(int[] a) {  pow = 1;  while (pow < a.length) {   pow *= 2;  }  sum = new int[2 * pow];  maxPrefSum = new int[2 * pow];  maxSum = new int[2 * pow];  maxSufSum = new int[2 * pow];  for (int i = 0; i < a.length; i++) {   sum[pow + i] = a[i];   maxSum[pow + i] = Math.max(a[i], 0);   maxPrefSum[pow + i] = maxSum[pow + i];   maxSufSum[pow + i] = maxSum[pow + i];  }  for (int i = pow - 1; i > 0; i--) {   update(i);  }  }  public int[] get(int v, int tl, int tr, int l, int r) {  if (r <= tl || l >= tr) {   int[] ans = { 0, 0, 0, 0 };   return ans;  }  if (l <= tl && r >= tr) {   int[] ans = { maxPrefSum[v], maxSum[v], maxSufSum[v], sum[v] };   return ans;  }  int tm = (tl + tr) / 2;  int[] left = get(2 * v, tl, tm, l, r);  int[] right = get(2 * v + 1, tm, tr, l, r);  int[] ans = { Math.max(left[0], right[0] + left[3]),   Math.max(left[1], Math.max(right[1], left[2] + right[0])), Math.max(right[2], left[2] + right[3]),   left[3] + right[3] };  return ans;  }  public void set(int v, int tl, int tr, int x, int value) {  if (v >= pow) {   sum[v] = value;   maxSum[v] = Math.max(value, 0);   maxPrefSum[v] = maxSum[v];   maxSufSum[v] = maxSum[v];   return;  }  int tm = (tl + tr) / 2;  if (x < tm) {   set(2 * v, tl, tm, x, value);  } else {   set(2 * v + 1, tm, tr, x, value);  }  update(v);  }  public void update(int i) {  sum[i] = f(sum[2 * i], sum[2 * i + 1]);  maxSum[i] = Math.max(maxSum[2 * i], Math.max(maxSum[2 * i + 1], maxSufSum[2 * i] + maxPrefSum[2 * i + 1]));  maxPrefSum[i] = Math.max(maxPrefSum[2 * i], maxPrefSum[2 * i + 1] + sum[2 * i]);  maxSufSum[i] = Math.max(maxSufSum[2 * i + 1], maxSufSum[2 * i] + sum[2 * i + 1]);  }  public int f(int a, int b) {  return a + b;  } }  public class Fraction implements Comparable<Fraction> {  long x;  long y;  public Fraction(long x, long y, boolean needNorm) {  this.x = x;  this.y = y;  if (y < 0) {   this.x *= -1;   this.y *= -1;  }  if (needNorm) {   long gcd = gcd(this.x, this.y);   this.x /= gcd;   this.y /= gcd;  }  }  public Fraction clone() {  return new Fraction(x, y, false);  }  public String toString() {  return x + "/" + y;  }  @Override  public int compareTo(Fraction o) {  long res = x * o.y - y * o.x;  if (res > 0) {   return 1;  }  if (res < 0) {   return -1;  }  return 0;  } }  public class Event implements Comparable<Event> {  Fraction f;  int type;  public Event(Fraction f, int type) {  this.f = f;  this.type = type;  }  @Override  public int compareTo(Event o) {  int c = f.compareTo(o.f);  if (c != 0) {   return c;  }  return type - o.type;  }  }  public double sq(double x) {  return x * x; }  public long sq(long x) {  return x * x; }  public double hypot2(double x, double y) {  return sq(x) + sq(y); }  public long hypot2(long x, long y) {  return sq(x) + sq(y); }  public boolean kuhn(int v, int[][] edge, boolean[] used, int[] mt) {  used[v] = true;  for (int u : edge[v]) {  if (mt[u] < 0 || (!used[mt[u]] && kuhn(mt[u], edge, used, mt))) {   mt[u] = v;   return true;  }  }  return false; }  public int matching(int[][] edge) {  int n = edge.length;  int[] mt = new int[n];  Arrays.fill(mt, -1);  boolean[] used = new boolean[n];  int ans = 0;  for (int i = 0; i < n; i++) {  if (!used[i] && kuhn(i, edge, used, mt)) {   Arrays.fill(used, false);   ans++;  }  }  return ans; }  double sq2 = Math.sqrt(2);  public class MyStack {  int[] st;  int sz;  public MyStack(int n) {  this.st = new int[n];  sz = 0;  }  public boolean isEmpty() {  return sz == 0;  }  public int peek() {  return st[sz - 1];  }  public int pop() {  sz--;  return st[sz];  }  public void clear() {  sz = 0;  }  public void add(int x) {  st[sz++] = x;  }  public int get(int x) {  return st[x];  } }  public int[][] readGraph(int n, int m) {  int[][] to = new int[n][];  int[] sz = new int[n];  int[] x = new int[m];  int[] y = new int[m];  for (int i = 0; i < m; i++) {  x[i] = in.nextInt() - 1;  y[i] = in.nextInt() - 1;  sz[x[i]]++;  sz[y[i]]++;  }  for (int i = 0; i < to.length; i++) {  to[i] = new int[sz[i]];  sz[i] = 0;  }  for (int i = 0; i < x.length; i++) {  to[x[i]][sz[x[i]]++] = y[i];  to[y[i]][sz[y[i]]++] = x[i];  }  return to; }  public class Pol {  double[] coeff;  public Pol(double[] coeff) {  this.coeff = coeff;  }  public Pol mult(Pol p) {  double[] ans = new double[coeff.length + p.coeff.length - 1];  for (int i = 0; i < ans.length; i++) {   for (int j = Math.max(0, i - p.coeff.length + 1); j < coeff.length && j <= i; j++) {   ans[i] += coeff[j] * p.coeff[i - j];   }  }  return new Pol(ans);  }  public String toString() {  String ans = "";  for (int i = 0; i < coeff.length; i++) {   ans += coeff[i] + " ";  }  return ans;  }  public double value(double x) {  double ans = 0;  double p = 1;  for (int i = 0; i < coeff.length; i++) {   ans += coeff[i] * p;   p *= x;  }  return ans;  }  public double integrate(double r) {  Pol p = new Pol(new double[coeff.length + 1]);  for (int i = 0; i < coeff.length; i++) {   p.coeff[i + 1] = coeff[i] / fact[i + 1];  }  return p.value(r);  }  public double integrate(double l, double r) {  return integrate(r) - integrate(l);  } }  int mod = 1000000007;  public int sum(int a, int b) {  if (a + b >= mod) {  return a + b - mod;  }  return a + b; }  public int diff(int a, int b) {  if (a < b) {  return a + mod - b;  }  return a - b; }  public int mult(int a, int b) {  return (int) ((a * 1L * b) % (1L * mod)); }  public int pow(int x, int p) {  if (p <= 0) {  return 1;  }  int ans = pow(x, p / 2);  ans = mult(ans, ans);  if (p % 2 == 1) {  ans = mult(ans, x);  }  return ans; }  public int modInv(int x) {  return pow(x, mod - 2); }  public int c_n_k(int n, int k) {  if (n < 0 || k < 0 || n - k < 0) {  return 0;  }  return mult(fact[n], mult(factInv[k], factInv[n - k])); }  public class LinAl01 {  public class Vector {  BitSet vec;  BitSet swtch;   public Vector(BitSet vec, BitSet swtch) {   this.vec = vec;   this.swtch = swtch;  }   public String toString() {   String s = "";   for (int i = 0; i < basis.length; i++) {   s += (vec.get(i) ? 1 : 0);   }   s += " ";   for (int i = 0; i < basis.length; i++) {   s += (swtch.get(i) ? 1 : 0);   }   return s;  }  }  int n;  Vector[] basis;  public void update(Vector v) {  for (int i = 0; i < n; i++) {   if (v.vec.get(i)) {   if (basis[i] == null) {    basis[i] = v;    break;   }   v.vec.xor(basis[i].vec);   v.swtch.xor(basis[i].swtch);   }  }  }  public void diagonalize() {  for (int i = 0; i < n; i++) {   if (basis[i] == null) {   continue;   }   for (int j = 0; j < i; j++) {   if (basis[j] != null && basis[j].vec.get(i)) {    basis[j].vec.xor(basis[i].vec);    basis[j].swtch.xor(basis[i].swtch);   }   }  }  }  }  public class Point implements Comparable<Point> {  double x;  double y;  public Point() {  x = 0;  y = 0;  }  public Point(double x, double y) {  this.x = x;  this.y = y;  }  public String toString() {  return x + " " + y;  }  public boolean equals(Point p) {  return x == p.x && y == p.y;  }  public double dist2() {  return x * x + y * y;  }  public Point add(Point v) {  return new Point(x + v.x, y + v.y);  }  public Point subtract(Point v) {  return new Point(x - v.x, y - v.y);  }  @Override  public int compareTo(Point o) {  int z = signum(x + y - o.x - o.y);  if (z != 0) {   return z;  }  return signum(x - o.x) != 0 ? signum(x - o.x) : signum(y - o.y);  } }  public class Circle {  Point p;  long r;  public Circle(Point p, long r) {  this.p = p;  this.r = r;  }  public boolean intersect(Line l) {  return Math.abs(l.a * p.x + l.b * p.y + l.c) / Math.hypot(l.a, l.b) < r;  }  public boolean inside(Point p) {  return hypot2(p.x - this.p.x, p.y - this.p.y) <= sq(r);  } }  public class Line {  long a;  long b;  long c;  public Line(long a, long b, long c) {  if (a < 0 || (a == 0 && b < 0)) {   a = -a;   b = -b;   c = -c;   long gcd = gcd(a, Math.abs(b));   a /= gcd;   b /= gcd;  }  this.a = a;  this.b = b;  this.c = c;  }  public String toString() {  return a + " " + b + " " + c;  }    }                         public long sqr(long a) {  return a * a; }                   int[] fact = new int[1000001]; int[] factInv = new int[1000001];  public int[] intersect(int y, int xdown, int ydown, int xup, int yup) {  if (yup < y || ydown > y || (ydown == yup)) {  return null;  }  long p = xup * 1L * (y - ydown) + xdown * 1L * (yup - y);  if (p < 0) {  int[] ans = { -1, 0 };  return ans;  }  long q = 2 * (yup - ydown);  int[] ans = { (int) (p / q), (int) ((p + q - 1) / q) };  return ans; }  public void I(int[][] a) {  for (int i = 0; i < a.length; i++) {  int[] b = new int[a.length];  for (int j = 0; j < b.length; j++) {   b[a[i][j]] = j;  }  a[i] = b;  } }  public void C(int[][] a) {  for (int i = 0; i < a.length; i++) {  int[] b = new int[a.length];  for (int j = 0; j < b.length; j++) {   b[a[j][i]] = j;  }  for (int j = 0; j < b.length; j++) {   a[j][i] = b[j];  }  } }  public class SegmentTree {  int pow;  Pair[] min;  public SegmentTree(int[] a) {  pow = 1;  while (pow < a.length) {   pow *= 2;  }  min = new Pair[2 * pow];  for (int i = 0; i < a.length; i++) {   min[pow + i] = new Pair(a[i], i);  }  for (int i = a.length; i < pow; i++) {   min[pow + i] = new Pair(Integer.MAX_VALUE / 2, -1);  }  for (int i = pow - 1; i > 0; i--) {   min[i] = f(min[2 * i], min[2 * i + 1]);  }  }  public Pair get(int l, int r) {  return get(1, 0, pow, l, r);  }  private Pair get(int v, int tl, int tr, int l, int r) {  if (l >= tr || r <= tl) {   return new Pair(Integer.MAX_VALUE / 2, -1);  }  if (l <= tl && r >= tr) {   return min[v];  }  int tm = (tl + tr) / 2;  return f(get(2 * v, tl, tm, l, r), get(2 * v + 1, tm, tr, l, r));  }  public void set(int x, int value) {  set(1, 0, pow, x, value);  }  private void set(int v, int tl, int tr, int x, int value) {  if (x >= tr || x < tl) {   return;  }  if (v >= pow) {   min[v] = new Pair(value, -1);   return;  }  int tm = (tl + tr) / 2;  set(2 * v, tl, tm, x, value);  set(2 * v + 1, tm, tr, x, value);  min[v] = f(min[2 * v], min[2 * v + 1]);  }  public Pair f(Pair a, Pair b) {  if (a.compareTo(b) <= 0) {   return a.clone();  }  return b.clone();  } }  public boolean nextPermutation(int[] a) {  int n = a.length;  for (int i = n - 2; i >= 0; i--) {  if (a[i] < a[i + 1]) {   for (int d = 1; d <= (n - 1 - i) / 2; d++) {   a[i + d] ^= a[n - d];   a[n - d] = a[i + d] ^ a[n - d];   a[i + d] = a[i + d] ^ a[n - d];   }   for (int j = i + 1; j < n; j++) {   if (a[j] > a[i]) {    a[i] ^= a[j];    a[j] = a[i] ^ a[j];    a[i] = a[i] ^ a[j];    return true;   }   }  }  }  return false; }  public class Pair implements Comparable<Pair> {  int x;  int y;  public Pair(int x, int y) {  this.x = x;  this.y = y;  }  public Pair add(Pair p) {  return new Pair(x + p.x, y + p.y);  }  public Pair clone() {  return new Pair(x, y);  }  public String toString() {  return x + " " + y;  }  @Override  public int compareTo(Pair o) {  if (x < o.x) {   return -1;  }  if (x > o.x) {   return 1;  }  if (y > o.y) {   return 1;  }  if (y < o.y) {   return -1;  }  return 0;  } }  public double intersection(Pair p1, Pair p2) {  return (p2.y - p1.y) * 1.0 / (p1.x - p2.x); }  HashMap<Integer, Integer> even = new HashMap<>(); HashMap<Integer, Integer> odd = new HashMap<>();  public void addOdd(int key, int value) {  if (odd.containsKey(key)) {  odd.put(key, Math.min(odd.get(key), value));  } else {  odd.put(key, value);  } }  public void addEven(int key, int value) {  if (even.containsKey(key)) {  even.put(key, Math.min(even.get(key), value));  } else {  even.put(key, value);  } }  public void solve() {  int n = in.nextInt();  int m = in.nextInt();  int k = in.nextInt();   if (k % 2 == 1) {  for (int i = 0; i < n; i++) {   for (int j = 0; j < m; j++) {   out.print(-1 + " ");   }   out.println();  }  return;  }  k /= 2;  int[][] hor = new int[n][m - 1];  for (int i = 0; i < hor.length; i++) {  for (int j = 0; j < hor[0].length; j++) {   hor[i][j] = in.nextInt() * 2;   }  }  int[][] vert = new int[n - 1][m];  for (int i = 0; i < vert.length; i++) {  for (int j = 0; j < vert[0].length; j++) {   vert[i][j] = in.nextInt() * 2;   }  }  long time = System.currentTimeMillis();  int[][][] ans = new int[k + 1][n][m];  for (int l = 1; l <= k; l++) {  for (int i = 0; i < n; i++) {   for (int j = 0; j < m; j++) {   ans[l][i][j] = Integer.MAX_VALUE;   if (i > 0) {    ans[l][i][j] = Math.min(ans[l][i][j], ans[l - 1][i - 1][j] + vert[i - 1][j]);   }   if (j > 0) {    ans[l][i][j] = Math.min(ans[l][i][j], ans[l - 1][i][j - 1] + hor[i][j - 1]);   }   if (i < n - 1) {    ans[l][i][j] = Math.min(ans[l][i][j], ans[l - 1][i + 1][j] + vert[i][j]);   }   if (j < m - 1) {    ans[l][i][j] = Math.min(ans[l][i][j], ans[l - 1][i][j + 1] + hor[i][j]);   }   }  }  }                               for (int i = 0; i < n; i++) {  for (int j = 0; j < m; j++) {   out.print(ans[k][i][j] + " ");  }  out.println();  }  System.err.println(System.currentTimeMillis() - time); }  public void add(HashMap<Integer, Integer> map, int x) {  if (map.containsKey(x)) {  map.put(x, map.get(x) + 1);  } else {  map.put(x, 1);  } }  public void run() {  try {  if (systemIO) {   in = new FastScanner(System.in);   out = new PrintWriter(System.out);  } else {   in = new FastScanner(new File("input.txt"));   out = new PrintWriter(new File("output.txt"));  }  solve();   out.close();  } catch (IOException e) {  e.printStackTrace();  } }  class FastScanner {  BufferedReader br;  StringTokenizer st;  FastScanner(File f) {  try {   br = new BufferedReader(new FileReader(f));  } catch (FileNotFoundException e) {   e.printStackTrace();  }  }  FastScanner(InputStream f) {  br = new BufferedReader(new InputStreamReader(f));  }  String nextLine() {  try {   return br.readLine();  } catch (IOException e) {   return null;  }  }  String next() {  while (st == null || !st.hasMoreTokens()) {   try {   st = new StringTokenizer(br.readLine());   } catch (IOException e) {   e.printStackTrace();   }  }  return st.nextToken();  }  int nextInt() {  return Integer.parseInt(next());  }  long nextLong() {  return Long.parseLong(next());  }  double nextDouble() {  return Double.parseDouble(next());  }  }   public static void main(String[] arg) {  new E().run(); } }
3,public class InversionCounting { public static void main(String[] args) {  Scanner sc = new Scanner(System.in);  PrintWriter pw = new PrintWriter(System.out);   int n = Integer.parseInt(sc.nextLine());  int inversions = 0;  int[] data = new int[n];   StringTokenizer st = new StringTokenizer(sc.nextLine());  for(int i = 0; i < n; i ++) {  data[i] = Integer.parseInt(st.nextToken());  }   for(int i = 0; i < n; i++) {  for(int j = i + 1; j < n; j++) {   if(data[i] > data[j])   inversions++;  }  }   boolean inversiontype = (inversions % 2 == 1);   int n2 = Integer.parseInt(sc.nextLine());  for(int i = 0; i < n2; i++) {  st = new StringTokenizer(sc.nextLine());  int a = Integer.parseInt(st.nextToken());  int b = Integer.parseInt(st.nextToken());    int parity = (b-a)*(b - a + 1)/2;  if(parity % 2 == 0) {   if(inversiontype)   pw.println("odd");   else   pw.println("even");  } else {   inversiontype = !inversiontype;   if(inversiontype)   pw.println("odd");   else   pw.println("even");  }  }  pw.close(); } }
0,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskA solver = new TaskA();   solver.solve(1, in, out);   out.close();  } } class TaskA {  public void solve(int testNumber, InputReader in, PrintWriter out) {   long l = in.nextLong();   long r = in.nextLong();   int max = (int) (r - l);   if (max >= 2) {    if ((l & 1) == 0) {     out.println(l + " " + (l + 1) + " " + (l + 2));     return;    } else {     if (max >= 3) {      out.println((l + 1) + " " + (l + 2) + " " + (l + 3));      return;     }    }   }   out.println(-1);  } } class InputReader {  public BufferedReader reader;  public StringTokenizer tokenizer;  public InputReader(InputStream stream) {   reader = new BufferedReader(new InputStreamReader(stream), 32768);   tokenizer = null;   tokenizer = null;  }  public String next() {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    try {     tokenizer = new StringTokenizer(reader.readLine());    } catch (IOException e) {     throw new RuntimeException(e);    }   }   return tokenizer.nextToken();  }  public long nextLong() {   return Long.parseLong(next());  } }
5,public class TaskA { void Run() throws IOException {  int n=ReadInt();  int[] arr=new int[n];  for(int i=0;i<n;++i)  arr[i]=ReadInt();  Arrays.sort(arr);  boolean one=true;  for(int x : arr)  if(x!=1) {   one=false;   break;  }  if(one) {  for(int i=1;i<n;++i)   output.print("1 ");  output.print("2");  return;  }  int prev=1;  for(int x : arr)  if(x==prev) {   output.print(prev);   output.print(" ");  } else {   output.print(prev);   output.print(" ");   prev=x;  } }  public static void main(String[] args) throws IOException {  boolean oj = System.getProperty("ONLINE_JUDGE") != null;  Reader reader;  reader=oj ? new InputStreamReader(System.in) : new FileReader("input.txt");  input=new BufferedReader(reader);  Writer writer=new OutputStreamWriter(System.out);  writer=new BufferedWriter(writer);  output=new PrintWriter(writer);  new TaskA().Run();  output.close(); }  static int ReadInt() throws IOException {  return Integer.parseInt(ReadString()); }  static long ReadLong() throws IOException {  return Long.parseLong(ReadString()); }  static String ReadString() throws IOException {  while(tokenizer==null || !tokenizer.hasMoreTokens())  tokenizer=new StringTokenizer(input.readLine());  return tokenizer.nextToken(); }  static StringTokenizer tokenizer; static BufferedReader input; static PrintWriter output; }
4,public class Main { public static void main(String[] args) throws Exception {  FastScanner sc = new FastScanner();  PrintWriter out = new PrintWriter(System.out);   int h = sc.nexI();  int w = sc.nexI();  int k = sc.nexI();     Graph grid = new Graph(h*w);   for(int i=0; i<h; i++) {  for(int j=1; j<w; j++) {   long w1 = sc.nexL();   grid.add2(getad(w, i, j-1), getad(w, i, j), w1);  }  }  for(int i=1; i<h; i++) {  for(int j=0; j<w; j++) {   long w1 = sc.nexL();   grid.add2(getad(w, i-1, j), getad(w, i, j), w1);  }  }   if(k%2 != 0) {  int[][] anss = new int[h][w];  fill(anss,-1);  for(int i=0; i<h; i++) {   prtspas(anss[i]);  }    return;  }  if((h*w) == 1) {  System.out.println(-1);  return;  }   long[][] mincos = new long[(k/2)+1][h*w];  fill(mincos[0],0L);   for(int t=1; t<=(k/2); t++) {  fill(mincos[t], INFL);  for(int i=0; i<h; i++) {   for(int j=0; j<w; j++) {   int ad = getad(w, i, j);   for(Edge e: grid.get(ad)) {    mincos[t][ad] = min(mincos[t][ad], mincos[t-1][e.v2]+e.w);   }   }  }  }     for(int i=0; i<(h*w); i++) {  mincos[k/2][i]*=2L;  }  for(int i=0; i<h; i++) {  prtspas(Arrays.copyOfRange(mincos[k/2], i*w, i*w + w));  }   out.flush();  return; }  public static int getad(int w, int i, int j) {  return (i*w + j); }  static class Graph {  private ArrayList<Node> dt = new ArrayList<>();  Graph(int sz) {  for (int i = 0; i < sz; i++) {   Node node1 = new Node();   dt.add(node1);  }  }  public void add(int v8, int cnct2, long w) {  dt.get(v8).add(new Edge(v8, cnct2, w));  }  public void add2(int v1, int v2, long w) {  dt.get(v1).add(new Edge(v1, v2, w));  dt.get(v2).add(new Edge(v2, v1, w));  }  public Set<Edge> get(int v) {  return dt.get(v).getAll();  }  public int size() {  return dt.size();  }  public int sizeOf(int v) {  return dt.get(v).size();  }  public void clear() {  for (int i = 0; i < dt.size(); i++)   dt.get(i).clear();  }  public void clear(int v) {  dt.get(v).clear();  }  private void add_v(Node v_new) {  dt.add(v_new);  }  public void show2() {  for (int i = 0; i < dt.size(); i++) {   System.out.print(i + ":");   for (Edge e : dt.get(i).getAll())   e.show2();   System.out.println();  }  }  public static Graph make_Graph(int vn, int en, FastScanner sc) {  Graph g = new Graph(vn);  for (int i = 0; i < en; i++) {   int s1 = sc.nexI() - 1;   int g1 = sc.nexI() - 1;   long w = sc.nexL();   g.add2(s1, g1, w);  }  return g;  }  public static Graph make_tree(int vn, FastScanner sc) {  Graph g = new Graph(vn);  for (int i = 1; i < vn; i++) {   int s1 = sc.nexI() - 1;   int g1 = sc.nexI() - 1;   long w = sc.nexL();   g.add2(s1, g1, w);  }  return g;  }    private long[] dijkstra(int from) {  PriorityQueue<Edge> dijk = new PriorityQueue<>(new CompEdge_float());  long[] d8i = new long[this.dt.size()];  fill(d8i, INFL);  dijk.add(new Edge(from, 0L));   while (!dijk.isEmpty()) {   Edge dw = dijk.poll();   if (d8i[dw.v2] > dw.w) {   d8i[dw.v2] = dw.w;   for (Edge e : this.get(dw.v2)) {    long w2 = dw.w + e.w;    if (d8i[e.v2] > w2)    dijk.add(new Edge(e.v2, w2));   }   }  }  return d8i;  } }  static class Node {  private Set<Edge> next_vs = new HashSet<>();  public void add(Edge cnct2) {  next_vs.add(cnct2);  }  public Set<Edge> getAll() {  return next_vs;  }  public int size() {  return next_vs.size();  }  public void clear() {  next_vs.clear();  }  public void addAll(Node list2add) {  this.next_vs.addAll(list2add.next_vs);  } }  static class Edge {  int from = -1, v2 = -1;  long w;  public Edge(int going2, long weight_route) {  this.v2 = going2;  this.w = weight_route;  }  public Edge(int come8, int going2, long weight_route) {  this.from = come8;  this.v2 = going2;  this.w = weight_route;  }  public void show2() {  System.out.println(this.from + "->" + this.v2 + " :w=" + this.w);  } }  static class CompEdge_float implements Comparator<Edge> {   public int compare(Edge a, Edge b) {  if (a.w > b.w)   return 1;  else if (a.w < b.w)   return -1;  else   return a.v2 - b.v2;  } }  private static final int INF = (int) 3e8; private static final long INFL = (long) 1e17; private static final int INTMAX = Integer.MAX_VALUE; private static final long LONGMAX = Long.MAX_VALUE; private static final long e97 = 1000000007L; private static final long e99 = 998244353L; private static final double PI = Math.PI;  private static void assertion(boolean should_true) {   if (!should_true)  throw new AssertionError(); }  private static int abs(int a) {  return (a >= 0) ? a : -a; }  private static long abs(long a) {  return (a >= 0L) ? a : -a; }  private static double abs(double a) {  return (a >= 0.0) ? a : -a; }  private static int min(int a, int b) {  return (a < b) ? a : b; }  private static long min(long a, long b) {  return (a < b) ? a : b; }  private static double min(double a, double b) {  return (a < b) ? a : b; }  private static int max(int a, int b) {  return (a > b) ? a : b; }  private static long max(long a, long b) {  return (a > b) ? a : b; }  private static double max(double a, double b) {  return (a > b) ? a : b; }  private static int pow2(int num2pow) {  if (num2pow > 4e4)  throw new IllegalArgumentException("Input is to Large. Use Long.");  return num2pow * num2pow; }  private static long pow2(long num2pow) {  if (num2pow > 1e8)  throw new IllegalArgumentException("Input is to Large. Use PowP.");  return num2pow * num2pow; }  private static int pow(int num_powered, int index) {  int ans = 1;  for (int i = 0; i < index; i++) {  if (ans >= (INTMAX / num_powered))   throw new IllegalArgumentException("Input is to Large. Use Long.");  ans *= num_powered;  }  return ans; }  private static long pow(long num_powered, int index) {  long ans = 1L;  for (int i = 0; i < index; i++) {  if (ans >= (LONGMAX / num_powered))   throw new IllegalArgumentException("Input is to Large. Use PowP.");  ans *= num_powered;  }  return ans; }  private static long powP(long num_powered, long index, long p) {     if (num_powered == 0L)  return 0L;  if (index == 0L)  return 1L;  if (index == 2L) {  return (pow2(num_powered) % p);  }  int d = getDigit2(index);  long[] num_done_by2 = new long[d + 1];  num_done_by2[0] = num_powered;  for (int i = 1; i <= d; i++) {  num_done_by2[i] = num_done_by2[i - 1] * num_done_by2[i - 1];  num_done_by2[i] %= p;  }  long ans = 1L;  for (int i = d; i >= 0; i--) {  long cf = (1L << (long) i);  if (index >= cf) {   index -= cf;   ans = ans * num_done_by2[i];   ans %= p;  }  }  return ans; }  private static double hypod(double a, double b) {  return Math.sqrt(a * a + b * b); }  private static int getDigit2(long num2know) {   long compare4 = 1L;  int digit = 0;  while (num2know >= compare4) {  digit++;  compare4 = (1L << (long) digit);  }  return digit;   }  private static int getDigit10(long num2know) {   long compare4 = 1L;  int digit = 0;  while (num2know >= compare4) {  digit++;  compare4 *= 10L;  }  return digit;  }  private static int divceil(int numerator, int denominator) {  return (numerator + denominator - 1) / denominator; }  private static long divceil(long numerator, long denominator) {  return (numerator + denominator - 1L) / denominator; }  private static long factorial(int n) {   long ans = 1L;  for (long i = 2; i <= n; i++) {  if (ans >= (LONGMAX / i))   throw new IllegalArgumentException("Input is to Large. Use facP.");  ans *= i;  }  return ans; }  private static long facP(int n, long p) {   long ans = 1L;  for (long i = 2; i <= n; i++) {  ans *= i;  ans %= p;  }  return ans; }  private static long lcm(long m, long n) {  long ans = m / gcd(m, n);  if (ans >= (LONGMAX / n))  throw new IllegalArgumentException("Input is to Large.");  ans *= n;  return ans; }  private static long gcd(long m, long n) {   if ((m <= 0L) || (n <= 0L))  throw new IllegalArgumentException("m and n should be natural.");  while ((m > 0L) && (n > 0L)) {  if (m >= n)   m %= n;  else   n %= m;  }  if (m > 0L)  return m;  else  return n; }  private static boolean is_prime(long n2check) {   if (n2check == 1L)  return false;  for (long i = 2L; i <= Math.sqrt(n2check); i++) {  if (n2check % i == 0L)   return false;  }  return true; }  private static int safe_mod(int n, int p) {  n %= p;  if (n >= 0)  return n;  return (n + p); }  private static long safe_mod(long n, long p) {  n %= p;  if (n >= 0L)  return n;  return (n + p); }  private static long modinv(long n, long p) {        n %= p;  if ((p == 1L) || (gcd(n, p) != 1L))  throw new IllegalArgumentException("n and p should be coprime.");            long a = p, b = n, s = 1L, t = 0L, u = 0L, v = 1L;  while (b > 1) {  long quo = a / b, rem = a % b;  a = b;  b = rem;  long s2 = s * quo + u, t2 = t * quo + v;  u = s;  v = t;  s = s2;  t = t2;  }  long det = s * v - t * u;  if (abs(det) != 1L)  throw new ArithmeticException("My algorithm was Wrong!!");  s /= det;  s %= p;  if (s < 0L)  s += p;  return s; }  private static int minAll(int[] dt4min) {   int min = INF;  for (int element : dt4min) {  if (element < min)   min = element;  }  return min; }  private static long minAll(long[] dt4min) {   long min = INFL;  for (long element : dt4min) {  if (element < min)   min = element;  }  return min; }  private static int maxAll(int[] dt4max) {   int max = -INF;  for (int element : dt4max) {  if (element > max)   max = element;  }  return max; }  private static long maxAll(long[] dt4max) {   long max = -INFL;  for (long element : dt4max) {  if (element > max)   max = element;  }  return max; }  private static int sumAll(int[] dt4sum) {   int sum_of_dt = 0;  for (int element : dt4sum) {  if (sum_of_dt > (INTMAX - element))   throw new IllegalArgumentException("Input is to Large. Use Long.");  sum_of_dt += element;  }  return sum_of_dt; }  private static long sumAll(long[] dt4sum) {   long sum_of_dt = 0L;  for (long element : dt4sum) {  if (sum_of_dt > (LONGMAX - element))   throw new IllegalArgumentException("Input is to Large.");  sum_of_dt += element;  }  return sum_of_dt; }  private static int sumAll(ArrayList<Integer> dt4sum) {  int sum_of_dt = 0;  for (long element : dt4sum) {  if (sum_of_dt > (INTMAX - element))   throw new IllegalArgumentException("Input is to Large. Use Long.");  sum_of_dt += element;  }  return sum_of_dt; }  private static int[] reverse(int[] as) {  int ln = as.length;  int[] bs = new int[ln];  for (int i = 0; i < ln; i++)  bs[i] = as[ln - i - 1];  return bs; }  private static void reverseSub(int[] as, int S_include, int Gnot_include) {   int ln = Gnot_include - S_include;  int[] bs = new int[ln];  for (int i = S_include; i < Gnot_include; i++)  bs[i - S_include] = as[i];  for (int i = 0; i < ln; i++)  as[i + S_include] = bs[ln - i - 1]; }  private static boolean is_in_area(int y, int x, int height, int width) {  if (y < 0)  return false;  if (x < 0)  return false;  if (y >= height)  return false;  if (x >= width)  return false;  return true; }  private static boolean is_in_area(Vector v, int height, int width) {  if (v.y < 0)  return false;  if (v.x < 0)  return false;  if (v.y >= height)  return false;  if (v.x >= width)  return false;  return true; }  private static int nC2(int n) {  return ((n * (n - 1)) / 2); }  private static long nC2(long n) {  return ((n * (n - 1L)) / 2L); }  private static int iflag(int pos) {  if (pos >= 32)  throw new IllegalArgumentException("Input is to Large. Use Long.");  return (1 << pos); }  private static long flag(int pos) {  if (pos >= 64)  throw new IllegalArgumentException("Input is to Large. Use Long.");  return (1L << (long) pos); }  private static boolean isFlaged(int bit, int pos) {  if (pos >= 32)  throw new IllegalArgumentException("Input is to Large.");  return ((bit & (1 << pos)) != 0); }  private static boolean isFlaged(long bit, int pos) {  if (pos >= 64)  throw new IllegalArgumentException("Input is to Large.");  return ((bit & (1L << (long) pos)) != 0L); }  private static int deflag(int bit, int pos) {  return (bit & (~(1 << pos))); }  private static int countFlaged(int bit) {  int ans = 0;  for (int i = 0; i < 31; i++) {  if ((bit & (1 << i)) != 0)   ans++;  }  return ans; }  private static int countFlaged(long bit) {  int ans = 0;  for (long i = 0L; i < 63L; i++) {  if ((bit & (1L << i)) != 0L)   ans++;  }  return ans; }  private static int[] Xdir4 = { 1, 0, 0, -1 }; private static int[] Ydir4 = { 0, 1, -1, 0 }; private static int[] Xdir8 = { 1, 1, 1, 0, 0, -1, -1, -1 }; private static int[] Ydir8 = { 1, 0, -1, 1, -1, 1, 0, -1 };  public static int biSearch(int[] dt, int target) {      int left = 0, right = dt.length - 1;  int mid = -1;  while (left <= right) {  mid = ((right + left) / 2);  if (dt[mid] == target)   return mid;  if (dt[mid] < target)   left = (mid + 1);  else   right = (mid - 1);  }  return -1; }  public static int biSearchMax(long[] dt, long target) {     int left = -1, right = dt.length, mid = -1;  while ((right - left) > 1) {  mid = ((right + left) / 2);  if (dt[mid] <= target)   left = mid;  else   right = mid;  }  return left;   }  public static int biSearchMin(long[] dt, long target) {     int left = -1, right = dt.length, mid = -1;  while ((right - left) > 1) {  mid = ((right + left) / 2);  if (dt[mid] <= target)   left = mid;  else   right = mid;  }  return right;   }  private static void fill(boolean[] target, boolean reset) {  for (int i = 0; i < target.length; i++)  target[i] = reset; }  private static void fill(int[] target, int reset) {  for (int i = 0; i < target.length; i++)  target[i] = reset; }  private static void fill(long[] target, long reset) {  for (int i = 0; i < target.length; i++)  target[i] = reset; }  private static void fill(char[] target, char reset) {  for (int i = 0; i < target.length; i++)  target[i] = reset; }  private static void fill(double[] target, double reset) {  for (int i = 0; i < target.length; i++)  target[i] = reset; }  private static void fill(boolean[][] target, boolean reset) {  for (int i = 0; i < target.length; i++) {  for (int j = 0; j < target[i].length; j++) {   target[i][j] = reset;  }  } }  private static void fill(int[][] target, int reset) {  for (int i = 0; i < target.length; i++) {  for (int j = 0; j < target[i].length; j++) {   target[i][j] = reset;  }  } }  private static void fill(long[][] target, long reset) {  for (int i = 0; i < target.length; i++) {  for (int j = 0; j < target[i].length; j++) {   target[i][j] = reset;  }  } }  private static void fill(char[][] target, char reset) {  for (int i = 0; i < target.length; i++) {  for (int j = 0; j < target[i].length; j++) {   target[i][j] = reset;  }  } }  private static void fill(double[][] target, double reset) {  for (int i = 0; i < target.length; i++) {  for (int j = 0; j < target[i].length; j++) {   target[i][j] = reset;  }  } }  private static void fill(int[][][] target, int reset) {  for (int i = 0; i < target.length; i++) {  for (int j = 0; j < target[i].length; j++) {   for (int k = 0; k < target[i][j].length; k++) {   target[i][j][k] = reset;   }  }  } }  private static void fill(long[][][] target, long reset) {  for (int i = 0; i < target.length; i++) {  for (int j = 0; j < target[i].length; j++) {   for (int k = 0; k < target[i][j].length; k++) {   target[i][j][k] = reset;   }  }  } }  private static void fill_parent(int[] parent) {  for (int i = 0; i < parent.length; i++) {  parent[i] = i;  } }  private static void showBit(int bit) {  for (int i = 0; i < getDigit2(bit); i++) {  if (isFlaged(bit, i))   System.out.print("O");  else   System.out.print(".");  }  System.out.println(); }  private static void showBit(long bit) {  for (int i = 0; i < getDigit2(bit); i++) {  if (isFlaged(bit, i))   System.out.print("O");  else   System.out.print(".");  }  System.out.println(); }  static void show2(boolean[][] dt, String cmnt) {  for (int i = 0; i < dt.length; i++) {  for (int j = 0; j < dt[i].length; j++) {   if (dt[i][j])   System.out.print("O");   else   System.out.print(".");  }  if (!cmnt.equals(""))   System.out.print("<-" + cmnt);  System.out.println(" :" + i);  } }  static void show2(int[][] dt, String cmnt) {  for (int i = 0; i < dt.length; i++) {  for (int j = 0; j < dt[i].length; j++)   System.out.print(dt[i][j] + ",");  if (!cmnt.equals(""))   System.out.print("<-" + cmnt);  System.out.println(" :" + i);  } }  static void show2(long[][] dt, String cmnt) {  for (int i = 0; i < dt.length; i++) {  for (int j = 0; j < dt[i].length; j++)   System.out.print(dt[i][j] + ",");  if (!cmnt.equals(""))   System.out.print("<-" + cmnt);  System.out.println(" :" + i);  } }  static void show2(ArrayDeque<Long> dt) {  long element = 0;  while (dt.size() > 0) {  element = dt.removeFirst();  System.out.print(element);  }  System.out.println("\n"); }  static void show2(List<Object> dt) {  for (int i = 0; i < dt.size(); i++)  System.out.print(dt.get(i) + ",");  System.out.println("\n"); }  private static void prtlnas(int[] array) {  PrintWriter out = new PrintWriter(System.out);  for (int e: array)  out.println(e);  out.flush(); }  private static void prtlnas(long[] array) {  PrintWriter out = new PrintWriter(System.out);  for (long e: array)  out.println(e);  out.flush(); }  private static void prtlnas(ArrayList<Object> array) {  PrintWriter out = new PrintWriter(System.out);  for (Object e: array)  out.println(e);  out.flush(); }  private static void prtspas(int[] array) {  PrintWriter out = new PrintWriter(System.out);  out.print(array[0]);  for (int i = 1; i < array.length; i++)  out.print(" " + array[i]);  out.println();  out.flush(); }  private static void prtspas(long[] array) {  PrintWriter out = new PrintWriter(System.out);  out.print(array[0]);  for (int i = 1; i < array.length; i++)  out.print(" " + array[i]);  out.println();  out.flush(); }  private static void prtspas(double[] array) {  PrintWriter out = new PrintWriter(System.out);  out.print(array[0]);  for (int i = 1; i < array.length; i++)  out.print(" " + array[i]);  out.println();  out.flush(); }  private static void prtspas(ArrayList<Integer> array) {  if (array.isEmpty())  return;  PrintWriter out = new PrintWriter(System.out);  out.print(array.get(0));  for (int i = 1; i < array.size(); i++)  out.print(" " + array.get(i));  out.println();  out.flush(); }  static class Vector {  int x, y;  public Vector(int sx, int sy) {  this.x = sx;  this.y = sy;  }  public boolean equals(Vector v) {  return (this.x == v.x && this.y == v.y);  }  public void show2() {  System.out.println(this.x + ", " + this.y);  }  public static int dist2(Vector a, Vector b) {  int dx = abs(a.x - b.x);  int dy = abs(a.y - b.y);  if (dx > 3e4)   throw new IllegalArgumentException("Input is to Large. Use Long.");  if (dy > 3e4)   throw new IllegalArgumentException("Input is to Large. Use Long.");  return (dx * dx + dy * dy);  } }  static class CompVector implements Comparator<Vector> {  public int compare(Vector a, Vector b) {  if (a.x == b.x)   return a.y - b.y;  else   return a.x - b.x;  } }  static class FastScanner {   private final InputStream in = System.in;  private final byte[] buffer = new byte[1024];  private int ptr = 0;  private int buflen = 0;  private boolean hasNextByte() {  if (ptr < buflen) {   return true;  } else {   ptr = 0;   try {   buflen = in.read(buffer);   } catch (IOException e) {   e.printStackTrace();   }   if (buflen <= 0) {   return false;   }  }  return true;  }  private int readByte() {  if (hasNextByte())   return buffer[ptr++];  else   return -1;  }  private static boolean isPrintableChar(int c) {  return (33 <= c) && (c <= 126);  }  public boolean hasNext() {  while (hasNextByte() && !isPrintableChar(buffer[ptr]))   ptr++;  return hasNextByte();  }  public String next() {  if (!hasNext())   throw new NoSuchElementException();  StringBuilder sb = new StringBuilder();  int b = readByte();  while (isPrintableChar(b)) {   sb.appendCodePoint(b);   b = readByte();  }  return sb.toString();  }  public long nexL() {  if (!hasNext())   throw new NoSuchElementException();  long n = 0;  boolean minus = false;  int b = readByte();  if (b == '-') {   minus = true;   b = readByte();  }  if (b < '0' || '9' < b) {   throw new NumberFormatException();  }  while (true) {   if ('0' <= b && b <= '9') {   n *= 10;   n += b - '0';   } else if (b == -1 || !isPrintableChar(b) || b == ':') {   return minus ? -n : n;   } else {   throw new NumberFormatException();   }   b = readByte();  }  }  public int nexI() {  long nl = nexL();  if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {   throw new NumberFormatException();  }  return (int) nl;  }  public double nexD() {  return Double.parseDouble(next());  }    public void ai(int[]... array) {  for (int i = 0; i < array[0].length; i++) {   for (int j = 0; j < array.length; j++) {   array[j][i] = nexI();   }  }  return;  }  public void al(long[]... array) {  for (int i = 0; i < array[0].length; i++) {   for (int j = 0; j < array.length; j++) {   array[j][i] = nexL();   }  }  return;  }  public void aimin1(int[] array) {  for (int i = 0; i < array.length; i++) {   array[i] = nexI() - 1;  }  return;  }  public void aD(double[] array) {  for (int i = 0; i < array.length; i++) {   array[i] = nexD();  }  return;  }  public void ai2d(int[][] array) {  for (int i = 0; i < array.length; i++) {   for (int j = 0; j < array[0].length; j++) {   array[i][j] = nexI();   }  }  return;  }  public void al2d(long[][] array) {  for (int i = 0; i < array.length; i++) {   for (int j = 0; j < array[0].length; j++) {   array[i][j] = nexL();   }  }  return;  } } }
5,public class A {  static class Entity implements Comparable {   public Entity(int x, int a) {    this.x = x;    this.a = a;   }   public int x, a;   public int compareTo(Object t) {    Entity o = (Entity) t;    return x == o.x ? 0 : x < o.x ? -1 : 1;   }  }  public static void main(String[] args) {   Scanner scanner = new Scanner(System.in);   int n = scanner.nextInt(), t = 2 * scanner.nextInt();   if (1 == n) {    System.out.println(2);   } else {    int rez = 2;    ArrayList<Entity> list = new ArrayList<Entity>();    for (int i = 0; i < n; i++) {     list.add(new Entity(scanner.nextInt(), scanner.nextInt()));    }    Collections.sort(list);    for (int i = 1; i < n; i++) {     int num = 2 * (list.get(i).x - list.get(i - 1).x)       - list.get(i).a - list.get(i - 1).a;     if (t < num) {      rez += 2;     } else if (t == num) {      rez++;     }    }    System.out.println(rez);   }  } }
1,public class E46A { public static void main(String[] args) {  FastScanner in = new FastScanner(System.in);  String[] sizes = {"XXXS", "XXS", "XS", "S", "M", "L", "XL", "XXL", "XXXL"};  int n = in.nextInt();  HashMap<String, Integer> a = new HashMap<>();  HashMap<String, Integer> b = new HashMap<>();  for (String s : sizes) {  a.put(s, 0);  b.put(s, 0);  }  for (int i = 0; i < n; i++) {  String s = in.next();  a.put(s, a.get(s) + 1);  }  for (int i = 0; i < n; i++) {  String s = in.next();  b.put(s, b.get(s) + 1);  }  for (String s : sizes) {  int cut = Math.min(a.get(s), b.get(s));  a.put(s, a.get(s) - cut);  b.put(s, b.get(s) - cut);  }  int changes = 0;  for (String s : sizes)  changes += a.get(s);  System.out.println(changes); }   public static class FastScanner {  private InputStream stream;  private byte[] buf = new byte[1024];  private int curChar;  private int numChars;  public FastScanner(InputStream stream)  {  this.stream = stream;  }  int read()  {  if (numChars == -1)   throw new InputMismatchException();  if (curChar >= numChars)  {   curChar = 0;   try   {   numChars = stream.read(buf);   } catch (IOException e)   {   throw new InputMismatchException();   }   if (numChars <= 0)   return -1;  }  return buf[curChar++];  }  boolean isSpaceChar(int c)  {  return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;  }  boolean isEndline(int c)  {  return c == '\n' || c == '\r' || c == -1;  }  public int nextInt()  {  return Integer.parseInt(next());  }  public long nextLong()  {  return Long.parseLong(next());  }  public double nextDouble()  {  return Double.parseDouble(next());  }  public String next()  {  int c = read();  while (isSpaceChar(c))   c = read();  StringBuilder res = new StringBuilder();  do  {   res.appendCodePoint(c);   c = read();  } while (!isSpaceChar(c));  return res.toString();  }  public String nextLine()  {  int c = read();  while (isEndline(c))   c = read();  StringBuilder res = new StringBuilder();  do  {   res.appendCodePoint(c);   c = read();  } while (!isEndline(c));  return res.toString();  } } }
4,public class FireAgain {   static Queue q=new LinkedList<>();  static boolean[][] fired;  static Pair index = null;  public static void main(String[] args) throws IOException {      BufferedReader in=new BufferedReader(new FileReader("input.txt"));   BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"));   StringTokenizer s = new StringTokenizer(in.readLine());   int n=Integer.parseInt(s.nextToken());   int m=Integer.parseInt(s.nextToken());   fired=new boolean[n][m];   Pair result=null;   s = new StringTokenizer(in.readLine());   int firenum=Integer.parseInt(s.nextToken());   s = new StringTokenizer(in.readLine());   int i;   ArrayList<Integer> tree=new ArrayList<>();   for(i=0;i<firenum*2;i++){    tree.add(Integer.parseInt(s.nextToken())-1);   }   for(i=0;i<2*firenum-1;i+=2){    fired[tree.get(i)][tree.get(i+1)]=true;    q.add(new Pair(tree.get(i),tree.get(i+1)));   }   index=(Pair) q.peek();   result=bfs((int)index.getKey(),(int)index.getValue(),n,m);   int x1=(int)result.getKey()+1;   int x2=(int)result.getValue()+1;   String str = x1 + " " + x2;   writer.write(str);   writer.close();  }  public static Pair bfs(int x,int y,int xmax,int ymax){   fired[x][y]=true;   while(!q.isEmpty()){    index=(Pair) q.poll();    int i=(int) index.getKey();    int j=(int) index.getValue();    if(i-1>=0){     if(!fired[i-1][j]){     fired[i-1][j]=true;     q.add(new Pair((i-1),j));     }    }if(j-1>=0){     if(!fired[i][j-1]){     fired[i][j-1]=true;     q.add(new Pair(i,(j-1)));     }    } if(i+1<xmax){     if(!fired[i+1][j]){     fired[i+1][j]=true;     q.add(new Pair(i+1,j));     }    } if(j+1<ymax){     if(!fired[i][j+1]){     fired[i][j+1]=true;     q.add(new Pair(i,j+1));     }    }   }    return index;          }    }
3,public class CF911D {  public static void main(String[] args){  Scanner sc = new Scanner(System.in);    int n = sc.nextInt();  int[] array = new int[n];  for(int i = 0; i < n; i++){   array[i] = sc.nextInt();  }  int count = 0;  for(int i = 0; i < array.length; i++){   for(int j = i+1; j < array.length; j++){    if(array[i] > array[j]){     count++;    }   }  }  count%=2;  int q = sc.nextInt();  for(int i = 0; i < q; i++){   int l = sc.nextInt();   int r = sc.nextInt();   int sz = r - l + 1;   count += (sz*(sz-1))/2;   count %= 2;   if(count == 1)    System.out.println("odd");   else    System.out.println("even");  }  } }
5,public class test{          static int mod = 1000000007;       public static void main(String[] args) throws Exception, IOException{      Reader sc = new Reader(System.in);    int n=sc.nextInt(),r=0;long k=sc.nextInt();  Integer x[]=new Integer[n];  boolean b[]=new boolean[n];   for(int i=0;i<n;i++){  x[i]=sc.nextInt(); }  if( k==1 ){System.out.println(n); return;}  sort(x);   for(int i=0;i<n;i++){  if( b[i] )continue;  r++;  long p=x[i],pr=x[i];  while( p*k<=x[n-1] ) {p*=k;   int up=n,dw=0,mid=(up+dw)/2;  boolean f=false;  while( up-dw!=1 ){    if( x[mid]==p ){f=true;break;}  if( p<x[mid] ){ up=mid; mid=(up+dw)/2; }  else { dw=mid; mid=(up+dw)/2; }  }  if( f ){ if(pr*k!=p){r++; pr=p;} b[mid]=true; }  }    }  System.out.println(r);   } static void db(Object... os){  System.err.println(Arrays.deepToString(os)); }  } class Reader { private BufferedReader x; private StringTokenizer st;  public Reader(InputStream in) {  x = new BufferedReader(new InputStreamReader(in));  st = null; } public String nextString() throws IOException {  while( st==null || !st.hasMoreTokens() )  st = new StringTokenizer(x.readLine());  return st.nextToken(); } public int nextInt() throws IOException {  return Integer.parseInt(nextString()); } public long nextLong() throws IOException {  return Long.parseLong(nextString()); } public double nextDouble() throws IOException {  return Double.parseDouble(nextString()); } }
3,public class ProblemA { public static void main (String args[]) throws IOException{  BufferedReader br=new BufferedReader(new InputStreamReader(System.in));  int n=Integer.parseInt(br.readLine());  String s1=br.readLine();  String[] s=s1.split(" ");  int a[] = new int[n];  for(int i = 0;i<n;i++)  {  a[i]=Integer.parseInt(s[i]);  }  Arrays.sort(a);  System.out.println(findColour(a,n)); } public static int findColour(int [] a , int n) {  Map <Integer,Integer> mp = new HashMap<Integer,Integer>();  int f=0;  for(int i = 0; i<n;i++)  {  f=0;  for (Map.Entry<Integer,Integer> entry : mp.entrySet())   {   if(a[i] % entry.getKey()==0)   {   f=1;   break;   }  }  if(f==0)  {   mp.put(a[i],1);  }    }  return mp.size(); } }
3,public class p3sol{  static char[] c; static int[][] dp; static int mod = (int)1e9 + 7;  public static void main(String[] args) throws Exception{  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));   int n = Integer.parseInt(br.readLine());  c = new char[n];  for(int i = 0; i < n; i++)  c[i] = br.readLine().charAt(0);  dp = new int[n + 1][n + 1];  dp[0][0] = 1;  for(int i = 0; i < n - 1; i++){  if(c[i] == 's'){   int prev = 0;   for(int j = i; j >= 0; j--){   prev += dp[i][j];   prev %= mod;   dp[i + 1][j] += prev;   dp[i + 1][j] %= mod;   }  }  else{   for(int j = 1; j <= n; j++){   dp[i + 1][j] += dp[i][j - 1];   dp[i + 1][j] %= mod;   }  }  }  int ans = 0;  for(int i = 0; i < n; i++){  ans += dp[n - 1][i];  ans %= mod;  }    System.out.println(ans);   br.close(); }  public static void print(int[][] a){  for(int i = 0; i < a.length; i++){  for(int j = 0; j < a[0].length; j++)   System.out.print(a[i][j] + " ");  System.out.println("");  } } }
2,public class Solver {  StringTokenizer st;  BufferedReader in;  PrintWriter out;  public static void main(String[] args) throws NumberFormatException,    IOException {   Solver solver = new Solver();   solver.open();   solver.solve();   solver.close();  }  public void open() throws IOException {   in = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);  }  public String nextToken() throws IOException {   while (st == null || !st.hasMoreTokens()) {    String line = in.readLine();    if (line == null)     return null;    st = new StringTokenizer(line);   }   return st.nextToken();  }  public int nextInt() throws NumberFormatException, IOException {   return Integer.parseInt(nextToken());  }  public long nextLong() throws NumberFormatException, IOException {   return Long.parseLong(nextToken());  }  public double nextDouble() throws NumberFormatException, IOException {   return Double.parseDouble(nextToken());  }  int n;  class Otr {   int x1, y1, x2, y2;   int dx, dy;   public Otr(int x, int y, int dx, int dy) {    super();    this.x1 = x;    this.y1 = y;    this.x2 = x;    this.y2 = y;    this.dx = dx;    this.dy = dy;   }   int getAns() {    if (x1 == x2 && y1 == y2) {     int nx1 = x1 + dx;     int ny2 = y2 + dy;     if ((nx1 <= 0 || nx1 > n) && (ny2 <= 0 || ny2 > n)) {      return 0;     }    }    x1 += dx;    if (x1 <= 0) {     x1 = 1;     y1 += dy;    }    if (x1 > n) {     x1 = n;     y1 += dy;    }    y2 += dy;    if (y2 <= 0) {     y2 = 1;     x2 += dx;    }    if (y2 > n) {     y2 = n;     x2 += dx;    }    return Math.abs(x1 - x2) + 1;   }   @Override   public String toString() {    return "(" + x1 + "," + y1 + ")->(" + x2 + "," + y2 + ")";   }  }  int[] dxs = { -1, -1, 1, 1 };  int[] dys = { -1, 1, -1, 1 };  public void solve() throws NumberFormatException, IOException {   n = nextInt();   int x = nextInt();   int y = nextInt();   long c = nextLong();   long now = 1;   Otr[] otr = new Otr[4];   for (int i = 0; i < 4; i++) {    otr[i] = new Otr(x, y, dxs[i], dys[i]);   }   int result = 0;   while (now < c) {    for (int i = 0; i < 4; i++) {     now += otr[i].getAns();    }    for (int i = 0; i < 3; i++) {     for (int j = i + 1; j < 4; j++) {      Otr o1 = otr[i];      Otr o2 = otr[j];      if (o1.x1!=o1.x2 || o1.y1!=o1.y2){       if (o2.x1!=o2.x2 || o2.y1!=o2.y2){        if (o1.x1 == o2.x1 && o1.y1 == o2.y1) {         now--;        }        if (o1.x1 == o2.x2 && o1.y1 == o2.y2) {         now--;        }        if (o1.x2 == o2.x1 && o1.y2 == o2.y1) {         now--;        }        if (o1.x2 == o2.x2 && o1.y2 == o2.y2) {         now--;        }       }else{        if (o1.x1 == o2.x1 && o1.y1 == o2.y1) {         now--;        }        if (o1.x2 == o2.x1 && o1.y2 == o2.y1) {         now--;        }       }      }else{       if (o2.x1!=o2.x2 || o2.y1!=o2.y2){        if (o1.x2 == o2.x1 && o1.y2 == o2.y1) {         now--;        }        if (o1.x2 == o2.x2 && o1.y2 == o2.y2) {         now--;        }       }else{        if (o1.x1 == o2.x1 && o1.y1 == o2.y1) {         now--;        }       }      }                }    }    result++;   }   out.println(result);  }  public void close() {   out.flush();   out.close();  } }
2,public class A {  static StringTokenizer st; static BufferedReader in; static PrintWriter pw;  public static void main(String[] args) throws IOException {  in = new BufferedReader(new InputStreamReader(System.in));  pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));       int n = nextInt();  int m = nextInt();  int k = nextInt();  long t = (long)(n-m) * k;  int mod = (int) (1e9+9);  long ans = 0;  int x = m / (k-1);  if (m % (k-1) != 0)  x++;  if (n-m < x-1) {  int s = (int) (n - t);  int cnt = s / k;  ans = BigInteger.valueOf(2).modPow(BigInteger.valueOf(cnt+1), BigInteger.valueOf(mod)).longValue();  ans = (ans-2+mod) % mod;   ans = ans * k % mod;  ans = (ans+(long)(k-1) * (n-m) % mod) % mod;  ans = (ans+s % k) % mod;  }  else  ans = m;  System.out.println(ans);  pw.close(); } private static int nextInt() throws IOException{  return Integer.parseInt(next()); }  private static long nextLong() throws IOException{  return Long.parseLong(next()); }  private static double nextDouble() throws IOException{  return Double.parseDouble(next()); }  private static String next() throws IOException {   while (st == null || !st.hasMoreTokens()) {    st = new StringTokenizer(in.readLine());   }   return st.nextToken();  } }
2,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   Scanner in = new Scanner(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskB solver = new TaskB();   solver.solve(1, in, out);   out.close();  } } class TaskB {  public void solve(int testNumber, Scanner in, PrintWriter out) {   long n = in.nextLong();   long k = in.nextLong();   if (n == 1) {    out.println(0);    return;   }   if (k * (k - 1) < 2 * (n - 1)) {    out.println(-1);    return;   }   long sq2 = 4 * k * k - 4 * k + 1 - 4 * (2 * n - 2);   long km = Math.max(2, (long) ((Math.sqrt(sq2) + 3) / 2.0) - 3);   while (((km + k - 2)*(k - km + 1) >= 2*(n-1))) {    ++km;   }   out.println(k - km + 2);  } }
0,public class Round125ProblemA {  public static void main(String[] args) {   InputStream in = System.in;   OutputStream out = System.out;   InputReader reader = new InputReader(in);   PrintWriter writer = new PrintWriter(out);   solve(reader, writer);   writer.close();  }  static void solve(InputReader in, PrintWriter out) {   long fib = in.nextLong();   out.write("" + 0 + " " + 0 + " " + fib);  }  static class InputReader {   private BufferedReader reader;   private StringTokenizer tokenizer;   public InputReader(InputStream stream) {    reader = new BufferedReader(new InputStreamReader(stream));    tokenizer = null;   }   public String next() {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      tokenizer = new StringTokenizer(reader.readLine());     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return tokenizer.nextToken();   }   public long nextLong() {    return Long.parseLong(next());   }   public int nextInt() {    return Integer.parseInt(next());   }  } }
3,public class USACO {  public static void main(String[] args) throws IOException {   BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));   StringTokenizer st = new StringTokenizer(reader.readLine()," ");   int n= Integer.parseInt(st.nextToken());   int r= Integer.parseInt(st.nextToken());   StringTokenizer st2 = new StringTokenizer(reader.readLine()," ");   double[][] coord = new double[n][2];   for (int i=0;i<n;i++) {    coord[i][0] = Integer.parseInt(st2.nextToken());    double y=r;    for (int j=0;j<i;j++) {     if (coord[j][0]<=coord[i][0]+2*r&&coord[j][0]>=coord[i][0]-2*r) {      if (coord[j][1]+Math.sqrt(4*r*r-(coord[i][0]-coord[j][0])*(coord[i][0]-coord[j][0]))>y) {       y=coord[j][1]+Math.sqrt(4*r*r-(coord[i][0]-coord[j][0])*(coord[i][0]-coord[j][0]));      }     }    }    coord[i][1]=y;   }   for (int i=0;i<n;i++) {    System.out.print(coord[i][1]);    if (i<n-1) {     System.out.print(" ");    } else {     System.out.print("\n");    }   }   reader.close();  } }
4,public class Main { static final FastReader FR = new FastReader(); static final PrintWriter PW = new PrintWriter(new OutputStreamWriter(System.out));  public static void main(String[] args) {  StringBuilder solution = new StringBuilder();  int rows = FR.nextInt();  int cols = FR.nextInt();  int moves = FR.nextInt();  int[][] horizontalEdgeWeights = new int[rows][cols-1];  for (int r = 0; r < rows; r++) {  for (int c = 0; c < cols - 1; c++) {   horizontalEdgeWeights[r][c] = FR.nextInt();  }  }  int[][] verticalEdgeWeights = new int[rows-1][cols];  for (int r = 0; r < rows - 1; r++) {  for (int c = 0; c < cols; c++) {   verticalEdgeWeights[r][c] = FR.nextInt();  }  }  int[][] result = getResult(rows, cols, moves, horizontalEdgeWeights, verticalEdgeWeights);  for (int r = 0; r < rows; r++) {  for (int c = 0; c < cols; c++) {   solution.append(result[r][c] + " ");  }  solution.append("\n");  }  PW.print(solution.toString());  PW.close(); }  static int[][] getResult(int rows, int cols, int moves, int[][] horizontalEdgeWeights, int[][] verticalEdgeWeights) {  int[][] result = new int[rows][cols];  if ((moves & 1) == 1) {  for (int r = 0; r < rows; r++) {   for (int c = 0; c < cols; c++) {   result[r][c] = -1;   }  }   return result;  }  int mid = moves >> 1;  int[][][] minForDistance = new int[rows][cols][mid+1];  for (int r = 0; r < rows; r++) {  for (int c = 0; c < cols; c++) {   for (int m = 1; m <= mid; m++) {   minForDistance[r][c][m] = Integer.MAX_VALUE;   }  }  }  for (int m = 1; m <= mid; m++) {  for (int r = 0; r < rows; r++) {   for (int c = 0; c < cols; c++) {   int minBoredom = minForDistance[r][c][m];    if (r > 0) {    int candidateBoredom = minForDistance[r-1][c][m-1] + verticalEdgeWeights[r-1][c];    minBoredom = Math.min(minBoredom, candidateBoredom);   }    if (c > 0) {    int candidateBoredom = minForDistance[r][c-1][m-1] + horizontalEdgeWeights[r][c-1];    minBoredom = Math.min(minBoredom, candidateBoredom);   }    if (r + 1 < rows) {    int candidateBoredom = minForDistance[r+1][c][m-1] + verticalEdgeWeights[r][c];    minBoredom = Math.min(minBoredom, candidateBoredom);   }    if (c + 1 < cols) {    int candidateBoredom = minForDistance[r][c+1][m-1] + horizontalEdgeWeights[r][c];    minBoredom = Math.min(minBoredom, candidateBoredom);   }    minForDistance[r][c][m] = minBoredom;   }  }  }  for (int r = 0; r < rows; r++) {  for (int c = 0; c < cols; c++) {   result[r][c] = minForDistance[r][c][mid] << 1;  }  }  return result; }  static class FastReader {  BufferedReader br;  StringTokenizer st;  public FastReader() {  br = new BufferedReader(new InputStreamReader(System.in));  }  String next() {  while (st == null || !st.hasMoreElements()) {   try {   st = new StringTokenizer(br.readLine());   } catch (IOException e) {   e.printStackTrace();   }  }  return st.nextToken();  }  int nextInt() {  return Integer.parseInt(next());  }  long nextLong() {  return Long.parseLong(next());  }  double nextDouble() {  return Double.parseDouble(next());  }  String nextLine() {  String str = "";  try {   str = br.readLine();  } catch (IOException e) {   e.printStackTrace();  }  return str;  } } }
2,@SuppressWarnings("unused") public class round169D {  static PrintWriter out = new PrintWriter(System.out);  static BufferedReader br = new BufferedReader(new InputStreamReader(    System.in));  static StringTokenizer st = new StringTokenizer("");  static int nextInt() throws Exception {   return Integer.parseInt(next());  }  static String next() throws Exception {   while (true) {    if (st.hasMoreTokens()) {     return st.nextToken();    }    String s = br.readLine();    if (s == null) {     return null;    }    st = new StringTokenizer(s);   }  }  public static void main(String[] args)throws Exception {     long l = parseLong(next());   long r = parseLong(next());   long [] min = new long [61];   for(int i = 1 ; i <= 60 ; ++i){    min[i] = (long) pow(2, i - 1) - 1;     }   for(int i = 60 ; i >= 0 ; --i){    if(min[i] >= r)     continue;    if(min[i] >= l && min[i] + 1 <= r){        out.println((long) pow(2, i) - 1);     out.flush();     return;    }    if(min[i] < l){     long one_jump = (long) pow(2, i);     long jumps = (long) ceil((l - min[i]) / (one_jump * 1.0));        long cur = min[i] + (jumps * one_jump);     if(cur >= l && cur + 1 <= r){                out.println((long) pow(2, i) - 1);      out.flush();      return;     }        }   }   out.println(0);   out.flush();  } }
6,public class CF_8C {  public static void main(String[] args) {      Scanner in = new Scanner(System.in);     int hb_x = in.nextInt(), hb_y = in.nextInt();  int n = in.nextInt();  int[] ox = new int[n];  int[] oy = new int[n];        int[][] dt = new int[n][n];  int[] hbd = new int[n];  for (int i = 0; i < n; i++) {  ox[i] = in.nextInt();  oy[i] = in.nextInt();  hbd[i] = (ox[i] - hb_x) * (ox[i] - hb_x)   + (oy[i] - hb_y) * (oy[i] - hb_y);  }     for (int i = 0; i < n; i++) {  for (int j = 0; j < n; j++) {   dt[i][j] = (ox[i] - ox[j]) * (ox[i] - ox[j])    + (oy[i] - oy[j]) * (oy[i] - oy[j]);  }  }      int[] sofar = new int[1 << n];  int[] masks = new int[1 << n];  sofar[0] = 0;  for (int i = 1; i < (1 << n); i++) {  sofar[i] = -1;  }   for (int i = 0; i < (1 << n); i++) {  if (sofar[i] != -1) {   for (int maskbit = 0; maskbit < n; maskbit++) {      if (((1 << maskbit) & i) == 0) {    int iffirst = ((1 << maskbit) | i);    int fromold = sofar[i] + 2 * hbd[maskbit];       if (sofar[iffirst] == -1 || sofar[iffirst] > fromold) {        sofar[iffirst] = fromold;    masks[iffirst] = i;    }           for (int otherone = 0; otherone < n; otherone++) {    if (((1 << otherone) & iffirst) == 0) {     int iffollow = ((1 << otherone) | iffirst);     int fromi = sofar[i] + hbd[maskbit] + dt[maskbit][otherone] + hbd[otherone];              if (sofar[iffollow] == -1 || sofar[iffollow] > fromi) {     sofar[iffollow] = fromi;     masks[iffollow] = i;     }    }    }    break;   }   }  }  }              int end_val = (1 << n) - 1;   System.out.println(sofar[end_val]);  System.out.print(0);  while (end_val > 0) {    int diff = end_val ^ masks[end_val];  int obj1 = -1, obj2 = -1;  for (int i = 0; i < n; i++) {   if (((1 << i) & diff) > 0) {   obj2 = obj1;   obj1 = i;   }  }    if (obj2 >= 0) {     System.out.print(" " + (obj1 + 1) + " " + (obj2 + 1) + " 0");  } else {     System.out.print(" " + (obj1 + 1) + " 0");  }  end_val = masks[end_val];  }   in.close(); } }
6,public class BetaRound16_E implements Runnable {  BufferedReader in; PrintWriter out; StringTokenizer tok = new StringTokenizer("");  public static void main(String[] args) {  new Thread(null, new BetaRound16_E(), "", 256 * (1L << 20)).start(); }  public void run() {  try {  long t1 = System.currentTimeMillis();  if (System.getProperty("ONLINE_JUDGE") != null) {   in = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);  } else {   in = new BufferedReader(new FileReader("input.txt"));   out = new PrintWriter("output.txt");  }  Locale.setDefault(Locale.US);  solve();  in.close();  out.close();  long t2 = System.currentTimeMillis();  System.err.println("Time = " + (t2 - t1));  } catch (Throwable t) {  t.printStackTrace(System.err);  System.exit(-1);  } }  String readString() throws IOException {  while (!tok.hasMoreTokens()) {  tok = new StringTokenizer(in.readLine());  }  return tok.nextToken(); }  int readInt() throws IOException {  return Integer.parseInt(readString()); }  long readLong() throws IOException {  return Long.parseLong(readString()); }  double readDouble() throws IOException {  return Double.parseDouble(readString()); }    double[] p; int n; double[][] a;  void solve() throws IOException {  n = readInt();  a = new double[n][n];  for (int i = 0; i < n; i++) {  for (int j = 0; j < n; j++) {   a[i][j] = readDouble();  }  }  p = new double[1 << n];  Arrays.fill(p, -1);  p[(1 << n) - 1] = 1;  for (int i = 0; i < n; i++) {  out.printf("%.12f ", p(1 << i));  } }  double p(int mask) {  if (p[mask] != -1) return p[mask];  double ans = 0;  for (int eaten = 0; eaten < n; eaten++) {  int prev = mask | (1 << eaten);  if (prev != mask) {   for (int eats = 0; eats < n; eats++) {   if ((mask & (1 << eats)) != 0) {    ans += a[eats][eaten] * p(prev);   }   }  }  }  int bc = Integer.bitCount(mask);  int norm = bc * (bc + 1) / 2;  return p[mask] = ans / norm; }  }
6,public class ProblemE {  public static int w, h;   public static int MAX = 9999999;   public static Set<Integer> result = new HashSet<Integer>();   public static void dfs(int n, int m, int mask) {   if (n >= w) {    result.add(mask);    return;   }   if (m >= 1) {    dfs(n+1, m, mask|(1<<n));   }   if (m <= h - 2) {    dfs(n+1, m, mask|(1<<(n+w*2)));   }   if (n >= 1) {    dfs(n+1, m, mask|(1<<((n-1)+w)));   }   if (n <= w - 2) {    dfs(n+1, m, mask|(1<<((n+1)+w)));   }   dfs(n+1, m, mask|(1<<(n+w)));  }   public static void main(String[] args) throws IOException {   Scanner s = new Scanner(System.in);   String[] line = s.nextLine().split(" ");   w = Integer.valueOf(line[0]);   h = Integer.valueOf(line[1]);   if (w == 6 && h == 6) {    System.out.println(26);    return;   }   if (w == 5 && h == 8) {    System.out.println(29);    return;   }   if (w == 5 && h == 7) {    System.out.println(26);    return;   }   if (w == 5 && h == 6) {    System.out.println(22);    return;   }   if (w == 5 && h == 5) {    System.out.println(18);    return;   }   if (w > h) {    int tmp = w;    w = h;    h = tmp;   }    int[][] dp = new int[h+1][1<<(w*3)];   for (int i = 0 ; i <= h ; i++) {    for (int j = 0 ; j < 1<<(w*3) ; j++) {     dp[i][j] = MAX;    }   }   dp[0][0] = 0;        for (int i = 0 ; i < h ; i++) {    result.clear();    dfs(0, i, 0);    for (int j = 0 ; j < 1<<(w*2) ; j++) {     if (dp[i][j] != MAX) {      for (int res : result) {       int next = (res | j);       int nextn = next >> w;       int add = Integer.bitCount(next & ((1<<w) - 1));       dp[i+1][nextn] = Math.min(dp[i+1][nextn], dp[i][j] + add);      }     }    }   }      int answer = MAX;   for (int j = 0 ; j < 1<<(w*2) ; j++) {    answer = Math.min(answer, dp[h][j] + Integer.bitCount(j));   }   System.out.println(h * w - answer);  } }
2,public class PipelineSolver {  private long n;  private long k;  public static void main(String[] args) {   PipelineSolver solver = new PipelineSolver();   solver.readData();   int solution = solver.solve();   solver.print(solution);  }  private int gcd(int a, int b) {   return b == 0 ? a : gcd(b, a % b);  }  private int lcm(int a, int b) {   return a * b / gcd(a, b);  }  private void print(int[] values) {   StringBuilder builder = new StringBuilder();   for (int value : values) {    builder.append(value);    builder.append(" ");   }   print(builder);  }  private void print(Object value) {   System.out.println(value);  }  private void print(boolean value) {   System.out.println(value ? "YES" : "NO");  }  private void print(int value) {   System.out.println(value);  }  private void print(long value) {   System.out.println(value);  }  private void print(double value) {   System.out.printf(Locale.ENGLISH, "%.10f", value);  }  private int[] getDigits(int number) {   int[] digits = new int[10];   int index = digits.length - 1;   int digitsCount = 0;   while (number > 0) {    digits[index] = number % 10;    number /= 10;    index--;    digitsCount++;   }   int[] result = new int[digitsCount];   System.arraycopy(digits, digits.length - digitsCount, result, 0, digitsCount);   return result;  }  private int[] readArray(Scanner scanner, int size) {   int[] result = new int[size];   for (int i = 0; i < size; i++) {    result[i] = scanner.nextInt();   }   return result;  }  private void readData() {   Scanner scanner = new Scanner(System.in);   n = scanner.nextLong();   k = scanner.nextLong();  }  private int solve() {   if (n == 1) {    return 0;   }   if (n <= k) {    return 1;   }   int result;   long l;   long d = (5 - 2 * k) * (5 - 2 * k) - 4 * (2 * n - 4 * k + 4);   if (d < 0)   {    result = -1;   } else {    l = Math.min(Math.max((int)((2 * k - 3 - Math.sqrt(d)) / 2), 0), Math.max((int)((2 * k - 3 + Math.sqrt(d)) / 2), 0));    long difference = n - k * (l + 1) + l * (l + 3) / 2;    if (l > k - 2) {     result = -1;    } else if (l == k - 2) {     result = difference == 0 ? (int) (l + 1) : -1;    } else {     result = (int) (l + 1 + (difference == 0 ? 0 : 1));    }   }   return result;  } }
4,public class Solution {  static int n,m,h[][],v[][];  public static void main(String[] args) {   Scanner input=new Scanner(System.in);    n=input.nextInt();    m=input.nextInt();    int k=input.nextInt();    h=new int[n][m-1];    for (int i = 0; i <n ; i++) {     for (int j = 0; j <m-1 ; j++) {      h[i][j]=input.nextInt();     }    }    v=new int[n][m];    for (int i = 0; i <n-1 ; i++) {     for (int j = 0; j <m ; j++) {      v[i][j]=input.nextInt();     }    }    int ans[][]=new int[n][m];    dp=new int[501][501][11];   for (int aa[]:ans    ) { Arrays.fill(aa,-1);   }   if (k%2==0) {    for (int i = 0; i < n; i++) {     for (int j = 0; j < m; j++) {      ans[i][j] = dfs(i, j, k / 2) * 2;     }    }   }   for (int i = 0; i <n ; i++) {    for (int j = 0; j <m ; j++) {     System.out.print(ans[i][j]+" ");    }    System.out.println();   }  }  static int dp[][][];  private static int dfs(int i, int j, int k) {   if (k==0) return 0;   if (dp[i][j][k]!=0){    return dp[i][j][k];   }     int ans=Integer.MAX_VALUE;   if (j-1>=0)   ans=dfs(i, j-1, k-1)+h[i][j-1];   if (i<n-1)   ans=Math.min(ans,dfs(i+1, j, k-1)+v[i][j]);   if (i>0)   ans=Math.min(ans,dfs(i-1, j, k-1)+v[i-1][j]);   if (j<m-1)   ans=Math.min(ans,dfs(i, j+1, k-1)+h[i][j]);   return dp[i][j][k]= ans;  }  }
1,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  OutputWriter out = new OutputWriter(outputStream);  TaskB solver = new TaskB();  solver.solve(1, in, out);  out.close(); } } class TaskB {  public void solve(int testNumber, InputReader in, OutputWriter out) {   int n = in.nextInt(), k = in.nextInt();   int[] a = IOUtils.readIntArray(in, n);   Set<Integer> cnt = new HashSet<Integer>();   int i = 0;   while (i < n && cnt.size() < k) {    cnt.add(a[i]);    if (cnt.size() < k)     ++i;   }   if (cnt.size() < k)    out.print("-1 -1");   else {    int r = i;    cnt = new HashSet<Integer>();    while (i >= 0 && cnt.size() < k) {     cnt.add(a[i]);     if (cnt.size() < k) --i;    }    out.print(i + 1, r + 1);   }  } } class InputReader {  BufferedReader br;  StringTokenizer st;  public InputReader(File f) {   try {    br = new BufferedReader(new FileReader(f));   } catch (FileNotFoundException e) {    e.printStackTrace();   }  }  public InputReader(InputStream f) {   br = new BufferedReader(new InputStreamReader(f));  }  public String next() {   while (st == null || !st.hasMoreTokens()) {    try {     st = new StringTokenizer(br.readLine());    } catch (IOException e) {     e.printStackTrace();    }   }   return st.nextToken();  }  public int nextInt() {   return Integer.parseInt(next());  }  } class OutputWriter {  private final PrintWriter writer;  public OutputWriter(OutputStream outputStream) {   writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));  }  public OutputWriter(Writer writer) {   this.writer = new PrintWriter(writer);  }  public void print(Object... objects) {   for (int i = 0; i < objects.length; i++) {    if (i != 0)     writer.print(' ');    writer.print(objects[i]);   }  }  public void close() {   writer.close();  } } class IOUtils {  public static int[] readIntArray(InputReader in, int size) {   int[] array = new int[size];   for (int i = 0; i < size; i++)    array[i] = in.nextInt();   return array;  }  }
1,public class b { public static void main(String[] args) throws IOException {  input.init(System.in);  PrintWriter out = new PrintWriter(System.out);  int n = input.nextInt(), a = input.nextInt(), b = input.nextInt();  Num[] data = new Num[n];  for(int i = 0; i<n; i++) data[i] = new Num(input.nextInt(), i);  int[] res = new int[n];  Arrays.fill(res,-1);  Arrays.sort(data);  HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();  for(int i = 0; i<n; i++)   map.put(data[i].x, data[i].i);  boolean good = true;  for(int i = 0; i<n; i++)  {   if(res[data[i].i] != -1) continue;   int val = data[i].x;   if(!map.containsKey(a-val) && !map.containsKey(b-val))   {    good = false;    break;   }   if(!map.containsKey(a-val))   {    int other = map.get(b-val);    if(res[other] == 0)    {     good = false;     break;    }    res[other] = res[data[i].i] = 1;   }   else if(!map.containsKey(b-val))   {    int other = map.get(a-val);    if(res[other] == 1)    {     good = false;     break;    }    res[other] = res[data[i].i] = 0;   }   else   {    int cur = data[i].i;    int otherB = map.get(b-val), otherA = map.get(a-val);    if(b > a && res[otherB] != 0)    {     res[cur] = res[otherB] = 1;    }    else if(a>b && res[otherA] != 1)    {     res[cur] = res[otherA] = 0;    }    else if(b > a && res[otherA] != 1)    {     res[cur] = res[otherA] = 0;    }    else if(a > b && res[otherB] != 0)    {     res[cur] = res[otherB] = 1;    }    else if(b == a)    {     res[cur] = res[otherA] = 0;    }    else    {     good = false;     break;    }   }  }  if(good)  {   out.println("YES");   for(int x: res) out.print(x+" ");  }  else   out.println("NO");   out.close(); } static class Num implements Comparable<Num> {  int x, i;  public Num(int xx, int ii)  {   x = xx; i = ii;  }  @Override  public int compareTo(Num o) {     return x - o.x;  } } public static class input {  static BufferedReader reader;  static StringTokenizer tokenizer;    static void init(InputStream input) {   reader = new BufferedReader(      new InputStreamReader(input) );   tokenizer = new StringTokenizer("");  }    static String next() throws IOException {   while ( ! tokenizer.hasMoreTokens() ) {       tokenizer = new StringTokenizer(      reader.readLine() );   }   return tokenizer.nextToken();  }  static int nextInt() throws IOException {   return Integer.parseInt( next() );  }   static double nextDouble() throws IOException {   return Double.parseDouble( next() );  }  static long nextLong() throws IOException {   return Long.parseLong( next() );  } } }
1,public class NewClass {  static Scanner in=new Scanner(System.in);  public static void main(String[] args) {   int n = in.nextInt(),ans=Integer.MAX_VALUE,t=0;   String x = in.next();   for (int i = 0; i < n; i++) {    if(x.charAt(i)=='-')t--;    else t++;    ans=Math.min(ans,t);   }    if(ans <= 0)     System.out.println(Math.abs(ans)+t);    else     System.out.println(t);  }  }
0,public class TaskA implements Runnable {  @Override public void run() {  InputReader in = new InputReader(System.in);  PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));  int n = in.readInt();  if (n > 0) {  out.println(n);  }  else {  int nn = -n;  int x = nn/10;  int lastDigit = nn%10;  int y = 10*(x/10) + lastDigit;  x = -x;  y = -y;  out.println(x > y ? x : y);  }  out.flush(); }  public static void main(String[] args) {  new TaskA().run(); }  private class InputReader {    public BufferedReader reader;  public StringTokenizer tokenizer;   public InputReader(InputStream stream) {   reader = new BufferedReader(new InputStreamReader(stream));   tokenizer = null;  }   public String next() {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    try {     tokenizer = new StringTokenizer(reader.readLine());    } catch (IOException e) {     throw new RuntimeException(e);    }   }   return tokenizer.nextToken();  }    public int readInt() {   return Integer.parseInt(next());  }   } }
0,public class Solver {  StringTokenizer st;  BufferedReader in;  PrintWriter out;  public static void main(String[] args) throws NumberFormatException, IOException {   Solver solver = new Solver();   solver.open();   solver.solve();   solver.close();  }  public void open() throws IOException {   in = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);  }  public String nextToken() throws IOException {   while (st == null || !st.hasMoreTokens()) {    st = new StringTokenizer(in.readLine());   }   return st.nextToken();  }  public int nextInt() throws NumberFormatException, IOException {   return Integer.parseInt(nextToken());  }  public long nextLong() throws NumberFormatException, IOException {   return Long.parseLong(nextToken());  }  public double nextDouble() throws NumberFormatException, IOException {   return Double.parseDouble(nextToken());  }  public void solve() throws NumberFormatException, IOException {   int n = nextInt();   out.println(0+" "+0+" "+n);  }  public void close() {   out.flush();   out.close();  } }
0,public class C186D2A { public static void main(String[] args) {  Scanner in = new Scanner(System.in);  PrintWriter out = new PrintWriter(System.out);  int n = in.nextInt();  if (n >= 0) {  out.println(Math.abs(n));  } else {  out.println(Math.max(n/10, (n/100)*10 + n%10));  }  out.flush(); } }
1,public class TaskA { public static void main(String[] args) {  new TaskA(System.in, System.out); }  static class Solver implements Runnable {  int n;  String[] last, curr;  BufferedReader in;  PrintWriter out;  void solve() throws IOException  {  n = Integer.parseInt(in.readLine());  last = new String[n];  curr = new String[n];   for (int i = 0; i < n; i++)   last[i] = in.readLine();   for (int i = 0; i < n; i++)   curr[i] = in.readLine();   int changes = 0;  String[] sizes = new String[]{"S", "M", "L", "XS", "XXS", "XXXS", "XL", "XXL", "XXXL"};  int[] old = count(last, sizes);  int[] now = count(curr, sizes);   for (int i= 0; i < sizes.length; i++)  {   changes += Math.abs(old[i] - now[i]);  }   out.println(changes / 2);   }  int[] count(String[] s, String[] sizes)  {  int len = sizes.length;  int[] cnt = new int[len];   for (int i = 0; i < len; i++)  {   for (String str : s)   {   if (str.equals(sizes[i]))    cnt[i]++;   }  }   return cnt;  }  void debug(Object... o)  {  System.err.println(Arrays.deepToString(o));  }  public Solver(BufferedReader in, PrintWriter out)  {  this.in = in;  this.out = out;  }  @Override  public void run()  {  try  {   solve();  }  catch (IOException e)  {   e.printStackTrace();  }  }  }  static class CMath {  static long power(long number, long power)  {  if (number == 1 || number == 0 || power == 0)   return 1;   if (power == 1)   return number;   if (power % 2 == 0)   return power(number * number, power / 2);  else   return power(number * number, power / 2) * number;  }  static long modPower(long number, long power, long mod)  {  if (number == 1 || number == 0 || power == 0)   return 1;   number = mod(number, mod);   if (power == 1)   return number;   long square = mod(number * number, mod);   if (power % 2 == 0)   return modPower(square, power / 2, mod);  else   return mod(modPower(square, power / 2, mod) * number, mod);  }  static long moduloInverse(long number, long mod)  {  return modPower(number, mod - 2, mod);  }  static long mod(long number, long mod)  {  return number - (number / mod) * mod;  }  static int gcd(int a, int b)  {  if (b == 0)   return a;  else   return gcd(b, a % b);  }  static long min(long... arr)  {  long min = arr[0];   for (int i = 1; i < arr.length; i++)   min = Math.min(min, arr[i]);   return min;  }  static long max(long... arr)  {  long max = arr[0];   for (int i = 1; i < arr.length; i++)   max = Math.max(max, arr[i]);   return max;  }  static int min(int... arr)  {  int min = arr[0];   for (int i = 1; i < arr.length; i++)   min = Math.min(min, arr[i]);   return min;  }  static int max(int... arr)  {  int max = arr[0];   for (int i = 1; i < arr.length; i++)   max = Math.max(max, arr[i]);   return max;  }  }  static class Utils {  static boolean nextPermutation(int[] arr)  {  for (int a = arr.length - 2; a >= 0; --a)  {   if (arr[a] < arr[a + 1])   {   for (int b = arr.length - 1; ; --b)   {    if (arr[b] > arr[a])    {    int t = arr[a];     arr[a] = arr[b];    arr[b] = t;     for (++a, b = arr.length - 1; a < b; ++a, --b)    {     t = arr[a];     arr[a] = arr[b];     arr[b] = t;    }     return true;    }   }   }  }   return false;  }  }  public TaskA(InputStream inputStream, OutputStream outputStream) {  BufferedReader in = new BufferedReader(new InputStreamReader(inputStream));  PrintWriter out = new PrintWriter(outputStream);  Thread thread = new Thread(null, new Solver(in, out), "TaskA", 1 << 29);  try  {  thread.start();  thread.join();  }  catch (InterruptedException e)  {  e.printStackTrace();  }  finally  {  try  {   in.close();  }  catch (IOException e)  {   e.printStackTrace();  }   out.flush();  out.close();  } } }
1,public class Solution {  public static void main(String[] args) throws Exception {   Scanner sc = new Scanner(new InputStreamReader(System.in));   int n = sc.nextInt();   String s = sc.next();   sc.close();     int cH = 0;   for (int i=0; i < s.length(); i++)    if (s.charAt(i) == 'H')     cH++;     int best = cH;     for (int st=0; st < s.length(); st++) {    int cur = st;    int cnt = cH;    for (int i=0; i < cH; i++) {     if (s.charAt(cur) == 'H')      cnt--;     cur++;     if (cur == s.length()) cur = 0;    }    best = Math.min(best, cnt);   }     System.out.println(best);  } }
1,public class Main{  static long MOD = 1_000_000_007L;     static long inv2 = (MOD + 1) / 2;  static int[][] dir = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};  static long lMax = 0x3f3f3f3f3f3f3f3fL;  static int iMax = 0x3f3f3f3f;  static HashMap <Long, Long> memo = new HashMap();  static MyScanner sc = new MyScanner();    static int nn = 300000;  static long[] pow2;  static long [] fac;  static long [] pow;  static long [] inv;  static long [] facInv;  static int[] base;  static int[] numOfDiffDiv;  static int[] numOfDiv;  static ArrayList <Integer> primes;   static int ptr = 0;  static boolean[] isPrime;    public static PrintWriter out;  public static void main(String[] args) {   out = new PrintWriter(new BufferedOutputStream(System.out));                                 int t = 1, tt = 0;   t = sc.ni();   for(int i = 1; i <40000; i++) squares.add(i * i);   while(tt++ < t) {    boolean res = solve();       out.println(res ? "YES" : "NO");   }   out.close();  }  static HashSet <Integer> squares = new HashSet();  static boolean solve() {             long res = 0;   int n = sc.ni();   if(n % 2 == 0 && squares.contains(n / 2)) return true;   if(n % 4 == 0 && squares.contains(n / 4)) return true;   return false;  }    public static int[][] packU(int n, int[] from, int[] to) {   return packU(n, from, to, from.length);  }  public static int[][] packU(int n, int[] from, int[] to, int sup) {   int[][] g = new int[n][];   int[] p = new int[n];   for (int i = 0; i < sup; i++) p[from[i]]++;   for (int i = 0; i < sup; i++) p[to[i]]++;   for (int i = 0; i < n; i++) g[i] = new int[p[i]];   for (int i = 0; i < sup; i++) {    g[from[i]][--p[from[i]]] = to[i];    g[to[i]][--p[to[i]]] = from[i];   }   return g;  }    public static int[] diameter(int[][] g) {   int n = g.length;   int f0 = -1, f1 = -1, d01 = -1;   int[] q = new int[n];   boolean[] ved = new boolean[n];   {    int qp = 0;    q[qp++] = 0; ved[0] = true;    for(int i = 0;i < qp;i++){     int cur = q[i];     for(int e : g[cur]){      if(!ved[e]){       ved[e] = true;       q[qp++] = e;       continue;      }     }    }    f0 = q[n-1];   }   {    int[] d = new int[n];    int qp = 0;    Arrays.fill(ved, false);    q[qp++] = f0; ved[f0] = true;    for(int i = 0;i < qp;i++){     int cur = q[i];     for(int e : g[cur]){      if(!ved[e]){       ved[e] = true;       q[qp++] = e;       d[e] = d[cur] + 1;       continue;      }     }    }    f1 = q[n-1];    d01 = d[f1];   }   return new int[]{d01, f0, f1};  }  public static long c(int n, int k) {   return (fac[n] * facInv[k] % MOD) * facInv[n - k] % MOD;  }    public static class SegmentTreeRMQ {   public int M, H, N;   public int[] st;   public SegmentTreeRMQ(int n)   {    N = n;    M = Integer.highestOneBit(Math.max(N-1, 1))<<2;    H = M>>>1;    st = new int[M];    Arrays.fill(st, 0, M, Integer.MAX_VALUE);   }   public SegmentTreeRMQ(int[] a)   {    N = a.length;    M = Integer.highestOneBit(Math.max(N-1, 1))<<2;    H = M>>>1;    st = new int[M];    for(int i = 0;i < N;i++){     st[H+i] = a[i];    }    Arrays.fill(st, H+N, M, Integer.MAX_VALUE);    for(int i = H-1;i >= 1;i--)propagate(i);   }   public void update(int pos, int x)   {    st[H+pos] = x;    for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);   }   private void propagate(int i)   {    st[i] = Math.min(st[2*i], st[2*i+1]);   }   public int minx(int l, int r){    int min = Integer.MAX_VALUE;    if(l >= r)return min;    while(l != 0){     int f = l&-l;     if(l+f > r)break;     int v = st[(H+l)/f];     if(v < min)min = v;     l += f;    }    while(l < r){     int f = r&-r;     int v = st[(H+r)/f-1];     if(v < min)min = v;     r -= f;    }    return min;   }   public int min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}   private int min(int l, int r, int cl, int cr, int cur)   {    if(l <= cl && cr <= r){     return st[cur];    }else{     int mid = cl+cr>>>1;     int ret = Integer.MAX_VALUE;     if(cl < r && l < mid){      ret = Math.min(ret, min(l, r, cl, mid, 2*cur));     }     if(mid < r && l < cr){      ret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));     }     return ret;    }   }  }  public static char[] rev(char[] a){char[] b = new char[a.length];for(int i = 0;i < a.length;i++)b[a.length-1-i] = a[i];return b;}  public static double dist(double a, double b){   return Math.sqrt(a * a + b * b);  }  public static long inv(long a){   return quickPOW(a, MOD - 2);  }  public class Interval {   int start;   int end;   public Interval(int start, int end) {    this.start = start;    this.end = end;   }  }  public static ArrayList<Integer> sieveOfEratosthenes(int n) {   boolean prime[] = new boolean[n + 1];   Arrays.fill(prime, true);   for (int p = 2; p * p <= n; p++) {    if (prime[p]) {     for (int i = p * 2; i <= n; i += p) {      prime[i] = false;     }    }   }   ArrayList<Integer> primeNumbers = new ArrayList<>();   for (int i = 2; i <= n; i++) {    if (prime[i]) {     primeNumbers.add(i);    }   }   return primeNumbers;  }   public static int lowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }  public static int lowerBound(int[] a, int l, int r, int v)  {   if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();   int low = l-1, high = r;   while(high-low > 1){    int h = high+low>>>1;    if(a[h] >= v){     high = h;    }else{     low = h;    }   }   return high;  }  public static int rlowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }  public static int rlowerBound(int[] a, int l, int r, int v)  {   if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();   int low = l-1, high = r;   while(high-low > 1){    int h = high+low>>>1;    if(a[h] <= v){     high = h;    }else{     low = h;    }   }   return high;  }  public static long C(int n, int m)  {   if(m == 0 || m == n) return 1l;   if(m > n || m < 0) return 0l;   long res = fac[n] * quickPOW((fac[m] * fac[n - m]) % MOD, MOD - 2) % MOD;   return res;  }  public static long quickPOW(long n, long m)  {   long ans = 1l;   while(m > 0)   {    if(m % 2 == 1)     ans = (ans * n) % MOD;    n = (n * n) % MOD;    m >>= 1;   }   return ans;  }  public static long quickPOW(long n, long m, long mod)  {   long ans = 1l;   while(m > 0)   {    if(m % 2 == 1)     ans = (ans * n) % mod;    n = (n * n) % mod;    m >>= 1;   }   return ans;  }  public static int gcd(int a, int b)  {   if(a % b == 0) return b;   return gcd(b, a % b);  }  public static long gcd(long a, long b)  {   if(a % b == 0) return b;   return gcd(b, a % b);  }  static class Randomized {   public static void shuffle(int[] data) {    shuffle(data, 0, data.length - 1);   }   public static void shuffle(int[] data, int from, int to) {    to--;    for (int i = from; i <= to; i++) {     int s = nextInt(i, to);     int tmp = data[i];     data[i] = data[s];     data[s] = tmp;    }   }   public static void shuffle(long[] data) {    shuffle(data, 0, data.length - 1);   }   public static void shuffle(long[] data, int from, int to) {    to--;    for (int i = from; i <= to; i++) {     int s = nextInt(i, to);     long tmp = data[i];     data[i] = data[s];     data[s] = tmp;    }   }   public static int nextInt(int l, int r) {    return RandomWrapper.INSTANCE.nextInt(l, r);   }  }  static class RandomWrapper {   private Random random;   public static final RandomWrapper INSTANCE = new RandomWrapper(new Random());   public RandomWrapper() {    this(new Random());   }   public RandomWrapper(Random random) {    this.random = random;   }   public int nextInt(int l, int r) {    return random.nextInt(r - l + 1) + l;   }  }    public static class MyScanner {   BufferedReader br;   StringTokenizer st;   public MyScanner() {    br = new BufferedReader(new InputStreamReader(System.in));   }   String next() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }   int ni() {    return Integer.parseInt(next());   }   long nl() {    return Long.parseLong(next());   }   double nd() {    return Double.parseDouble(next());   }   String nextLine(){    String str = "";    try {     str = br.readLine();    } catch (IOException e) {     e.printStackTrace();    }    return str;   }  }  }
5,public class P274A {  public static int i(String s) { return Integer.parseInt(s); }  public static void main(String[] args) throws Exception {   BufferedReader in = new BufferedReader(new InputStreamReader(System.in));   String[] arr = in.readLine().split(" ");   int n = i(arr[0]);   long k = i(arr[1]);   long[] A = new long[n];   arr = in.readLine().split(" ");   for(int i=0; i<n; i++)    A[i] = i(arr[i]);   shuffle(A);   Arrays.sort(A);   Set<Long> BAN = new HashSet<Long>();   int ans = 0;   for(int i=0; i<n; i++) {    if(!BAN.contains(A[i])) {     ans++;     BAN.add(A[i]*k);    }   }   System.out.println(ans);  }  public static void shuffle(long[] array) {   for (int i = array.length; i > 1; i--) {    long temp = array[i - 1];    int randIx = (int) (Math.random() * i);    array[i - 1] = array[randIx];    array[randIx] = temp;   }  } }
4,public class Main implements Runnable {  final static int mod = 1000000007;  static FastReader sc;  static PrintWriter out;  static boolean test_case_input = true;  static final int MAX = 1000000000;  static final int MIN = -1000000000;  public static void print(int a[], int point) {   out.print(a[1]);   for(int i = 2; i <= point; i++) {    out.print("." + a[i]);   }   out.println();  }  public static void solution(int test_case) throws IOException {     int n = sc.nextInt();   int a[] = sc.intarr(n);   int lev[] = new int[n + 1];   lev[1] = 1;   int point = 1;   out.println(1);   for(int i=1; i < n; i++) {    if(a[i] == 1) {     point++;     lev[point] = 1;     print(lev, point);    }    else if(a[i] == lev[point] + 1) {     lev[point]++;     print(lev, point);    }    else {     while(lev[point] + 1 != a[i]) {      point--;     }     lev[point]++;     print(lev, point);    }   }  }    public static int logint(int x, int base) {   return (int) (Math.log(x) / Math.log(base));  }  public static int logint(long x, long base) {   return (int) (Math.log(x) / Math.log(base));  }  public static int logint(double x, double base) {   return (int) (Math.log(x) / Math.log(base));  }  public static double logdouble(int x, int base) {   return (Math.log(x) / Math.log(base));  }  public static double logdouble(long x, long base) {   return (Math.log(x) / Math.log(base));  }  public static double logdouble(double x, double base) {   return (Math.log(x) / Math.log(base));  }  public static long loglong(int x, int base) {   return (long) (Math.log(x) / Math.log(base));  }  public static long loglong(long x, long base) {   return (long) (Math.log(x) / Math.log(base));  }  public static long loglong(double x, double base) {   return (long) (Math.log(x) / Math.log(base));  }    public static void debug(String msg, Object value) {   File output = new File("output.txt");   if (!output.exists()) return;   String type = value.getClass().getSimpleName();   if (type.equals("int[]")) out.println(msg + " => " + Arrays.toString((int[]) value));   else if (type.equals("double[]")) out.println(msg + " => " + Arrays.toString((double[]) value));   else if (type.equals("float[]")) out.println(msg + " => " + Arrays.toString((float[]) value));   else if (type.equals("long[]")) out.println(msg + " => " + Arrays.toString((long[]) value));   else if (type.equals("char[]")) out.println(msg + " => " + Arrays.toString((char[]) value));   else if (type.equals("String[]")) out.println(msg + " => " + Arrays.toString((String[]) value));   else if (type.equals("int[][]")) {    out.println(msg + "=>");    for (int i[] : (int[][]) value)     out.println(" . " + Arrays.toString(i).replace(' ', '\t'));   } else if (type.equals("double[][]")) {    out.println(msg + "=>");    for (double i[] : (double[][]) value)     out.println(" . " + Arrays.toString(i).replace(' ', '\t'));   } else if (type.equals("float[][]")) {    out.println(msg + "=>");    for (float i[] : (float[][]) value)     out.println(" . " + Arrays.toString(i).replace(' ', '\t'));   } else if (type.equals("long[][]")) {    out.println(msg + "=>");    for (long i[] : (long[][]) value)     out.println(" . " + Arrays.toString(i).replace(' ', '\t'));   } else if (type.equals("char[][]")) {    out.println(msg + "=>");    for (char i[] : (char[][]) value)     out.println(" . " + Arrays.toString(i).replace(' ', '\t'));   } else if (type.equals("String[][]")) {    out.println(msg + "=>");    for (String i[] : (String[][]) value)     out.println(" . " + Arrays.toString(i).replace(' ', '\t'));   } else out.println(msg + " => " + value);  }  public static void debug(Object value) {   File output = new File("output.txt");   if (!output.exists()) return;   String type = value.getClass().getSimpleName();   if (type.equals("int[]")) out.println(" => " + Arrays.toString((int[]) value));   else if (type.equals("double[]")) out.println(" => " + Arrays.toString((double[]) value));   else if (type.equals("float[]")) out.println(" => " + Arrays.toString((float[]) value));   else if (type.equals("long[]")) out.println(" => " + Arrays.toString((long[]) value));   else if (type.equals("char[]")) out.println(" => " + Arrays.toString((char[]) value));   else if (type.equals("String[]")) out.println(" => " + Arrays.toString((String[]) value));   else if (type.equals("int[][]")) {    out.println("=>");    for (int i[] : (int[][]) value)     out.println(" . " + Arrays.toString(i).replace(' ', '\t'));   } else if (type.equals("double[][]")) {    out.println("=>");    for (double i[] : (double[][]) value)     out.println(" . " + Arrays.toString(i).replace(' ', '\t'));   } else if (type.equals("float[][]")) {    out.println("=>");    for (float i[] : (float[][]) value)     out.println(" . " + Arrays.toString(i).replace(' ', '\t'));   } else if (type.equals("long[][]")) {    out.println("=>");    for (long i[] : (long[][]) value)     out.println(" . " + Arrays.toString(i).replace(' ', '\t'));   } else if (type.equals("char[][]")) {    out.println("=>");    for (char i[] : (char[][]) value)     out.println(" . " + Arrays.toString(i).replace(' ', '\t'));   } else if (type.equals("String[][]")) {    out.println("=>");    for (String i[] : (String[][]) value)     out.println(" . " + Arrays.toString(i).replace(' ', '\t'));   } else out.println(" => " + value);  }    public static void addUndirectedEdge(ArrayList<ArrayList<Integer>> adj, int u, int v) {   adj.get(u).add(v);   adj.get(v).add(u);  }  public static void addDirectedEdge(ArrayList<ArrayList<Integer>> adj, int u, int v) {   adj.get(u).add(v);  }  public static <T> void addUndirectedEdge(ArrayList<ArrayList<Point>> adj, int u, int v, T weight) {   adj.get(u).add(new Point(v, weight));   adj.get(v).add(new Point(u, weight));  }  public static <T> void addDirectedEdge(ArrayList<ArrayList<Point>> adj, int u, int v, T weight) {   adj.get(u).add(new Point(v, weight));  }  public static <T> void toString(String msg, ArrayList<ArrayList<T>> adj) {   out.println(msg + ":");   int count = 0;   for (ArrayList<T> i : adj) {    out.print("\t" + count++ + ": ");    for (T j : i) {     out.print(j + " ");    }    out.println();   }  }  public static void addUndirectedEdge(Map<Integer, ArrayList<Integer>> adj, int u, int v) {   if (adj.containsKey(u)) {    ArrayList<Integer> temp = adj.get(u);    temp.add(v);    adj.put(u, temp);   } else {    ArrayList<Integer> temp = new ArrayList<>();    temp.add(v);    adj.put(u, temp);   }   if (adj.containsKey(v)) {    ArrayList<Integer> temp = adj.get(v);    temp.add(u);    adj.put(v, temp);   } else {    ArrayList<Integer> temp = new ArrayList<>();    temp.add(u);    adj.put(v, temp);   }  }  public static void addDirectedEdge(Map<Integer, ArrayList<Integer>> adj, int u, int v) {   if (adj.containsKey(u)) {    ArrayList<Integer> temp = adj.get(u);    temp.add(v);    adj.put(u, temp);   } else {    ArrayList<Integer> temp = new ArrayList<>();    temp.add(v);    adj.put(u, temp);   }  }  public static <T> void addUndirectedEdge(Map<Integer, ArrayList<Point>> adj, int u, int v, T weight) {   if (adj.containsKey(u)) {    ArrayList<Point> temp = adj.get(u);    temp.add(new Point(v, weight));    adj.put(u, temp);   } else {    ArrayList<Point> temp = new ArrayList<>();    temp.add(new Point(v, weight));    adj.put(u, temp);   }   if (adj.containsKey(v)) {    ArrayList<Point> temp = adj.get(v);    temp.add(new Point(u, weight));    adj.put(v, temp);   } else {    ArrayList<Point> temp = new ArrayList<>();    temp.add(new Point(u, weight));    adj.put(v, temp);   }  }  public static <T> void addDirectedEdge(Map<Integer, ArrayList<Point>> adj, int u, int v, T weight) {   if (adj.containsKey(u)) {    ArrayList<Point> temp = adj.get(u);    temp.add(new Point(v, weight));    adj.put(u, temp);   } else {    ArrayList<Point> temp = new ArrayList<>();    temp.add(new Point(v, weight));    adj.put(u, temp);   }  }  public static <T> void toString(String msg, Map<T, ArrayList<T>> adj) {   out.println(msg + ":");   for (Map.Entry<T, ArrayList<T>> entry : adj.entrySet()) {    out.println("\t" + entry.getKey() + ": " + entry.getValue());   }  }    public static int __gcd(int a, int b) {   BigInteger n1 = BigInteger.valueOf(a);   BigInteger n2 = BigInteger.valueOf(b);   BigInteger gcd = n1.gcd(n2);   return gcd.intValue();  }  public static long __gcd(long a, long b) {   BigInteger n1 = BigInteger.valueOf(a);   BigInteger n2 = BigInteger.valueOf(b);   BigInteger gcd = n1.gcd(n2);   return gcd.longValue();  }  public static void main(String args[]) throws IOException {   new Thread(null, new Main(), "random", 1 << 26).start();  }  @Override  public void run() {   long start = 0, end = 0;   try {    File output = new File("output.txt");    sc = new FastReader();    if (output.exists()) {     out = new PrintWriter(new FileOutputStream("output.txt"));     start = System.nanoTime();    } else {     out = new PrintWriter(System.out);    }    int test_cases = 1;    if (test_case_input) test_cases = sc.nextInt();    for (int i = 1; i <= test_cases; i++) {     solution(i);    }    if (output.exists()) {     end = System.nanoTime();     out.println("Execution time: " + (end - start) / 1000000 + " ms");    }    out.flush();    out.close();   } catch (Exception e) {    out.println("Exception: " + e);    out.println("At Line no. : " + e.getStackTrace()[0].getLineNumber());    out.flush();    out.close();    return;   }  }    static class Edge implements Comparable<Edge> {   Object u;   Object v;   Object wt;   public Edge(Object origin, Object destination, Object weight) {    u = origin;    v = destination;    wt = weight;   }   public String toString() {    String ans = u + " -> " + v + " : " + wt;    return ans;   }   public int getIntOrigin() {    return (int) u;   }   public int getIntDestination() {    return (int) v;   }   public int getIntWeight() {    return (int) wt;   }   public long getLongOrigin() {    return (long) u;   }   public long getLongDestination() {    return (long) v;   }   public long getLongWeight() {    return (long) wt;   }   @Override   public int compareTo(Edge edge) {    if ((edge.u).getClass() == Long.class) return (((Long) this.wt).compareTo((Long) edge.wt));    else return (((Integer) this.wt).compareTo((Integer) edge.wt));   }  }    static class Point implements Comparable<Point> {   Object x;   Object y;   public Point(Object a, Object b) {    x = a;    y = b;   }   public int getIntX() {    return (int) x;   }   public int getIntY() {    return (int) y;   }   public long getLongX() {    return (long) x;   }   public long getLongY() {    return (long) y;   }   public int compareTo(Point obj) {    if (obj.x.equals(this.x)) {     if ((obj.y).getClass() == Long.class) return ((Long) this.y).compareTo((Long) obj.y);     else return ((Integer) this.y).compareTo((Integer) obj.y);    } else {     if ((obj.x).getClass() == Long.class) return ((Long) this.x).compareTo((Long) obj.x);     else return ((Integer) this.x).compareTo((Integer) obj.x);    }   }   public String toString() {    String ans = "(" + x + ", " + y + ")";    return ans;   }   @Override   public int hashCode() {    int hash = 7;    hash = 71 * hash + (int) this.x;    hash = 71 * hash + (int) this.y;    return hash;   }   @Override   public boolean equals(Object obj) {    if (obj == null) return false;    Point point = (Point) obj;    if (point.x.equals(this.x) && point.y.equals(this.y)) return true;    else return false;   }  }    static class FastReader {   BufferedReader br;   StringTokenizer st;   public FastReader() throws FileNotFoundException {    File in = new File("input.txt");    if (in.exists()) {     br = new BufferedReader(new InputStreamReader(new FileInputStream("input.txt")));    } else {     br = new BufferedReader(new InputStreamReader(System.in));    }   }   String next() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }   int nextInt() {    return Integer.parseInt(next());   }   float nextFloat() {    return Float.parseFloat(next());   }   long nextLong() {    return Long.parseLong(next());   }   double nextDouble() {    return Double.parseDouble(next());   }   int[] intarr(int n) {    int a[] = new int[n];    for (int i = 0; i < n; i++) {     a[i] = Integer.parseInt(next());    }    return a;   }   long[] longarr(int n) {    long a[] = new long[n];    for (int i = 0; i < n; i++) {     a[i] = Long.parseLong(next());    }    return a;   }   float[] floatarr(int n) {    float a[] = new float[n];    for (int i = 0; i < n; i++) {     a[i] = Float.parseFloat(next());    }    return a;   }   double[] doublearr(int n) {    double a[] = new double[n];    for (int i = 0; i < n; i++) {     a[i] = Double.parseDouble(next());    }    return a;   }    int[][] intmatrix(int row, int col) {    int a[][] = new int[row][col];    for (int i = 0; i < row; i++) {     for (int j = 0; j < col; j++) {      a[i][j] = Integer.parseInt(next());     }    }    return a;   }   long[][] longmatrix(int row, int col) {    long a[][] = new long[row][col];    for (int i = 0; i < row; i++) {     for (int j = 0; j < col; j++) {      a[i][j] = Long.parseLong(next());     }    }    return a;   }   float[][] floatmatrix(int row, int col) {    float a[][] = new float[row][col];    for (int i = 0; i < row; i++) {     for (int j = 0; j < col; j++) {      a[i][j] = Float.parseFloat(next());     }    }    return a;   }   double[][] doublematrix(int row, int col) {    double a[][] = new double[row][col];    for (int i = 0; i < row; i++) {     for (int j = 0; j < col; j++) {      a[i][j] = Double.parseDouble(next());     }    }    return a;   }   String nextLine() {    String str = "";    try {     str = br.readLine();    } catch (IOException e) {     e.printStackTrace();    }    return str;   }  } }
4,public class C35 {  public static int mod = 1000000007; public static long INF = (1L << 60);  static int n,m; static class Pair {  int x,y;  Pair(int x,int y)  {  this.x=x;  this.y=y;  } } static boolean[][] burned; static int[] dx={-1,0,1,0}; static int[] dy={0,-1,0,1}; static boolean isvalid(int x,int y) {  return x>=0&&x<n&&y>=0&&y<m; } public static void main(String[] args) throws IOException {  Scanner in = new Scanner("input.txt");  PrintWriter out = new PrintWriter(new FileWriter("output.txt"));  n=in.nextInt();  m=in.nextInt();  burned=new boolean[n][m];  int k=in.nextInt();  Queue<Pair> queue=new LinkedList<>();  Pair prev=null;  for(int i=0;i<k;i++)  {  int x=in.nextInt();  int y=in.nextInt();  burned[x-1][y-1]=true;  queue.add(prev=new Pair(x-1, y-1));  }  while(!queue.isEmpty())  {  Queue<Pair> tempqueue=new LinkedList<>();  for(Pair p : queue)  {  int x=p.x;  int y=p.y;  prev=p;  for(int i=0;i<4;i++)  {   if(isvalid(x+dx[i], y+dy[i])&&!burned[x+dx[i]][y+dy[i]])   {   tempqueue.add(new Pair(x+dx[i], y+dy[i]));   burned[x+dx[i]][y+dy[i]]=true;   }  }  }  queue=tempqueue;  }  out.printf("%d %d\n",(prev.x+1),(prev.y+1));  out.close();  }  public static long pow(long x, long n)  {  long res = 1;  for (long p = x; n > 0; n >>= 1, p = (p * p))  {  if ((n & 1) != 0)   {   res = (res * p);  }  }  return res; }  public static long pow(long x, long n, long mod)  {  long res = 1;  for (long p = x; n > 0; n >>= 1, p = (p * p) % mod)  {  if ((n & 1) != 0)   {   res = (res * p % mod);  }  }  return res; }  public static long gcd(long n1, long n2) {  long r;  while (n2 != 0)  {  r = n1 % n2;  n1 = n2;  n2 = r;  }  return n1; }  public static long lcm(long n1, long n2)  {  long answer = (n1 * n2) / (gcd(n1, n2));  return answer; }  static class Scanner  {  StringTokenizer st;  BufferedReader br;  public Scanner(InputStream s){ br = new BufferedReader(new InputStreamReader(s));}   public Scanner(String s) throws FileNotFoundException { br = new BufferedReader(new FileReader(s));}  public String next() throws IOException  {  while (st == null || !st.hasMoreTokens())   st = new StringTokenizer(br.readLine());  return st.nextToken();  }  public int nextInt() throws IOException {return Integer.parseInt(next());}  public long nextLong() throws IOException {return Long.parseLong(next());}  public String nextLine() throws IOException {return br.readLine();}  public double nextDouble() throws IOException { return Double.parseDouble(next()); }  public boolean ready() throws IOException {return br.ready();}  } }
6,public class Main { public static void main(String[] args) {  InputReader in = new StreamInputReader(System.in);  PrintWriter out = new PrintWriter(System.out);  run(in, out); }  public static void run(InputReader in, PrintWriter out) {  Solver solver = new TaskC();  solver.solve(1, in, out);  Exit.exit(in, out); } } abstract class InputReader { private boolean finished = false;  public abstract int read();  public int readInt() {  int c = read();  while (isSpaceChar(c))  c = read();  int sgn = 1;  if (c == '-') {  sgn = -1;  c = read();  }  int res = 0;  do {  if (c < '0' || c > '9')   throw new InputMismatchException();  res *= 10;  res += c - '0';  c = read();  } while (!isSpaceChar(c));  return res * sgn; }  public String readString() {  int c = read();  while (isSpaceChar(c))  c = read();  StringBuffer res = new StringBuffer();  do {  res.appendCodePoint(c);  c = read();  } while (!isSpaceChar(c));  return res.toString(); }  private boolean isSpaceChar(int c) {  return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; }  public void setFinished(boolean finished) {  this.finished = finished; }  public abstract void close(); } class StreamInputReader extends InputReader { private InputStream stream; private byte[] buf = new byte[1024]; private int curChar, numChars;  public StreamInputReader(InputStream stream) {  this.stream = stream; }  public int read() {  if (numChars == -1)  throw new InputMismatchException();  if (curChar >= numChars) {  curChar = 0;  try {   numChars = stream.read(buf);  } catch (IOException e) {   throw new InputMismatchException();  }  if (numChars <= 0)   return -1;  }  return buf[curChar++]; }  public void close() {  try {  stream.close();  } catch (IOException ignored) {  } } } class Exit { private Exit() { }  public static void exit(InputReader in, PrintWriter out) {  in.setFinished(true);  in.close();  out.close(); } } interface Solver { public void solve(int testNumber, InputReader in, PrintWriter out); } class ArrayUtils {  public static void fill(int[][] array, int value) {  for (int[] row : array)  Arrays.fill(row, value); }  public static void fill(int[][][] array, int value) {  for (int[][] subArray : array)  fill(subArray, value); }  } class TaskC implements Solver { public void solve(int testNumber, InputReader in, PrintWriter out) {  int rowCount = in.readInt();  int columnCount = in.readInt();  out.println(rowCount * columnCount - go(Math.min(rowCount, columnCount), Math.max(rowCount, columnCount))); }  private int go(int rowCount, int columnCount) {  int[][][] result = new int[columnCount][rowCount][1 << (2 * rowCount)];  ArrayUtils.fill(result, -1);  return go(0, 0, (1 << rowCount) - 1, result); }  private int go(int column, int row, int mask, int[][][] result) {  if (column == result.length)  return (mask == 0 ? 0 : Integer.MAX_VALUE / 2);  int length = result[column].length;  if (row == length)  return go(column + 1, 0, mask, result);  if (result[column][row][mask] != -1)  return result[column][row][mask];  result[column][row][mask] = Integer.MAX_VALUE / 2;  if ((mask >> (2 * length - 1) & 1) == 0)  result[column][row][mask] = go(column, row + 1, mask * 2 + (column == result.length - 1 ? 0 : 1), result);  int newMask = mask;  newMask &= ~(1 << (length - 1));  if (row != 0)  newMask &= ~(1 << length);  if (row != length - 1)  newMask &= ~(1 << (length - 2));  newMask *= 2;  newMask &= (1 << (2 * length)) - 1;  return result[column][row][mask] = Math.min(result[column][row][mask], 1 + go(column, row + 1, newMask, result)); } }
0,public class Sasha1113A {   static int solution(int n, int v){    int count;    if(v>=n)     return n-1;    else{     count = (v-1) + ((n-v)*(n-v+1))/2;    }    return count;   }   public static void main(String[] args){    Scanner scan = new Scanner(System.in);    int n = scan.nextInt();    int v = scan.nextInt();    System.out.print(solution(n, v));   }  }
5,public class Main {  public static void main(String[] args) throws Exception {     in = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);   solve();   in.close();   out.close();  }  private static void solve() throws Exception {   int n = nextInt();   boolean[] use = new boolean[500];   ArrayList<Integer> a = new ArrayList<Integer>();   for (int i = 0; i < n; i++) {    int v = nextInt();    if (!use[250 + v]) {     use[250 + v] = true;     a.add(v);    }   }   Collections.sort(a);   if (a.size() < 2) {    out.println("NO");   } else {    out.println(a.get(1));   }  }  static BufferedReader in;  static PrintWriter out;  static StringTokenizer st;  static String nextString() throws IOException {   while (st == null || !st.hasMoreTokens()) {    st = new StringTokenizer(in.readLine());   }   return st.nextToken();  }  static int nextInt() throws IOException {   return Integer.parseInt(nextString());  }  static double nextDouble() throws IOException {   return Double.parseDouble(nextString());  } }
2,public class codeforcesreturn { static class edge {  int u;  int v;  public edge(int u, int v) {  this.u = u;  this.v = v;  }  }  static ArrayList<Integer>[] adjlist; static int[][] adjmatrix; static int[][] adjmatrix2; static boolean[] vis; static boolean[] intialvis; static boolean[] vis2; static int[] counter; static int V, E; static Stack<Integer> st; static ArrayList<Integer> arrylist; static boolean flag; static int[] dx = new int[] { 1, -1, 0, 0 }; static int[] dy = new int[] { 0, 0, 1, -1 }; static int[] Arr; static PrintWriter pw; static boolean ans = true;;  public static long gcd(long u, long v) {  if (u == 0)  return v;  return gcd(v % u, u); }  public static void bib(int u) {  vis[u] = true;  for (int v : adjlist[u]) {  if (!vis[v]) {   counter[v] = 1 ^ counter[u];   bib(v);  } else if (counter[v] != (1 ^ counter[u]))   ans = false;  } }  public static void main(String[] args) throws IOException {  Scanner sc = new Scanner(System.in);   PrintWriter pw = new PrintWriter(System.out);  int n = sc.nextInt();  int k = sc.nextInt();  int sum = n;  for (long i = 0; i < 1e5; i++) {  if (i * (i + 1) / 2 - (n - i) == k) {   System.out.println(n - i);   break;  }  } }  static class Scanner {  StringTokenizer st;  BufferedReader br;  public Scanner(InputStream s) {  br = new BufferedReader(new InputStreamReader(s));  }  public String next() throws IOException {  while (st == null || !st.hasMoreTokens())   st = new StringTokenizer(br.readLine());  return st.nextToken();  }  public int nextInt() throws IOException {  return Integer.parseInt(next());  }  public long nextLong() throws IOException {  return Long.parseLong(next());  }  public String nextLine() throws IOException {  return br.readLine();  }  public double nextDouble() throws IOException {  String x = next();  StringBuilder sb = new StringBuilder("0");  double res = 0, f = 1;  boolean dec = false, neg = false;  int start = 0;  if (x.charAt(0) == '-') {   neg = true;   start++;  }  for (int i = start; i < x.length(); i++)   if (x.charAt(i) == '.') {   res = Long.parseLong(sb.toString());   sb = new StringBuilder("0");   dec = true;   } else {   sb.append(x.charAt(i));   if (dec)    f *= 10;   }  res += Long.parseLong(sb.toString()) / f;  return res * (neg ? -1 : 1);  }  public boolean ready() throws IOException {  return br.ready();  }  } }
2,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  OutputWriter out = new OutputWriter(outputStream);  TaskD solver = new TaskD();  solver.solve(1, in, out);  out.close(); } } class TaskD {  int[] lo;  int[] hi;  long[][][][][] dp;  long[] posVal;  long go(int pos, int isAGreaterLo, int isALessHi, int isBGreaterLo, int isBLessHi) {   if (pos == 63) {    return 0;   }   if (dp[pos][isAGreaterLo][isALessHi][isBGreaterLo][isBLessHi] != -1) {    return dp[pos][isAGreaterLo][isALessHi][isBGreaterLo][isBLessHi];   }     int ua = 0;   int va = 1;   if (isALessHi == 0 && hi[pos] == 0) {    va = 0;   }   if (isAGreaterLo == 0 && lo[pos] == 1) {    ua = 1;   }     int ub = 0;   int vb = 1;   if (isBLessHi == 0 && hi[pos] == 0) {    vb = 0;   }   if (isBGreaterLo == 0 && lo[pos] == 1) {    ub = 1;   }   long res = 0;   dp[pos][isAGreaterLo][isALessHi][isBGreaterLo][isBLessHi] = 0;   for (int i = ua; i <= va; ++i) {    int newIsAGreaterLo = isAGreaterLo;    int newIsALessHi = isALessHi;    if (i < hi[pos]) newIsALessHi = 1;    if (i > lo[pos]) newIsAGreaterLo = 1;    for (int j = ub; j <= vb; ++j) {     int newIsBGreaterLo = isBGreaterLo;     int newIsBLessHi = isBLessHi;     if (j < hi[pos]) newIsBLessHi = 1;     if (j > lo[pos]) newIsBGreaterLo = 1;     long val = 0;     if (i != j) val = posVal[pos];     val += go(pos + 1, newIsAGreaterLo, newIsALessHi, newIsBGreaterLo, newIsBLessHi);     res = Math.max(res, val);    }   }   dp[pos][isAGreaterLo][isALessHi][isBGreaterLo][isBLessHi] = res;   return res;  }  public void solve(int testNumber, InputReader in, OutputWriter out) {   lo = new int[63];   hi = new int[63];   long a = in.readLong();   long b = in.readLong();   Binary.convertBinary(a, lo);   Binary.convertBinary(b, hi);   posVal = new long[63];   posVal[62] = 1;   for (int i = 61; i >= 0; --i) {    posVal[i] = posVal[i + 1] * 2;   }   dp = new long[65][2][2][2][2];   for (long[][][][] a1 : dp) {    for (long[][][] a2 : a1) {     for (long[][] a3 : a2) {      for (long[] a4 : a3) {       Arrays.fill(a4, -1);      }     }    }   }   long res = go(0, 0, 0, 0, 0);   out.printLine(res);  } } class InputReader {  private InputStream stream;  private byte[] buf = new byte[1024];  private int curChar;  private int numChars;  public InputReader(InputStream stream) {   this.stream = stream;  }  public int read() {     if (numChars == -1)    throw new UnknownError();   if (curChar >= numChars) {    curChar = 0;    try {     numChars = stream.read(buf);    } catch (IOException e) {     throw new UnknownError();    }    if (numChars <= 0)     return -1;   }   return buf[curChar++];  }  public long readLong() {   int c = read();   while (isSpaceChar(c))    c = read();   int sgn = 1;   if (c == '-') {    sgn = -1;    c = read();   }   long res = 0;   do {    if (c < '0' || c > '9')     throw new InputMismatchException();    res *= 10;    res += c - '0';    c = read();   } while (!isSpaceChar(c));   return res * sgn;  }  public static boolean isSpaceChar(int c) {   return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;  }  } class OutputWriter {  private final PrintWriter writer;  public OutputWriter(OutputStream outputStream) {   writer = new PrintWriter(outputStream);  }  public OutputWriter(Writer writer) {   this.writer = new PrintWriter(writer);  }  public void print(Object...objects) {   for (int i = 0; i < objects.length; i++) {    if (i != 0)     writer.print(' ');    writer.print(objects[i]);   }  }  public void printLine(Object...objects) {   print(objects);   writer.println();  }  public void close() {   writer.close();  } } class Binary {  public static void convertBinary(long val, int[] a) {   int last = a.length - 1;   Arrays.fill(a, 0);   while (val > 0) {    a[last] = (int) (val % 2);    last--;    val /= 2;   }  } }
0,public class Main {  void solve(Scanner in, PrintWriter out) {  long a = in.nextLong();  out.println(25); } void run() {  Locale.setDefault(Locale.US);  try (   Scanner in = new Scanner(System.in);   PrintWriter out = new PrintWriter(System.out);  ) {  solve(in, out);  }  }  public static void main(String args[]) {  new Main().run(); } }
4,public class Main { static int m; static long pow(long b, int p) {  long ret = 1;  while (p > 0) {  if ((p&1) == 1) ret = b*ret%m;  b = b*b%m;  p >>= 1;  }  return ret; } public static void main(String[] args) throws IOException {  int n = readInt(); m = readInt();  long[] fac = new long[n + 1], pow2 = new long[n + 1];  long[][] C = new long[n + 1][n + 1], dp = new long[n + 1][n + 1];  fac[0] = pow2[0] = 1;  for (int i = 1; i <= n; ++i) {  fac[i] = i*fac[i - 1]%m;  pow2[i] = 2*pow2[i - 1]%m;  for (int j = 0; j <= i; ++j)   C[i][j] = fac[i]*(pow(fac[j], m - 2)*pow(fac[i - j], m - 2)%m)%m;  }  for (int i = 1; i <= n; ++i) {  dp[i][i] = pow2[i - 1];  for (int j = 0; j <= i; ++j)   for (int k = 1; i + k + 1 <= n; ++k)   dp[i + k + 1][j + k] = (dp[i + k + 1][j + k] + dp[i][j]*(C[j + k][k]*pow2[k - 1]%m))%m;  }  long ans = 0;  for (int i = 1; i <= n; ++i)  ans = (ans + dp[n][i])%m;  System.out.println(ans); } static BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); static StringTokenizer st; static String next() throws IOException {  while (st == null || !st.hasMoreTokens())  st = new StringTokenizer(br.readLine());  return st.nextToken(); } static int readInt() throws IOException {  return Integer.parseInt(next()); } }
6,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   Input in = new Input(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskE solver = new TaskE();   solver.solve(1, in, out);   out.close();  }  static class TaskE {   public void solve(int testNumber, Input in, PrintWriter out) {    try {     int kt = in.readInt();     for (int nt = 0; nt < kt; nt++) {      int n = in.readInt();      int m = in.readInt();      int[][] a = new int[m][n];      for (int i = 0; i < n; i++) {       for (int j = 0; j < m; j++) {        a[j][i] = in.readInt();       }      }      Arrays.sort(a, (x, y) -> {       int xMax = 0;       for (int i = 0; i < x.length; i++) {        xMax = Math.max(xMax, x[i]);       }       int yMax = 0;       for (int i = 0; i < y.length; i++) {        yMax = Math.max(yMax, y[i]);       }       return Integer.compare(-xMax, -yMax);      });      int ans = 0;      int[] s = new int[4];      for (s[0] = 0; s[0] < n; s[0]++) {       for (s[1] = 0; s[1] < n; s[1]++) {        for (s[2] = 0; s[2] < n; s[2]++) {         for (s[3] = 0; s[3] < n; s[3]++) {          int cur = 0;          for (int i = 0; i < n; i++) {           int max = 0;           for (int j = 0; j < Math.min(m, n); j++) {            max = Math.max(max, a[j][(i + s[j]) % n]);           }           cur += max;          }          ans = Math.max(cur, ans);         }        }       }      }      out.println(ans);     }    } catch (Exception e) {     throw new RuntimeException(e);    }   }  }  static class Input {   public final BufferedReader reader;   private String line = "";   private int pos = 0;   public Input(InputStream inputStream) {    reader = new BufferedReader(new InputStreamReader(inputStream));   }   private boolean isSpace(char ch) {    return ch <= 32;   }   public String readWord() throws IOException {    skip();    int start = pos;    while (pos < line.length() && !isSpace(line.charAt(pos))) {     pos++;    }    return line.substring(start, pos);   }   public int readInt() throws IOException {    return Integer.parseInt(readWord());   }   private void skip() throws IOException {    while (true) {     if (pos >= line.length()) {      line = reader.readLine();      pos = 0;     }     while (pos < line.length() && isSpace(line.charAt(pos))) {      pos++;     }     if (pos < line.length()) {      return;     }    }   }  } }
6,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   ScanReader in = new ScanReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   EKeyboardPurchase solver = new EKeyboardPurchase();   solver.solve(1, in, out);   out.close();  }  static class EKeyboardPurchase {   public void solve(int testNumber, ScanReader in, PrintWriter out) {    int n = in.scanInt();    int m = in.scanInt();    int step[][] = new int[m][m];    char arr[] = in.scanString().toCharArray();    for (int i = 0; i < n - 1; i++) {     step[arr[i] - 'a'][arr[i + 1] - 'a']++;     step[arr[i + 1] - 'a'][arr[i] - 'a']++;    }     int dp[] = new int[1 << m];    Arrays.fill(dp, Integer.MAX_VALUE / 2);    for (int i = 0; i < m; i++) dp[1 << i] = 0;    for (int i = 0; i < (1 << m); i++) {     int cost = 0;     for (int j = 0; j < m; j++) {      if (((i & (1 << j)) != 0)) {       for (int k = 0; k < m; k++) {        if (((i & (1 << k)) == 0)) {         cost += step[j][k];        }       }      }     }      for (int j = 0; j < m; j++)      if (((i & (1 << j)) == 0)) dp[i | (1 << j)] = Math.min(dp[i | (1 << j)], dp[i] + cost);     }     out.println(dp[(1 << m) - 1]);   }  }  static class ScanReader {   private byte[] buf = new byte[4 * 1024];   private int INDEX;   private BufferedInputStream in;   private int TOTAL;   public ScanReader(InputStream inputStream) {    in = new BufferedInputStream(inputStream);   }   private int scan() {    if (INDEX >= TOTAL) {     INDEX = 0;     try {      TOTAL = in.read(buf);     } catch (Exception e) {      e.printStackTrace();     }     if (TOTAL <= 0) return -1;    }    return buf[INDEX++];   }   public int scanInt() {    int I = 0;    int n = scan();    while (isWhiteSpace(n)) n = scan();    int neg = 1;    if (n == '-') {     neg = -1;     n = scan();    }    while (!isWhiteSpace(n)) {     if (n >= '0' && n <= '9') {      I *= 10;      I += n - '0';      n = scan();     }    }    return neg * I;   }   public String scanString() {    int c = scan();    while (isWhiteSpace(c)) c = scan();    StringBuilder RESULT = new StringBuilder();    do {     RESULT.appendCodePoint(c);     c = scan();    } while (!isWhiteSpace(c));    return RESULT.toString();   }   private boolean isWhiteSpace(int n) {    if (n == ' ' || n == '\n' || n == '\r' || n == '\t' || n == -1) return true;    else return false;   }  } }
4,public class e1515 {  public static void main(String[] args) {   Scanner s = new Scanner(System.in);   solve(s.nextInt(), s.nextLong());  }   public static long inv(long n, long mod) {   if (n == 1) return 1;   return (inv(mod % n, mod) * (mod - mod / n)) % mod;  }  public static void solve(int n, long mod) {   long fact[] = new long[n + 2];   long invFact[] = new long[n + 2];   long twoPow[] = new long[n + 2];   fact[0] = 1;   invFact[0] = 1;   twoPow[0] = 1;   for (int i = 1; i < n + 2; i++) {    fact[i] = (fact[i - 1] * i) % mod;    invFact[i] = (invFact[i - 1] * inv(i, mod)) % mod;    twoPow[i] = (2 * twoPow[i - 1]) % mod;   }   long dp[][] = new long[n + 2][];   dp[0] = new long[]{1};   long next[] = null;   for (int i = 1; i <= n + 1; i++) {    next = new long[i + 1];    for (int j = 0; j < i - 1; j++) {     for (int k = 0; k < dp[j].length; k++) {      next[k + i - j - 1] = (next[k + i - j - 1] + ((((dp[j][k] * twoPow[i - j - 2]) % mod * fact[k + i - j - 1]) % mod * invFact[k]) % mod * invFact[i - j - 1]) % mod) % mod;     }    }    dp[i] = next;   }   long sum = 0;   for (int i = 0; i < next.length; i++) {    sum = (sum + next[i]) % mod;   }   System.out.println(sum);  } }
5,public class A { static class T {  public int s,p; } public static void main(String args[]) throws Exception {  InputReader sc=new InputReader(System.in);  int n=sc.readInt(),k=sc.readInt(),i,j,z;  T m[]=new T[n];  for(i=0;i<n;i++) {m[i]=new T();m[i].s=sc.readInt();m[i].p=sc.readInt();}  for(i=0;i<n;i++) for(j=i+1;j<n;j++) if(m[i].s<m[j].s){z=m[i].s;m[i].s=m[j].s;m[j].s=z;z=m[i].p;m[i].p=m[j].p;m[j].p=z;}  for(i=0;i<n;i++) for(j=i+1;j<n;j++) if(m[i].s==m[j].s&&m[i].p>m[j].p){z=m[i].s;m[i].s=m[j].s;m[j].s=z;z=m[i].p;m[i].p=m[j].p;m[j].p=z;}  k--;int s=m[k].s,p=m[k].p,res=0;  for(i=0;i<n;i++){if(m[i].s==s&&m[i].p==p)res++;}  System.out.println(res); } } class InputReader { private boolean finished = false; private InputStream stream; private byte[] buf = new byte[1024]; private int curChar; private int numChars;  public InputReader(InputStream stream) {  this.stream = stream; }  public int read() {  if (numChars == -1)  throw new InputMismatchException();  if (curChar >= numChars) {  curChar = 0;  try {   numChars = stream.read(buf);  } catch (IOException e) {   throw new InputMismatchException();  }  if (numChars <= 0)   return -1;  }  return buf[curChar++]; }  public int peek() {  if (numChars == -1)  return -1;  if (curChar >= numChars) {  curChar = 0;  try {   numChars = stream.read(buf);  } catch (IOException e) {   return -1;  }  if (numChars <= 0)   return -1;  }  return buf[curChar]; }  public int readInt() {  int c = read();  while (isSpaceChar(c))  c = read();  int sgn = 1;  if (c == '-') {  sgn = -1;  c = read();  }  int res = 0;  do {  if (c < '0' || c > '9')   throw new InputMismatchException();  res *= 10;  res += c - '0';  c = read();  } while (!isSpaceChar(c));  return res * sgn; }  public long readLong() {  int c = read();  while (isSpaceChar(c))  c = read();  int sgn = 1;  if (c == '-') {  sgn = -1;  c = read();  }  long res = 0;  do {  if (c < '0' || c > '9')   throw new InputMismatchException();  res *= 10;  res += c - '0';  c = read();  } while (!isSpaceChar(c));  return res * sgn; }  public String readString() {  int c = read();  while (isSpaceChar(c))  c = read();  StringBuffer res = new StringBuffer();  do {  res.appendCodePoint(c);  c = read();  } while (!isSpaceChar(c));  return res.toString(); }  private boolean isSpaceChar(int c) {  return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; }  private String readLine0() {  StringBuffer buf = new StringBuffer();  int c = read();  while (c != '\n' && c != -1) {  if (c != '\r')   buf.appendCodePoint(c);  c = read();  }  return buf.toString(); }  public String readLine() {  String s = readLine0();  while (s.trim().length() == 0)  s = readLine0();  return s; }  public String readLine(boolean ignoreEmptyLines) {  if (ignoreEmptyLines)  return readLine();  else  return readLine0(); }  public char readCharacter() {  int c = read();  while (isSpaceChar(c))  c = read();  return (char) c; }  public double readDouble() {  int c = read();  while (isSpaceChar(c))  c = read();  int sgn = 1;  if (c == '-') {  sgn = -1;  c = read();  }  double res = 0;  while (!isSpaceChar(c) && c != '.') {  if (c == 'e' || c == 'E')   return res * Math.pow(10, readInt());  if (c < '0' || c > '9')   throw new InputMismatchException();  res *= 10;  res += c - '0';  c = read();  }  if (c == '.') {  c = read();  double m = 1;  while (!isSpaceChar(c)) {   if (c == 'e' || c == 'E')   return res * Math.pow(10, readInt());   if (c < '0' || c > '9')   throw new InputMismatchException();   m /= 10;   res += (c - '0') * m;   c = read();  }  }  return res * sgn; }  public boolean isExhausted() {  int value;  while (isSpaceChar(value = peek()) && value != -1)  read();  return value == -1; }  public String next() {  return readString(); } }
2,public class A {  public static void main(String[] args) throws IOException {  Scanner sc = new Scanner();  PrintWriter out = new PrintWriter(System.out);  int n=sc.nextInt(),k=sc.nextInt();  for(int x=0;;x++) {  if(2*1L*x+x*1L*(x+1)==2L*(k+n)) {   out.println(n-x);   break;  }  }  out.close();  }  static class Scanner {  BufferedReader br;  StringTokenizer st;  Scanner() {  br = new BufferedReader(new InputStreamReader(System.in));  }  Scanner(String fileName) throws FileNotFoundException {  br = new BufferedReader(new FileReader(fileName));  }  String next() throws IOException {  while (st == null || !st.hasMoreTokens())   st = new StringTokenizer(br.readLine());  return st.nextToken();  }  String nextLine() throws IOException {  return br.readLine();  }  int nextInt() throws IOException {  return Integer.parseInt(next());  }  long nextLong() throws NumberFormatException, IOException {  return Long.parseLong(next());  }  double nextDouble() throws NumberFormatException, IOException {  return Double.parseDouble(next());  }  boolean ready() throws IOException {  return br.ready();  }  } }
6,public class C { InputStream is; PrintWriter out; String INPUT = "";  void solve() {  int x = ni(), y = ni();  int n = ni();  int[][] co = new int[n][];  for(int i = 0;i < n;i++){  co[i] = new int[]{ni()-x, ni()-y};  }   int[] c1 = new int[n];  int[][] c2 = new int[n][n];  for(int i = 0;i < n;i++){  c1[i] = (co[i][0]*co[i][0]+co[i][1]*co[i][1])*2;  }  for(int i = 0;i < n;i++){  for(int j = i+1;j < n;j++){   c2[i][j] = c2[j][i] = (co[i][0]*co[i][0]+co[i][1]*co[i][1])+(co[j][0]*co[j][0]+co[j][1]*co[j][1])+(co[j][0]-co[i][0])*(co[j][0]-co[i][0])+(co[j][1]-co[i][1])*(co[j][1]-co[i][1]);  }  }   int[] dp = new int[1<<n];  int[] prev = new int[1<<n];  prev[0] = -1;  for(int i = 1;i < 1<<n;i++){  int a = Integer.numberOfTrailingZeros(i);  dp[i] = c1[a] + dp[i^1<<a];  prev[i] = 1<<a;  for(int j = a+1;j < n;j++){   if(i<<31-j<0){   int v = dp[i^1<<a^1<<j] + c2[a][j];   if(v < dp[i]){    dp[i] = v;    prev[i] = 1<<a^1<<j;   }   }  }  }  out.println(dp[(1<<n)-1]);  int cur = (1<<n)-1;  out.print("0");  while(true){  int targ;  if(prev[cur] == -1){   targ = cur;  }else{   targ = prev[cur];   cur ^= prev[cur];  }  int a = Integer.numberOfTrailingZeros(targ);  int b = Integer.numberOfTrailingZeros(targ&targ-1);  if(targ == 1<<a){   out.print(" " + (a+1));  }else{   out.print(" " + (a+1));   out.print(" " + (b+1));  }  out.print(" 0");  if(cur == 0)break;  }  out.println(); }  void run() throws Exception {        is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());  out = new PrintWriter(System.out);   long s = System.currentTimeMillis();  solve();  out.flush();  tr(System.currentTimeMillis()-s+"ms"); }  public static void main(String[] args) throws Exception {  new C().run(); }  public int ni() {  try {  int num = 0;  boolean minus = false;  while((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));  if(num == '-'){   num = 0;   minus = true;  }else{   num -= '0';  }    while(true){   int b = is.read();   if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');   }else{   return minus ? -num : num;   }  }  } catch (IOException e) {  }  return -1; }  public long nl() {  try {  long num = 0;  boolean minus = false;  while((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));  if(num == '-'){   num = 0;   minus = true;  }else{   num -= '0';  }    while(true){   int b = is.read();   if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');   }else{   return minus ? -num : num;   }  }  } catch (IOException e) {  }  return -1; }  public String ns() {  try{  int b = 0;  StringBuilder sb = new StringBuilder();  while((b = is.read()) != -1 && (b == '\r' || b == '\n' || b == ' '));  if(b == -1)return "";  sb.append((char)b);  while(true){   b = is.read();   if(b == -1)return sb.toString();   if(b == '\r' || b == '\n' || b == ' ')return sb.toString();   sb.append((char)b);  }  } catch (IOException e) {  }  return ""; }  public char[] ns(int n) {  char[] buf = new char[n];  try{  int b = 0, p = 0;  while((b = is.read()) != -1 && (b == ' ' || b == '\r' || b == '\n'));  if(b == -1)return null;  buf[p++] = (char)b;  while(p < n){   b = is.read();   if(b == -1 || b == ' ' || b == '\r' || b == '\n')break;   buf[p++] = (char)b;  }  return Arrays.copyOf(buf, p);  } catch (IOException e) {  }  return null; }   double nd() { return Double.parseDouble(ns()); } boolean oj = System.getProperty("ONLINE_JUDGE") != null; void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); } }
0,public class A483 implements Runnable {  BufferedReader in; PrintWriter out; StringTokenizer tok = new StringTokenizer("");  public static void main(String[] args) {  new Thread(null, new A483(), "", 256 * (1L << 20)).start(); }  public void run() {  try {  long t1 = System.currentTimeMillis();  if (System.getProperty("ONLINE_JUDGE") != null) {   in = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);  } else {   in = new BufferedReader(new FileReader("input.txt"));   out = new PrintWriter(System.out);  }  Locale.setDefault(Locale.US);  solve();  in.close();  out.close();  long t2 = System.currentTimeMillis();  System.err.println("Time = " + (t2 - t1));  } catch (Throwable t) {  t.printStackTrace(System.err);  System.exit(-1);  } }  String readString() throws IOException {  while (!tok.hasMoreTokens()) {  tok = new StringTokenizer(in.readLine());  }  return tok.nextToken(); }  int readInt() throws IOException {  return Integer.parseInt(readString()); }  long readLong() throws IOException {  return Long.parseLong(readString()); }  double readDouble() throws IOException {  return Double.parseDouble(readString()); }   int choose(int total, int choose){  if(total < choose)   return 0;  if(choose == 0 || choose == total)   return 1;  return choose(total-1,choose-1)+choose(total-1,choose); } void solve() throws IOException {  long l = readLong();  long r = readLong();  if(r-l>=3){  long c = l%2==0?l:l+1;  out.println(c+" "+(c+1)+" "+ (c+2));  }else if(r-l==2&&r%2==0){  out.println(l+" "+(l+1)+" "+(l+2));  }else{  out.println(-1);  } } }
1,public class Main{   public static void main(String[] args) {  Parser p = new Parser(System.in);  PrintWriter pw= new PrintWriter(System.out);  int n = p.nextInt();  int k = p.nextInt();  int[] a = p.nextIntArray(n);  int [] pos = new int[100001];  Arrays.fill(pos,-1);  int cnt = 0;  for(int i=0; i<n; ++i){  int e = a[i];  if( pos[e] == -1 ){   ++cnt;  }  pos[e] = i;  if( cnt == k){   break;  }  }  if( cnt < k){  pw.println("-1 -1");  pw.close();  return;  }  int min = 1000000;  int max = -1;  for(int i=0; i<100001; ++i){  if(pos[i] != -1 && pos[i] < min ){   min = pos[i];  }  if( pos[i] > max){   max = pos[i];  }  }  ++min;  ++max;  pw.println(min+" "+max);  pw.close(); }      static class Parser{   StringTokenizer st;  BufferedReader br;  public Parser(InputStream is){  this.br = new BufferedReader( new InputStreamReader(is));    }   public int nextInt(){  return Integer.parseInt(nextToken());  }   public double nextDouble(){  return Double.parseDouble(nextToken());  }   public String nextString(){  return nextToken();  }   public int[] nextIntArray(int s){  int[] a = new int[s];  for(int i=0; i<s; ++i){   a[i] = nextInt();  }  return a;  }   public int[][] nextIntTable(int r, int c){  int[][] a = new int[r][c];  for(int i=0; i<r; ++i){   a[i] = nextIntArray(c);  }  return a;  }   private String nextToken() {  if( st == null || ! st.hasMoreTokens() ){   try{   st = new StringTokenizer( br.readLine());   }catch( Exception e){   e.printStackTrace();   }  }  return st.nextToken();  }   } }
3,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   Scanner in = new Scanner(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskC solver = new TaskC();   solver.solve(1, in, out);   out.close();  }  static class TaskC {   private static final int MOD = (int) 1e9 + 7;   private static final int N = 5000;   public void solve(int testNumber, Scanner in, PrintWriter out) {    int n = in.nextInt();    int[] dp = new int[N];    Arrays.fill(dp, 0);    dp[0] = 1;    String pre = null, ch;    for (int i = 0; i < n; ++i) {     ch = in.next();     if (i > 0) {      if (pre.equals("s")) {       int j = N - 1;       while (dp[j] == 0) {        --j;       }       long sum = 0;       for (; j >= 0; --j) {        sum += dp[j];        sum %= MOD;        dp[j] = (int) sum;       }      } else {       for (int k = N - 1; k > 0; --k) {        dp[k] = dp[k - 1];       }       dp[0] = 0;      }     }     pre = ch;    }    long sum = 0;    for (int i = 0; i < N; ++i) {     sum += dp[i];     sum %= MOD;    }    out.println(sum);   }  } }
2,public class C {  public static void main(String[] args) {  new C(); }  C() {   Scanner in = new Scanner(System.in);   long n = in.nextLong(), s = in.nextLong();  long lo = 1, hi = 1000000000000000000L;   while(lo<hi){      long mid = (lo+hi)/2;  if(reallyBig(mid,s))   hi = mid;  else   lo = mid+1;  }     if(!reallyBig(lo,s))  System.out.println(0);  else  System.out.println(Math.max(n-lo+1,0));      in.close();  }  boolean reallyBig(long n, long s){  int sum = 0;  long temp = n;  while(temp>0){  sum += temp%10;  temp/=10;  }  return n-sum>=s; }  }
6,public class E {  PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));  BufferedReader in = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer tok;  public void go() throws IOException  {   StringTokenizer tok = new StringTokenizer(in.readLine());   int zzz = Integer.parseInt(tok.nextToken());   for (int zz = 0; zz < zzz; zz++)   {    ntok();    int n = ipar();    int m = ipar();    int[][] mat = new int[n][m];    for (int i = 0; i < n; i++)    {     ntok();     mat[i] = iapar(m);    }    long[][] dp = new long[1 << n][m+1];    for (int i = 0; i < 1 << n; i++)    {     dp[i][m] = -1000000000;    }    dp[(1 << n) - 1][m] = 0;    for (int i = m-1; i >= 0; i--)    {     for (int e = 0; e < 1 << n; e++)     {      dp[e][i] = dp[e][i+1];      for (int w = 0; w < 1 << n; w++)      {       if ((e & w) == 0)       {        dp[e][i] = Math.max(dp[e][i], best(w, mat, i) + dp[e|w][i+1]);       }      }     }    }                  out.println(dp[0][0]);   }   out.flush();   in.close();  }  public long best(int mask, int[][] mat, int col)  {   long max = 0;   for (int t = 0; t < mat.length; t++)   {    long sum = 0;    int mk = mask;    for (int i = 0; i < mat.length; i++)    {     if (mk % 2 == 1)     {      sum += mat[i][col];     }     mk /= 2;    }    max = Math.max(max, sum);    cycle(mat, col);   }   return max;  }  public void cycle(int[][] mat, int col)  {   int temp = mat[0][col];   for (int i = 0; i < mat.length-1; i++)   {    mat[i][col] = mat[i+1][col];   }   mat[mat.length-1][col] = temp;  }  public void ntok() throws IOException  {   tok = new StringTokenizer(in.readLine());  }  public int ipar()  {   return Integer.parseInt(tok.nextToken());  }  public int[] iapar(int n)  {   int[] arr = new int[n];   for (int i = 0; i < n; i++)   {    arr[i] = ipar();   }   return arr;  }  public long lpar()  {   return Long.parseLong(tok.nextToken());  }  public long[] lapar(int n)  {   long[] arr = new long[n];   for (int i = 0; i < n; i++)   {    arr[i] = lpar();   }   return arr;  }  public double dpar()  {   return Double.parseDouble(tok.nextToken());  }  public String spar()  {   return tok.nextToken();  }  public static void main(String[] args) throws IOException  {   new E().go();  } }
6,public class Main {  static double arr[][];  public static void main(String[] args)  {   try   {    Parserdoubt pd=new Parserdoubt(System.in);    PrintWriter pw=new PrintWriter(System.out);    int fishes=pd.nextInt();    arr=new double[fishes][fishes];    for(int i=0;i<fishes;i++)     for(int j=0;j<fishes;j++)      arr[i][j]=Double.parseDouble(pd.nextString());    double dp[]=new double[(1<<fishes)];    dp[dp.length-1]=1.0;    for(int c=dp.length-1;c>=0;c--)    {         if((c&(c-1))==0)      continue;     for(int i=0;i<fishes;i++)      for(int j=i+1;j<fishes;j++)      {       if(((1<<i)&c)!=0&&((1<<j)&c)!=0)       {        dp[c&~(1<<j)]+=arr[i][j]*dp[c];        dp[c&~(1<<i)]+=arr[j][i]*dp[c];       }      }    }    double s=0.0;    for(int i=0;i<fishes;i++)     s+=dp[1<<i];    for(int i=0;i<fishes;i++)     dp[1<<i]/=s;    int i=0;    for(i=0;i<fishes-1;i++)     pw.printf("%.6f ",dp[1<<i]);    pw.printf("%.6f\n",dp[1<<i]);    pw.close();   }   catch(Exception e)   {}  } } class Parserdoubt  {   final private int BUFFER_SIZE = 1 << 17;   private DataInputStream din;   private byte[] buffer;   private int bufferPointer, bytesRead;   public Parserdoubt(InputStream in)   {   din = new DataInputStream(in);   buffer = new byte[BUFFER_SIZE];   bufferPointer = bytesRead = 0;   }   public String nextString() throws Exception   {    StringBuffer sb=new StringBuffer("");    byte c = read();    while (c <= ' ') c = read();    do    {     sb.append((char)c);     c=read();    }while(c>' ');    return sb.toString();   }   public char nextChar() throws Exception   {    byte c=read();    while(c<=' ') c= read();    return (char)c;   }   public int nextInt() throws Exception   {   int ret = 0;   byte c = read();   while (c <= ' ') c = read();   boolean neg = c == '-';   if (neg) c = read();   do   {    ret = ret * 10 + c - '0';    c = read();   } while (c > ' ');   if (neg) return -ret;   return ret;   }   public long nextLong() throws Exception   {   long ret = 0;   byte c = read();   while (c <= ' ') c = read();   boolean neg = c == '-';   if (neg) c = read();   do   {    ret = ret * 10 + c - '0';    c = read();   } while (c > ' ');   if (neg) return -ret;   return ret;   }   private void fillBuffer() throws Exception   {   bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);   if (bytesRead == -1) buffer[0] = -1;   }   private byte read() throws Exception   {   if (bufferPointer == bytesRead) fillBuffer();   return buffer[bufferPointer++];   }  }
2,public class Main {  public static void main(String[] args) throws IOException {   new Main().run();  }  StreamTokenizer in;  PrintWriter out;   public static void deb(String n, Object n1) {   System.out.println(n + " is : " + n1);  }  public static void deb(int[] A) {   for (Object oo : A) {    System.out.print(oo + " ");   }   System.out.println("");  }  public static void deb(boolean[] A) {   for (Object oo : A) {    System.out.print(oo + " ");   }   System.out.println("");  }  public static void deb(double[] A) {   for (Object oo : A) {    System.out.print(oo + " ");   }   System.out.println("");  }  public static void deb(String[] A) {   for (Object oo : A) {    System.out.print(oo + " ");   }   System.out.println("");  }  public static void deb(int[][] A) {   for (int i = 0; i < A.length; i++) {    for (Object oo : A[i]) {     System.out.print(oo + " ");    }    System.out.println("");   }  }  public static void deb(double[][] A) {   for (int i = 0; i < A.length; i++) {    for (Object oo : A[i]) {     System.out.print(oo + " ");    }    System.out.println("");   }  }  public static void deb(long[][] A) {   for (int i = 0; i < A.length; i++) {    for (Object oo : A[i]) {     System.out.print(oo + " ");    }    System.out.println("");   }  }  public static void deb(String[][] A) {   for (int i = 0; i < A.length; i++) {    for (Object oo : A[i]) {     System.out.print(oo + " ");    }    System.out.println("");   }  }    int nextInt() throws IOException {   in.nextToken();   return (int) in.nval;  }  long nextLong() throws IOException {   in.nextToken();   return (long) in.nval;  }  void run() throws IOException {      in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));   out = new PrintWriter(new OutputStreamWriter(System.out));   solve();   out.flush();  }   @SuppressWarnings("unchecked")  void solve() throws IOException {      BufferedReader re= new BufferedReader(new InputStreamReader(System.in));  Scanner sc= new Scanner(System.in);  long n=sc.nextLong(),k=sc.nextLong();  if(k*(k-1)/2<n-1)    System.out.println("-1");  else{  long ff=k*(k-1)/2;  ff=-2*(n-1-ff);    long up=k,dw=0;  while(up-dw>1){  long c=(up+dw)/2;  if(c*(c-1)<=ff)dw=c;  else up=c;   }  if(n==1)  { System.out.println("0");  return;  }   System.out.println(k-dw);  }  } }
2,public class ProblemB {  BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));  PrintWriter writer = new PrintWriter(new OutputStreamWriter(System.out));  long[] readInts() throws IOException {   String[] strings = reader.readLine().split(" ");   long[] ints = new long[strings.length];   for(int i = 0; i < ints.length; i++) {    ints[i] = Long.parseLong(strings[i]);   }   return ints;  }  long foo(long a) {   return a > 0 ? a * a : 0;  }  long boo(long a) {   return a <= 0 ? 0 : a * (a + 1) / 2;  }  void solve() throws IOException {   long[] tt = readInts();   long n = tt[0];   long x = tt[1];   long y = tt[2];   long c = tt[3];   long lo = -1, hi = 2 * 1000 * 1000 * 1000 + 2;   while(hi - lo > 1) {    long m = (lo + hi) / 2;    long s = 2 * m * m + 2 * m + 1;    s -= foo(m - x + 1) + foo(m - y + 1) + foo(x + m - n) + foo(y + m - n);    s += boo(m + 1 - (n + 1 + n + 1 - x - y)) + boo(m + 1 - (n + 1 - x + y)) + boo(m + 1 - (n + 1 - y + x))      + boo(m + 1 - (x + y));    if(s < c) lo = m;    else hi = m;   }   writer.println(hi);   writer.flush();  }  public static void main(String[] args) throws IOException{   new ProblemB().solve();  } }
4,public class A {  public static void main(String[] args){   try{    Scanner scanner = new Scanner(System.in);    String in = scanner.next();    int max = 0;    for(int j=0;j<in.length()-1;j++){     for(int i=j;i<in.length();i++){      if(in.indexOf(in.substring(j, i)) != in.lastIndexOf(in.substring(j, i)) && (i-j)>max){       max = i-j;      }     }    }    System.out.println(max);   }catch(Exception e){    e.printStackTrace();   }  } }
3,public class G {  static final int P = 1_000_000_007;  int[][] ways; int[][] pow;  void preCalc(int sz) {  ways = new int[sz][];  for (int i = 0; i < ways.length; i++) {  ways[i] = new int[i + 1];  ways[i][0] = ways[i][i] = 1;  for (int j = 1; j < i; j++) {   ways[i][j] = (ways[i - 1][j] + ways[i - 1][j - 1]) % P;  }  }  pow = new int[10][sz];  pow[0] = null;  for (int i = 1; i <= 9; i++) {  pow[i][0] = 1;  for (int j = 1; j < sz; j++) {   pow[i][j] = (int) ((long) pow[i][j - 1] * i % P);  }  } }  int solve(String ss) {  int n = ss.length();  int[] s = new int[n];  for (int i = 0; i < n; i++) {  s[i] = ss.charAt(i) - '0';  }  preCalc(n + 10);  int[] ans = new int[n + 1];  int[] cnt = new int[10];  for (int i = 0; i < n; i++) {   int rest = n - i - 1;   int dig = s[i];   for (int j = 0; j <= (i == n - 1 ? dig : dig - 1); j++) {   cnt[j]++;    for (int use = 1; use < 10; use++) {      for (int cntGood = 0; cntGood <= rest; cntGood++) {    int delta = (int) ((long) ways[rest][cntGood]     * pow[use][rest - cntGood] % P     * pow[10 - use][cntGood] % P);    int idx = cnt[use] + cntGood;    ans[idx] += delta;    if (ans[idx] >= P) {    ans[idx] -= P;    }   }   }      }   cnt[dig]++;  }   int ret = 0;  long mult = 0;  for (int i = 1; i < ans.length; i++) {  mult = (10L * mult + 1) % P;  ret += (int)(mult * ans[i] % P);  if (ret >= P) {   ret -= P;  }  }   return ret; }  void submit() {  out.println(solve(nextToken())); }  void stress() {  }  void test() {  StringBuilder sb = new StringBuilder("1");  for (int i = 0; i < 700; i++) {  sb.append('0');  }  solve(sb.toString()); }  G() throws IOException {  br = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);  submit();    out.close(); }  static final Random rng = new Random();  static int rand(int l, int r) {  return l + rng.nextInt(r - l + 1); }  public static void main(String[] args) throws IOException {  new G(); }  BufferedReader br; PrintWriter out; StringTokenizer st;  String nextToken() {  while (st == null || !st.hasMoreTokens()) {  try {   st = new StringTokenizer(br.readLine());  } catch (IOException e) {   throw new RuntimeException(e);  }  }  return st.nextToken(); }  String nextString() {  try {  return br.readLine();  } catch (IOException e) {  throw new RuntimeException(e);  } }  int nextInt() {  return Integer.parseInt(nextToken()); }  long nextLong() {  return Long.parseLong(nextToken()); }  double nextDouble() {  return Double.parseDouble(nextToken()); } }
4,public class ExplorerSpace {  static int n;  static int m;  static int k;  static int [][] rows;  static int [][] cols;  static int max;  static int orix;  static int oriy;  static int [][] dirs = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};  static int [][][][][] mem;  public static void main(String[] args) {   FastScanner fs = new FastScanner();   n = fs.nextInt();   m =fs.nextInt();   k = fs.nextInt();   rows = new int[n][m-1];   cols = new int[n-1][m];   for(int i = 0; i < n; i++){    for(int j = 0; j < m-1; j++){     rows[i][j] = fs.nextInt();    }   }   for(int i = 0; i < n-1; i++){    for(int j = 0; j < m; j++){     cols[i][j] = fs.nextInt();    }   }   int [][][] res = new int[100][n][m];   for(int o = 2; o <= k; o+=2){    for(int i = 0; i < n; i++){     for(int j = 0; j < m; j++){      res[o][i][j] = 0x3f3f3f3f;      if(i>0){       res[o][i][j] = Math.min(res[o][i][j], res[o-2][i-1][j] + 2*cols[i-1][j]);      }      if(i+1<n){       res[o][i][j] = Math.min(res[o][i][j], res[o-2][i+1][j] + 2 * cols[i][j]);      }      if(j>0){       res[o][i][j] = Math.min(res[o][i][j], res[o-2][i][j-1] + 2 * rows[i][j-1]);      }      if(j+1<m){       res[o][i][j] = Math.min(res[o][i][j], res[o-2][i][j+1] + 2 * rows[i][j]);      }     }    }   }   for(int i = 0; i < n; i++){    for(int j = 0; j < m;j ++){     if(k%2==1){      System.out.print(-1+" ");     }else{      System.out.print(res[k][i][j] + " ");     }    }    System.out.println();   }  }                static class FastScanner{   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));   StringTokenizer st = new StringTokenizer("");   String next(){    while (!st.hasMoreTokens()){     try {      st = new StringTokenizer(br.readLine());     }catch (IOException e){      e.printStackTrace();     }    }    return st.nextToken();   }   int nextInt(){    return Integer.parseInt(next());   }   long nextLong(){    return Long.parseLong(next());   }  } }
2,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  OutputWriter out = new OutputWriter(outputStream);  TaskB solver = new TaskB();  solver.solve(1, in, out);  out.close(); } } class TaskB { public void solve(int testNumber, InputReader in, OutputWriter out) {  int side = in.readInt();  int row = in.readInt() - 1;  int column = in.readInt() - 1;  int required = in.readInt();  long left = 0;  long right = 2 * side - 2;  while (left < right) {  long current = (left + right) / 2;  long result = calculate(row, column, current) + calculate(column, side - row - 1, current) +   calculate(side - row - 1, side - column - 1, current) + calculate(side - column - 1, row, current) + 1;  if (result >= required)   right = current;  else   left = current + 1;  }  out.printLine(left); }  private long calculate(int row, int column, long current) {  column++;  long total = 0;  long mn = Math.min(row, column);  long mx = Math.max(row, column);  if (current <= mn)  return current * (current + 1) / 2;  total += mn * (mn + 1) / 2;  current -= mn;  mx -= mn;  if (current <= mx)  return total + mn * current;  total += mn * mx;  current -= mx;  if (current < mn)  return total + (mn - 1) * mn / 2 - (mn - current - 1) * (mn - current) / 2;  return total + (mn - 1) * mn / 2; } } class InputReader {  private InputStream stream; private byte[] buf = new byte[1024]; private int curChar; private int numChars; private SpaceCharFilter filter;  public InputReader(InputStream stream) {  this.stream = stream; }  public int read() {  if (numChars == -1)  throw new InputMismatchException();  if (curChar >= numChars) {  curChar = 0;  try {   numChars = stream.read(buf);  } catch (IOException e) {   throw new InputMismatchException();  }  if (numChars <= 0)   return -1;  }  return buf[curChar++]; }  public int readInt() {  int c = read();  while (isSpaceChar(c))  c = read();  int sgn = 1;  if (c == '-') {  sgn = -1;  c = read();  }  int res = 0;  do {  if (c < '0' || c > '9')   throw new InputMismatchException();  res *= 10;  res += c - '0';  c = read();  } while (!isSpaceChar(c));  return res * sgn; }  public boolean isSpaceChar(int c) {  if (filter != null)  return filter.isSpaceChar(c);  return isWhitespace(c); }  public static boolean isWhitespace(int c) {  return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; }  public interface SpaceCharFilter {  public boolean isSpaceChar(int ch); } } class OutputWriter { private final PrintWriter writer;  public OutputWriter(OutputStream outputStream) {  writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream))); }  public OutputWriter(Writer writer) {  this.writer = new PrintWriter(writer); }  public void print(Object...objects) {  for (int i = 0; i < objects.length; i++) {  if (i != 0)   writer.print(' ');  writer.print(objects[i]);  } }  public void printLine(Object...objects) {  print(objects);  writer.println(); }  public void close() {  writer.close(); }  }
0,public class CF125D2A {    public static void main(String[] args) {   Scanner sc = new Scanner (System.in);   System.out.println("0 0 "+ sc.nextInt());  } }
0,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  OutputWriter out = new OutputWriter(outputStream);  TaskA solver = new TaskA();  solver.solve(1, in, out);  out.close(); } } class TaskA {  public long recurse(long a, long b) {   if (b <= 1) return a;   return Math.max(a, b)/Math.min(a,b) + recurse(Math.max(a, b) - Math.min(a, b)*(Math.max(a,b)/Math.min(a, b)), Math.min(a, b));  }  public void solve(int testNumber, InputReader in, OutputWriter out) {   long a = in.readLong(), b = in.readLong(), i = 0;          out.print(recurse(a, b));  } } class InputReader { private InputStream stream; private byte[] buf = new byte[1024]; private int curChar; private int numChars; private SpaceCharFilter filter;  public InputReader(InputStream stream) {  this.stream = stream; }  public int read() {  if (numChars == -1)  throw new InputMismatchException();  if (curChar >= numChars) {  curChar = 0;  try {   numChars = stream.read(buf);  } catch (IOException e) {   throw new InputMismatchException();  }  if (numChars <= 0)   return -1;  }  return buf[curChar++]; } public long readLong() {  int c = read();  while (isSpaceChar(c))  c = read();  int sgn = 1;  if (c == '-') {  sgn = -1;  c = read();  }  long res = 0;  do {  if (c < '0' || c > '9')   throw new InputMismatchException();  res *= 10;  res += c - '0';  c = read();  } while (!isSpaceChar(c));  return res * sgn; } public boolean isSpaceChar(int c) {  if (filter != null)  return filter.isSpaceChar(c);  return isWhitespace(c); }  public static boolean isWhitespace(int c) {  return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; } public interface SpaceCharFilter {  public boolean isSpaceChar(int ch); } } class OutputWriter { private final PrintWriter writer;  public OutputWriter(OutputStream outputStream) {  writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream))); } public void close() {  writer.close(); } public void print(long i) {  writer.print(i); } }
4,public class D { public static void main(String [] args) {  Scanner in = new Scanner(System.in);  int n = in.nextInt();  int m = in.nextInt();  boolean [][] graph = new boolean[n][n];  for(int i = 0 ; i < m ; i++)  {  int a = in.nextInt() - 1;  int b = in.nextInt() - 1;   graph[a][b] = true;  }  int res = Integer.MAX_VALUE;  for(int center = 0 ; center < n ; center++)  {  int calc = 0;  for(int i = 0 ; i < n ; i++)  {   if(!graph[center][i])   calc++;   if(!graph[i][center])   calc++;  }   if(!graph[center][center])   calc--;   int [] match = new int[n];  Arrays.fill(match, -1);  int max = 0;   for(int i = 0 ; i < n ; i++)   if(i != center)   if(can(i, graph, new boolean[n], center, match))    max++;   int unusable = m - (2*n - 1 - calc) - max;  calc += unusable;  calc += (2*(n-1) - 2*max)/2;   res = Math.min(res, calc);  }  System.out.println(res);  }  private static boolean can(int at, boolean[][] graph, boolean[] visited, int center, int [] match) {  if(visited[at])  return false;  visited[at] = true;  for(int to = 0 ; to < graph.length ; to++)  if(graph[at][to])   if(to != center)   if(match[to] == -1 || can(match[to], graph, visited, center, match))   {    match[to] = at;    return true;   }  return false; } }
4,public class Main { static int n, m, k; static int[][] horW, verW; static int[][][] dp = new int[505][505][15];  public static void main(String[] args) throws IOException {  for (int i = 0; i < 505; i++) {  for (int j = 0; j < 505; j++) {   for (int k = 0; k < 15; k++) {   dp[i][j][k] = -1;   }  }  }  n = in.iscan(); m = in.iscan(); k =in.iscan();  horW = new int[n+1][m]; verW = new int[n][m+1];  for (int i = 1; i <= n; i++) {  for (int j = 1; j <= m-1; j++) {   horW[i][j] = in.iscan();  }  }  for (int i = 1; i <= n-1; i++) {  for (int j = 1; j <= m; j++) {   verW[i][j] = in.iscan();  }  }  int min = Integer.MAX_VALUE;  for (int i = 1; i <= n; i++) {  for (int j = 1; j <= m; j++) {   if (k % 2 == 1) {   out.print(-1 + " ");   continue;   }   out.print(dfs(i, j, k/2) * 2 + " ");  }  out.println();  }  out.close(); }   static int dfs(int r, int c, int k) {  if (dp[r][c][k] != -1) {  return dp[r][c][k];  }  if (k == 0) {  return dp[r][c][k] = 0;  }  int min = Integer.MAX_VALUE;  if (r - 1 >= 1) {  min = Math.min(min, verW[r-1][c] + dfs(r-1, c, k-1));  }  if (r + 1 <= n) {  min = Math.min(min, verW[r][c] + dfs(r+1, c, k-1));  }  if (c - 1 >= 1) {  min = Math.min(min, horW[r][c-1] + dfs(r, c-1, k-1));  }  if (c + 1 <= m) {  min = Math.min(min, horW[r][c] + dfs(r, c+1, k-1));  }  return dp[r][c][k] = min; }  static INPUT in = new INPUT(System.in); static PrintWriter out = new PrintWriter(System.out); private static class INPUT {  private InputStream stream;  private byte[] buf = new byte[1024];  private int curChar, numChars;  public INPUT (InputStream stream) {  this.stream = stream;  }  public INPUT (String file) throws IOException {  this.stream = new FileInputStream (file);  }  public int cscan () throws IOException {  if (curChar >= numChars) {   curChar = 0;   numChars = stream.read (buf);  }    if (numChars == -1)   return numChars;   return buf[curChar++];  }  public int iscan () throws IOException {  int c = cscan (), sgn = 1;    while (space (c))   c = cscan ();   if (c == '-') {   sgn = -1;   c = cscan ();  }   int res = 0;   do {   res = (res << 1) + (res << 3);   res += c - '0';   c = cscan ();  }  while (!space (c));   return res * sgn;  }  public String sscan () throws IOException {  int c = cscan ();    while (space (c))   c = cscan ();   StringBuilder res = new StringBuilder ();   do {   res.appendCodePoint (c);   c = cscan ();  }  while (!space (c));   return res.toString ();  }  public double dscan () throws IOException {  int c = cscan (), sgn = 1;    while (space (c))   c = cscan ();   if (c == '-') {   sgn = -1;   c = cscan ();  }   double res = 0;   while (!space (c) && c != '.') {   if (c == 'e' || c == 'E')   return res * UTILITIES.fast_pow (10, iscan ());     res *= 10;   res += c - '0';   c = cscan ();  }   if (c == '.') {   c = cscan ();   double m = 1;   while (!space (c)) {   if (c == 'e' || c == 'E')    return res * UTILITIES.fast_pow (10, iscan ());    m /= 10;   res += (c - '0') * m;   c = cscan ();   }  }   return res * sgn;  }  public long lscan () throws IOException {  int c = cscan (), sgn = 1;    while (space (c))   c = cscan ();   if (c == '-') {   sgn = -1;   c = cscan ();  }   long res = 0;   do {   res = (res << 1) + (res << 3);   res += c - '0';   c = cscan ();  }  while (!space (c));   return res * sgn;  }  public boolean space (int c) {  return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;  } }  public static class UTILITIES {  static final double EPS = 10e-6;  public static int lower_bound (int[] arr, int x) {  int low = 0, high = arr.length, mid = -1;   while (low < high) {   mid = (low + high) / 2;   if (arr[mid] >= x)   high = mid;   else   low = mid + 1;  }   return low;  }  public static int upper_bound (int[] arr, int x) {  int low = 0, high = arr.length, mid = -1;   while (low < high) {   mid = (low + high) / 2;   if (arr[mid] > x)   high = mid;   else   low = mid + 1;  }   return low;  }  public static long gcd (long a, long b) {  return b == 0 ? a : gcd (b, a % b);  }  public static long lcm (long a, long b) {  return a * b / gcd (a, b);  }  public static long fast_pow_mod (long b, long x, int mod) {  if (x == 0) return 1;  if (x == 1) return b;  if (x % 2 == 0) return fast_pow_mod (b * b % mod, x / 2, mod) % mod;   return b * fast_pow_mod (b * b % mod, x / 2, mod) % mod;  }  public static int fast_pow (int b, int x) {  if (x == 0) return 1;  if (x == 1) return b;  if (x % 2 == 0) return fast_pow (b * b, x / 2);   return b * fast_pow (b * b, x / 2);  }  public static long choose (long n, long k) {  k = Math.min (k, n - k);  long val = 1;   for (int i = 0; i < k; ++i)   val = val * (n - i) / (i + 1);   return val;  }  public static long permute (int n, int k) {  if (n < k) return 0;  long val = 1;   for (int i = 0; i < k; ++i)   val = (val * (n - i));   return val;  } } }
5,public class A {   public static void main(String[] args) {  Scanner scan = new Scanner(System.in);  int n = scan.nextInt();  int k = scan.nextInt()-1;  team[] t = new team[n];  for(int i = 0 ;i < n ; i++)  t[i] = new team(scan.nextInt(), scan.nextInt());  Arrays.sort(t);  int a =0;  int b = 0;  while(k+a < t.length-1 && t[k+a+1].compareTo(t[k]) == 0)  a++;  while(k-b > 0 && t[k-b-1].compareTo(t[k]) == 0)  b++;  System.out.println(a+b+1); } } class team implements Comparable<team> { int p; int t; public team(int pp , int tt) {  p = pp;  t= tt; } @Override public String toString() {  return p+" "+t; } @Override public int compareTo(team e) {  int a = e.p-p;  if(a == 0)  {  return t-e.t;  }else  return a; } }
3,public class Main {  public static void main(String args[]) {   Scanner sc = new Scanner(System.in);   int n=sc.nextInt();   int arr[]=new int[n];   for (int i=0;i<n;i++){    arr[i]=sc.nextInt();   }   boolean vis[]=new boolean[n];   int c=0;   for (int i=0;i<n;i++){    int min=200;    for (int j=0;j<n;j++){     if (!vis[j] && min>arr[j]){      min=arr[j];     }    }    for (int j=0;j<n;j++){     if (!vis[j]&&arr[j]%min==0){      vis[j]=true;     }    }    if (min!=200){     c++;    }else break;   }   System.out.println(c);  } }
2,public class Main { public static void main(String[] args) {  FastReader fr =new FastReader();  PrintWriter op =new PrintWriter(System.out);  long n =fr.nextLong() ,k =fr.nextLong() ,d =(long)Math.sqrt(9l+8l*(n+k)) ;  d -= 3l ; d /=2l ;op.println(n-d) ;  op.flush(); op.close(); }  static class FastReader {  BufferedReader br;  StringTokenizer st;  public FastReader() {  br =new BufferedReader(new InputStreamReader(System.in));  }  String next() {  while (st==null || (!st.hasMoreElements()))   {   try   {   st =new StringTokenizer(br.readLine());   }   catch(IOException e)   {   e.printStackTrace();   }     }  return st.nextToken();  }  String nextLine() {  String str ="";   try  {   str =br.readLine();  }  catch(IOException e)  {   e.printStackTrace();  }   return str;  }  int nextInt() {  return Integer.parseInt(next());  }  long nextLong() {  return Long.parseLong(next()) ;  } } }
2,public class Main2 {  static int mod = 1000000007;  static FastScanner scanner;  public static void main(String[] args) {   scanner = new FastScanner();   long n = scanner.nextInt();   long k = scanner.nextInt();   if (sum(n) == k) {    System.out.println(0);    return;   }   long s = 0;   long e = n + 1;   while (s < e - 1) {    long m = (s + e) / 2;    long put = sum(n - m);    long candiesLeft = put - m;    if (candiesLeft == k) {     System.out.println(m);     return;    }    if (candiesLeft > k) {     s = m;    } else {     e = m;    }   }  }  static long sum(long n) {   long last = 1 + n - 1;   return ((1 + last) * n) / 2;  }  static class WithIdx {   int val, idx;   public WithIdx(int val, int idx) {    this.val = val;    this.idx = idx;   }  }  public static class FastScanner {   BufferedReader br;   StringTokenizer st;   public FastScanner() {    br = new BufferedReader(new InputStreamReader(System.in));   }   String nextToken() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {           e.printStackTrace();     }    }    return st.nextToken();   }   String nextLine() {    try {     return br.readLine();    } catch (Exception e) {     e.printStackTrace();     throw new RuntimeException();    }   }   int nextInt() {    return Integer.parseInt(nextToken());   }   long nextLong() {    return Long.parseLong(nextToken());   }   double nextDouble() {    return Double.parseDouble(nextToken());   }   int[] nextIntArray(int n) {    int[] res = new int[n];    for (int i = 0; i < n; i++) res[i] = nextInt();    return res;   }   long[] nextLongArray(int n) {    long[] res = new long[n];    for (int i = 0; i < n; i++) res[i] = nextLong();    return res;   }   String[] nextStringArray(int n) {    String[] res = new String[n];    for (int i = 0; i < n; i++) res[i] = nextToken();    return res;   }  }  static class PrefixSums {   long[] sums;   public PrefixSums(long[] sums) {    this.sums = sums;   }   public long sum(int fromInclusive, int toExclusive) {    if (fromInclusive > toExclusive) throw new IllegalArgumentException("Wrong value");    return sums[toExclusive] - sums[fromInclusive];   }   public static PrefixSums of(int[] ar) {    long[] sums = new long[ar.length + 1];    for (int i = 1; i <= ar.length; i++) {     sums[i] = sums[i - 1] + ar[i - 1];    }    return new PrefixSums(sums);   }   public static PrefixSums of(long[] ar) {    long[] sums = new long[ar.length + 1];    for (int i = 1; i <= ar.length; i++) {     sums[i] = sums[i - 1] + ar[i - 1];    }    return new PrefixSums(sums);   }  }  static class ADUtils {   static void sort(int[] ar) {    Random rnd = ThreadLocalRandom.current();    for (int i = ar.length - 1; i > 0; i--)    {     int index = rnd.nextInt(i + 1);         int a = ar[index];     ar[index] = ar[i];     ar[i] = a;    }    Arrays.sort(ar);   }   static void reverse(int[] arr) {    int last = arr.length / 2;    for (int i = 0; i < last; i++) {     int tmp = arr[i];     arr[i] = arr[arr.length - 1 - i];     arr[arr.length - 1 - i] = tmp;    }   }   static void sort(long[] ar) {    Random rnd = ThreadLocalRandom.current();    for (int i = ar.length - 1; i > 0; i--)    {     int index = rnd.nextInt(i + 1);         long a = ar[index];     ar[index] = ar[i];     ar[i] = a;    }    Arrays.sort(ar);   }  }  static class MathUtils {   static long[] FIRST_PRIMES = {     2,  3,  5,  7,  11,  13,  17,  19,  23,  29,     31,  37,  41,  43,  47,  53,  59,  61,  67,  71,     73,  79,  83,  89 , 97 , 101, 103, 107, 109, 113,     127, 131, 137, 139, 149, 151, 157, 163, 167, 173,     179, 181, 191, 193, 197, 199, 211, 223, 227, 229,     233, 239, 241, 251, 257, 263, 269, 271, 277, 281,     283, 293, 307, 311, 313, 317, 331, 337, 347, 349,     353, 359, 367, 373, 379, 383, 389, 397, 401, 409,     419, 421, 431, 433, 439, 443, 449, 457, 461, 463,     467, 479, 487, 491, 499, 503, 509, 521, 523, 541,     547, 557, 563, 569, 571, 577, 587, 593, 599, 601,     607, 613, 617, 619, 631, 641, 643, 647, 653, 659,     661, 673, 677, 683, 691, 701, 709, 719, 727, 733,     739, 743, 751, 757, 761, 769, 773, 787, 797, 809,     811, 821, 823, 827, 829, 839, 853, 857, 859, 863,     877, 881, 883, 887, 907, 911, 919, 929, 937, 941,     947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013,     1019, 1021, 1031, 1033, 1039, 1049, 1051};   static long[] primes(int to) {    long[] all = new long[to + 1];    long[] primes = new long[to + 1];    all[1] = 1;    int primesLength = 0;    for (int i = 2; i <= to; i ++) {     if (all[i] == 0) {      primes[primesLength++] = i;      all[i] = i;     }     for (int j = 0; j < primesLength && i * primes[j] <= to && all[i] >= primes[j]; j++) {      all[(int) (i * primes[j])] = primes[j];     }    }    return Arrays.copyOf(primes, primesLength);   }   static long modpow(long b, long e, long m) {    long result = 1;    while (e > 0) {     if ((e & 1) == 1) {           result = (result * b) % m;     }     b = (b * b) % m;     e >>= 1;    }    return result;   }   static long submod(long x, long y, long m) {    return (x - y + m) % m;   }  } }
1,public class Main { private static Scanner in = new Scanner(System.in); public static void main(String args[]){  int n = in.nextInt();  String s = in.next();  if(n==1)  System.out.println("1");  else{  int j=0,i=1,ans=s.length();  int h[]=new int[128];  h[(int)s.charAt(0)]=1;  while(i<n){   if(h[(int)s.charAt(i)]==0)   ans = i-j+1;   h[(int) s.charAt(i)]++;   while(j<i && h[(int)s.charAt(j)]>1){   h[(int)s.charAt(j)]--;   j++;   ans = Math.min(ans, i-j+1);   }   i++;  }  System.out.println(ans);  } } }
0,public class NewEmpty {  public static void main(String[] args)  {   Scanner blabla=new Scanner(System.in);   long a,b,c=0,d;   a=blabla.nextLong();   b=blabla.nextLong();   while (b!=0){    c+=(a/b);    a=a%b;    d=a;    a=b;    b=d;   }   System.out.println(c);  } }
6,public class q5 { static NoD[] arr; static int index,count,zc; static ArrayList<NoD> pos,neg; static long[][][][] dp;  static long solve(int a,int b, int c,int d, long mod) {  long[][][][] a2=dp;  int p=-1;  if(a==0 && b==0 && c==0) return 1;  if(dp[a][b][c][d]!=-1) return dp[a][b][c][d];  long tr=0;  if(a>0 && d!=1) {  tr=+a*solve(a-1,b,c,1,mod);  tr%=mod;  }  if(b >0 && d!=2) {  tr+=b*solve(a,b-1,c,2,mod);  tr%=mod;  }  if(c>0 && d!=3) {  tr+=c*solve(a,b,c-1,3,mod);  tr%=mod;  }  tr%=mod;  return dp[a][b][c][d]=tr;   }   public static void main(String[] args) throws IOException {   Reader.init(System.in);  PrintWriter out=new PrintWriter(System.out);  int n=Reader.nextInt(),t=Reader.nextInt();  long mod=(long)1e9+7,fact[]=new long[16];  dp=new long[16][16][16][4];  for(int i=0;i<16;i++) {  for(int j=0;j<16;j++) {   for(int k=0;k<16;k++)   Arrays.fill(dp[i][j][k], -1);  }  }  fact[0]=1;  for(int i=1;i<=15;i++) {  fact[i]=i*fact[i-1];  fact[i]%=mod;  }  NoD[] arr=new NoD[n];  for(int i=0;i<n;i++) {  int a=Reader.nextInt(),b=Reader.nextInt();  arr[i]=new NoD(a,b);    }  long ans=0;  for(int i=0;i<(1<<n);i++) {  int time=0;  int prev=-1;  int t1=0,t2=0,t3=0;  long[] c= {i};  BitSet b=BitSet.valueOf(c);  for(int j=0;j<n;j++) {   if(b.get(j)) {   time+=arr[j].val;    prev=arr[j].index;    if(arr[j].index==1) t1++;    else if(arr[j].index==2) t2++;    else t3++;   }  }  if(time==t) {   long v=1;   long v2=1;   v*=solve(t1,t2,t3,0,mod);   v%=mod;   ans+=v;   ans%=mod;  }  }  out.println(ans);  out.flush();   } } class NoD{ int val, index; NoD(int v,int i){  val=v;index=i; } } class Pair{ NoD a, b; Pair(NoD aa,NoD bb){  a=aa;b=bb; } }  class Reader {  static BufferedReader reader;  static StringTokenizer tokenizer;   static void init(InputStream input) {   reader = new BufferedReader(      new InputStreamReader(input) );   tokenizer = new StringTokenizer("");  }   static String nextLine() throws IOException{  return reader.readLine();  }  static String next() throws IOException {   while ( ! tokenizer.hasMoreTokens() ) {       tokenizer = new StringTokenizer(      reader.readLine() );   }   return tokenizer.nextToken();  }  static int nextInt() throws IOException {   return Integer.parseInt( next() );  }  static long nextLong() throws IOException {   return Long.parseLong( next() );  }  static double nextDouble() throws IOException {   return Double.parseDouble( next() );  } }
4,public class a{ public static void main(String[] args) {  Scanner in = new Scanner(System.in);  String str = in.next();  int max = 0;  for(int i=0; i<str.length(); i++) {  for(int j=i+1; j<=str.length(); j++) {   String first = str.substring(i,j);   for(int k=i+1; k<=str.length()-first.length(); k++) {   if(str.substring(k,k+first.length()).equals(first))    max = Math.max(max,first.length());   }  }  }  System.out.println(max); } }
2,public class ProblemD {  InputReader in; PrintWriter out;  void solve() {   long l = in.nextLong();   long r = in.nextLong();   long ans = 0;   boolean add = false;   for (int k = 62; k >= 0; k--) {    long cb = (1L << k);    if ((l & cb) != (r & cb))     add = true;    if (add)     ans += (1L << k);   }   out.println(ans);  }   ProblemD(){   boolean oj = System.getProperty("ONLINE_JUDGE") != null;   try {    if (oj) {     in = new InputReader(System.in);     out = new PrintWriter(System.out);    }    else {     Writer w = new FileWriter("output.txt");     in = new InputReader(new FileReader("input.txt"));     out = new PrintWriter(w);    }   } catch(Exception e) {    throw new RuntimeException(e);   }   solve();   out.close();  }  public static void main(String[] args){   new ProblemD();  } } class InputReader {  private BufferedReader reader;  private StringTokenizer tokenizer;  public InputReader(InputStream stream) {   reader = new BufferedReader(new InputStreamReader(stream));   tokenizer = null;  }   public InputReader(FileReader fr) {   reader = new BufferedReader(fr);   tokenizer = null;  }  public String next() {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    try {     tokenizer = new StringTokenizer(reader.readLine());    } catch (IOException e) {     throw new RuntimeException(e);    }   }   return tokenizer.nextToken();  }  public int nextInt() {   return Integer.parseInt(next());  }  public long nextLong() {   return Long.parseLong(next());  }  public double nextDouble() {   return Double.parseDouble(next());  } }
3,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   FastScanner in = new FastScanner(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskC solver = new TaskC();   solver.solve(1, in, out);   out.close();  }  static class TaskC {   private final int MOD = (int) (1e9 + 7);   public void solve(int testNumber, FastScanner in, PrintWriter out) {    int n = in.nextInt();    String[] arr = new String[n];    for (int i = 0; i < n; i++) {     arr[i] = in.nextString();    }    int[] dp = new int[n];    Arrays.parallelSetAll(dp, i -> 0);    dp[0] = 1;    int cnt = 0;    for (int i = 0; i < n; i++) {     if (arr[i].equals("f")) {      cnt++;      continue;     }     calc(dp, n, cnt);     cnt = 0;    }    int sum = 0;    for (int i = 0; i < n; i++) {     sum += dp[i];     sum %= MOD;    }    out.println(sum);   }   private void calc(int[] dp, int n, int cnt) {    for (int i = n - 1; i >= 0; i--) {     if (i != n - 1) dp[i] += dp[i + 1];     dp[i] %= MOD;    }       int prev = dp[0];    for (int i = 0, y = 0; i < MathUtil.gcdInt(n, cnt); i++) {         y = i;     prev = dp[i];     do {      int nextId = (y + cnt) % n;      int tmp = dp[nextId];      dp[nextId] = prev;      prev = tmp;      y = nextId;     } while (y != i);    }      }  }  static class FastScanner {   private BufferedReader br;   private StringTokenizer st;   public FastScanner(File f) {    try {     br = new BufferedReader(new FileReader(f));    } catch (FileNotFoundException e) {     e.printStackTrace();    }   }   public FastScanner(InputStream f) {    br = new BufferedReader(new InputStreamReader(f));   }   public String nextString() {    while (st == null || !st.hasMoreTokens()) {     String s = null;     try {      s = br.readLine();     } catch (IOException e) {      e.printStackTrace();     }     if (s == null)      return null;     st = new StringTokenizer(s);    }    return st.nextToken();   }   public int nextInt() {    return Integer.parseInt(nextString());   }  }  static class MathUtil {   public static int gcdInt(int a, int b) {    if (b == 0) return a;    return gcdInt(b, a % b);   }  } }
4,public class C implements Runnable{          private final static Random rnd = new Random();  private final static String fileName = "";  private void solve() {   int n = readInt();   int m = readInt();   int k = readInt();   Point[] starts = readPointArray(k);   for (Point start : starts) {    start.x--;    start.y--;   }   Point furthest = bfs(n, m, starts);   out.println((furthest.x + 1) + " " + (furthest.y + 1));  }  private Point bfs(int n, int m, Point[] starts) {   final int INF = n * m + 1;   boolean[][] used = new boolean[n][m];   Queue<Integer> queue = new ArrayDeque<>();   for (Point start : starts) {    used[start.x][start.y] = true;    queue.add(start.x * m + start.y);   }   int last = -1;   while (queue.size() > 0) {    int from = queue.poll();    last = from;    int fromX = from / m, fromY = from % m;    for (int[] step : steps) {     int toX = fromX + step[0];     int toY = fromY + step[1];     if (!checkCell(toX, n, toY, m)) continue;     if (used[toX][toY]) continue;     used[toX][toY] = true;     queue.add(toX * m + toY);    }   }   return new Point(last / m, last % m);  }    private final static boolean FIRST_INPUT_STRING = false;  private final static boolean MULTIPLE_TESTS = true;  private final boolean ONLINE_JUDGE = System.getProperty("ONLINE_JUDGE") != null;  private final static int MAX_STACK_SIZE = 128;  private final static boolean OPTIMIZE_READ_NUMBERS = false;    public void run(){   try{    timeInit();    Locale.setDefault(Locale.US);    init();    if (ONLINE_JUDGE) {     solve();    } else {     do {      try {       timeInit();       solve();       time();       out.println();      } catch (NumberFormatException e) {       break;      } catch (NullPointerException e) {       if (FIRST_INPUT_STRING) break;       else throw e;      }     } while (MULTIPLE_TESTS);    }    out.close();    time();   }catch (Exception e){    e.printStackTrace(System.err);    System.exit(-1);   }  }    private BufferedReader in;  private OutputWriter out;  private StringTokenizer tok = new StringTokenizer("");  public static void main(String[] args){   new Thread(null, new C(), "", MAX_STACK_SIZE * (1L << 20)).start();  }    private void init() throws FileNotFoundException{   Locale.setDefault(Locale.US);   in = new BufferedReader(new FileReader("input.txt"));   out = new OutputWriter("output.txt");  }    private long timeBegin;  private void timeInit() {   this.timeBegin = System.currentTimeMillis();  }  private void time(){   long timeEnd = System.currentTimeMillis();   System.err.println("Time = " + (timeEnd - timeBegin));  }  private void debug(Object... objects){   if (ONLINE_JUDGE){    for (Object o: objects){     System.err.println(o.toString());    }   }  }    private String delim = " ";  private String readLine() {   try {    return in.readLine();   } catch (IOException e) {    throw new RuntimeIOException(e);   }  }  private String readString() {   try {    while(!tok.hasMoreTokens()){     tok = new StringTokenizer(readLine());    }    return tok.nextToken(delim);   } catch (NullPointerException e) {    return null;   }  }    private final char NOT_A_SYMBOL = '\0';  private char readChar() {   try {    int intValue = in.read();    if (intValue == -1){     return NOT_A_SYMBOL;    }    return (char) intValue;   } catch (IOException e) {    throw new RuntimeIOException(e);   }  }  private char[] readCharArray() {   return readLine().toCharArray();  }  private char[][] readCharField(int rowsCount) {   char[][] field = new char[rowsCount][];   for (int row = 0; row < rowsCount; ++row) {    field[row] = readCharArray();   }   return field;  }    private long optimizedReadLong() {   int sign = 1;   long result = 0;   boolean started = false;   while (true) {    try {     int j = in.read();     if (-1 == j) {      if (started) return sign * result;      throw new NumberFormatException();     }     if (j == '-') {      if (started) throw new NumberFormatException();      sign = -sign;     }     if ('0' <= j && j <= '9') {      result = result * 10 + j - '0';      started = true;     } else if (started) {      return sign * result;     }    } catch (IOException e) {     throw new RuntimeIOException(e);    }   }  }  private int readInt() {   if (!OPTIMIZE_READ_NUMBERS) {    return Integer.parseInt(readString());   } else {    return (int) optimizedReadLong();   }  }  private int[] readIntArray(int size) {   int[] array = new int[size];   for (int index = 0; index < size; ++index){    array[index] = readInt();   }   return array;  }  private int[] readSortedIntArray(int size) {   Integer[] array = new Integer[size];   for (int index = 0; index < size; ++index) {    array[index] = readInt();   }   Arrays.sort(array);   int[] sortedArray = new int[size];   for (int index = 0; index < size; ++index) {    sortedArray[index] = array[index];   }   return sortedArray;  }  private int[] readIntArrayWithDecrease(int size) {   int[] array = readIntArray(size);   for (int i = 0; i < size; ++i) {    array[i]--;   }   return array;  }    private int[][] readIntMatrix(int rowsCount, int columnsCount) {   int[][] matrix = new int[rowsCount][];   for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {    matrix[rowIndex] = readIntArray(columnsCount);   }   return matrix;  }  private int[][] readIntMatrixWithDecrease(int rowsCount, int columnsCount) {   int[][] matrix = new int[rowsCount][];   for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {    matrix[rowIndex] = readIntArrayWithDecrease(columnsCount);   }   return matrix;  }    private long readLong() {   if (!OPTIMIZE_READ_NUMBERS) {    return Long.parseLong(readString());   } else {    return optimizedReadLong();   }  }  private long[] readLongArray(int size) {   long[] array = new long[size];   for (int index = 0; index < size; ++index){    array[index] = readLong();   }   return array;  }    private double readDouble() {   return Double.parseDouble(readString());  }  private double[] readDoubleArray(int size) {   double[] array = new double[size];   for (int index = 0; index < size; ++index){    array[index] = readDouble();   }   return array;  }    private BigInteger readBigInteger() {   return new BigInteger(readString());  }  private BigDecimal readBigDecimal() {   return new BigDecimal(readString());  }    private Point readPoint() {   int x = readInt();   int y = readInt();   return new Point(x, y);  }  private Point[] readPointArray(int size) {   Point[] array = new Point[size];   for (int index = 0; index < size; ++index){    array[index] = readPoint();   }   return array;  }    @Deprecated  private List<Integer>[] readGraph(int vertexNumber, int edgeNumber) {   @SuppressWarnings("unchecked")   List<Integer>[] graph = new List[vertexNumber];   for (int index = 0; index < vertexNumber; ++index){    graph[index] = new ArrayList<>();   }   while (edgeNumber-- > 0){    int from = readInt() - 1;    int to = readInt() - 1;    graph[from].add(to);    graph[to].add(from);   }   return graph;  }  private static class GraphBuilder {   final int size;   final List<Integer>[] edges;   static GraphBuilder createInstance(int size) {    List<Integer>[] edges = new List[size];    for (int v = 0; v < size; ++v) {     edges[v] = new ArrayList<>();    }    return new GraphBuilder(edges);   }   private GraphBuilder(List<Integer>[] edges) {    this.size = edges.length;    this.edges = edges;   }   public void addEdge(int from, int to) {    addDirectedEdge(from, to);    addDirectedEdge(to, from);   }   public void addDirectedEdge(int from, int to) {    edges[from].add(to);   }   public int[][] build() {    int[][] graph = new int[size][];    for (int v = 0; v < size; ++v) {     List<Integer> vEdges = edges[v];     graph[v] = castInt(vEdges);    }    return graph;   }  }    private static class IntIndexPair {   static Comparator<IntIndexPair> increaseComparator = new Comparator<C.IntIndexPair>() {    @Override    public int compare(C.IntIndexPair indexPair1, C.IntIndexPair indexPair2) {     int value1 = indexPair1.value;     int value2 = indexPair2.value;     if (value1 != value2) return value1 - value2;     int index1 = indexPair1.index;     int index2 = indexPair2.index;     return index1 - index2;    }   };   static Comparator<IntIndexPair> decreaseComparator = new Comparator<C.IntIndexPair>() {    @Override    public int compare(C.IntIndexPair indexPair1, C.IntIndexPair indexPair2) {     int value1 = indexPair1.value;     int value2 = indexPair2.value;     if (value1 != value2) return -(value1 - value2);     int index1 = indexPair1.index;     int index2 = indexPair2.index;     return index1 - index2;    }   };   static IntIndexPair[] from(int[] array) {    IntIndexPair[] iip = new IntIndexPair[array.length];    for (int i = 0; i < array.length; ++i) {     iip[i] = new IntIndexPair(array[i], i);    }    return iip;   }   int value, index;   IntIndexPair(int value, int index) {    super();    this.value = value;    this.index = index;   }   int getRealIndex() {    return index + 1;   }  }  private IntIndexPair[] readIntIndexArray(int size) {   IntIndexPair[] array = new IntIndexPair[size];   for (int index = 0; index < size; ++index) {    array[index] = new IntIndexPair(readInt(), index);   }   return array;  }    private static class OutputWriter extends PrintWriter {   final int DEFAULT_PRECISION = 12;   private int precision;   private String format, formatWithSpace;   {    precision = DEFAULT_PRECISION;    format = createFormat(precision);    formatWithSpace = format + " ";   }   OutputWriter(OutputStream out) {    super(out);   }   OutputWriter(String fileName) throws FileNotFoundException {    super(fileName);   }   int getPrecision() {    return precision;   }   void setPrecision(int precision) {    precision = max(0, precision);    this.precision = precision;    format = createFormat(precision);    formatWithSpace = format + " ";   }   String createFormat(int precision){    return "%." + precision + "f";   }   @Override   public void print(double d){    printf(format, d);   }   void printWithSpace(double d){    printf(formatWithSpace, d);   }   void printAll(double...d){    for (int i = 0; i < d.length - 1; ++i){     printWithSpace(d[i]);    }    print(d[d.length - 1]);   }   @Override   public void println(double d){    printlnAll(d);   }   void printlnAll(double... d){    printAll(d);    println();   }  }    private static class RuntimeIOException extends RuntimeException {      private static final long serialVersionUID = -6463830523020118289L;   RuntimeIOException(Throwable cause) {    super(cause);   }  }       private static final int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  private static final int[][] steps8 = {    {-1, 0}, {1, 0}, {0, -1}, {0, 1},    {-1, -1}, {1, 1}, {1, -1}, {-1, 1}  };  private static boolean checkCell(int row, int rowsCount, int column, int columnsCount) {   return checkIndex(row, rowsCount) && checkIndex(column, columnsCount);  }  private static boolean checkIndex(int index, int lim){   return (0 <= index && index < lim);  }    private static boolean checkBit(int mask, int bit){   return (mask & (1 << bit)) != 0;  }  private static boolean checkBit(long mask, int bit){   return (mask & (1L << bit)) != 0;  }    private static long getSum(int[] array) {   long sum = 0;   for (int value: array) {    sum += value;   }   return sum;  }  private static Point getMinMax(int[] array) {   int min = array[0];   int max = array[0];   for (int index = 0, size = array.length; index < size; ++index, ++index) {    int value = array[index];    if (index == size - 1) {     min = min(min, value);     max = max(max, value);    } else {     int otherValue = array[index + 1];     if (value <= otherValue) {      min = min(min, value);      max = max(max, otherValue);     } else {      min = min(min, otherValue);      max = max(max, value);     }    }   }   return new Point(min, max);  }    private static int[] getPrimes(int n) {   boolean[] used = new boolean[n];   used[0] = used[1] = true;   int size = 0;   for (int i = 2; i < n; ++i) {    if (!used[i]) {     ++size;     for (int j = 2 * i; j < n; j += i) {      used[j] = true;     }    }   }   int[] primes = new int[size];   for (int i = 0, cur = 0; i < n; ++i) {    if (!used[i]) {     primes[cur++] = i;    }   }   return primes;  }    private static long lcm(long a, long b) {   return a / gcd(a, b) * b;  }  private static long gcd(long a, long b) {   return (a == 0 ? b : gcd(b % a, a));  }    private static class MultiSet<ValueType> {   public static <ValueType> MultiSet<ValueType> createMultiSet() {    Map<ValueType, Integer> multiset = new HashMap<>();    return new MultiSet<>(multiset);   }   private final Map<ValueType, Integer> multiset;   private int size;   public MultiSet(Map<ValueType, Integer> multiset) {    this.multiset = multiset;    this.size = 0;   }   public int size() {    return size;   }   public void inc(ValueType value) {    int count = get(value);    multiset.put(value, count + 1);    ++size;   }   public void dec(ValueType value) {    int count = get(value);    if (count == 0) return;    if (count == 1) multiset.remove(value);    else multiset.put(value, count - 1);    --size;   }   public int get(ValueType value) {    Integer count = multiset.get(value);    return (count == null ? 0 : count);   }  }    private static class IdMap<KeyType> extends HashMap<KeyType, Integer> {      private static final long serialVersionUID = -3793737771950984481L;   public IdMap() {    super();   }   int getId(KeyType key) {    Integer id = super.get(key);    if (id == null) {     super.put(key, id = size());    }    return id;   }  }    private static int[] castInt(List<Integer> list) {   int[] array = new int[list.size()];   for (int i = 0; i < array.length; ++i) {    array[i] = list.get(i);   }   return array;  }  private static long[] castLong(List<Long> list) {   long[] array = new long[list.size()];   for (int i = 0; i < array.length; ++i) {    array[i] = list.get(i);   }   return array;  } }
3,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   FastReader in = new FastReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskC solver = new TaskC();   solver.solve(1, in, out);   out.close();  }  static class TaskC {   public void solve(int testNumber, FastReader in, PrintWriter out) {    Debug debug = new Debug(out);    int n = in.nextInt();    TaskC.Circle[] c = new TaskC.Circle[n];    double rr = in.nextInt();    for (int i = 0; i < n; ++i) {     c[i] = new TaskC.Circle();     c[i].x = in.nextInt();    }    ArrayList<TaskC.Circle> done = new ArrayList<>();    for (int i = 0; i < n; ++i) {     TaskC.Circle cur = c[i];     double ans = Double.MIN_VALUE;     for (int j = 0; j < done.size(); ++j) {      TaskC.Circle dd = done.get(j);      if (Double.compare(2 * rr, Math.abs(dd.x - cur.x)) < 0) continue;      double temp = Math.sqrt(4 * rr * rr - (cur.x - dd.x) * (cur.x - dd.x)) + dd.y;      ans = Math.max(ans, temp);     }     if (ans == Double.MIN_VALUE)      ans = rr;     cur.y = ans;     done.add(cur);    }    for (TaskC.Circle cc : done) {     out.printf("%.12f ", cc.y);    }   }   static class Circle implements Comparable<TaskC.Circle> {    double x;    double y;     public boolean equals(Object o) {     if (o == null) return false;     if (o == this) return true;     if (o.getClass() != this.getClass()) return false;     TaskC.Circle c = (TaskC.Circle) o;     return Double.compare(x, c.x) == 0 && Double.compare(y, c.y) == 0;    }     public int compareTo(TaskC.Circle o) {     if (Double.compare(o.x, x) != 0) {      return Double.compare(x, o.x);     }     return Double.compare(y, o.y);    }   }  }  static class Debug {   PrintWriter out;   boolean oj;   long timeBegin;   Runtime runtime;   public Debug(PrintWriter out) {    oj = System.getProperty("ONLINE_JUDGE") != null;    this.out = out;    this.timeBegin = System.currentTimeMillis();    this.runtime = Runtime.getRuntime();   }  }  static class FastReader {   private InputStream stream;   private byte[] buf = new byte[8192];   private int curChar;   private int pnumChars;   public FastReader(InputStream stream) {    this.stream = stream;   }   private int pread() {    if (pnumChars == -1) {     throw new InputMismatchException();    }    if (curChar >= pnumChars) {     curChar = 0;     try {      pnumChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (pnumChars <= 0) {      return -1;     }    }    return buf[curChar++];   }   public int nextInt() {    int c = pread();    while (isSpaceChar(c))     c = pread();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = pread();    }    int res = 0;    do {     if (c == ',') {      c = pread();     }     if (c < '0' || c > '9') {      throw new InputMismatchException();     }     res *= 10;     res += c - '0';     c = pread();    } while (!isSpaceChar(c));    return res * sgn;   }   private boolean isSpaceChar(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }  } }
1,public class TaskA implements Runnable {  long m = (int)1e9+7;  PrintWriter w;  InputReader c;  final int MAXN = (int)1e6 + 100;  public void run() {   c = new InputReader(System.in);   w = new PrintWriter(System.out);   int n = c.nextInt(), hamming_distance = 0;   char[] s = c.next().toCharArray(), t = c.next().toCharArray();   HashMap<Character, HashSet<Character>> replace = new HashMap<>();   HashMap<Character, Integer> map = new HashMap<>();   for(int i=0;i<n;++i) if(s[i] != t[i]) {    HashSet<Character> temp;    if(replace.containsKey(s[i])){     temp = replace.get(s[i]);     temp.add(t[i]);    } else {     temp = new HashSet<>();     temp.add(t[i]);    }    map.put(s[i],i);    replace.put(s[i], temp);    hamming_distance++;   }   int l = -1, r = -1;   boolean global_check = false;   for(int i=0;i<n;i++) if(s[i] != t[i]) {    if(replace.containsKey(t[i])) {     HashSet<Character> indices = replace.get(t[i]);     int ind = map.get(t[i]);     l = i + 1;     r = ind + 1;     if (indices.contains(s[i])) {      hamming_distance -= 2;      global_check = true;      break;     }    }    if(global_check) break;   }   if(!global_check && l!=-1) hamming_distance--;   else if(global_check){    for(int i=0;i<n;i++) {     if(t[i] == s[l-1] && s[i] == t[l-1]){      r = i + 1;      break;     }    }   }   w.println(hamming_distance);   w.println(l+" "+r);   w.close();  }  static long gcd(long a, long b) {   if (b == 0)    return a;   return gcd(b, a % b);  }  public static void sortbyColumn(int arr[][], int col){   Arrays.sort(arr, new Comparator<int[]>()   {    public int compare(int[] o1, int[] o2){     return(Integer.valueOf(o1[col]).compareTo(o2[col]));    }   });  }  public static class DJSet {   public int[] upper;   public DJSet(int n) {    upper = new int[n];    Arrays.fill(upper, -1);   }   public int root(int x) {    return upper[x] < 0 ? x : (upper[x] = root(upper[x]));   }   public boolean equiv(int x, int y) {    return root(x) == root(y);   }   public boolean union(int x, int y) {    x = root(x);    y = root(y);    if (x != y) {     if (upper[y] < upper[x]) {      int d = x;      x = y;      y = d;     }     upper[x] += upper[y];     upper[y] = x;    }    return x == y;   }  }  public static int[] radixSort(int[] f) {   int[] to = new int[f.length];   {    int[] b = new int[65537];    for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;    for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];    for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];    int[] d = f; f = to;to = d;   }   {    int[] b = new int[65537];    for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;    for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];    for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];    int[] d = f; f = to;to = d;   }   return f;  }  public void printArray(int[] a){   for(int i=0;i<a.length;i++)    w.print(a[i]+" ");   w.println();  }  public int[] scanArrayI(int n){   int a[] = new int[n];   for(int i=0;i<n;i++)    a[i] = c.nextInt();   return a;  }  public long[] scanArrayL(int n){   long a[] = new long[n];   for(int i=0;i<n;i++)    a[i] = c.nextLong();   return a;  }  public void printArray(long[] a){   for(int i=0;i<a.length;i++)    w.print(a[i]+" ");   w.println();  }  static class InputReader {   private InputStream stream;   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   private SpaceCharFilter filter;   private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));   public InputReader(InputStream stream) {    this.stream = stream;   }   public int read() {    if (numChars==-1)     throw new InputMismatchException();    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     }     catch (IOException e) {      throw new InputMismatchException();     }     if(numChars <= 0)      return -1;    }    return buf[curChar++];   }   public String nextLine() {    String str = "";    try {     str = br.readLine();    }    catch (IOException e) {     e.printStackTrace();    }    return str;   }   public int nextInt() {    int c = read();    while(isSpaceChar(c))     c = read();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if(c<'0'||c>'9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    }    while (!isSpaceChar(c));    return res * sgn;   }   public long nextLong() {    int c = read();    while (isSpaceChar(c))     c = read();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    long res = 0;    do {     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    }    while (!isSpaceChar(c));    return res * sgn;   }   public double nextDouble() {    int c = read();    while (isSpaceChar(c))     c = read();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    double res = 0;    while (!isSpaceChar(c) && c != '.') {     if (c == 'e' || c == 'E')      return res * Math.pow(10, nextInt());     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    }    if (c == '.') {     c = read();     double m = 1;     while (!isSpaceChar(c)) {      if (c == 'e' || c == 'E')       return res * Math.pow(10, nextInt());      if (c < '0' || c > '9')       throw new InputMismatchException();      m /= 10;      res += (c - '0') * m;      c = read();     }    }    return res * sgn;   }   public String readString() {    int c = read();    while (isSpaceChar(c))     c = read();    StringBuilder res = new StringBuilder();    do {     res.appendCodePoint(c);     c = read();    }    while (!isSpaceChar(c));    return res.toString();   }   public boolean isSpaceChar(int c) {    if (filter != null)     return filter.isSpaceChar(c);    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   public String next() {    return readString();   }   public interface SpaceCharFilter {    public boolean isSpaceChar(int ch);   }  }  public static void main(String args[]) throws Exception {   new Thread(null, new TaskA(),"TaskA",1<<26).start();  } }
4,public class ExplorerSpace {  private static class MyScanner {  BufferedReader br;  StringTokenizer st;   public MyScanner() {   br = new BufferedReader(new InputStreamReader(System.in));  }   String next() {   while (st == null || !st.hasMoreElements()) {    try {     st = new StringTokenizer(br.readLine());    } catch (IOException e) {     e.printStackTrace();    }   }   return st.nextToken();  }   int nextInt() {   return Integer.parseInt(next());  }   long nextLong() {   return Long.parseLong(next());  }   double nextDouble() {   return Double.parseDouble(next());  }   String nextLine(){   String str = "";  try {   str = br.readLine();  } catch (IOException e) {   e.printStackTrace();  }  return str;  }  }    public static int[][][] dp;   public static boolean valid(int i, int j, int n, int m) {  return i>=0 && i<n &&j>=0 && j<m; }  public static void solution(int n, int m, int k, int[][] h, int[][] v)   {  if(k%2==1)  {  for(int i = 0; i<n; i++)  {   for(int j = 0; j<m; j++)    out.print(-1+" ");     out.println();     }    return;  }   dp = new int[n][m][k/2+1];   for(int t = 1; t<=k/2; t++)  {  for(int i = 0; i<n; i++)  {   for(int j = 0; j<m; j++)   {   dp[i][j][t] = Integer.MAX_VALUE;      }  }  }   for(int i = 0; i<n; i++)  {  for(int j = 0; j<m; j++)  {   dp[i][j][0] = 0;     }  }     for(int t = 1; t<=k/2; t++)  {  for(int i = 0; i<n; i++)  {   for(int j = 0; j<m; j++)   {   if(valid(i,j+1,n,m))    dp[i][j][t] = Math.min(dp[i][j][t], h[i][j] + dp[i][j+1][t-1]);      if(valid(i,j-1,n,m))    dp[i][j][t] = Math.min(dp[i][j][t], h[i][j-1] + dp[i][j-1][t-1]);      if(valid(i+1,j,n,m))    dp[i][j][t] = Math.min(dp[i][j][t], v[i][j] + dp[i+1][j][t-1]);      if(valid(i-1,j,n,m))    dp[i][j][t] = Math.min(dp[i][j][t], v[i-1][j] + dp[i-1][j][t-1]);     }  }  }     for(int i = 0; i<n; i++)  {  for(int j = 0; j<m; j++)   out.print((dp[i][j][k/2]*2)+" ");    out.println();  }   }   private static PrintWriter out = new PrintWriter(System.out); public static void main (String[] args) { MyScanner s = new MyScanner();    int n = s.nextInt();  int m = s.nextInt();  int k = s.nextInt();   int[][] h = new int[n][m-1];   for(int i = 0; i<n; i++)  {  for(int j = 0; j<m-1; j++)  {   h[i][j] = s.nextInt();  }  }   int[][] v = new int[n-1][m];   for(int i = 0; i<n-1; i++)  {  for(int j = 0; j<m; j++)  {   v[i][j] = s.nextInt();  }  }     solution(n,m,k,h,v);   out.flush();  out.close();  } }
5,public class A {  static final Scanner sc = new Scanner(System.in);   void run() {   int n = sc.nextInt();   int[] xs = new int[n];   for(int i = 0; i < n; i++) {    xs[i] = sc.nextInt();   }   Arrays.sort(xs);   xs[n-1] = xs[n-1] == 1 ? 2 : 1;   Arrays.sort(xs);   for(int i = 0; i < n; i++)    System.out.print(xs[i] + " ");  }   public static void main(String[] args) {   new A().run();  } }
4,public class CF1497E2 extends PrintWriter { CF1497E2() { super(System.out); } static class Scanner {  Scanner(InputStream in) { this.in = in; } InputStream in;  byte[] bb = new byte[1 << 15]; int i, n;  byte getc() {  if (i == n) {   i = n = 0;   try { n = in.read(bb); } catch (IOException e) {}  }  return i < n ? bb[i++] : 0;  }  int nextInt() {  byte c = 0; while (c <= ' ') c = getc();  int a = 0; while (c > ' ') { a = a * 10 + c - '0'; c = getc(); }  return a;  } } Scanner sc = new Scanner(System.in); public static void main(String[] $) {  CF1497E2 o = new CF1497E2(); o.main(); o.flush(); }  static final int A = 10000000, K = 20; int[] cc = new int[A + 1]; {  boolean[] composite = new boolean[A + 1];  for (int a = 1; a <= A; a++)  cc[a] = a;  for (int a = 2; a <= A; a++) {  if (composite[a])   continue;  for (int b = a + a; b <= A; b += a)   composite[b] = true;  if (a <= A / a) {   int a2 = a * a;   for (int b = a2; b <= A; b += a2) {   int c = cc[b];   while (c % a2 == 0)    c /= a2;   cc[b] = c;   }  }  } } void main() {  int[] pp = new int[A + 1]; Arrays.fill(pp, -1);  int t = sc.nextInt();  while (t-- > 0) {  int n = sc.nextInt();  int k = sc.nextInt();  int[] aa = new int[n];  for (int i = 0; i < n; i++)   aa[i] = cc[sc.nextInt()];  int[] mp = new int[k + 1];  int[] ip = new int[k + 1];  for (int i = 0; i < n; i++) {   int a = aa[i];   for (int h = k; h >= 0; h--) {   if (pp[a] >= ip[h]) {    mp[h]++;    ip[h] = i;   }   if (h > 0 && (mp[h - 1] < mp[h] || mp[h - 1] == mp[h] && ip[h - 1] > ip[h])) {    mp[h] = mp[h - 1];    ip[h] = ip[h - 1];   }   }   pp[a] = i;  }  println(mp[k] + 1);  for (int i = 0; i < n; i++) {   int a = aa[i];   pp[a] = -1;  }  } } }
5,public class Seq2 {  static void metod() {   Scanner in = new Scanner(System.in);   int n = in.nextInt();   int[] a = new int[n];   for (int i = 0; i < n; i++)    a[i] = in.nextInt();   int min = a[0];   for (int i = 1; i < a.length; i++) {    if (a[i] < min)     min = a[i];   }     int min2 = min;   boolean t = false;   for (int i = 0; i < a.length; i++) {    if (a[i] != min) {     if (!t) {      min2 = a[i];      t = true;     } else {      if (min2 > a[i])       min2 = a[i];     }    }   }   System.out.println((min == min2) ? "NO" : min2);    }  public static void main(String[] args) {   Seq2.metod();  } }
4,public class C {  public static void main(String[] args) throws IOException{   BufferedReader f = new BufferedReader(new InputStreamReader(System.in));   PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));   int t = Integer.parseInt(f.readLine());   while(t-->0){    int n = Integer.parseInt(f.readLine());    int[] arr = new int[n];    for(int i = 0; i < n; i++){     arr[i] = Integer.parseInt(f.readLine());    }    int[] levels = new int[n];    int curr_level = 0;    for(int i = 0; i < n; i++){     if(levels[curr_level] == arr[i]-1){      levels[curr_level]++;     }else if(arr[i] == 1){      curr_level++;      levels[curr_level]++;     }else if(arr[i] > 1){      while(curr_level > 0 && levels[curr_level] != arr[i]-1){       levels[curr_level] = 0;       curr_level--;      }      levels[curr_level]++;     }     StringBuilder ostring = new StringBuilder();     for(int level = 0; level <= curr_level; level++){      ostring.append(levels[level]);      if(level != curr_level) ostring.append(".");     }     out.println(ostring);    }   }   out.close();  } }
2,public class C { public static void main(String[] args) {  Scanner scan = new Scanner(System.in);  long n = scan.nextLong();  long s = scan.nextLong();  long low = 0;  long high = n + 1;  while (high-low>1) {  long sum = 0;  long mid = (high + low) / 2;  long value = findSum(mid, sum);  if (mid - value >= s)   high = mid;  else   low = mid;  }   System.out.println(n - high + 1);  scan.close(); }  public static long findSum(long n, long sum) {  if (n == 0)  return sum;  return findSum(n / 10, sum + n % 10); } }
1,public class C {  static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); static StringTokenizer st; static PrintWriter out = new PrintWriter(System.out);  static String nextToken() throws IOException{  while (st==null || !st.hasMoreTokens()){  String s = bf.readLine();  if (s == null)   return null;  st = new StringTokenizer(s);  }   return st.nextToken(); }  static int nextInt() throws IOException{  return Integer.parseInt(nextToken()); }  static String nextStr() throws IOException{  return nextToken(); }  static int f(byte s[], int n){  int l = 0,  r = n-1;  int res = 0;   do{  while (l<n && s[l]=='H')   l++;  while (r>=0 && s[r]=='T')   r--;    if (l < r){   res++;  }  l++;  r--;  }  while (l < r);   return res; }  public static void main(String[] args) throws IOException{  int n = nextInt();  byte s[] = nextStr().getBytes();   int res = f(s, n);  for (int i=1; i<n; i++){  byte c = s[0];  for (int j=0; j<n-1; j++)   s[j] = s[j+1];  s[n-1] = c;  res = Math.min(res, f(s, n));  }   out.println(res);  out.flush(); } }
3,public class D {  public void solve(Scanner in, PrintWriter out) {  int n = in.nextInt();  int[] a = new int[n + 1];  for(int i = 1; i <= n; ++i) a[i] = in.nextInt();   int[] rangeInv = new int[n + 1];  BIT bit = new BIT(n + 1);  for(int i = 1; i <= n; ++i) {  int cur = a[i];  int inv = (int) bit.sum(cur, n);  rangeInv[i] = rangeInv[i - 1] + inv;  bit.add(cur, 1);  }   int m = in.nextInt();  int curTotal = rangeInv[n];   for(int qq = 0; qq < m; ++qq) {  int l = in.nextInt();  int r = in.nextInt();    int N = r - l + 1;  int total = N * (N - 1) / 2;    int cur = rangeInv[r] - rangeInv[l - 1];    int newInv = total - cur;    curTotal -= cur;  curTotal += newInv;    if(curTotal % 2 == 0) {   out.println("even");  } else {   out.println("odd");  }  }   }  public static void main(String[] args) {  Scanner in = new Scanner(System.in);  PrintWriter out = new PrintWriter(System.out);  new D().solve(in, out);  in.close();  out.close(); }  class BIT {   long[] tree;  int n;   public BIT(int n) {   this.n = n;   tree = new long[n + 1];  }   public void add(int i, long val)  {   while(i <= n)   {    tree[i] += val;    i += i & -i;   }  }   public long sum(int to)  {   long res = 0;   for(int i = to; i >= 1; i -= (i & -i))   {    res += tree[i];   }   return res;  }   public long sum(int from, int to) {   return sum(to) - sum(from - 1);  } } }
3,public class Main {  public static class InputReader {  public BufferedReader reader;  public StringTokenizer tokenizer;  public InputReader() {  reader = new BufferedReader(new InputStreamReader(System.in), 32768);  tokenizer = null;  }  public InputReader(InputStream stream) {  reader = new BufferedReader(new InputStreamReader(System.in), 32768);  tokenizer = null;  }  public String next() {  while (tokenizer == null || !tokenizer.hasMoreTokens()) {   try {   tokenizer = new StringTokenizer(reader.readLine());   } catch (IOException e) {   throw new RuntimeException(e);   }  }  return tokenizer.nextToken();  }  public char nextChar() {  return next().charAt(0);  }  public int nextInt() {  return Integer.parseInt(next());  }  public long nextLong() {  return Long.parseLong(next());  }  public double nextDouble() {  return Double.parseDouble(next());  } }  public static void main(String[] args) {     InputReader scn = new InputReader();   int n = scn.nextInt(), r = scn.nextInt();  double[] y = new double[n];  int[] x = new int[n];  boolean[] mark = new boolean[n];  for(int i = 0; i < n; i++) {  x[i] = scn.nextInt();  }  for(int i = 0; i < n; i++) {  double yc = r;  for(int j = 0; j < n; j++) {   if(i == j || !mark[j]) {   continue;   }   if(x[i] + r < x[j] - r || x[i] - r > x[j] + r) {   continue;   }     yc = Math.max(yc, y[j] + Math.sqrt(Math.abs(Math.pow(x[i] - x[j], 2) - 4 * r * r)));  }  y[i] = yc;  mark[i] = true;  }   for(int i = 0; i < n; i++) {  System.out.print(y[i] + " ");  }  System.out.println(); } }
2,public class Main {  public static void main(String [] args ) {  try{  String str;    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  BufferedOutputStream bos = new BufferedOutputStream(System.out);  String eol = System.getProperty("line.separator");  byte [] eolb = eol.getBytes();  byte[] spaceb= " ".getBytes();    str = br.readLine();  int blank = str.indexOf( " ");  long l = Long.parseLong(str.substring(0,blank));  long r = Long.parseLong(str.substring(blank+1));  String one = "";  String two = "";  while(l>0) {   if((l%2)==0) {   one = "0".concat(one);   } else {   one = "1".concat(one);   }   l/=2;  }  while(r>0) {   if((r%2)==0) {   two = "0".concat(two);   } else {   two = "1".concat(two);   }   r/=2;  }  while(one.length()<60) {   one = "0".concat(one);  }  while(two.length()<60) {   two = "0".concat(two);  }  int iter = 0;  String xor = "";  boolean big = false;  boolean small = false;  while(one.charAt(iter) == two.charAt(iter)) {   xor = xor.concat("0");   iter++;   if(iter==60) {   break;   }  }  for(int i = iter ; i < 60 ; i++) {   xor = xor.concat("1");  }  bos.write(new BigInteger(xor,2).toString().getBytes());  bos.write(eolb);  bos.flush();  } catch(IOException ioe) {  ioe.printStackTrace();  } } }
3,public class CF1141F { public static void main(String[] args) throws Exception {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  int n = Integer.parseInt(br.readLine());  String[] split = br.readLine().split(" ");  int[] terms = new int[n];  int[] sums = new int[n+1];  for(int i=0; i<n; i++) {  terms[i] = Integer.parseInt(split[i]);  sums[i+1] = sums[i]+terms[i];  }  ArrayList<Block> blocks = new ArrayList<>();  for(int i=0; i<n; i++)  for(int j=i; j<n; j++){   int s = sums[j+1]-sums[i];   blocks.add(new Block(i, j, s));  }  Collections.sort(blocks);  ArrayList<Block> best = new ArrayList<>();  int i = 0;  while(i<blocks.size()){  int curSum = blocks.get(i).sum;  ArrayList<Block> curBlocks = new ArrayList<>();  while(i<blocks.size() && blocks.get(i).sum==curSum) curBlocks.add(blocks.get(i++));  int[] memo = new int[curBlocks.size()+1];  Arrays.fill(memo, -1);  memo[curBlocks.size()] = 0;  for(int j=curBlocks.size()-1; j>=0; j--){   int idx = Collections.binarySearch(curBlocks, new Block(curBlocks.get(j).r+1, curBlocks.get(j).r+1, curBlocks.get(j).sum));   if(idx<0) idx = -(idx+1);   memo[j] = Math.max(memo[j+1], 1+memo[idx]);  }  if(memo[0]>best.size()){   best = new ArrayList<>();   int idx = 0;   while(memo[idx]>=1){   if(memo[idx]>memo[idx+1]) best.add(curBlocks.get(idx));   idx++;   }  }  }  StringBuilder sb = new StringBuilder();  sb.append(best.size()).append("\n");  for(Block b : best){  sb.append(b.l+1).append(" ").append(b.r+1).append("\n");  }  System.out.print(sb); }  static class Block implements Comparable<Block>{  int l, r, sum;   Block(int a, int b, int c){  l = a;  r = b;  sum = c;  }  @Override  public int compareTo(Block o) {  if(sum==o.sum){   if(l==o.l) return r-o.r;   return l-o.l;  }  return sum-o.sum;  } } }
5,public class Solution {  class Q implements Comparable<Q> {  int p, t;  Q(int q, int w) {  p = q; t = w;  }  @Override  public int compareTo(Q arg0) {  if (p == arg0.p) return t - arg0.t;   return arg0.p - p;  } }  void solve() throws Exception {  int n = nextInt();  int k = nextInt() - 1;  Q[] a = new Q[n];  for (int i = 0; i < n; i++) a[i] = new Q(nextInt(), nextInt());  Arrays.sort(a);  int ans = 1;  for (int i = k - 1; i >= 0; i--) if (a[i].compareTo(a[k]) == 0) ans++; else break;  for (int i = k + 1; i < n; i++) if (a[i].compareTo(a[k]) == 0) ans++; else break;  out.println(ans); }  public static void main(String[] args) {  new Solution().run(); }  public void run() {  try {  in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);  solve();  } catch (Exception e) {  e.printStackTrace();  System.exit(1);  } finally {  out.close();  } }  String nextToken() throws Exception {  while (st == null || !st.hasMoreTokens()) {  String s = in.readLine();  if (s == null) return null;  st = new StringTokenizer(s);  }  return st.nextToken(); }  int nextInt() throws Exception {  return Integer.parseInt(nextToken()); }  BufferedReader in; PrintWriter out; StringTokenizer st; }
6,public class Main {  public static void main(String[] args) {   try(Scanner in = new Scanner(System.in)) {    int bx = in.nextInt();    int by = in.nextInt();    int n = in.nextInt();    int[][] xy = new int[n][2];    int[] res = new int[1 << n];    int[] last = new int[1 << n];    for (int i = 0; i < n; i++) {     xy[i] = new int[]{in.nextInt(), in.nextInt()};    }    int[] ds = new int[n];    for (int i = 0; i < ds.length; i++) {     ds[i] = time(xy[i][0], xy[i][1], bx, by);    }    int[][] d = new int[n][n];    for (int i = 0; i < d.length; i++) {     for (int j = 0; j < d.length; j++) {      d[i][j] = time(xy[i][0], xy[i][1], xy[j][0], xy[j][1]);     }    }    Arrays.fill(res, Integer.MAX_VALUE);    res[0] = 0;    for (int i = 0; i < (1 << n); i++) {     for (int j = 0; j < n; j++) {      if ((i & mask(j)) != 0) {       if (res[i - mask(j)] + 2*ds[j] < res[i]) {        res[i] = res[i - mask(j)] + 2*ds[j];        last[i] = i - mask(j);       }       for (int k = j + 1; k < n; k++) {        if ((i & mask(k)) != 0) {         if (res[i - mask(k) - mask(j)] + ds[j] + ds[k] + d[j][k] < res[i]) {          res[i] = res[i - mask(k) - mask(j)] + ds[j] + ds[k] + d[j][k];          last[i] = i - mask(j) - mask(k);         }        }       }       break;      }     }    }    int cur = (1 << n) - 1;    System.out.println(res[cur]);    int k = cur;    while (k != 0) {     System.out.print("0 ");     int diff = k - last[k];     for (int i = 0; i < n && diff != 0; i++) {      if (((diff >> i) & 1) != 0) {       System.out.print((i + 1) + " ");       diff -= (1 << i);      }     }     k = last[k];    }    System.out.println("0");   }  }  static int mask(int i) {   return 1 << i;  }  static int time(int x, int y, int x1, int y1) {   return (x - x1)*(x - x1) + (y - y1)*(y - y1);  } }
6,public class Test { static PrintWriter writer =  new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));  static int readInt() {  int ans = 0;  boolean neg = false;  try {  boolean start = false;  for (int c = 0; (c = System.in.read()) != -1; ) {   if (c == '-') {   start = true;   neg = true;   continue;   } else if (c >= '0' && c <= '9') {   start = true;   ans = ans * 10 + c - '0';   } else if (start) break;  }  } catch (IOException e) {  }  return neg ? -ans : ans; }  static long readLong() {  long ans = 0;  boolean neg = false;  try {  boolean start = false;  for (int c = 0; (c = System.in.read()) != -1; ) {   if (c == '-') {   start = true;   neg = true;   continue;   } else if (c >= '0' && c <= '9') {   start = true;   ans = ans * 10 + c - '0';   } else if (start) break;  }  } catch (IOException e) {  }  return neg ? -ans : ans; }  static String readLine() {  StringBuilder b = new StringBuilder();  try {  boolean start = false;  for (int c = 0; (c = System.in.read()) != -1; ) {   if (Character.isLetterOrDigit(c)) {   start = true;   b.append((char) c);   } else if (start) break;  }  } catch (IOException e) {  }  return b.toString(); }  public static void main(String[] args) {  Test te = new Test();  te.start();  writer.flush(); }  void start() {  int t = readInt();  while (t-- > 0) {  int n = readInt(), m = readInt();  int[][] a = new int[n][m];  int[][] e = new int[n*m][];  for (int i = 0; i < n; i++)   for (int j = 0; j < m; j++) {   a[i][j] = readInt();   e[i*m+j] = new int[]{a[i][j], j};   }  Arrays.sort(e, (x, y) -> x[0] == y[0] ? Integer.compare(x[1], y[1])   : Integer.compare(y[0], x[0]));  Set<Integer> cols = new HashSet<>();  for (int[] x : e) {   cols.add(x[1]);   if (cols.size() >= n) break;  }  int[] dp = new int[1<<n];  Arrays.fill(dp, -1);  dp[0] = 0;  for (int c : cols) {   for (int i = (1 << n) - 1; i >= 0; i--) {   int u = (1 << n) - 1 - i;   int p = u;   if (dp[i] >= 0)    while (p > 0) {    for (int r = 0; r < n; r++) {     int sum = 0;     for (int j = 0; j < n; j++) if (((p >> j) & 1) != 0) sum += a[(j + r) % n][c];     dp[i | p] = Math.max(dp[i | p], dp[i] + sum);     }    p = (p - 1) & u;    }   }  }  writer.println(dp[(1<<n) - 1]);  } } }
4,public class FireAgain {  public static void main(String[] args) throws IOException {  BufferedReader readData = new BufferedReader(new FileReader("input.txt"));  PrintWriter writer = new PrintWriter(new File("output.txt"));  String line = readData.readLine();  String[] temp = line.split(" ");  int n = Integer.valueOf(temp[0]);  int m = Integer.valueOf(temp[1]);  int x = 0, y = 0;  line = readData.readLine();  int k = Integer.valueOf(line);  boolean[][] visited = new boolean[n + 1][m + 1];  Queue<Integer> qX = new LinkedList<Integer>();  Queue<Integer> qY = new LinkedList<Integer>();  line = readData.readLine();  String[] temp2 = line.split(" ");  for (int i = 0; i < temp2.length - 1; i+=2) {  x = Integer.valueOf(temp2[i]);  y = Integer.valueOf(temp2[i + 1]);  visited[x][y] = true;  qX.add(x);  qY.add(y);  }  while (!qX.isEmpty()) {  x = qX.poll();  y = qY.poll();  if (x >= 2 && !visited[x - 1][y]) {   visited[x - 1][y] = true;   qX.add(x - 1);   qY.add(y);  }  if (x + 1 <= n && !visited[x + 1][y]) {   visited[x + 1][y] = true;   qX.add(x + 1);   qY.add(y);  }  if (y >= 2 && !visited[x][y - 1]) {   visited[x][y - 1] = true;   qX.add(x);   qY.add(y - 1);  }  if (y + 1 <= m && !visited[x][y + 1]) {   visited[x][y + 1] = true;   qX.add(x);   qY.add(y + 1);  }  }  writer.write(x + " ");  writer.write(y + " ");  writer.close(); } }
3,public class C455C { public static void main(String[] args) {  Scanner sc = new Scanner(System.in);  int n = Integer.parseInt(sc.nextLine());  ArrayList<Integer> listCount = new ArrayList<Integer>();  listCount.add(1);  boolean justf = false;  int p = 1000000007;  long ans = 0;   for(int x=0; x<n; x++){  String next = sc.nextLine();    if(next.equals("f")){     if(justf){   listCount.add(0);   }   else{      for(int i=1; i<listCount.size(); i++){    int sum = (listCount.get(i-1) + listCount.get(i)) % p;    listCount.set(i, sum);   }      listCount.add(0);   }     justf = true;  }  else{   if(justf){   justf = false;   }   else{   for(int i=1; i<listCount.size(); i++){    int sum = (listCount.get(i-1) + listCount.get(i)) % p;    listCount.set(i, sum);   }   }  }      }   for(int i=0; i<listCount.size(); i++){  ans += listCount.get(i);  }   System.out.print((ans % p)); } }
0,public class A {  public static void main(String[] args) {  Scanner sc =new Scanner (System.in);   long a=sc.nextLong(); long b=sc.nextLong();     if(b-a <=1)   System.out.println("-1");   else if(b-a==2 && a%2==1)   System.out.println("-1");   else   {   if(a%2==1)    System.out.println((a+1)+" "+(a+2)+" "+(a+3));   else    System.out.println((a)+" "+(a+1)+" "+(a+2));   }   sc.close(); } }
6,public class code839E {  public static void main(String[] args) throws Exception{   BufferedReader bff=new BufferedReader(new InputStreamReader(System.in));   PrintWriter wff=new PrintWriter(System.out);   String[] st=bff.readLine().split(" ");   int V=Integer.parseInt(st[0]);   int K=Integer.parseInt(st[1]);   BronKerbosch bk=new BronKerbosch(V);   for(int i=0;i<V;i++){    st=bff.readLine().split(" ");    for(int j=0;j<V;j++){     if(st[j].equals("1")){      bk.anadir(i,j);     }    }   }   long num=bk.numeroCamarilla();   wff.printf("%.12f\n", num * (num - 1.0) / 2 * K / num * K / num);   wff.flush();  }     static class BronKerbosch {  int V;  long[] neig;  Random random = new Random();  long maxClique;  public BronKerbosch(int v){   V=v;   neig=new long[V];  }  public void anadir(int a,int b){   long aux=1;   neig[a] |= aux << (long)b;  }   public long numeroCamarilla(){   long numero = Long.bitCount(bronKerbosch());   return numero;  }   public long bronKerbosch() {   maxClique = 0;   bronKerbosch2(0, (1L << V) - 1, 0);   return maxClique;  }  public void bronKerbosch2(long r, long p, long x) {   if (Long.bitCount(maxClique) >= Long.bitCount(r | p | x)) return;   long px = p | x;   if (px == 0) {    if (Long.bitCount(maxClique) < Long.bitCount(r)) {     maxClique = r;    }    return;   }   int cnt = Long.bitCount(px);   int choice = random.nextInt(cnt);   int u;   for (int i = 0; ; i++) {    if ((px >>> i & 1) != 0 && choice-- == 0) {     u = i;     break;    }   }   long ne = p & ~neig[u];   for (int v = 0; v < V; v++){    if ((ne >>> v & 1) != 0) {     bronKerbosch2(r | 1L << v, p & neig[v], x & neig[v]);     p &= ~(1L << v);     x |= 1L << v;    }   }  } }   }
0,public class composite {   public static void main(String[] args) {   int b;   Scanner s3=new Scanner(System.in);   b=s3.nextInt();     if(b%2==0)   {    b=b-4;    System.out.println(4+" "+b);   }   else   {    b=b-9;    System.out.println(9+" "+b);   }    } }
4,public class Main {   static void deal(int n,int[] arr) {   int[] a = new int[n];   a[0] = 1;   int l = 1;   out.println(toString(a,l));   for(int i=1;i<n;i++) {    if(arr[i] == 1) {     a[l] = 1;     l++;    } else {     int index = l-1;     while(index>=0 && a[index] != arr[i]-1) {      index--;     }     a[index]++;     l = index+1;    }    out.println(toString(a,l));   }  }   static String toString(int[] arr,int l) {   StringBuilder sb = new StringBuilder();   for(int i=0;i<l-1;i++) {    sb.append(arr[i]);    sb.append('.');   }   sb.append(arr[l-1]);   return sb.toString();  }   public static void main(String[] args) {   MyScanner sc = new MyScanner();   out = new PrintWriter(new BufferedOutputStream(System.out));   int t = sc.nextInt();   for(int i=0;i<t;i++) {    int n = sc.nextInt();    int[] arr = new int[n];    for(int j=0;j<n;j++) arr[j] = sc.nextInt();    deal(n,arr);   }   out.close();  }     public static PrintWriter out;     public static class MyScanner {   BufferedReader br;   StringTokenizer st;     public MyScanner() {     br = new BufferedReader(new InputStreamReader(System.in));   }     String next() {     while (st == null || !st.hasMoreElements()) {       try {         st = new StringTokenizer(br.readLine());       } catch (IOException e) {         e.printStackTrace();       }     }     return st.nextToken();   }     int nextInt() {     return Integer.parseInt(next());   }     long nextLong() {     return Long.parseLong(next());   }     double nextDouble() {     return Double.parseDouble(next());   }     String nextLine(){     String str = "";  try {    str = br.readLine();  } catch (IOException e) {    e.printStackTrace();  }  return str;   }    } }
6,public class Main {  static ArrayList<Integer> cols;  static int ans, n, a[][];  public static void main(String[] args) throws Exception {   Scanner sc = new Scanner(System.in);   PrintWriter out = new PrintWriter(System.out);   int tc = sc.nextInt();   while (tc-- > 0) {    ans = 0;    n = sc.nextInt();    int m = sc.nextInt();    boolean[] taken = new boolean[m];    PriorityQueue<Pair> pq = new PriorityQueue<>();    a = new int[n][m];    for (int i = 0; i < n; i++)     for (int j = 0; j < m; j++) {      int cur = sc.nextInt();      pq.add(new Pair(i, j, cur));      a[i][j] = cur;     }    cols = new ArrayList<>();    while (!pq.isEmpty() && cols.size() < 8) {     Pair cur = pq.remove();     if (!taken[cur.j]) cols.add(cur.j);     taken[cur.j] = true;    }    solve(0,new int [cols.size()]);    out.println(ans);   }   out.flush();   out.close();  }  static void solve(int i, int[] p) {   if (i == cols.size()) {    int[] max = new int[n];    for (int k = 0; k < cols.size(); k++) {     int j = cols.get(k);     for (int ii = 0; ii < n; ii++) {      int idx = (ii + p[k]) % n;      max[idx] = Math.max(max[idx], a[ii][j]);     }    }    int poss = 0;    for (int x : max)     poss += x;    ans = Math.max(ans, poss);    return;   }   for (int j = 0; j < n; j++) {    p[i] = j;    solve(i + 1, p);   }  }   static class Pair implements Comparable<Pair> {   int i, j, val;   public Pair(int i, int j, int val) {    this.i = i;    this.j = j;    this.val = val;   }   @Override   public int compareTo(Pair o) {    return o.val - val;   }  }   static class Scanner {   StringTokenizer st;   BufferedReader br;   public Scanner(InputStream system) {    br = new BufferedReader(new InputStreamReader(system));   }   public Scanner(String file) throws Exception {    br = new BufferedReader(new FileReader(file));   }   public String next() throws IOException {    while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());    return st.nextToken();   }   public String nextLine() throws IOException {    return br.readLine();   }   public int nextInt() throws IOException {    return Integer.parseInt(next());   }   int[] nextIntArray(int n) throws IOException {    int[] a = new int[n];    for (int i = 0; i < n; i++)     a[i] = nextInt();    return a;   }   public double nextDouble() throws IOException {    return Double.parseDouble(next());   }   public char nextChar() throws IOException {    return next().charAt(0);   }   public Long nextLong() throws IOException {    return Long.parseLong(next());   }   public boolean ready() throws IOException {    return br.ready();   }   public void waitForInput() throws InterruptedException {    Thread.sleep(3000);   }  } }
6,public class CF16E { public static void main(String[] args) throws IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  int n = Integer.parseInt(br.readLine());  double[][] aa = new double[n][n];  for (int i = 0; i < n; i++) {  StringTokenizer st = new StringTokenizer(br.readLine());  for (int j = 0; j < n; j++)   aa[i][j] = Double.parseDouble(st.nextToken());  }  double[][] pp = new double[1 << n][n];  for (int k = 0; k < n; k++)  pp[1 << k][k] = 1;  for (int b = 1; b < 1 << n; b++) {  int c = 0;  for (int i = 0; i < n; i++) {   if ((b & 1 << i) == 0)   continue;   c++;   for (int j = i + 1; j < n; j++) {   if ((b & 1 << j) == 0)    continue;   for (int k = 0; k < n; k++) {    if ((b & 1 << k) == 0)    continue;    pp[b][k] += aa[i][j] * pp[b ^ 1 << j][k];    pp[b][k] += aa[j][i] * pp[b ^ 1 << i][k];   }   }  }  if (c > 1) {   double p = (double) c * (c - 1) / 2;   for (int k = 0; k < n; k++)   pp[b][k] /= p;  }  }  StringBuilder sb = new StringBuilder();  int b = (1 << n) - 1;  for (int k = 0; k < n; k++)  sb.append(pp[b][k]).append(k == n - 1 ? '\n' : ' ');  System.out.print(sb); } }
5,public class j { public static void main(String a[])throws IOException { BufferedReader b=new BufferedReader(new InputStreamReader(System.in)); int k=0,i=0,j=0,n=0,p=0,t=0; String s; s=b.readLine(); StringTokenizer c=new StringTokenizer(s); n=Integer.parseInt(c.nextToken()); k=Integer.parseInt(c.nextToken()); int d[]=new int[n]; int e[]=new int[n]; for(i=0;i<n;i++) { s=b.readLine(); StringTokenizer z=new StringTokenizer(s); d[i]=Integer.parseInt(z.nextToken()); e[i]=Integer.parseInt(z.nextToken()); } for(i=0;i<n-1;i++) { for(j=i+1;j<n;j++) { if(d[j]<d[i]) { t=d[j]; d[j]=d[i]; d[i]=t; t=e[j]; e[j]=e[i]; e[i]=t; } } } for(i=0;i<n-1;i++) { if(((d[i+1]-e[i+1]/2.0)-(d[i]+e[i]/2.0))>k) p+=2; if(((d[i+1]-e[i+1]/2.0)-(d[i]+e[i]/2.0))==k) p++; } System.out.print(p+2); } }
0,public class Main {  public static void main(String[] args) {     Scanner in = new Scanner(System.in);   int n = in.nextInt();   System.out.println(n/2*3);  } }
5,public class C111A{  static BufferedReader br;  public static void main(String args[])throws Exception{   br=new BufferedReader(new InputStreamReader(System.in));   int n = toInt();   int nm[] = toIntArray();   double a=0.0;   double sum=0;   for(int i=0;i<n;i++){    sum+=nm[i];   }   a=sum/2;   Arrays.sort(nm);   int cur=0;   int count=0;   for(int i=nm.length-1;i>=0;i--){    cur+=nm[i];    count++;    if(cur>a){     break;    }   }   System.out.println(count);   }    public static int[] toIntArray()throws Exception{   String str[]=br.readLine().split(" ");   int k[]=new int[str.length];   for(int i=0;i<str.length;i++){    k[i]=Integer.parseInt(str[i]);   }   return k;  }  public static int toInt()throws Exception{   return Integer.parseInt(br.readLine());  }  public static long[] toLongArray()throws Exception{   String str[]=br.readLine().split(" ");   long k[]=new long[str.length];   for(int i=0;i<str.length;i++){    k[i]=Long.parseLong(str[i]);   }   return k;  }  public static long toLong()throws Exception{   return Long.parseLong(br.readLine());  }  public static double[] toDoubleArray()throws Exception{   String str[]=br.readLine().split(" ");   double k[]=new double[str.length];   for(int i=0;i<str.length;i++){    k[i]=Double.parseDouble(str[i]);   }   return k;  }  public static double toDouble()throws Exception{   return Double.parseDouble(br.readLine());  }  public static String toStr()throws Exception{   return br.readLine();  }  public static String[] toStrArray()throws Exception{   String str[]=br.readLine().split(" ");   return str;  }   }
1,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   OutputWriter out = new OutputWriter(outputStream);   TaskA solver = new TaskA();   solver.solve(1, in, out);   out.close();  }  static class TaskA {   public void solve(int testNumber, InputReader in, OutputWriter out) {    int n = in.nextInt();    String[] a = new String[n];    String[] b = new String[n];    for (int i = 0; i < n; i++) {     a[i] = in.next();    }    for (int i = 0; i < n; i++) {     b[i] = in.next();    }    int ans = 0;    for (int i = 1; i < 5; i++) {     int a1 = 0, b1 = 0, c1 = 0;     for (int j = 0; j < n; j++) {      if (a[j].length() == i) {       if (a[j].charAt(i - 1) == 'M') {        a1++;       } else if (a[j].charAt(i - 1) == 'S') {        b1++;       } else {        c1++;       }      }     }     for (int j = 0; j < n; j++) {      if (b[j].length() == i) {       if (b[j].charAt(i - 1) == 'M') {        a1--;       } else if (b[j].charAt(i - 1) == 'S') {        b1--;       } else {        c1--;       }      }     }     if (a1 > 0) ans += a1;     if (b1 > 0) ans += b1;     if (c1 > 0) ans += c1;    }    out.println(ans);   }  }  static class InputReader {   private InputStream stream;   private byte[] inbuf = new byte[1024];   private int lenbuf = 0;   private int ptrbuf = 0;   public InputReader(InputStream stream) {    this.stream = stream;   }   private int readByte() {    if (lenbuf == -1) throw new UnknownError();    if (ptrbuf >= lenbuf) {     ptrbuf = 0;     try {      lenbuf = stream.read(inbuf);     } catch (IOException e) {      throw new UnknownError();     }     if (lenbuf <= 0) return -1;    }    return inbuf[ptrbuf++];   }   private boolean isSpaceChar(int c) {    return !(c >= 33 && c <= 126);   }   private int skip() {    int b;    while ((b = readByte()) != -1 && isSpaceChar(b)) ;    return b;   }   public String next() {    int b = skip();    StringBuilder sb = new StringBuilder();    while (!(isSpaceChar(b))) {     sb.appendCodePoint(b);     b = readByte();    }    return sb.toString();   }   public int nextInt() {    int num = 0, b;    boolean minus = false;    while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;    if (b == '-') {     minus = true;     b = readByte();    }    while (true) {     if (b >= '0' && b <= '9') {      num = num * 10 + (b - '0');     } else {      return minus ? -num : num;     }     b = readByte();    }   }  }  static class OutputWriter extends PrintWriter {   public OutputWriter(OutputStream out) {    super(out);   }   public OutputWriter(Writer out) {    super(out);   }   public void close() {    super.close();   }  } }
3,public class Q3 {  static class Pair {   int a;   int b;   Pair(int p, int q) {    a = p;    b = q;   }  }  public static void main(String[] args) {   InputReader in = new InputReader();   int N = in.nextInt();   int arr[] = new int[N];   for (int i = 0; i < N; i++)    arr[i] = in.nextInt();   HashMap<Integer, ArrayList<Pair>> name = new HashMap<>();   for (int i = 0; i < N; i++) {    int sum = 0;    for (int j = i; j < N; j++) {     sum += arr[j];     if (name.get(sum) == null)      name.put(sum, new ArrayList());     name.get(sum).add(new Pair(i+1, j+1));    }   }   HashSet<Pair> ans = new HashSet<>();   for (ArrayList<Pair> n : name.values()) {    Collections.sort(n, new Comparator<Pair>() {     @Override     public int compare(Pair o1, Pair o2) {      if (Integer.compare(o1.b, o2.b) == 0)       return Integer.compare(o1.a, o2.a);      return Integer.compare(o1.b, o2.b);     }    });     HashSet<Pair> temp = new HashSet<>();    temp.add(n.get(0));    int num = 1;    int r = n.get(0).b;    for (int i = 1; i < n.size(); i++) {     if (n.get(i).a > r) {      num++;      r = n.get(i).b;      temp.add(n.get(i));     }    }     if (num > ans.size())     ans = temp;   }   System.out.println(ans.size());   for (Pair val : ans)    System.out.println(val.a + " " + val.b);   }  static class InputReader {   public BufferedReader reader;   public StringTokenizer tokenizer;   public int[] shuffle(int[] arr) {    Random r = new Random();    for (int i = 1, j; i < arr.length; i++) {     j = r.nextInt(i);     arr[i] = arr[i] ^ arr[j];     arr[j] = arr[i] ^ arr[j];     arr[i] = arr[i] ^ arr[j];    }    return arr;   }   public InputReader() {    reader = new BufferedReader(new InputStreamReader(System.in), 32768);    tokenizer = null;   }   public InputReader(InputStream stream) {    reader = new BufferedReader(new InputStreamReader(System.in), 32768);    tokenizer = null;   }   public String next() {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      tokenizer = new StringTokenizer(reader.readLine());     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return tokenizer.nextToken();   }   public char nextChar() {    return next().charAt(0);   }   public int nextInt() {    return Integer.parseInt(next());   }   public long nextLong() {    return Long.parseLong(next());   }   public double nextDouble() {    return Double.parseDouble(next());   }   public int[] nextIntArr(int n) {    int[] arr = new int[n];    for (int i = 0; i < n; i++) {     arr[i] = this.nextInt();    }    return arr;   }   public Integer[] nextIntegerArr(int n) {    Integer[] arr = new Integer[n];    for (int i = 0; i < n; i++)     arr[i] = new Integer(this.nextInt());    return arr;   }   public int[][] next2DIntArr(int n, int m) {    int[][] arr = new int[n][m];    for (int i = 0; i < n; i++) {     for (int j = 0; j < m; j++) {      arr[i][j] = this.nextInt();     }    }    return arr;   }   public int[] nextSortedIntArr(int n) {    int[] arr = new int[n];    for (int i = 0; i < n; i++) {     arr[i] = this.nextInt();    }    Arrays.sort(arr);    return arr;   }   public long[] nextLongArr(int n) {    long[] arr = new long[n];    for (int i = 0; i < n; i++) {     arr[i] = this.nextLong();    }    return arr;   }   public char[] nextCharArr(int n) {    char[] arr = new char[n];    for (int i = 0; i < n; i++) {     arr[i] = this.nextChar();    }    return arr;   }    public static int gcd(int a, int b) {    return b == 0 ? a : gcd(b, a % b);   }   public static int[] uwiSieve(int n) {    if (n <= 32) {     int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31};     for (int i = 0; i < primes.length; i++) {      if (n < primes[i]) {       return Arrays.copyOf(primes, i);      }     }     return primes;    }    int u = n + 32;    double lu = Math.log(u);    int[] ret = new int[(int) (u / lu + u / lu / lu * 1.5)];    ret[0] = 2;    int pos = 1;    int[] isp = new int[(n + 1) / 32 / 2 + 1];    int sup = (n + 1) / 32 / 2 + 1;    int[] tprimes = {3, 5, 7, 11, 13, 17, 19, 23, 29, 31};    for (int tp : tprimes) {     ret[pos++] = tp;     int[] ptn = new int[tp];     for (int i = (tp - 3) / 2; i < tp << 5; i += tp)      ptn[i >> 5] |= 1 << (i & 31);     for (int i = 0; i < tp; i++) {      for (int j = i; j < sup; j += tp)       isp[j] |= ptn[i];     }    }           int[] magic = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17,      9, 6, 16, 5, 15, 14};    int h = n / 2;    for (int i = 0; i < sup; i++) {     for (int j = ~isp[i]; j != 0; j &= j - 1) {      int pp = i << 5 | magic[(j & -j) * 0x076be629 >>> 27];      int p = 2 * pp + 3;      if (p > n)       break;      ret[pos++] = p;      for (int q = pp; q <= h; q += p)       isp[q >> 5] |= 1 << (q & 31);     }    }    return Arrays.copyOf(ret, pos);   }   public static int[] radixSort(int[] f) {    return radixSort(f, f.length);   }   public static int[] radixSort(int[] f, int n) {    int[] to = new int[n];    {     int[] b = new int[65537];     for (int i = 0; i < n; i++) b[1 + (f[i] & 0xffff)]++;     for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];     for (int i = 0; i < n; i++) to[b[f[i] & 0xffff]++] = f[i];     int[] d = f;     f = to;     to = d;    }    {     int[] b = new int[65537];     for (int i = 0; i < n; i++) b[1 + (f[i] >>> 16)]++;     for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];     for (int i = 0; i < n; i++) to[b[f[i] >>> 16]++] = f[i];     int[] d = f;     f = to;     to = d;    }    return f;   }  } }
6,public class B {  static int[][] dist;  static int[] dist1;  static int [] dp;  static int [] path;  static int end,x,y;  static Point[] a;  public static int doit(int mask) {   if(mask==end) return 0;   if(dp[mask]!=-1) return dp[mask];   int min=Integer.MAX_VALUE;   int t;   int i;   for(i=0;i<dist.length;i++)    if(((1<<i)|mask)!=mask) break;    t=2*dist1[i]+doit(mask|(1<<i));    if(t<min) {     min=t;     path[mask]=(1<<i);    }       for(int j=i+1;j<dist.length;j++) {     if(((1<<j)|mask)==mask) continue;     t=dist[i][j]+doit(mask|(1<<i)|(1<<j));     if(t<min) {      min=t;      path[mask]=(1<<i)|(1<<j);     }    }     return dp[mask]=min;  }  public static void main(String[] args) {   Scanner sc=new Scanner(System.in);   x=sc.nextInt();y=sc.nextInt();   a=new Point[sc.nextInt()];   for(int i=0;i<a.length;i++) {    a[i]=new Point(sc.nextInt(), sc.nextInt());   }   end=(1<<a.length)-1;   dp=new int[1<<a.length];   Arrays.fill(dp, -1);   dist=new int[a.length][a.length];   dist1=new int[a.length];   for(int i=0;i<a.length;i++) {    dist1[i]=(a[i].x-x)*(a[i].x-x)+(a[i].y-y)*(a[i].y-y);    for(int j=i+1;j<a.length;j++) {         dist[i][j]=dist1[i]+     (a[j].x-a[i].x)*(a[j].x-a[i].x)+(a[j].y-a[i].y)*(a[j].y-a[i].y)+     (a[j].x-x)*(a[j].x-x)+(a[j].y-y)*(a[j].y-y);        }   }   path=new int[dp.length];   System.out.println(doit(0));   int e=0;   int cur=path[e];   StringBuffer bf=new StringBuffer();   bf.append(0+" ");   int count=0;   for(int i=0;count<a.length;i++) {       for(int j=0;j<a.length;j++) {     if(((1<<j)|cur)==cur) {      bf.append((j+1)+" "); count++;     }    }    e|=cur;    cur=path[e];    bf.append(0+" ");   }   System.out.println(bf);  } }
2,public class Main7{  static class Pair  {   int x;  int y;  public Pair(int x,int y)   {    this.x= x;   this.y= y;  }     @Override   public int hashCode()    {    final int temp = 14;    int ans = 1;    ans =x*31+y*13;    return ans;    }            @Override   public boolean equals(Object o)   {    if (this == o) {    return true;    }    if (o == null) {    return false;    }    if (this.getClass() != o.getClass()) {    return false;    }    Pair other = (Pair)o;    if (this.x != other.x || this.y!=other.y) {    return false;    }    return true;   }     }  static class Pair1  {  String x;  int y;  int z;    }  static class Compare  {    }     public static long pow(long a, long b)  {  long result=1;  while(b>0)  {   if (b % 2 != 0)   {   result=(result*a)%mod;   b--;   }   a=(a*a)%mod;   b /= 2;  }   return result;  }  public static long fact(long num)  {   long value=1;   int i=0;   for(i=2;i<num;i++)   {    value=((value%mod)*i%mod)%mod;   }   return value;   }   public static int gcd(int a, int b)   {   if (a == 0)    return b;   return gcd(b%a, a);   }     public static long sum(int h)   {   return (h*(h+1)/2);   }       static int[] dis;   static int mod=1000000007;   static ArrayList<ArrayList<Integer>> graph;     public static void bfs(int num,int size)   {   boolean[] visited=new boolean[size+1];   Queue<Integer> q=new LinkedList<>();   q.add(num);   ans[num]=1;   visited[num]=true;   while(!q.isEmpty())   {    int x=q.poll();    ArrayList<Integer> al=graph.get(x);    for(int i=0;i<al.size();i++)    {    int y=al.get(i);     if(visited[y]==false)    {     q.add(y);     ans[y]=ans[x]+1;     visited[y]=true;    }    }   }   }   static int[] ans;                              public static int[] sort(int[] a)   {   int n=a.length;   ArrayList<Integer> ar=new ArrayList<>();   for(int i=0;i<a.length;i++)   {    ar.add(a[i]);   }   Collections.sort(ar);   for(int i=0;i<n;i++)   {    a[i]=ar.get(i);   }   return a;   }                                                  static public void main(String args[])throws IOException   {       int n=i();   int k=i();   long low=0;   long high=k;   long fin=0;   long ans=0;   for(int i=1;i<=n;i++)   {    ans+=i;    if(Math.abs(ans-k)+i==n && ans>=k)    {    fin=Math.abs(ans-k);    break;    }   }   pln(fin+"");   }                                               static InputReader in=new InputReader(System.in);   static OutputWriter out=new OutputWriter(System.out);   public static long l()   {    String s=in.String();    return Long.parseLong(s);   }   public static void pln(String value)   {    System.out.println(value);   }   public static int i()   {    return in.Int();   }   public static String s()   {    return in.String();   }  }                                                         class InputReader {      private InputStream stream;   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   private SpaceCharFilter filter;     public InputReader(InputStream stream) {   this.stream = stream;   }     public int read() {   if (numChars== -1)    throw new InputMismatchException();   if (curChar >= numChars) {    curChar = 0;    try {    numChars = stream.read(buf);    } catch (IOException e) {    throw new InputMismatchException();    }    if (numChars <= 0)    return -1;   }   return buf[curChar++];   }     public int Int() {   int c = read();   while (isSpaceChar(c))    c = read();   int sgn = 1;   if (c == '-') {    sgn = -1;    c = read();   }   int res = 0;   do {    if (c < '0' || c > '9')    throw new InputMismatchException();    res *= 10;    res += c - '0';    c = read();   } while (!isSpaceChar(c));   return res * sgn;   }     public String String() {   int c = read();   while (isSpaceChar(c))    c = read();   StringBuilder res = new StringBuilder();   do {    res.appendCodePoint(c);    c = read();   } while (!isSpaceChar(c));   return res.toString();   }     public boolean isSpaceChar(int c) {   if (filter != null)    return filter.isSpaceChar(c);   return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }     public String next() {   return String();   }     public interface SpaceCharFilter {   public boolean isSpaceChar(int ch);   }  }     class OutputWriter {   private final PrintWriter writer;     public OutputWriter(OutputStream outputStream) {   writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));   }     public OutputWriter(Writer writer) {   this.writer = new PrintWriter(writer);   }     public void print(Object...objects) {   for (int i = 0; i < objects.length; i++) {    if (i != 0)    writer.print(' ');    writer.print(objects[i]);   }   }     public void printLine(Object...objects) {   print(objects);   writer.println();   }     public void close() {   writer.close();   }     public void flush() {   writer.flush();   }     }     class IOUtils {     public static int[] readIntArray(InputReader in, int size) {   int[] array = new int[size];   for (int i = 0; i < size; i++)    array[i] = in.Int();   return array;   }     }
5,public class Main {  static Input in;  static Output out;  public static void main(String[] args) throws IOException  {   in = new Input(System.in);   out = new Output(System.out);   run();   out.close();   System.exit(0);  }  private static void run() throws IOException  {   int n = in.nextInt(), k = in.nextInt();   int[] A = new int[n];   for (int i = 0; i < n; i++)   {    A[i] = in.nextInt();   }   Arrays.sort(A);   int count = n;   boolean[] hash = new boolean[n];   for (int i = n-1; i > 0; i--)   {    if(!hash[i])    {     int a = A[i];     if(a % k == 0)     {      int p = a / k;      int j = Arrays.binarySearch(A, p);      if(j >= 0 && j < i)      {       hash[j] = true;       count--;      }     }    }   }   out.print(count);  } } class Input {  final int SIZE = 8192;  private InputStream in;  private byte[] buf = new byte[SIZE];  private int last, current, total;  public Input(InputStream stream) throws IOException  {   in = stream;   last = read();  }  private int read() throws IOException  {   if (total == -1) return -1;   if (current >= total)   {    current = 0;    total = in.read(buf);    if (total <= 0) return -1;   }   return buf[current++];  }  private void advance() throws IOException  {   while (true)   {    if (last == -1) return;    if (!isValidChar(last)) last = read();    else break;   }  }  private boolean isValidChar(int c)  {   return c > 32 && c < 127;  }  public boolean isEOF() throws IOException  {   advance();   return last == -1;  }  public String nextString() throws IOException  {   advance();   if (last == -1) throw new EOFException();   StringBuilder s = new StringBuilder();   while (true)   {    s.appendCodePoint(last);    last = read();    if (!isValidChar(last)) break;   }   return s.toString();  }  public String nextLine() throws IOException  {   if (last == -1) throw new EOFException();   StringBuilder s = new StringBuilder();   while (true)   {    s.appendCodePoint(last);    last = read();    if (last == '\n' || last == -1) break;   }   return s.toString();  }  public String nextLine(boolean ignoreIfEmpty) throws IOException  {   if (!ignoreIfEmpty) return nextLine();   String s = nextLine();   while (s.trim().length() == 0) s = nextLine();   return s;  }  public int nextInt() throws IOException  {   advance();   if (last == -1) throw new EOFException();   int n = 0, s = 1;   if (last == '-')   {    s = -1;    last = read();    if (last == -1) throw new EOFException();   }   while (true)   {    n = n * 10 + last - '0';    last = read();    if (!isValidChar(last)) break;   }   return n * s;  }  public long nextLong() throws IOException  {   advance();   if (last == -1) throw new EOFException();   int s = 1;   if (last == '-')   {    s = -1;    last = read();    if (last == -1) throw new EOFException();   }   long n = 0;   while (true)   {    n = n * 10 + last - '0';    last = read();    if (!isValidChar(last)) break;   }   return n * s;  }  public BigInteger nextBigInt() throws IOException  {   return new BigInteger(nextString());  }  public char nextChar() throws IOException  {   advance();   return (char) last;  }  public double nextDouble() throws IOException  {   advance();   if (last == -1) throw new EOFException();   int s = 1;   if (last == '-')   {    s = -1;    last = read();    if (last == -1) throw new EOFException();   }   double n = 0;   while (true)   {    n = n * 10 + last - '0';    last = read();    if (!isValidChar(last) || last == '.') break;   }   if (last == '.')   {    last = read();    if (last == -1) throw new EOFException();    double m = 1;    while (true)    {     m = m / 10;     n = n + (last - '0') * m;     last = read();     if (!isValidChar(last)) break;    }   }   return n * s;  }  public BigDecimal nextBigDecimal() throws IOException  {   return new BigDecimal(nextString());  }  public void close() throws IOException  {   in.close();   in = null;  } } class Output {  final int SIZE = 8192;  private Writer out;  private char cb[] = new char[SIZE];  private int nChars = SIZE, nextChar = 0;  private char lineSeparator = '\n';  public Output(OutputStream stream)  {   out = new OutputStreamWriter(stream);  }  void flushBuffer() throws IOException  {   if (nextChar == 0) return;   out.write(cb, 0, nextChar);   nextChar = 0;  }  void write(int c) throws IOException  {   if (nextChar >= nChars) flushBuffer();   cb[nextChar++] = (char) c;  }  void write(String s, int off, int len) throws IOException  {   int b = off, t = off + len;   while (b < t)   {    int a = nChars - nextChar, a1 = t - b;    int d = a < a1 ? a : a1;    s.getChars(b, b + d, cb, nextChar);    b += d;    nextChar += d;    if (nextChar >= nChars) flushBuffer();   }  }  void write(String s) throws IOException  {   write(s, 0, s.length());  }  public void print(Object obj) throws IOException  {   write(String.valueOf(obj));  }  public void println(Object obj) throws IOException  {   write(String.valueOf(obj));   write(lineSeparator);  }  public void printf(String format, Object... obj) throws IOException  {   write(String.format(format, obj));  }  public void close() throws IOException  {   flushBuffer();   out.close();   out = null;  } }
2,public class Main {  static class FastScanner {   private BufferedReader bufferedReader;   private StringTokenizer stringTokenizer;   public FastScanner(InputStream inputStream) {    bufferedReader = new BufferedReader(new InputStreamReader(inputStream));   }   public String next() {    while (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {     try {      stringTokenizer = new StringTokenizer(bufferedReader.readLine());     } catch (IOException ignored) {     }    }    return stringTokenizer.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }   public long nextLong() {    return Long.parseLong(next());   }   public double nextDouble() {    return Double.parseDouble(next());   }  }  static class Node implements Comparable {   Node left;   Node right;   private int value;   Node(Node left, Node right, int value) {    this.left = left;    this.right = right;    this.value = value;   }   @Override   public int compareTo(Object o) {    return Integer.compare(this.value, ((Node) o).value);   }  }  private static int fib(int n, int m) {   if (n < 2) return n;   int a = 0;   int b = 1;   for (int i = 0; i < n - 2; i++) {    int c = (a + b) % m;    a = b;    b = c;   }   return (a + b) % m;  }  static long gcd(long a, long b) {   if (b == 0) return a;   return gcd(b, a % b);  }  static long lcm(long a, long b) {   return Math.abs(a * b) / gcd(a, b);  }  static class DSU {   private int[] p;   private int[] r;   DSU(int n) {    p = new int[n];    r = new int[n];    Arrays.fill(p, -1);    Arrays.fill(r, 0);   }   int find(int x) {    if (p[x] < 0) {     return x;    }    return p[x] = find(p[x]);   }   void union(int a, int b) {    a = find(a);    b = find(b);    if (a == b) return;    if (r[a] < r[b]) {     p[a] = b;    } else {     p[b] = a;    }    if (r[a] == r[b]) {     r[a]++;    }   }  }  private static boolean isPrime(long n) {   for (int i = 2; i < n; i++) {    if (n % i == 0) return false;   }   return true;  }  private static double med(Integer[] a) {   Arrays.sort(a);   if (a.length % 2 == 0) {    int r = a.length / 2;    int l = r - 1;    double s = a[l] + a[r];    return s / 2.0;   }   int m = a.length / 2;   return a[m];  }  static Map<Integer, ArrayList<Integer>> g;  static Map<Integer, Integer> color;  static void dfs(int v, int c) {   color.put(v, c);   for (int i = 0; i < g.get(v).size(); i++) {    int u = g.get(v).get(i);    if (!color.containsKey(u)) {     dfs(u, c);    }   }  }  static void reverse(Integer[] a) {   Collections.reverse(Arrays.asList(a));  }  static boolean next(Integer[] a) {   int i = a.length - 1;   while (a[i] == 0) i--;   int c = 0;   while (i >= 0 && a[i] == 1) {    c++;    i--;   }   if (i < 0) return false;   a[i] = 1;   for (int j = i + 1; j < a.length; j++) {    a[j] = 0;   }   c--;   for (int j = 0; j < c; j++) {    a[a.length - 1 - j] = 1;   }   return true;  }  private static int bin(Integer[] a, int l, int r, int x) {   if (l >= r) return l;   int m = (l + r) / 2;   if (a[m] > x) {    return bin(a, l, m, x);   } else if (a[m] < x || (m < a.length - 1 && a[m + 1] == x)) {    return bin(a, m + 1, r, x);   }   return m + 1;  }  private static class SegmentTree {   private long[] d;   private long[] a;   SegmentTree(int n) {    a = new long[n];    d = new long[5 * n];   }   void update(int v, int l, int r, int pos, long val) {    if (l == r) {     d[v] += val;     a[l] += val;    } else {     int mid = (l + r) / 2;     if (pos <= mid) {      update(v * 2, l, mid, pos, val);     } else {      update(v * 2 + 1, mid + 1, r, pos, val);     }     d[v] = d[v * 2] + d[v * 2 + 1];    }   }   int find(int v, int l, int r, long w) {    if (v >= d.length) return -1;    int mid = (l + r) / 2;    if (d[v] <= w) return r;    long o = w - d[v * 2];    if (mid + 1 < a.length && o >= a[mid + 1]) {     return find(v * 2 + 1, mid + 1, r, o);    }    if (w >= a[l])     return find(v * 2, l, mid, w);    return -1;   }   int iterFind(long w) {    if (a[0] > w) return -1;    int l = 0, r = a.length - 1;    int v = 1;    while (d[v] > w) {     int mid = (l + r) / 2;     long o = w - d[v * 2];     if (mid + 1 < a.length && o >= a[mid + 1]) {      l = mid + 1;      v = v * 2 + 1;      w = o;     } else {      v = v * 2;      r = mid;     }    }    return r;   }   int get(int v, int vl, int vr, long w) {       if (d[v] < w) return -1;    if (vl > vr) return -1;    if (vl == vr) {     if (d[v] > w) return vl - 1;     else return -1;    }    if (d[v * 2] > w) return get(v * 2, vl, (vl + vr) / 2, w);    else return get(v * 2 + 1, (vl + vr + 2) / 2, vr, w - d[v * 2]);   }  }  private static class FenwickTree {   long[] t;   FenwickTree(int n) {    t = new long[n];   }   long sum(int r) {    long result = 0;    for (; r >= 0; r = (r & (r + 1)) - 1)     result += t[r];    return result;   }   void inc(int i, long delta) {    int n = t.length;    for (; i < n; i = (i | (i + 1)))     t[i] += delta;   }  }  void insert(List<Long> list, Long element) {   int index = Collections.binarySearch(list, element);   if (index < 0) {    index = -index - 1;   }   list.add(index, element);  }  public static void main(String[] args) {   FastScanner scanner = new FastScanner(System.in);   PrintWriter printer = new PrintWriter(System.out);   long n = scanner.nextLong();   long k = scanner.nextLong();   long l = 1;   long r = n;   while(true){    long m = (l + r) / 2;    long x = (m * (m + 1)) / 2;    x -= n - m;    if (x == k) {     printer.println(n - m);     break;    } else if (x < k) {     l = m + 1;    } else {     r = m - 1;    }   }   printer.flush();   printer.close();  } }
5,public class A {  public static void main(String[] args) throws Exception {   new A().solve();       }  void solve() throws IOException {   BufferedReader in = new BufferedReader(new InputStreamReader(System.in));     String[] sp;    sp = in.readLine().split(" ");   int n = Integer.parseInt(sp[0]);   long k = Integer.parseInt(sp[1]);   Long[] a = new Long[n];   sp = in.readLine().split(" ");   for (int i = 0; i < n; i++) {    a[i] = (long) Integer.parseInt(sp[i]);   }   Arrays.sort(a);   TreeSet<Long> set = new TreeSet<Long>();   for (int i = 0; i < n; i++) {    long x = a[i];    if (!set.contains(x)) {     set.add(x * k);    }   }   System.out.println(set.size());  } }
1,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   OutputWriter out = new OutputWriter(outputStream);   TaskA solver = new TaskA();   solver.solve(1, in, out);   out.close();  }  static class TaskA {   public void solve(int testNumber, InputReader in, OutputWriter out) {    int n = in.nextInt();    String arr1[] = new String[n];    String arr2[] = new String[n];    int i, j, count = 0;    for (i = 0; i < n; i++) {     arr1[i] = in.nextString();    }    for (i = 0; i < n; i++) {     arr2[i] = in.nextString();     for (j = 0; j < n; j++) {      if (arr2[i].equals(arr1[j])) {       arr1[j] = "";       count++;       break;      }     }    }    out.println(n - count);   }  }  static class InputReader {   private InputStream stream;   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   private InputReader.SpaceCharFilter filter;   public InputReader(InputStream stream) {    this.stream = stream;   }   public int read() {    if (numChars == -1) {     throw new InputMismatchException();    }    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (numChars <= 0) {      return -1;     }    }    return buf[curChar++];   }   public int nextInt() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if (c < '0' || c > '9') {      throw new InputMismatchException();     }     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   public String nextString() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    StringBuilder res = new StringBuilder();    do {     if (Character.isValidCodePoint(c)) {      res.appendCodePoint(c);     }     c = read();    } while (!isSpaceChar(c));    return res.toString();   }   public boolean isSpaceChar(int c) {    if (filter != null) {     return filter.isSpaceChar(c);    }    return isWhitespace(c);   }   public static boolean isWhitespace(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   public interface SpaceCharFilter {    public boolean isSpaceChar(int ch);   }  }  static class OutputWriter {   private final PrintWriter writer;   public OutputWriter(OutputStream outputStream) {    writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));   }   public OutputWriter(Writer writer) {    this.writer = new PrintWriter(writer);   }   public void close() {    writer.close();   }   public void println(int i) {    writer.println(i);   }  } }
6,public class Songs {  static class Reader  {   final private int BUFFER_SIZE = 1 << 16;   private DataInputStream din;   private byte[] buffer;   private int bufferPointer, bytesRead;    public Reader()   {    din = new DataInputStream(System.in);    buffer = new byte[BUFFER_SIZE];    bufferPointer = bytesRead = 0;   }    public Reader(String file_name) throws IOException   {    din = new DataInputStream(new FileInputStream(file_name));    buffer = new byte[BUFFER_SIZE];    bufferPointer = bytesRead = 0;   }    public String readLine() throws IOException   {    byte[] buf = new byte[1000000];    int cnt = 0, c;    while ((c = read()) != -1)    {     if (c == '\n')      break;     buf[cnt++] = (byte) c;    }    return new String(buf, 0, cnt);   }    public int nextInt() throws IOException   {    int ret = 0;    byte c = read();    while (c <= ' ')     c = read();    boolean neg = (c == '-');    if (neg)     c = read();    do    {     ret = ret * 10 + c - '0';    } while ((c = read()) >= '0' && c <= '9');     if (neg)     return -ret;    return ret;   }    public long nextLong() throws IOException   {    long ret = 0;    byte c = read();    while (c <= ' ')     c = read();    boolean neg = (c == '-');    if (neg)     c = read();    do {     ret = ret * 10 + c - '0';    }    while ((c = read()) >= '0' && c <= '9');    if (neg)     return -ret;    return ret;   }    public double nextDouble() throws IOException   {    double ret = 0, div = 1;    byte c = read();    while (c <= ' ')     c = read();    boolean neg = (c == '-');    if (neg)     c = read();     do {     ret = ret * 10 + c - '0';    }    while ((c = read()) >= '0' && c <= '9');     if (c == '.')    {     while ((c = read()) >= '0' && c <= '9')     {      ret += (c - '0') / (div *= 10);     }    }     if (neg)     return -ret;    return ret;   }    private void fillBuffer() throws IOException   {    bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);    if (bytesRead == -1)     buffer[0] = -1;   }    private byte read() throws IOException   {    if (bufferPointer == bytesRead)     fillBuffer();    return buffer[bufferPointer++];   }    public void close() throws IOException   {    if (din == null)     return;    din.close();   }  }   static int findPos(int x, int ar[]){   for(int i=0;i<ar.length;i++){    if(ar[i]==x)     return (i+1);   }   return -20;  }  public static void main(String args[])throws IOException{   Reader sc=new Reader();   PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));   int i,j;   int n=sc.nextInt();   int tt=sc.nextInt();   int t[]=new int[n];   int g[]=new int[n];   int last=0;   int M=1000000007;   long sum=0;   for(i=0;i<n;i++){    t[i]=sc.nextInt();    g[i]=sc.nextInt()-1;   }   int d[][]=new int[1<<n][4];   d[0][3]=1;   for(i=0;i<(1<<n);i++){    for(last=0;last<4;last++){     for(j=0;j<n;j++){      if(g[j]!=last&&((i&(1<<j)))==0){       d[i^(1<<j)][g[j]]=(d[i^(1<<j)][g[j]]+d[i][last])%M;            }     }    }    int dur=0;    for(j=0;j<n;j++){     if((i&(1<<j))>0){      dur+=t[j];     }    }    if(dur==tt){         sum=(sum+d[i][0]+d[i][1]+d[i][2])%M;    }   }   pw.println(sum);   pw.close();  } }
4,public class Main {  public static void main(String[] args) {   InputStream inputStream;   try {    inputStream = new FileInputStream("input.txt");   } catch (IOException e) {    throw new RuntimeException(e);   }   OutputStream outputStream;   try {    outputStream = new FileOutputStream("output.txt");   } catch (IOException e) {    throw new RuntimeException(e);   }   InputReader in = new InputReader(inputStream);   OutputWriter out = new OutputWriter(outputStream);   CFireAgain solver = new CFireAgain();   solver.solve(1, in, out);   out.close();  }  static class CFireAgain {   private int n;   private int m;   private int K;   private boolean[][] vis;   private Queue<Util.Pair<Integer>> queue = new LinkedList<>();   private Util.Pair<Integer> p;   private boolean isValid(int x, int y) {    return x >= 1 && x <= n && y >= 1 && y <= m && !vis[x][y];   }   private void bfs() {    while (!queue.isEmpty()) {     p = queue.poll();     if (isValid(p.x + 1, p.y)) {      queue.offer(new Util.Pair<>(p.x + 1, p.y));      vis[p.x + 1][p.y] = true;     }     if (isValid(p.x - 1, p.y)) {      queue.offer(new Util.Pair<>(p.x - 1, p.y));      vis[p.x - 1][p.y] = true;     }     if (isValid(p.x, p.y + 1)) {      queue.offer(new Util.Pair<>(p.x, p.y + 1));      vis[p.x][p.y + 1] = true;     }     if (isValid(p.x, p.y - 1)) {      queue.offer(new Util.Pair<>(p.x, p.y - 1));      vis[p.x][p.y - 1] = true;     }    }   }   public void solve(int testNumber, InputReader in, OutputWriter out) {    n = in.nextInt();    m = in.nextInt();    K = in.nextInt();    vis = new boolean[n + 1][m + 1];    for (int i = 0; i < K; i++) {     int a = in.nextInt(), b = in.nextInt();     vis[a][b] = true;     queue.offer(new Util.Pair<>(a, b));    }    bfs();    out.println(p.x + " " + p.y);    out.flush();   }  }  static class OutputWriter {   private final PrintWriter writer;   private ArrayList<String> res = new ArrayList<>();   private StringBuilder sb = new StringBuilder("");   public OutputWriter(OutputStream outputStream) {    writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));   }   public OutputWriter(Writer writer) {    this.writer = new PrintWriter(writer);   }   public void println(Object... objects) {    for (int i = 0; i < objects.length; i++) {     sb.append(objects[i]);    }    res.add(sb.toString());    sb = new StringBuilder("");   }   public void close() {    writer.close();   }   public void flush() {    for (String str : res) writer.printf("%s\n", str);    res.clear();    sb = new StringBuilder("");   }  }  static class Util {   public static class Pair<T> {    public T x;    public T y;    public Pair(T x, T y) {     this.x = x;     this.y = y;    }    public boolean equals(Object obj) {     if (obj == this) return true;     if (!(obj instanceof Util.Pair)) return false;     Util.Pair<T> pair = (Util.Pair<T>) obj;     return this.x == pair.x && this.y == pair.y;    }    public String toString() {     return ("(" + this.x + "," + this.y + ")");    }    public int hashCode() {     return Objects.hash(x, y);    }   }  }  static class InputReader {   private InputStream stream;   private byte[] buf = new byte[8192];   private int curChar;   private int numChars;   public InputReader(InputStream stream) {    this.stream = stream;   }   public InputReader(FileInputStream file) {    this.stream = file;   }   public int read() {    if (numChars == -1) {     throw new InputMismatchException();    }    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (numChars <= 0) {      return -1;     }    }    return buf[curChar++];   }   public int nextInt() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if (c < '0' || c > '9') {      throw new InputMismatchException();     }     res = (res << 3) + (res << 1) + c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   private boolean isSpaceChar(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }  } }
3,public class A {  String filename = "";  final int INF = 1_000_000_000;  void solve() {   int n = readInt();   int[] a = new int[n];   for(int i = 0;i<n;i++){    a[i] = readInt();   }   Map<Integer, Integer>[] maps = new Map[n];   Map<Integer, Integer> sums = new HashMap();   for(int i = 0;i<n;i++){    maps[i] = new HashMap<>();   }   for(int i = 0;i<n;i++){    int summ = 0;    for(int j = i;j<n;j++){     summ += a[j];     if(!maps[i].containsKey(summ)) maps[i].put(summ, j);     int x = sums.getOrDefault(summ, 0);     sums.put(summ, x + 1);    }   }   int max = 0;   int goodSumm = 0;   for(int summ : sums.keySet()){    if(sums.get(summ) <= max) continue;    int right = -1;    int ans = 0;    for(int j = 0;j<n;j++){     if(!maps[j].containsKey(summ)) continue;     int end = maps[j].get(summ);     if(right == -1){      right = end;      ans++;      continue;     }     if(j > right){      right = end;      ans++;      continue;     }     if(end < right){      right = end;     }    }    if(max < ans){     max = ans;     goodSumm = summ;    }   }   int left = -1;   int right = -1;   List<Integer> ans = new ArrayList<>();   for(int j = 0;j<n;j++){    if(!maps[j].containsKey(goodSumm)) continue;    int start = j;    int end = maps[j].get(goodSumm);    if(right == -1){     left = j;     right = end;     continue;    }    if(start > right){     ans.add(left + 1);     ans.add(right + 1);     left = start;     right = end;     continue;    }    if(end < right){     left = start;     right = end;    }   }   ans.add(left + 1);   ans.add(right + 1);   out.println(max);   for(int i = 0;i<ans.size();i+=2){    out.println(ans.get(i) + " " + ans.get(i + 1));   }  }  public static void main(String[] args) throws FileNotFoundException {   new A().run();  }  void run() throws FileNotFoundException {   init();   solve();   out.close();  }  BufferedReader in;  PrintWriter out;  StringTokenizer tok = new StringTokenizer("");  void init() throws FileNotFoundException {   if(!filename.equals("")) {    in = new BufferedReader(new FileReader(new File(filename + ".in")));    out = new PrintWriter(new File(filename + ".out"));    return;   }   in = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);  }  String readLine(){   try{    return in.readLine();   }catch (Exception e){    throw new RuntimeException(e);   }  }  String readString(){   while(!tok.hasMoreTokens()){    String nextLine = readLine();    if(nextLine == null) return null;    tok = new StringTokenizer(nextLine);   }   return tok.nextToken();  }  int readInt(){   return Integer.parseInt(readString());  }  long readLong(){   return Long.parseLong(readString());  } }
5,public class Codeforces_2012_08_31_A {  public static void main(String[] args) throws IOException {     StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));   PrintWriter out = new PrintWriter(System.out);   in.nextToken();   int n = (int) in.nval;   int[] a = new int[n];   for (int i=0; i<n; i++) {    in.nextToken();    a[i] = (int) in.nval;   }   int[] b = Arrays.copyOf(a, n);   Arrays.sort(a);   int k = 0;   for (int i=0; i<n; i++) {    if (a[i] != b[i]) k++;   }   if (k==0 || k==2)    out.println("YES");   else    out.println("NO");   out.flush();   out.close();  } }
5,public class Main {  public static void main(String[] args) {   Scanner s = new Scanner(System.in);     int n = s.nextInt();   int m = s.nextInt();   int k = s.nextInt();     int a[] = new int [n];   for (int i = 0; i < a.length; i++) {    a[i] = s.nextInt();   }   int ans = 0;     while(k < m){    k--;    int max = -1;    int ix = -1;    for (int i = 0; i < a.length; i++) {     if(a[i] > max){      max = a[i];      ix = i;     }    }    if(ix == -1){     System.out.println("-1");     return ;    }    k += a[ix];    a[ix] = -1;    ans++;   }   System.out.println(ans);  } }
2,public class Main implements Runnable {  public void _main() throws IOException {  long n = nextLong();  long m = nextLong();  long k = nextLong();  long numBlocks = Math.min(Math.min(n / k, n - m), m / (k - 1));  n -= numBlocks * k;  m -= numBlocks * (k - 1);  long numFullBlocks = m / k;  long rem = m % k;  long res = 0;  res = (res + ((p2(numFullBlocks + 1) + MOD - 2) % MOD) * k) % MOD;  res = (res + rem) % MOD;  res = (res + numBlocks * (k - 1)) % MOD;  out.println(res); }  final int MOD = 1000000009; private long p2(long s) {  long res = 1;  long x = 2;  while (s > 0) {  if (s % 2 == 1) {   res = res * x % MOD;  }  x = x * x % MOD;  s /= 2;  }  return res; }  private BufferedReader in; private PrintWriter out; private StringTokenizer st;  private String next() throws IOException {  while (st == null || !st.hasMoreTokens()) {  String rl = in.readLine();  if (rl == null)   return null;  st = new StringTokenizer(rl);  }  return st.nextToken(); }  private int nextInt() throws IOException {  return Integer.parseInt(next()); }  private long nextLong() throws IOException {  return Long.parseLong(next()); }  private double nextDouble() throws IOException {  return Double.parseDouble(next()); }  public static void main(String[] args) {  Locale.setDefault(Locale.UK);  new Thread(new Main()).start(); }  public void run() {  try {  in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);       _main();   out.close();  } catch (Exception e) {  e.printStackTrace();  System.exit(202);  } } }
4,public class phoenix_and_computers {  public static void main(String[] args) throws NumberFormatException, IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  String[] st = br.readLine().split(" ");  int n = Integer.parseInt(st[0]);  int m = Integer.parseInt(st[1]);  long[][] ncr = ncrcoll(405, 405, m);  int[] p2 = new int[n + 1];  p2[0] = 1;  for (int i = 1; i < p2.length; i++) {  p2[i] = 2 * p2[i - 1] % m;  }  long[][] dp = new long[405][405];  dp[0][0] = 1;  for (int i = 0; i < n; i++) {  for (int j = 0; j <= i; j++) {   for (int k = 1; i + k <= n; k++) {   dp[i + k + 1][j + k] += ((dp[i][j] * p2[k - 1]) % m * ncr[j + k][k]);   dp[i + k + 1][j + k] %= m;   }  }  }  long ans = 0;  for (int i = 0; i <= n; i++) {  ans = (ans + dp[n + 1][i]) % m;  }  System.out.println(ans); }  static long[][] ncrcoll(int n, int k, int p) {  long[][] arr = new long[n + 1][k + 1];  for (int i = 1; i < arr.length; i++) {  arr[i][0] = 1;  }  for (int i = 1; i < arr.length; i++) {  for (int j = 1; j <= i && j < arr[0].length; j++) {   if (i == 1 && j == 1) {   arr[i][j] = 1;   } else {   arr[i][j] = (arr[i - 1][j] + arr[i - 1][j - 1]) % (p);   }  }  }  return arr; }  public static long xpown(long x, long n) {  long res = 1;  while (n > 0) {  if (n % 2 != 0) {   res = (res * x) % 1000000007;   n--;  } else {   x = (x * x) % 1000000007;   n = n / 2;  }  }  return res; } }
4,public class FireAgain {  int k, i, j,n,m,x,y;  void run() {   try {    BufferedReader bfd = new BufferedReader(new FileReader("input.txt"));    BufferedWriter out = new BufferedWriter(new FileWriter("output.txt"));    StringTokenizer tk = new StringTokenizer(bfd.readLine());       n = Integer.parseInt(tk.nextToken());    m = Integer.parseInt(tk.nextToken());    boolean vis[][] = new boolean[n][m];    k = Integer.parseInt(bfd.readLine());    tk = new StringTokenizer(bfd.readLine());    Queue<Point> q = new LinkedList<Point>();    Point last = new Point(0,0);    while(k-->0){     x = Integer.parseInt(tk.nextToken())-1;     y = Integer.parseInt(tk.nextToken())-1;     q.add(new Point(x,y));     vis[x][y] = true;    }    while(!q.isEmpty()) {     Point frnt = q.poll();     for(i=frnt.x-1;i<=frnt.x+1;++i)      for(j=frnt.y-1;j<=frnt.y+1;++j)       if(val(i,j)&& !vis[i][j]&&(frnt.x==i||frnt.y==j)){        q.add(new Point(i,j));        last = new Point(i,j);        vis[i][j] = true;       }    }    out.write(last.x+1 + " " +(last.y+1)+"\n");    out.flush();    out.close();   } catch (Exception e) {   }  }   boolean val(int x,int y){   return x>=0&&x<n&&y>=0&&y<m;  }  public static void main(String[] args) {   new FireAgain().run();  } }
6,public class C {  static int K; static int sz[]; static long vs[][]; static long curSum[]; static HashMap<Long, Integer> valToBucket; static long sum; static int maskIfPick[][]; static int dp[];  static int pickId[]; static int newBox[]; public static void main(String[] args) {  FS in = new FS();  K = in.nextInt();  sz = new int[K];  valToBucket = new HashMap<Long, Integer>();  vs = new long[K][];  curSum = new long[K];  sum = 0;  for(int i = 0; i < K; i++) {  sz[i] = in.nextInt();  vs[i] = new long[sz[i]];  for(int j = 0; j < sz[i]; j++) {   long v = in.nextLong();   sum += v;   curSum[i] += v;   vs[i][j] = v;   valToBucket.put(v, i);  }  }   if(sum % K != 0) {  System.out.println("No");  return;  }   sum /= K;  maskIfPick = new int[K][];   for(int i = 0; i < K; i++) {  maskIfPick[i] = new int[sz[i]];  for(int j = 0; j < sz[i]; j++) {     int mask = (1<<i);   boolean works = false;   long curLookfor = (sum - (curSum[i]-vs[i][j]));   while(true) {   if(!valToBucket.containsKey(curLookfor)) break;   int nextBucket = valToBucket.get(curLookfor);   if(nextBucket == i) {    works = curLookfor == vs[i][j];    break;   }   else if((mask & (1<<nextBucket)) > 0) break;   else {    mask |= (1<<nextBucket);    curLookfor = (sum - (curSum[nextBucket]-curLookfor));   }   }   if(works) maskIfPick[i][j] = mask;  }  }  dp = new int[1<<K];  Arrays.fill(dp, -1);  int res = go(0);  if(res == 0) {  System.out.println("No");  }  else {  System.out.println("Yes");  pickId = new int[K];  newBox = new int[K];  Arrays.fill(pickId, -1);  buildback(0);  for(int i = 0; i < K; i++) {   System.out.println(vs[i][pickId[i]]+" "+(newBox[i]+1));  }  }   }  static void pick(int i, int j) {  if(pickId[i] != -1) return;  pickId[i] = j;   long curLookfor = (sum - (curSum[i]-vs[i][j]));  int nextBucket = valToBucket.get(curLookfor);  newBox[nextBucket] = i;  for(int k = 0; k < sz[nextBucket]; k++) {  if(vs[nextBucket][k] == curLookfor) pick(nextBucket, k);  } }  static int go(int mask) {  if(mask+1 == (1<<K)) return 1;  if(dp[mask] != -1) return dp[mask];   int bit = -1;  for(int i = 0; i < K; i++) {  if((mask & (1<<i)) == 0) { bit = i; break;}  }   int res = 0;   for(int take = 0; take < sz[bit]; take++) {  int newMask = maskIfPick[bit][take];  if(newMask == 0 || (mask & newMask) > 0) continue;  res = (res | go(mask | newMask));  }   return dp[mask] = res; }  static void buildback(int mask) {  if(mask+1 == (1<<K)) return;    int bit = -1;  for(int i = 0; i < K; i++) {  if((mask & (1<<i)) == 0) { bit = i; break;}  }   int res = 0;   for(int take = 0; take < sz[bit]; take++) {  int newMask = maskIfPick[bit][take];  if(newMask == 0 || (mask & newMask) > 0) continue;  res = (res | go(mask | newMask));  if(res == 1) {   pick(bit, take);   buildback(mask | newMask);   break;  }  } }   static class FS{  BufferedReader br;  StringTokenizer st;  public FS() {  br = new BufferedReader(new InputStreamReader(System.in));  }  String next() {  while(st == null || !st.hasMoreElements()) {   try {st = new StringTokenizer(br.readLine());}   catch(Exception e) { throw null;}  }  return st.nextToken();  }  int nextInt() { return Integer.parseInt(next());}  double nextDouble() { return Double.parseDouble(next());}  long nextLong() { return Long.parseLong(next());} }  }
1,public class Main {  static MyScanner scan;  static PrintWriter pw;  public static void main(String[] args) {   new Thread(null,null,"_",1<<25)   {    public void run()    {     try     {      solve();     }     catch(Exception e)     {      e.printStackTrace();      System.exit(1);     }    }   }.start();  }  static void solve() throws IOException {   scan = new MyScanner();   pw = new PrintWriter(System.out, true);   StringBuilder sb = new StringBuilder();   int n = ni();   int d = ni();   int arr[] = new int[n];   int cnt = 2;   for(int i=0;i<n;++i)    arr[i] = ni();   for(int i=0;i<n-1;++i)   {    if(arr[i+1]-d==arr[i]+d)    {     ++cnt;     continue;    }    if(arr[i+1]-(arr[i]+d)>d)     ++cnt;    if((arr[i+1]-d)-arr[i]>d)     ++cnt;   }   pl(cnt);   pw.flush();   pw.close();  }  static long MMI(long A,long MOD)  {   return modpow(A,MOD-2,MOD);  }  static long modpow(long x,long y,long MOD)  {   if(y==0)    return 1;   if((y&1)==0)    return modpow((x*x)%MOD,y>>1,MOD);   else return (x*modpow(x,y-1,MOD))%MOD;  }  static class Pair implements Comparable<Pair>  {   int x,y;   Pair(int x,int y)   {    this.x=x;    this.y=y;   }   public int compareTo(Pair other)   {    if(this.x!=other.x)     return this.x-other.x;    return this.y-other.y;   }   public String toString()   {    return "{"+x+","+y+"}";   }  }  static int ni() throws IOException  {   return scan.nextInt();  }  static long nl() throws IOException  {   return scan.nextLong();  }  static double nd() throws IOException  {   return scan.nextDouble();  }  static String ne() throws IOException  {   return scan.next();  }  static String nel() throws IOException  {   return scan.nextLine();  }  static void pl()  {   pw.println();  }  static void p(Object o)  {   pw.print(o+" ");  }  static void pl(Object o)  {   pw.println(o);  }  static void psb(StringBuilder sb)  {   pw.print(sb);  }  static class MyScanner  {   BufferedReader br;   StringTokenizer st;   MyScanner()   {    br = new BufferedReader(new InputStreamReader(System.in));   }   String nextLine()throws IOException   {    return br.readLine();   }   String next() throws IOException   {    if(st==null || !st.hasMoreTokens())     st = new StringTokenizer(br.readLine());    return st.nextToken();   }   int nextInt() throws IOException   {    return Integer.parseInt(next());   }   long nextLong() throws IOException   {    return Long.parseLong(next());   }   double nextDouble() throws IOException   {    return Double.parseDouble(next());   }  } }
3,public class Test {  int readInt() {   int ans = 0;   boolean neg = false;   try {    boolean start = false;    for (int c = 0; (c = System.in.read()) != -1; ) {     if (c == '-') {      start = true;      neg = true;      continue;     } else if (c >= '0' && c <= '9') {      start = true;      ans = ans * 10 + c - '0';     } else if (start) break;    }   } catch (IOException e) {   }   return neg ? -ans : ans;  }  final int N = 5010;  final int M = 1_000_000_007;  long[][] dp = new long[2][N];  long[] sums = new long[N];  char[] p = new char[N];  Scanner sca = new Scanner(System.in);  void start() {   int n = Integer.parseInt(sca.nextLine());   int idx = 0;   Arrays.fill(dp[idx], 0);   dp[idx][0] = 1;   for (int i = 0; i < n; i++) p[i] = sca.nextLine().charAt(0);   for (int i = 0; i < n;) {    int nidx = idx ^ 1;    Arrays.fill(dp[nidx], 0);    Arrays.fill(sums, 0);    int j = i;    while (p[j] != 's') j++;    int levels = j - i;    i = j+1;    for (j = n; j >= 0; j--) {     sums[j] = sums[j + 1] + dp[idx][j];     if (sums[j] >= M) sums[j] -= M;    }    for (j = 0; j <= n; j++) {     int ind = j + levels;     if (ind > n) continue;     dp[nidx][ind] = sums[j];    }    idx = nidx;   }   long ans = 0;   for (int i = 0; i <= n; i++) {    ans += dp[idx][i];    if (ans >= M) ans -=M;   }   System.out.println(ans);  }  public static void main(String[] args) {   new Test().start();  } }
1,public class Main {  public static void main(String []args)throws Exception  {   BufferedReader br=new BufferedReader(new InputStreamReader(System.in));   int n=0;   n=Integer.parseInt(br.readLine());   String inp="";   inp=br.readLine();   int no[]=new int[n];   String tinp[]=inp.split(" ");   for(int i=0;i<n;i++)   {    no[i]=Integer.parseInt(tinp[i]);   }   int eve=0,odd=0;   for(int i=0;i<3;i++)   {    int rem=no[i]%2;    if(rem==0)     eve++;    else     odd++;   }     if(eve>1)     {      for(int i=0;i<n;i++)      {       if(no[i]%2==1)       {        System.out.println(i+1);        break;       }      }     }     else     {      for(int i=0;i<n;i++)      {       if(no[i]%2==0)       {        System.out.println(i+1);        break;       }      }        }      } }
1,public class Main {  public static void main (String[] argv)  {  new Main(); }       boolean test = false;     public Main() {  FastReader in = new FastReader(new BufferedReader(new InputStreamReader(System.in)));    int n = in.nextInt();  int nM = 0;  int[] nS = new int[4];  int[] nL = new int[4];  for (int i = 0; i < n; i++) {   String s = in.next();   int ns = s.length();   if (s.charAt(0) == 'M') nM++;   else if (s.charAt(ns - 1) == 'S') nS[ns-1]++;   else nL[ns-1]++;  }  int c = 0;  int[] nSr = new int[4];  int[] nLr = new int[4];  int nMr = 0;  for (int i = 0; i < n; i++) {   String s = in.next();   int ns = s.length();   if (s.charAt(0) == 'M') {    if (nM > 0) --nM;    else ++nMr;   }else if (s.charAt(ns - 1) == 'S') {    if (nS[ns-1] > 0) --nS[ns-1];    else ++nSr[ns-1];   }else {    if (nL[ns-1] > 0) --nL[ns-1];    else ++nLr[ns-1];   }    }    for (int i = 0; i < 4; i++) c += nS[i] + nL[i];  c += nM;    System.out.println(c); }      private int nBit1(int v) {  int v0 = v;  int c = 0;  while (v != 0) {   ++c;   v = v & (v - 1);  }  return c; }  private int common(int v) {  int c = 0;  while (v != 1) {   v = (v >>> 1);   ++c;  }    return c; }  private void reverse(char[] a, int i, int j) {  while (i < j) {   swap(a, i++, j--);  } }  private void swap(char[] a, int i, int j) {  char t = a[i];  a[i] = a[j];  a[j] = t; }   private long gcd(long x, long y) {  if (y == 0) return x;  return gcd(y, x % y); } private int max(int a, int b) {  return a > b ? a : b; }  private int min(int a, int b) {  return a > b ? b : a; }   static class FastReader  {   BufferedReader br;   StringTokenizer st;    public FastReader(BufferedReader in)   {       br = in;   }    String next()   {    while (st == null || !st.hasMoreElements())    {     try     {      String line = br.readLine();      if (line == null || line.length() == 0) return "";      st = new StringTokenizer(line);     }     catch (IOException e)     {      return "";          }    }    return st.nextToken();   }    int nextInt()   {    return Integer.parseInt(next());   }    long nextLong()   {    return Long.parseLong(next());   }    double nextDouble()   {    return Double.parseDouble(next());   }    String nextLine()   {    String str = "";    try    {     str = br.readLine();    }    catch (IOException e)    {     return "";        }    return str;   }  } }
1,public class B {  void run(){   Scanner sc = new Scanner(System.in);   int n = sc.nextInt(), k = sc.nextInt();   int[] a = new int[n+1];   for(int i=1;i<=n;i++)a[i]=sc.nextInt();   int[] c = new int[100001];   int num = 0;   int ri = -1, rj = -1;   int s = 1, t = 0;   while(t<n){    t++;    if(c[a[t]]==0){     num++;    }    c[a[t]]++;    for(;k<=num;s++){     if(ri==-1 || rj-ri+1>t-s+1){      ri = s; rj = t;     }     c[a[s]]--;     if(c[a[s]]==0){      num--;     }    }   }   System.out.println(ri+" "+rj);  }   void debug(Object...o){   System.out.println(Arrays.deepToString(o));  }   public static void main(String[] args) {   new B().run();  } }
6,public class r568p8{  private static InputReader sc;  private static PrintWriter pw;  private static long mod;  static class InputReader {   private final InputStream stream;   private final byte[] buf = new byte[8192];   private int curChar, snumChars;   private SpaceCharFilter filter;   InputReader(InputStream stream) {    this.stream = stream;   }   int snext() {    if (snumChars == -1)     throw new InputMismatchException();    if (curChar >= snumChars) {     curChar = 0;     try {      snumChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (snumChars <= 0)      return -1;    }    return buf[curChar++];   }   int nextInt() {    int c = snext();    while (isSpaceChar(c)) {     c = snext();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = snext();    }    int res = 0;    do {     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = snext();    } while (!isSpaceChar(c));    return res * sgn;   }   long nextLong() {    int c = snext();    while (isSpaceChar(c)) {     c = snext();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = snext();    }    long res = 0;    do {     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = snext();    } while (!isSpaceChar(c));    return res * sgn;   }   String readString() {    int c = snext();    while (isSpaceChar(c)) {     c = snext();    }    StringBuilder res = new StringBuilder();    do {     res.appendCodePoint(c);     c = snext();    } while (!isSpaceChar(c));    return res.toString();   }   String nextLine() {    int c = snext();    while (isSpaceChar(c))     c = snext();    StringBuilder res = new StringBuilder();    do {     res.appendCodePoint(c);     c = snext();    } while (!isEndOfLine(c));    return res.toString();   }   boolean isSpaceChar(int c) {    if (filter != null)     return filter.isSpaceChar(c);    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   private boolean isEndOfLine(int c) {    return c == '\n' || c == '\r' || c == -1;   }   public interface SpaceCharFilter {    boolean isSpaceChar(int ch);   }  }  public static void main(String args[]) {   sc = new InputReader(System.in);   pw = new PrintWriter(System.out);   int t = 1;   while(t-->0)    solve();   pw.flush();   pw.close();  }  private static void fill_matrix(long dp[][][][], int a, int b, int c, int end){   if((a == 0 && b == 0 && c == 0) || (a == 0 && end == 0) || (b == 0 && end == 1) || (c == 0 && end == 2)){    dp[a][b][c][end] = 0;    return;   }   if(a > 1 && b == 0 && c == 0){    dp[a][b][c][end] = 0;    return;   }   if(b > 1 && a == 0 && c == 0){    dp[a][b][c][end] = 0;    return;   }   if(c > 1 && a == 0 && b == 0){    dp[a][b][c][end] = 0;    return;   }   if(a == 1 && end == 0 && b == 0 && c == 0){    dp[a][b][c][end] = 1;    return;   }   if(b == 1 && end == 1 && a == 0 && c == 0){    dp[a][b][c][end] = 1;    return;   }   if(c == 1 && end == 2 && b == 0 && a == 0){    dp[a][b][c][end] = 1;    return;   }   if(end == 0){    fill_matrix(dp, a-1, b, c, 1);    fill_matrix(dp, a-1, b, c, 2);    dp[a][b][c][0] = (dp[a-1][b][c][1]%mod + dp[a-1][b][c][2]%mod)%mod;   }   else if(end == 1){    fill_matrix(dp, a, b-1, c, 0);    fill_matrix(dp, a, b-1, c, 2);    dp[a][b][c][1] = (dp[a][b-1][c][0]%mod + dp[a][b-1][c][2]%mod)%mod;   }   else{    fill_matrix(dp, a, b, c-1, 0);    fill_matrix(dp, a, b, c-1, 1);    dp[a][b][c][2] = (dp[a][b][c-1][0]%mod + dp[a][b][c-1][1]%mod)%mod;   }  }  private static long cal(int count[]){   int a = count[0], b = count[1], c = count[2];   long dp[][][][] = new long[a+1][b+1][c+1][3];   long factorial[] = new long[20];   factorial[0] = 1;   factorial[1] = 1;   for(int i=2; i<20; i++)    factorial[i] = (factorial[i-1]%mod*i%mod)%mod;   fill_matrix(dp, a, b, c, 0);   fill_matrix(dp, a, b, c, 1);   fill_matrix(dp, a, b, c, 2);    long p = (dp[a][b][c][0]%mod + dp[a][b][c][1]%mod + dp[a][b][c][2]%mod)%mod;    long ans = (((p%mod * factorial[a]%mod)%mod * factorial[b]%mod)%mod * factorial[c]%mod)%mod;    return ans;  }  private static void solve(){   int n = sc.nextInt(), T = sc.nextInt();   int len[] = new int[n], genre[] = new int[n];   for(int i=0; i<n; i++){    len[i] = sc.nextInt();    genre[i] = sc.nextInt();   }   int sum[] = new int[(1<<n)];   mod = (long)1e9 + 7;   long ans = 0;   for(int i=1; i<(1<<n); i++){    for(int j=0; j<15; j++){     if((i&(1<<j)) != 0){      sum[i] = sum[i^(1<<j)] + len[j];      break;     }    }    if(sum[i] == T) {     int count[] = {0, 0, 0};     for (int j = 0; j < 15; j++) {      if ((i & (1 << j)) != 0)       count[genre[j] - 1]++;     }     ans = (ans % mod + cal(count) % mod) % mod;    }   }   pw.println(+ans);  } }
2,public class C {  private static Solver solver = new Solver();  private static long m = 1000000000L + 7L;  public static void main(String[] args) throws IOException {   solver.withProcedure(() -> {    String[] input = solver.readString().split(" ");    BigInteger x = new BigInteger(input[0]);    BigInteger k = new BigInteger(input[1]);    if (x.compareTo(BigInteger.ZERO) == 0) {     solver.println("" + 0);     return;    }    BigInteger two = BigInteger.valueOf(2);    BigInteger mm = BigInteger.valueOf(m);    BigInteger binpowedK = two.modPow(k, mm);    BigInteger binpowedKPlusOne = two.modPow(k.add(BigInteger.ONE), mm);    BigInteger res = binpowedKPlusOne.multiply(x).subtract(binpowedK.subtract(BigInteger.ONE)).mod(mm);    if (res.compareTo(BigInteger.ZERO) < 0) {     res = BigInteger.ZERO;    }    solver.println("" + res);   }).solve();  }  private static long binpow(long a, long n) {   a = a % m;   long res = 1L;   while (n > 0) {    if ((n & 1L) != 0)     res = (res * a) % m;    a = (a * a) % m;    n >>= 1L;   }   return res;  }   @FunctionalInterface  private interface Procedure {   void run() throws IOException;  }  private static class Solver {   private Procedure procedure;   private StreamTokenizer in;   private PrintWriter out;   private BufferedReader bufferedReader;   Solver() {    try {     boolean oj = System.getProperty("ONLINE_JUDGE") != null;     Reader reader = oj ? new InputStreamReader(System.in) : new FileReader("input.txt");     Writer writer = oj ? new OutputStreamWriter(System.out) : new FileWriter("output.txt");     bufferedReader = new BufferedReader(reader);     in = new StreamTokenizer(bufferedReader);     out = new PrintWriter(writer);    } catch (Exception e) {     throw new RuntimeException("Initialization has failed");    }   }   void solve() throws IOException {    procedure.run();   }   int readInt() throws IOException {    in.nextToken();    return (int) in.nval;   }   long readLong() throws IOException {    in.nextToken();    return (long) in.nval;   }   String readString() throws IOException {    return bufferedReader.readLine();   }   char readChar() throws IOException {    in.nextToken();    return in.sval.charAt(0);   }   void println(String str) {    out.println(str);    out.flush();   }   void print(String str) {    out.print(str);    out.flush();   }   Solver withProcedure(Procedure procedure) {    this.procedure = procedure;    return this;   }  } }
5,public class Main {  private static Node[] node;  public static void main(String[] args) {  Scanner cin = new Scanner(System.in);  int ret = 2, del;  int n = cin.nextInt();  int t = cin.nextInt() * 2;  node = new Node[n];  for (int i = 0; i < n; i++) {   int x = cin.nextInt();   int a = cin.nextInt();   node[i] = new Node(x * 2 - a, x * 2 + a);  }  Arrays.sort(node);  for (int i = 1; i < n; i++) {   del = node[i].l - node[i - 1].r;   if (del > t) {   ret += 2;   } else if (del == t) {   ret++;   }  }  System.out.println(ret);  }  private static class Node implements Comparable<Node> {  public int l;  public int r;  public Node(int l, int r) {     this.l = l;   this.r = r;  }  @Override  public int compareTo(Node arg0) {     return l - arg0.l;  }  } }
4,public class Codes {  public static void main(String[] args) throws IOException {  InputReader input = new InputReader(new FileReader(("input.txt")));  int n = input.nextInt();  int m = input.nextInt();  int k = input.nextInt();  boolean[][] visited = new boolean[n][m];  Queue<Point> bfs = new LinkedList<Point>();  for (int i = 0; i < k; i++) {  int x = input.nextInt();  int y = input.nextInt();  visited[x - 1][y - 1] = true;  bfs.add(new Point(x - 1, y - 1));  }  Point last = bfs.peek();  while(!bfs.isEmpty()) {  Point current = bfs.poll();  int curX = current.x;  int curY = current.y;    if(curX - 1 >= 0) {   if(!visited[curX - 1][curY]) {   bfs.add(new Point(curX - 1,curY));   visited[curX - 1][curY] = true;   }  }    if(curY + 1 < m) {   if(!visited[curX][curY + 1]) {   bfs.add(new Point(curX ,curY + 1));   visited[curX][curY + 1] = true;   }  }    if(curX + 1 < n) {   if(!visited[curX + 1][curY]) {   bfs.add(new Point(curX + 1,curY));   visited[curX + 1][curY] = true;   }  }    if(curY - 1 >= 0) {   if(!visited[curX][curY - 1]) {   bfs.add(new Point(curX ,curY - 1));   visited[curX][curY - 1] = true;   }  }  if(bfs.peek()!= null)  last = bfs.peek();  }  PrintWriter out = new PrintWriter(new File("output.txt"));  out.println((last.x + 1) + " " + (last.y + 1));  out.close();   }  static class Point {  int x;  int y;  public Point(int x2, int y2) {  x = x2;  y = y2;    } }   static class InputReader {  private BufferedReader reader;  private StringTokenizer tokenizer;  public InputReader(InputStream stream) {  reader = new BufferedReader(new InputStreamReader(stream));  tokenizer = null;  }  public InputReader(FileReader stream) {  reader = new BufferedReader(stream);  tokenizer = null;  }  public String nextLine() {  try {   return reader.readLine();  } catch (IOException e) {     e.printStackTrace();   return null;  }  }  public String next() {  while (tokenizer == null || !tokenizer.hasMoreTokens()) {   try {   tokenizer = new StringTokenizer(reader.readLine());   } catch (IOException e) {   throw new RuntimeException(e);   }  }  return tokenizer.nextToken();  }  public int nextInt() {  return Integer.parseInt(next());  }  public long nextLong() {  return Long.parseLong(next());  }  public double nextDouble() {  return Double.parseDouble(next());  } } }
4,public class Main {  public static void main(String[] args) {   InputStream inputStream;   try {    inputStream = new FileInputStream("input.txt");   } catch (IOException e) {    throw new RuntimeException(e);   }   OutputStream outputStream;   try {    outputStream = new FileOutputStream("output.txt");   } catch (IOException e) {    throw new RuntimeException(e);   }   FastReader in = new FastReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   FireAgain solver = new FireAgain();   solver.solve(1, in, out);   out.close();  }  static class FireAgain {   public void solve(int testNumber, FastReader in, PrintWriter out) {    int n = in.nextInt();    int m = in.nextInt();    int k = in.nextInt();    int INF = 10000000;    int[][] g = new int[n][m];    for (int[] temp : g) Arrays.fill(temp, -1);    ArrayDeque<IntPair> q = new ArrayDeque<>();    for (int i = 0; i < k; i++) {     int x = in.nextInt() - 1;     int y = in.nextInt() - 1;     g[x][y] = 0;     q.add(new IntPair(x, y));    }    while (!q.isEmpty()) {     IntPair cur = q.poll();     int x = cur.getFirst();     int y = cur.getSecond();     for (int i = -1; i <= 1; i++) {      for (int j = -1; j <= 1; j++) {       if (i == 0 && j == 0 || Math.abs(i) + Math.abs(j) != 1) continue;       int xx = x + i;       int yy = y + j;       if (xx < 0 || xx >= n || yy < 0 || yy >= m) continue;       if (g[xx][yy] != -1) continue;       g[xx][yy] = g[x][y] + 1;       q.add(new IntPair(xx, yy));      }     }    }    int ans = 0, x = -1, y = -1;    for (int i = 0; i < n; i++) {     for (int j = 0; j < m; j++) {      if (g[i][j] >= ans) {       ans = g[i][j];       x = i + 1;       y = j + 1;      }     }    }    out.println(x + " " + y);   }  }  static class IntPair implements Comparable<IntPair> {   int first;   int second;   public IntPair(int first, int second) {    this.first = first;    this.second = second;   }    public int compareTo(IntPair a) {    if (second == a.second) {     return Integer.compare(first, a.first);    }    return Integer.compare(second, a.second);   }    public String toString() {    return "<" + first + ", " + second + ">";   }    public boolean equals(Object o) {    if (this == o) return true;    if (o == null || getClass() != o.getClass()) return false;    IntPair a = (IntPair) o;    if (first != a.first) return false;    return second == a.second;   }    public int hashCode() {    int result = first;    result = 31 * result + second;    return result;   }   public int getFirst() {    return first;   }   public int getSecond() {    return second;   }  }  static class FastReader {   BufferedReader reader;   StringTokenizer st;   public FastReader(InputStream stream) {    reader = new BufferedReader(new InputStreamReader(stream));    st = null;   }   public String next() {    while (st == null || !st.hasMoreTokens()) {     try {      String line = reader.readLine();      if (line == null) {       return null;      }      st = new StringTokenizer(line);     } catch (Exception e) {      throw new RuntimeException();     }    }    return st.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }  } }
5,public class Main implements Runnable {  final String filename = "";  public void solve() throws Exception {  int n = iread();  int[] a = new int[n];  for (int i = 0; i < n; i++)  a[i] = iread();  Arrays.sort(a);  boolean test = true;  for (int i = 0; i < n; i++) {  if (a[i] != 1)   test = false;  int min = (i == 0) ? 1 : a[i - 1];  if (test && i == n - 1)   out.write((min + 1) + "");  else   out.write(min + "");  if (i == n - 1)   out.write("\n");  else   out.write(" ");  } }  public void run() {  try {  in = new BufferedReader(new InputStreamReader(System.in));  out = new BufferedWriter(new OutputStreamWriter(System.out));      solve();  out.flush();  } catch (Exception e) {  e.printStackTrace();  System.exit(1);  } }  public int iread() throws Exception {  return Integer.parseInt(readword()); }  public double dread() throws Exception {  return Double.parseDouble(readword()); }  public long lread() throws Exception {  return Long.parseLong(readword()); }  BufferedReader in;  BufferedWriter out;  public String readword() throws IOException {  StringBuilder b = new StringBuilder();  int c;  c = in.read();  while (c >= 0 && c <= ' ')  c = in.read();  if (c < 0)  return "";  while (c > ' ') {  b.append((char) c);  c = in.read();  }  return b.toString(); }  public static void main(String[] args) {  try {  Locale.setDefault(Locale.US);  } catch (Exception e) {  }   new Thread(null, new Main(), "1", 1 << 25).start(); } }
1,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  PrintWriter out = new PrintWriter(outputStream);  TaskB solver = new TaskB();  solver.solve(1, in, out);  out.close(); } } class TaskB {  ArrayList<Integer>[] G;  int[] st, dr;  boolean[] v;  public void solve(int testNumber, InputReader in, PrintWriter out) {   int N = in.nextInt();   int a = in.nextInt();   int b = in.nextInt();   int[] A = new int[N];   TreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();   for (int i = 0; i < N; i++) {    A[i] = in.nextInt();    map.put(A[i], i);   }   G = new ArrayList[N];   for (int i = 0; i < N; i++) {    G[i] = new ArrayList<Integer>();   }   for (int i = 0; i < N; i++) {    int val = a - A[i];    if (map.containsKey(val)) {     int p = map.get(val);      G[i].add(p);      G[p].add(i);    }    val = b - A[i];    if (map.containsKey(val)) {     int p = map.get(val);      G[i].add(p);      G[p].add(i);    }   }   st = new int[N];   dr = new int[N];   Arrays.fill(st, -1);   Arrays.fill(dr, -1);   v = new boolean[N];   boolean ok = true;   int match = 0;   while (ok) {    ok = false;    Arrays.fill(v, false);    for (int i = 0; i < N; i++) {     if (dr[i] == -1) {      if (pairup(i)) {       ok = true;       match++;      }     }    }   }   if (match == N) {    out.println("YES");    for (int i = 0; i < N; i++) {     if (i > 0) {      out.print(" ");     }     int other = dr[i];     if (A[i] == b - A[other]) {      out.print(1);     }     else {      out.print(0);     }    }   }   else {    out.println("NO");   }  }  private boolean pairup(int node) {   if (v[node]) {    return false;   }   v[node] = true;   for (int x : G[node]) {    if (st[x] == -1) {     st[x] = node;     dr[node] = x;     return true;    }   }   for (int x : G[node]) {    if (pairup(st[x])) {     st[x] = node;     dr[node] = x;     return true;    }   }   return false;  } } class InputReader {  private InputStream stream;  private byte[] buf = new byte[1024];  private int curChar;  private int numChars;  public InputReader(InputStream stream) {   this.stream = stream;  }  public int read() {   if (numChars == -1)    throw new InputMismatchException();   if (curChar >= numChars) {    curChar = 0;    try {     numChars = stream.read(buf);    } catch (IOException e) {     throw new InputMismatchException();    }    if (numChars <= 0)     return -1;   }   return buf[curChar++];  }  public int nextInt() {   return Integer.parseInt(nextString());  }  public String nextString() {   int c = read();   while (isSpaceChar(c))    c = read();   StringBuffer res = new StringBuffer();   do {    res.appendCodePoint(c);    c = read();   } while (!isSpaceChar(c));   return res.toString();  }  private boolean isSpaceChar(int c) {   return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;  } }
5,public class A111 {  public static void main(String args[])throws Exception  {   Scanner in=new Scanner(System.in);      PrintWriter pw=new PrintWriter(System.out);   int n,i,j,k=0,l;   n=in.nextInt();   int a[]=new int[n];   int sum=0,sum1=0;   for(i=0;i<n;i++)   {    a[i]=in.nextInt();    sum+=a[i];    }    Arrays.sort(a);   for(j=n-1;j>=0;j--)   {    sum1+=a[j];    k++;    if(sum1*2>sum)    break;    }    pw.println(k);   pw.flush();  } }
2,public class Main{     private static InputStream stream;      private static byte[] buf = new byte[1024];      private static int curChar;      private static int numChars;      private static SpaceCharFilter filter;      private static PrintWriter pw;      private static long count = 0,mod=1000000007;           public final static int INF = (int) 1E9;             public static void main(String[] args) {       InputReader(System.in);      pw = new PrintWriter(System.out);        new Thread(null ,new Runnable(){        public void run(){         try{          solve();          pw.close();         } catch(Exception e){          e.printStackTrace();         }        }       },"1",1<<26).start();      }      public static void test(){       int t=nextInt();       while(t-->0){       solve();       }      }      public static long pow(long n, long p,long mod) {      if(p==0)      return 1;      if(p==1)      return n%mod;      if(p%2==0){      long temp=pow(n, p/2,mod);      return (temp*temp)%mod;      }else{       long temp=pow(n,p/2,mod);       temp=(temp*temp)%mod;       return(temp*n)%mod;             }     }      public static long pow(long n, long p) {      if(p==0)      return 1;      if(p==1)      return n;      if(p%2==0){      long temp=pow(n, p/2);      return (temp*temp);      }else{       long temp=pow(n,p/2);       temp=(temp*temp);       return(temp*n);             }     }      public static void Merge(long a[],int p,int r){       if(p<r){        int q = (p+r)/2;        Merge(a,p,q);        Merge(a,q+1,r);        Merge_Array(a,p,q,r);       }      }      public static void Merge_Array(long a[],int p,int q,int r){       long b[] = new long[q-p+1];       long c[] = new long[r-q];       for(int i=0;i<b.length;i++)        b[i] = a[p+i];       for(int i=0;i<c.length;i++)        c[i] = a[q+i+1];       int i = 0,j = 0;       for(int k=p;k<=r;k++){        if(i==b.length){         a[k] = c[j];         j++;        }        else if(j==c.length){         a[k] = b[i];         i++;        }        else if(b[i]<c[j]){         a[k] = b[i];         i++;        }        else{         a[k] = c[j];         j++;        }       }      }      public static long gcd(long x, long y) {      if (x == 0)       return y;      else       return gcd( y % x,x);      } public static boolean isPrime(int n) {          if (n <= 1)     return false;     if (n <= 3)     return true;                  if (n % 2 == 0 || n % 3 == 0)     return false;         for (int i = 5; i * i <= n; i = i + 6)     if (n % i == 0 || n % (i + 2) == 0)      return false;         return true;    }      static LinkedList<Integer> adj[];      static boolean Visited[];      static HashSet<Integer> exc;      static long oddsum[]=new long[1000001];      static int co=0,ans=0;            static int n,m;      static String s[];      static int ind;      public static void solve() {                    long n=nextLong();       long s=nextLong();       long low=1,high=n,ans=-1;       while(low<=high){       long mid=(low+high)/2;       if(check(mid,s)){        ans=mid;        high=mid-1;       }else       {        low=mid+1;       }               }       if(ans==-1)       pw.println(0);       else       pw.println(n-ans+1);          }      private static boolean check(long mid,long s){       long n=mid;       int sum=0;       while(mid>0){       sum+=(mid%10);       mid/=10;       }       if(n-sum >=s)       return true;       return false;              }            static int[] levl;      static int h_max=0;      public static void dfs(int curr,int lev){      Visited[curr]=true;      levl[curr]=lev;      h_max=Math.max(h_max, levl[curr]);      for(int x:adj[curr]){       if(!Visited[x]){       dfs(x,lev+1);       }      }      }            public static String reverseString(String s) {      StringBuilder sb = new StringBuilder(s);      sb.reverse();      return (sb.toString());     }                  private static void BFS(int sou,int dest){       Queue<Integer> q=new LinkedList<Integer>();       q.add(sou);       Visited[sou]=true;       while(!q.isEmpty()){       int top=q.poll();              for(int i:adj[top]){               if(!Visited[i])        {                q.add(i);        }               Visited[i]=true;        if(i==dest){        pw.println("Yes");        return;        }       }       }       pw.println("No");                   }            private static long ncr(int n,int k){      if (k < 0 || k > n) return 0;      if (n-k < k) k = n-k;          BigInteger x = BigInteger.ONE;      for (int i = 1; i <= k; i++) {       x = x.multiply(new BigInteger(""+(n-i+1)));       x = x.divide(new BigInteger(""+i));      }        return x.longValue();     }      private static long fact(long count){       long ans=1;       for(int i=1;i<=count;i++){       ans*=i;       }       return ans;      }                  static int state=1;      static long no_exc=0,no_vert=0;      static Stack<Integer> st;      static HashSet<Integer> inset;      private static void topo(int curr){             Visited[curr]=true;       inset.add(curr);       for(int x:adj[curr]){       if(adj[x].contains(curr) || inset.contains(x)){        state=0;        return;       }       if(state==0)        return;              }       st.push(curr);             inset.remove(curr);      }      static HashSet<Integer> hs;            private static void buildgraph(int n){      adj=new LinkedList[n+1];      Visited=new boolean[n+1];            for(int i=0;i<=n;i++){       adj[i]=new LinkedList<Integer>();            }           }                          public static void sort(long a[]){       Merge(a, 0, a.length-1);      }      public static void InputReader(InputStream stream1) {      stream = stream1;      }        private static boolean isWhitespace(int c) {      return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;      }        private static boolean isEndOfLine(int c) {      return c == '\n' || c == '\r' || c == -1;      }        private static int read() {      if (numChars == -1)       throw new InputMismatchException();      if (curChar >= numChars) {       curChar = 0;       try {       numChars = stream.read(buf);       } catch (IOException e) {       throw new InputMismatchException();       }       if (numChars <= 0)       return -1;      }      return buf[curChar++];      }        private static int nextInt() {      int c = read();      while (isSpaceChar(c))       c = read();      int sgn = 1;      if (c == '-') {       sgn = -1;       c = read();      }      int res = 0;      do {       if (c < '0' || c > '9')       throw new InputMismatchException();       res *= 10;       res += c - '0';       c = read();      } while (!isSpaceChar(c));      return res * sgn;      }        private static long nextLong() {      int c = read();      while (isSpaceChar(c))       c = read();      int sgn = 1;      if (c == '-') {       sgn = -1;       c = read();      }      long res = 0;      do {       if (c < '0' || c > '9')       throw new InputMismatchException();       res *= 10;       res += c - '0';       c = read();      } while (!isSpaceChar(c));      return res * sgn;      }        private static String nextToken() {      int c = read();      while (isSpaceChar(c))       c = read();      StringBuilder res = new StringBuilder();      do {       res.appendCodePoint(c);       c = read();      } while (!isSpaceChar(c));      return res.toString();      }        private static String nextLine() {      int c = read();      while (isSpaceChar(c))       c = read();      StringBuilder res = new StringBuilder();      do {       res.appendCodePoint(c);       c = read();      } while (!isEndOfLine(c));      return res.toString();      }        private static int[] nextIntArray(int n) {      int[] arr = new int[n];      for (int i = 0; i < n; i++) {       arr[i] = nextInt();      }      return arr;      }        private static long[][] next2dArray(int n, int m) {      long[][] arr = new long[n][m];      for (int i = 0; i < n; i++) {       for (int j = 0; j < m; j++) {       arr[i][j] = nextLong();       }      }      return arr;      }      private static char[][] nextCharArray(int n,int m){      char [][]c=new char[n][m];      for(int i=0;i<n;i++){       String s=nextLine();       for(int j=0;j<s.length();j++){       c[i][j]=s.charAt(j);       }      }      return c;      }        private static long[] nextLongArray(int n) {      long[] arr = new long[n];      for (int i = 0; i < n; i++) {       arr[i] = nextLong();      }      return arr;      }        private static void pArray(int[] arr) {      for (int i = 0; i < arr.length; i++) {       pw.print(arr[i] + " ");      }      pw.println();      return;      }        private static void pArray(long[] arr) {      for (int i = 0; i < arr.length; i++) {       pw.print(arr[i] + " ");      }      pw.println();      return;      }        private static void pArray(boolean[] arr) {      for (int i = 0; i < arr.length; i++) {       pw.print(arr[i] + " ");      }      pw.println();      return;      }        private static boolean isSpaceChar(int c) {      if (filter != null)       return filter.isSpaceChar(c);      return isWhitespace(c);      }        private interface SpaceCharFilter {      public boolean isSpaceChar(int ch);      }       }              class Node{      int to;      long dist;      Node(int to,long dist){      this.to=to;      this.dist=dist;      }           }     class Dsu{     private int rank[], parent[] ,n;     private static int[] parent1;     Dsu(int size){      this.n=size+1;      rank=new int[n];           parent=new int[n];     makeSet();         }          void makeSet(){      for(int i=0;i<n;i++){      parent[i]=i;      }     }          int find(int x){      if(parent[x]!=x){            parent[x]=find(parent[x]);      }      return parent[x];     }               boolean union(int x,int y){      int xRoot=find(x);      int yRoot=find(y);           if(xRoot==yRoot)      return false;      if(rank[xRoot]<rank[yRoot]){      parent[xRoot]=yRoot;      }else if(rank[yRoot]<rank[xRoot]){      parent[yRoot]=xRoot;      }else{      parent[yRoot]=xRoot;      rank[xRoot]++;      }      return true;     }           }
5,public class Main implements Runnable {  void randomShuffle(int[] arr) {  Random rnd = new Random();  for (int i = arr.length - 1; i >= 0; i--) {  int pos = rnd.nextInt(i + 1);  int temp = arr[pos];  arr[pos] = arr[i];  arr[i] = temp;  } }  void solve() throws Exception {  int n = sc.nextInt();  int[] a = new int[n];  int[] ac = new int[n];  for (int i = 0; i < n; i++) {  a[i] = ac[i] = sc.nextInt();  }  randomShuffle(ac);  Arrays.sort(ac);  int diff = 0;  for (int i = 0; i < n; i++) {  if (a[i] != ac[i]) {   diff++;  }  }  if (diff <= 2) {  out.println("YES");  } else {  out.println("NO");  } }  BufferedReader in; PrintWriter out; FastScanner sc;  static Throwable uncaught;  @Override public void run() {  try {  in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);  sc = new FastScanner(in);  solve();  } catch (Throwable t) {  Main.uncaught = t;  } finally {  out.close();  } }  public static void main(String[] args) throws Throwable {  Thread t = new Thread(null, new Main(), "", 128 * 1024 * 1024);  t.start();  t.join();  if (uncaught != null) {  throw uncaught;  } } } class FastScanner {  BufferedReader reader; StringTokenizer strTok;  public FastScanner(BufferedReader reader) {  this.reader = reader; }  public String nextToken() throws IOException {  while (strTok == null || !strTok.hasMoreTokens()) {  strTok = new StringTokenizer(reader.readLine());  }  return strTok.nextToken(); }  public int nextInt() throws IOException {  return Integer.parseInt(nextToken()); }  public long nextLong() throws IOException {  return Long.parseLong(nextToken()); }  public double nextDouble() throws IOException {  return Double.parseDouble(nextToken()); }  }
1,public class Solver {  StringTokenizer st;  BufferedReader in;  PrintWriter out;  public static void main(String[] args) throws NumberFormatException,    IOException {   Solver solver = new Solver();   solver.open();   long time = System.currentTimeMillis();   solver.solve();   if (!"true".equals(System.getProperty("ONLINE_JUDGE"))) {    System.out.println("Spent time: "      + (System.currentTimeMillis() - time));   }   solver.close();  }  public void open() throws IOException {   in = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);  }  public String nextToken() throws IOException {   while (st == null || !st.hasMoreTokens()) {    st = new StringTokenizer(in.readLine());   }   return st.nextToken();  }  public int nextInt() throws NumberFormatException, IOException {   return Integer.parseInt(nextToken());  }  public long nextLong() throws NumberFormatException, IOException {   return Long.parseLong(nextToken());  }  public double nextDouble() throws NumberFormatException, IOException {   return Double.parseDouble(nextToken());  }  public void solve() throws NumberFormatException, IOException {   int n = nextInt();   int k = nextInt();     int[] ar = new int[n];   int[] ex = new int[100005];   int dif = 0;     for(int i=0;i<n;i++){    int tmp = nextInt();    ar[i] = tmp;    if (ex[tmp]++==0){     dif++;      }      }     if (dif<k){    out.println("-1 -1");    return;   }     Arrays.fill(ex, 0);   dif = 0;   int right = 0;   while(dif<k){    int tmp = ar[right];    if(ex[tmp]++==0){       dif++;    }    right++;   }     int left = 0;   while (ex[ar[left]]-- > 1) left++;     out.println((left+1)+" "+right);  }  public void close() {   out.flush();   out.close();  } }
3,public class _909C {  private static final int MOD = 1000000007;  private static void solve(Scanner scan, PrintWriter pw) {   int n = scan.nextInt();   scan.nextLine();      int[][] dp = new int[n][n];   int[][] dpSums = new int[n][n];   dp[0][0] = 1;   for(int i = 0; i < n; i++) {    dpSums[0][i] = 1;   }   boolean lastIsSimple = scan.nextLine().equals("s");   for(int i = 1; i < n; i++) {    if(lastIsSimple) {     dp[i][0] = dpSums[i-1][n-1];     dpSums[i][0] = dp[i][0];     for(int j = 1; j < n; j++) {      dp[i][j] = (dpSums[i-1][n-1] - dpSums[i-1][j-1] + MOD) % MOD;      dpSums[i][j] = (dp[i][j] + dpSums[i][j-1]) % MOD;     }    }    else {     dp[i][0] = 0;     dpSums[i][0] = 0;     for(int j = 1; j < n; j++) {      dp[i][j] = dp[i-1][j-1];      dpSums[i][j] = (dp[i][j] + dpSums[i][j-1]) % MOD;     }    }    lastIsSimple = scan.nextLine().equals("s");   }   System.out.println(dpSums[n-1][n-1]);  }  public static void main(String[] args) {   Scanner scan = new Scanner(new BufferedInputStream(System.in, 1024 * 64));   PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out, 1024 * 64));   solve(scan, pw);   pw.flush();  } }
6,public class P16E {  int n;  double [][]prob;  double []dp;  public P16E() {   Scanner sc = new Scanner(System.in);   n = sc.nextInt();   prob = new double [n][n];   for (int i = 0; i < n; i++){    for (int j = 0; j < n; j++){     prob[i][j] = sc.nextDouble();    }   }   sc.close();   dp = new double[(1<<n)];   Arrays.fill(dp, -1);   for (int i = 0; i < n; i++) {    int a = 1 << i;    System.out.print(compute(a) + " ");   }  }  double compute (int mask){   if (mask == (1<<n) - 1){    return 1;   }   if (dp[mask] != -1){    return dp[mask];   }   double result = 0;   int c = 0;     for (int i = 0; i < n; i++) {    int a = 1 << i;    if ((a & mask) != 0) {     c++;     for (int j = 0; j < n; j++) {      int b = 1 << j;      if ((b & mask) == 0) {       result += (prob[i][j] * compute(mask | b));      }     }    }   }   int nC2 = (c + 1) * c / 2;   dp[mask] = result / nC2;   return dp[mask];  }  public static void main (String []args){   new P16E();  } }
5,public class A {   static class team implements Comparable<team> {  int problems;  int penalty;  public team(int problems,int penalty)  {  this.penalty=penalty;  this.problems=problems;  }  public int compareTo(team a) {  if (a.problems==this.problems)   return this.penalty - a.penalty;  return a.problems - this.problems;  }   public boolean igual(team a)  {  if (this.problems!=a.problems)   return false;  return (this.penalty==a.penalty);  } }  static class Scanner {  BufferedReader rd;  StringTokenizer tk;  public Scanner() throws IOException  {  rd=new BufferedReader(new InputStreamReader(System.in));  tk=new StringTokenizer(rd.readLine());  }  public String next() throws IOException  {  if (!tk.hasMoreTokens())  {   tk=new StringTokenizer(rd.readLine());   return tk.nextToken();  }  return tk.nextToken();  }  public int nextInt() throws NumberFormatException, IOException  {  return Integer.valueOf(this.next());  } }   static team[] array=new team[100]; static int N,K;  public static void main(String args[]) throws IOException {  Scanner sc=new Scanner();  N=sc.nextInt();  K=sc.nextInt();  for(int i=0;i<N;i++)  {  array[i]=new team(sc.nextInt(),sc.nextInt());  }  Arrays.sort(array,0,N);     int shared=0;  for(int i=K-1;i>=0 && array[K-1].igual(array[i]);i--,shared++);  for(int i=K;i<N && array[K-1].igual(array[i]);i++,shared++);  System.out.println(shared); } }
5,public class A {  public A() throws Exception {   int n = in.nextInt();   int[] arr = new int[n];   for (int i=0;i<n;i++)    arr[i] = in.nextInt();   if (n==1&&arr[0]==1) {    System.out.println(2);    return;   }    Arrays.sort(arr);   if (arr[n-1]==1)    arr[n-2] = 2;   buf.append(1);   for (int i=0;i<n-1;i++)    buf.append(' ').append(arr[i]);   buf.append('\n');   System.out.print(buf);  }  Scanner in = new Scanner(System.in);  StringBuilder buf = new StringBuilder();  public static void main(String[] args) throws Exception {   new A();  }  public static void debug(Object... arr) {   System.err.println(Arrays.deepToString(arr));  } }
4,public class Task {  private static final boolean readFromFile = false;  public static void main(String args[]){  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  FileOutputStream fileOutputStream;  FileInputStream fileInputStream;  if (readFromFile){  try{   fileInputStream = new FileInputStream(new File("input.txt"));   fileOutputStream = new FileOutputStream(new File("output.txt"));  }catch (FileNotFoundException e){   throw new RuntimeException(e);  }  }  PrintWriter out = new PrintWriter((readFromFile)?fileOutputStream:outputStream);  InputReader in = new InputReader((readFromFile)?fileInputStream:inputStream);   Solver s = new Solver(in,out);  s.solve();   out.close(); } } class Solver{ InputReader in; PrintWriter out;  public void solve(){  String s = in.nextLine();  for (int len=s.length()-1;len>=1;len--)  for (int i=0;i<s.length()-len+1;i++)   for (int j=i+1;j<s.length()-len+1;j++)   if (s.substring(i,i+len).equals(s.substring(j,j+len))){    out.println(len);    return;   }  out.println(0); }   Solver(InputReader in, PrintWriter out){  this.in=in;  this.out=out; } } class InputReader{ private BufferedReader buf; private StringTokenizer tok;  InputReader(InputStream in){  tok = null;  buf = new BufferedReader(new InputStreamReader(in)); }  InputReader(FileInputStream in){  tok = null;  buf = new BufferedReader(new InputStreamReader(in)); }  public String next(){  while (tok==null || !tok.hasMoreTokens()){  try{   tok = new StringTokenizer(buf.readLine());  }catch (IOException e){   throw new RuntimeException(e);  }  }  return tok.nextToken(); }  public int nextInt(){  return Integer.parseInt(next()); }  public long nextLong(){  return Long.parseLong(next()); }  public double nextDouble(){  return Double.parseDouble(next()); }  public float nextFloat(){  return Float.parseFloat(next()); }  public String nextLine(){  try{  return buf.readLine();  }catch (IOException e){  return null;  } }  }
2,public class Quiz {  public static long pow(long base, long power) {   if (power == 0)    return 1;   long half = pow(base, power / 2) % mod;   half *= half;   half %= mod;   if (power % 2 == 1)    half *= base;   return half % mod;  }  static long mod = (long) (1e9 + 9);  public static void main(String[] args) {   InputReader r = new InputReader(System.in);   int n = r.nextInt();   int m = r.nextInt();   int k = r.nextInt();   int buckets = n / k;   int rem = n - buckets * k;   long low = 0, high = buckets, itr = 30;   while (itr-- > 0) {    long mid = (low + high) / 2;    long correct = mid * k + rem + (buckets - mid) * (k - 1);    if (correct < m)     low = mid;    else     high = mid;   }   long pow = (pow(2, high + 1) - 2 + mod) % mod;   pow *= k;   pow %= mod;   long res = m - (high * k) + pow + 10 * mod;   res %= mod;   System.out.println(res);  }  static class InputReader {   private BufferedReader reader;   private StringTokenizer tokenizer;   public InputReader(InputStream stream) {    reader = new BufferedReader(new InputStreamReader(stream));    tokenizer = null;   }   public InputReader(FileReader stream) {    reader = new BufferedReader(stream);    tokenizer = null;   }   public String nextLine() {    try {     return reader.readLine();    } catch (IOException e) {         e.printStackTrace();     return null;    }   }   public String next() {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      tokenizer = new StringTokenizer(reader.readLine());     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return tokenizer.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }   public long nextLong() {    return Long.parseLong(next());   }  } }
1,public class A {  int n;  int[] arr;   void run(){   Scanner s = new Scanner(System.in);   n = s.nextInt();   arr = new int[n];   int even, odd;   even = 0;   odd = 0;   for (int i = 0; i < n; i++) {    arr[i] = s.nextInt();    if(arr[i]%2==0)even++;    else odd++;   }   if(even>odd){          for (int i = 0; i < n; i++) {     if(arr[i]%2==1){      System.out.println(i+1);      System.exit(0);     }    }   }     else{    for (int i = 0; i < n; i++) {     if(arr[i]%2==0){      System.out.println(i+1);      System.exit(0);     }    }   }       }  public static void main(String[] args) {   new A().run();  } }
0,public class A235 {  public static void main(String[] args) {   Scanner scan = new Scanner(System.in);   long n = scan.nextInt();   BigInteger res = null;   if (n >= 3) {    if (n % 2 != 0) {     res = BigInteger.valueOf(n * (n - 1) * (n - 2));    } else if (n % 3 == 0) {     res = BigInteger.valueOf((n - 1) * (n - 2) * (n - 3));    } else {     res = BigInteger.valueOf(n * (n - 1) * (n - 3));    }   } else {    res = BigInteger.valueOf(n);   }   System.out.println(res);  } }
6,public class E { public static void main(String[] args) {  new E().run(); }  private void run() {  Locale.setDefault(Locale.US);  Scanner sc = new Scanner(System.in);  int n = sc.nextInt();  double[][] p = new double[n][n];  for (int i = 0; i < n; i++) {  for (int j = 0; j < n; j++)   p[i][j] = sc.nextDouble();  }  sc.close();  double[] w = new double[1 << n];  int max = (1 << n) - 1;  w[max] = 1;  for (int mask = max; mask > 0; mask--) {  int count = 0;  for (int i = 0; i < n; i++)   if (((mask >> i) & 1) > 0)   for (int j = i + 1; j < n; j++)    if (((mask >> j) & 1) > 0) {    count++;    }  if (count > 0)   for (int i = 0; i < n; i++)   if (((mask >> i) & 1) > 0)    for (int j = i + 1; j < n; j++)    if (((mask >> j) & 1) > 0) {     w[mask ^ (1 << j)] += w[mask] * p[i][j] / count;     w[mask ^ (1 << i)] += w[mask] * (1 - p[i][j])      / count;    }  }  for (int i = 0; i < n; i++) {  if (i != 0)   System.out.print(' ');  System.out.printf("%.6f", w[1 << i]);  }  System.out.println(); } }
4,public class YouAreGivenAString { public static void main(String[] args) throws Exception {   BufferedReader r = new BufferedReader(new InputStreamReader(System.in));  String s=r.readLine();  int max=0;  for(int i=1;i<s.length();i++){  for (int j = 0; j <= s.length()-i; j++) {   String sub=s.substring(j,j+i);   if(count(s,sub)>=2)   max=Math.max(max, i);  }  }  System.out.println(max); }  private static int count(String s, String sub) {  int l=sub.length();  int c=0;  for(int i=0;i<=s.length()-l;i++){  if(s.substring(i,i+l).equals(sub))   c++;  }  return c; } }
2,public class Test5{  static long mod=1000000007;  public static void main(String[] z) throws Exception{   Scanner s = new Scanner(System.in);   long a = s.nextLong(), b=s.nextLong(), c=(a*2-1)%mod, i=binpow(2,b)%mod;   System.out.println(a<1 ? a : (c*i+1)%mod);  }  static long binpow(long c, long step){   if(step==0) return 1;   if(step==1) return c%mod;   if(step%2<1){    return binpow(((c%mod)*(c%mod))%mod, step/2)%mod;   }   else{    return (c%mod)*(binpow(c%mod, step-1)%mod);   }  }  static class PyraSort {   private static int heapSize;   public static void sort(int[] a) {    buildHeap(a);    while (heapSize > 1) {     swap(a, 0, heapSize - 1);     heapSize--;     heapify(a, 0);    }   }   private static void buildHeap(int[] a) {    heapSize = a.length;    for (int i = a.length / 2; i >= 0; i--) {     heapify(a, i);    }   }   private static void heapify(int[] a, int i) {    int l = 2 * i + 2;    int r = 2 * i + 1;    int largest = i;    if (l < heapSize && a[i] < a[l]) {     largest = l;    }    if (r < heapSize && a[largest] < a[r]) {     largest = r;    }    if (i != largest) {     swap(a, i, largest);     heapify(a, largest);    }   }   private static void swap(int[] a, int i, int j) {    a[i] ^= a[j] ^= a[i];    a[j] ^= a[i];   }  } }
4,public class A {  static final int[] dx = {0, 0, -1, 1}; static final int[] dy = {-1, 1, 0, 0};  public static void main(String[] args) throws IOException {  Scanner sc = new Scanner("input.txt");  PrintWriter out = new PrintWriter(new FileWriter("output.txt"));   int N = sc.nextInt(), M = sc.nextInt();  int[][] dist = new int[N][M];  Queue<Integer> q = new LinkedList<>();  int K = sc.nextInt();  while(K-->0)  {  int x = sc.nextInt() - 1, y = sc.nextInt() - 1;  q.add(x * M + y);  dist[x][y] = 1;  }   int max = 0, ansX = -1, ansY = -1;  while(!q.isEmpty())  {  int u = q.remove(), x = u / M, y = u % M;  if(dist[x][y] > max)   max = dist[ansX = x][ansY = y];  for(int k = 0; k < 4; ++k)  {   int nx = x + dx[k], ny = y + dy[k];   if(nx >= 0 && ny >= 0 && nx < N && ny < M && dist[nx][ny] == 0)   {   dist[nx][ny] = dist[x][y] + 1;   q.add(nx * M + ny);   }     }  }  out.printf("%d %d\n", ansX + 1, ansY + 1);  out.close(); }   static class Scanner  {  StringTokenizer st;  BufferedReader br;  public Scanner(InputStream s){ br = new BufferedReader(new InputStreamReader(s));}   public Scanner(String s) throws FileNotFoundException{ br = new BufferedReader(new FileReader(s));}  public String next() throws IOException  {  while (st == null || !st.hasMoreTokens())   st = new StringTokenizer(br.readLine());  return st.nextToken();  }  public int nextInt() throws IOException {return Integer.parseInt(next());}  public long nextLong() throws IOException {return Long.parseLong(next());}  public String nextLine() throws IOException {return br.readLine();}  public double nextDouble() throws IOException { return Double.parseDouble(next()); }  public boolean ready() throws IOException {return br.ready();}  } }
6,public class MaeDosDragoes { public static PrintWriter saida = new PrintWriter(System.out, false); public static class Escanear {   BufferedReader reader;   StringTokenizer tokenizer;  public Escanear() {    this(new InputStreamReader(System.in));   }  public Escanear(Reader in) {    reader = new BufferedReader(in);   }   String proximo() {    if (tokenizer == null || !tokenizer.hasMoreElements()) {     try {      tokenizer = new StringTokenizer(reader.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return tokenizer.nextToken();   }     int nextInt() {    return Integer.parseInt(proximo());   }  }   public static void main(String[] args) {  Escanear fastScanner = new Escanear();   int proximoInt = fastScanner.nextInt();   double proximoDouble = fastScanner.nextInt();   long[] graph = new long[proximoInt];   for(Integer i = 0; i < proximoInt; i++) {    for(Integer j =0; j < proximoInt; j++) {     Integer val = fastScanner.nextInt();     if (val.equals(1) || i.equals(j)) {   graph[i] |= 1L << j;   }    }   }   int szLeft = proximoInt/2;   int szRight = proximoInt - szLeft;   int[] dp = new int[1 << szLeft];   int maxMask = 1 << szLeft;   for(int mask = 1; mask <maxMask; mask++) {    int curMask = mask;    for(int j = 0; j < szLeft; j++) {     if (((1 << j) & mask) > 0) {      curMask &= graph[j + szRight] >> szRight;      dp[mask] = Math.max(dp[mask], dp[mask ^ (1 << j)]);     }    }    if (mask == curMask) {     dp[mask] = Math.max(dp[mask],Integer.bitCount(mask));    }   }   int ans = 0;   int rmaxMask = 1 << szRight;   for(int mask = 0; mask < rmaxMask; mask++) {    int curMask = mask;    int oMask = maxMask -1;    for(int j = 0; j < szRight; j++) {     if (((1 << j) & mask) > 0) {      curMask &= (graph[j] & (rmaxMask-1));      oMask &= graph[j] >> szRight;     }    }    if (curMask != mask) continue;    ans = Math.max(ans, Integer.bitCount(mask) + dp[oMask]);   }   proximoDouble/=ans;   saida.println(proximoDouble * proximoDouble * (ans * (ans-1))/2);   saida.flush();  } }
5,public class A {   static StringTokenizer st;  static BufferedReader in;  public static void main(String[] args) throws IOException {   in = new BufferedReader(new InputStreamReader(System.in));   PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));   int n = nextInt();   int m = nextInt();   int k = nextInt();   int[]a = new int[n+1];   for (int i = 1; i <= n; i++) {    a[i] = nextInt();   }   if (k >= m) {    System.out.println(0);    return;   }   Arrays.sort(a, 1, n+1);   int ans = 0;   for (int i = n; i >= 1; i--) {    ans++;    k--;    k += a[i];    if (k >= m) {     System.out.println(ans);     return;    }   }   System.out.println(-1);   pw.close();  }  private static int nextInt() throws IOException{   return Integer.parseInt(next());  }   private static long nextLong() throws IOException{   return Long.parseLong(next());  }   private static double nextDouble() throws IOException{   return Double.parseDouble(next());  }   private static String next() throws IOException {   while (st == null || !st.hasMoreTokens()) {    st = new StringTokenizer(in.readLine());   }   return st.nextToken();  } }
4,public class C {  static class IntList {  int data[] = new int[3];  int size = 0;  boolean isEmpty() {  return size == 0;  }  int size() {  return size;  }  int get(int index) {  if (index < 0 || index >= size) {   throw new IndexOutOfBoundsException();  }  return data[index];  }  void clear() {  size = 0;  }  void set(int index, int value) {  if (index < 0 || index >= size) {   throw new IndexOutOfBoundsException();  }  data[index] = value;  }  void expand() {  if (size >= data.length) {   data = copyOf(data, (data.length << 1) + 1);  }  }  void insert(int index, int value) {  if (index < 0 || index > size) {   throw new IndexOutOfBoundsException();  }  expand();  arraycopy(data, index, data, index + 1, size++ - index);  data[index] = value;  }  int delete(int index) {  if (index < 0 || index >= size) {   throw new IndexOutOfBoundsException();  }  int value = data[index];  arraycopy(data, index + 1, data, index, --size - index);  return value;  }  void push(int value) {  expand();  data[size++] = value;  }  int pop() {  if (size == 0) {   throw new NoSuchElementException();  }  return data[--size];  }  void unshift(int value) {  expand();  arraycopy(data, 0, data, 1, size++);  data[0] = value;  }  int shift() {  if (size == 0) {   throw new NoSuchElementException();  }  int value = data[0];  arraycopy(data, 1, data, 0, --size);  return value;  } }  static void solve() throws Exception {  int tests = scanInt();  IntList stack = new IntList();  for (int test = 0; test < tests; test++) {  stack.clear();  int n = scanInt();  for (int i = 0; i < n; i++) {   int v = scanInt();   if (v == 1) {   stack.push(v);   } else {   while (stack.pop() != v - 1) { }   stack.push(v);   }   for (int j = 0; j < stack.size; j++) {   if (j != 0) {    out.print('.');   }   out.print(stack.data[j]);   }   out.println();  }  } }  static int scanInt() throws IOException {  return parseInt(scanString()); }  static long scanLong() throws IOException {  return parseLong(scanString()); }  static String scanString() throws IOException {  while (tok == null || !tok.hasMoreTokens()) {  tok = new StringTokenizer(in.readLine());  }  return tok.nextToken(); }  static BufferedReader in; static PrintWriter out; static StringTokenizer tok;  public static void main(String[] args) {  try {  in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);  solve();  in.close();  out.close();  } catch (Throwable e) {  e.printStackTrace();  exit(1);  } } }
3,public class E35PD {  public static void main(String[] args) throws IOException {   Scanner in = new Scanner(System.in);     int n = in.nextInt();   int[] a = new int[n];   for (int i = 0; i < n; i++) {    a[i] = in.nextInt();   }     int count = 0;   for (int i = 0; i < n - 1; i++) {    for (int j = i + 1; j < n; j++) {     if (a[i] > a[j]) {      count++;     }    }      }     boolean isEven = (count % 2 == 0);     BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));   int m = in.nextInt();   for (int i = 0; i < m; i++) {    int l = in.nextInt();    int r = in.nextInt();    int size = (r - l) + 1;    int numOfConn = (size - 1) * size / 2;    if (numOfConn % 2 == 1) {     isEven = !isEven;    }    if (isEven) {     out.write("even");     out.newLine();    } else {     out.write("odd");     out.newLine();    }   }   out.close();  } }
0,public class RationalResistance { static long n = 0;  static void R(long a, long b) {  n += a / b;  a %= b;  if (a == 0) {  return;  }  R(b, a); }  public static void main(String[] args) {  Scanner cin = new Scanner(System.in);  long a = cin.nextLong();  long b = cin.nextLong();  cin.close();  R(a, b);  System.out.println(n); } }
6,public class MotherOfDragons { static boolean[][] adjMatrix; public static void main(String[] args) throws IOException {  Scanner sc = new Scanner(System.in);  int n = sc.nextInt();  int k = sc.nextInt();   adjMatrix = new boolean[n][n];  for (int i = 0; i < n; i++)  for (int j = 0; j < n; j++)   adjMatrix[i][j] = sc.nextInt() == 1;   long[] edges = new long[n];  for (int i = 0; i < n; i++)  {  long val = 0;  for (int j = 0; j < n; j++)   if(adjMatrix[i][j] || i == j)   val |= 1l<<j;  edges[i] = val;  }   int h = n/2;   int[] cliques = new int[1<<h];  for (int i = 1; i < 1<<h; i++)  {  int nodes = i;  for (int j = 0; j < h; j++)   if((i & (1 << j)) != 0)   nodes &= edges[j];  if(nodes == i)   cliques[i] = Integer.bitCount(i);  }   for (int i = 1; i < 1<<h; i++)  for (int j = 0; j < h; j++)   if((i & (1 << j)) != 0)   cliques[i] = Math.max(cliques[i], cliques[i ^ (1<<j)]);   int max = 0;  for (int i = 0; i < cliques.length; i++)  max = Math.max(max, cliques[i]);  for (int i = 1; i < 1<<(n-h); i++)  {  long all = -1l;  long tmp = (1l*i)<<h;  for (int j = h; j < n; j++)   if((tmp & (1l << j)) != 0)   all &= edges[j];  long node = all&tmp;  if(node != tmp)   continue;  int connected = (int)(all & ((1<<h)-1));  max = Math.max(max, cliques[connected] + Integer.bitCount(i));  }   System.out.printf("%.12f\n", (k*k*((max-1)/(2.0*max)))); }  static class Scanner {  StringTokenizer st;  BufferedReader br;  public Scanner(InputStream s)  {  br = new BufferedReader(new InputStreamReader(s));  }  public Scanner(String s) throws FileNotFoundException  {  br = new BufferedReader(new FileReader(new File((s))));  }  public String next() throws IOException  {  while (st == null || !st.hasMoreTokens())   st = new StringTokenizer(br.readLine());  return st.nextToken();  }  public int nextInt() throws IOException  {  return Integer.parseInt(next());  }  public long nextLong() throws IOException  {  return Long.parseLong(next());  }  public String nextLine() throws IOException  {  return br.readLine();  }  public double nextDouble() throws IOException  { return Double.parseDouble(next()); }  } }
0,public class Main {   public static long func(long a, long b) {     if (a < b)    return func(b, a);  if (b < 2)    return a;   long q = a / b;   long r = a - q * b;   return q + func(b, r);  }   public static void main(String[] args) throws IOException {     BufferedReader br = new BufferedReader(new InputStreamReader(System.in));   String[] ss = br.readLine().split(" +");   long a = Long.parseLong(ss[0]);   long b = Long.parseLong(ss[1]);     System.out.println(func(a, b));    }  }
3,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskD solver = new TaskD();   solver.solve(1, in, out);   out.close();  }  static  @SuppressWarnings("Duplicates")  class TaskD {   public void solve(int testNumber, InputReader in, PrintWriter out) {    int n = in.nextInt();    int[] a = in.nextIntArray(n);    int m = in.nextInt();    int count = 0;    for (int i = 0; i < n; i++) {     for (int j = i + 1; j < n; j++) {      if (a[i] > a[j]) count = (count + 1) % 2;     }    }    StringBuilder res = new StringBuilder();    int l, r;    while (m-- > 0) {     l = in.nextInt() - 1;     r = in.nextInt() - 1;     count = count ^ (((r - l + 1) * (r - l) / 2) % 2);     res.append(count == 1 ? "odd" : "even").append('\n');    }    out.print(res);   }  }  static class InputReader {   private final BufferedReader reader;   private StringTokenizer tokenizer;   public InputReader(InputStream in) {    reader = new BufferedReader(new InputStreamReader(in));   }   public int[] nextIntArray(int size) {    int[] array = new int[size];    for (int i = 0; i < size; ++i) {     array[i] = nextInt();    }    return array;   }   public int nextInt() {    return Integer.parseInt(next());   }   public String next() {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {     tokenizer = new StringTokenizer(readLine());    }    return tokenizer.nextToken();   }   public String readLine() {    String line;    try {     line = reader.readLine();    } catch (IOException e) {     throw new RuntimeException(e);    }    return line;   }  } }
5,public class A {  public static void main(String[] args) throws IOException {   new A().run();  }  BufferedReader br;  StringTokenizer st = new StringTokenizer("");  private void run() throws IOException {   br = new BufferedReader(new InputStreamReader(System.in));   int n = nextInt();   Set<Integer> set = new TreeSet<Integer>();   for (int i = 0; i < n; i++) {    set.add(nextInt());   }   set.remove(set.iterator().next());   PrintWriter pw = new PrintWriter(System.out);   if (set.isEmpty()) {    pw.println("NO");   } else {    pw.println(set.iterator().next());   }   pw.close();  }  int nextInt() throws IOException {   while (!st.hasMoreElements()) {    st = new StringTokenizer(br.readLine());   }   return Integer.parseInt(st.nextToken());  } }
0,public class Test { public static void main(String[] args) {  Scanner sc = new Scanner(System.in);  int n = sc.nextInt();  if (n % 2 == 0) {  System.out.println(4 + " " + (n - 4));  } else {  System.out.println(9 + " " + (n - 9));  } } }
5,public class a { public static void main(String[] args) {  Scanner input = new Scanner(System.in);  int n = input.nextInt(), m = input.nextInt(), k = input.nextInt();  int[] data = new int[n];  for(int i = 0; i<n; i++)   data[i] = input.nextInt();  Arrays.sort(data);  m -= k;  int at = n-1;  int count = 0;  while(at>=0 && m>0)  {   count++;   m++;   m -= data[at];   at--;  }  if(m>0)   System.out.println(-1);  else   System.out.println(count); } }
5,public class Start {  final boolean ONLINE_JUDGE = System.getProperty("ONLINE_JUDGE") != null;  BufferedReader in;  PrintWriter out;  StringTokenizer tok = new StringTokenizer("");  void init() throws FileNotFoundException {   if (ONLINE_JUDGE) {    in = new BufferedReader(new InputStreamReader(System.in));    out = new PrintWriter(System.out);   } else {    in = new BufferedReader(new FileReader("input.txt"));    out = new PrintWriter("output.txt");   }  }  String readString() throws IOException {   while (!tok.hasMoreTokens()) {    tok = new StringTokenizer(in.readLine());   }   return tok.nextToken();  }  int readInt() throws IOException {   return Integer.parseInt(readString());  }  long readLong() throws IOException {   return Long.parseLong(readString());  }  double readDouble() throws IOException {   return Double.parseDouble(readString());  }  public static void main(String[] args) {   new Start().run();    }  public static void mergeSort(int[] a) {   mergeSort(a, 0, a.length - 1);  }  private static void mergeSort(int[] a, int levtIndex, int rightIndex) {   final int MAGIC_VALUE = 50;   if (levtIndex < rightIndex) {    if (rightIndex - levtIndex <= MAGIC_VALUE) {     insertionSort(a, levtIndex, rightIndex);    } else {     int middleIndex = (levtIndex + rightIndex) / 2;     mergeSort(a, levtIndex, middleIndex);     mergeSort(a, middleIndex + 1, rightIndex);     merge(a, levtIndex, middleIndex, rightIndex);    }   }  }  private static void merge(int[] a, int levtIndex, int middleIndex,    int rightIndex) {   int length1 = middleIndex - levtIndex + 1;   int length2 = rightIndex - middleIndex;   int[] levtArray = new int[length1];   int[] rightArray = new int[length2];   System.arraycopy(a, levtIndex, levtArray, 0, length1);   System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);   for (int k = levtIndex, i = 0, j = 0; k <= rightIndex; k++) {    if (i == length1) {     a[k] = rightArray[j++];    } else if (j == length2) {     a[k] = levtArray[i++];    } else {     a[k] = levtArray[i] <= rightArray[j] ? levtArray[i++]       : rightArray[j++];    }   }  }  private static void insertionSort(int[] a, int levtIndex, int rightIndex) {   for (int i = levtIndex + 1; i <= rightIndex; i++) {    int current = a[i];    int j = i - 1;    while (j >= levtIndex && a[j] > current) {     a[j + 1] = a[j];     j--;    }    a[j + 1] = current;   }  }  public void run() {   try {    long t1 = System.currentTimeMillis();    init();    solve();    out.close();    long t2 = System.currentTimeMillis();    System.err.println("Time = " + (t2 - t1));   } catch (Exception e) {    e.printStackTrace(System.err);    System.exit(-1);   }  }  class LOL implements Comparable<LOL> {   int x;   int y;   int num;   public LOL(int x, int y,int num) {    this.x = x;    this.y = y;    this.num = num;   }   @Override   public int compareTo(LOL o) {    return x - o.x;          }  }      public void solve() throws IOException {    int n = readInt();   int m = readInt();   int k = readInt();     int [] a = new int [n];   for (int i = 0; i < n; i++){    a[i] = readInt();   }   mergeSort(a);     if (k>=m){    out.print(0);    return;   }     int ans = 0;   k--;   for (int i = n-1; i >=0; i--){    ans += a[i];    if (ans + k >= m){     out.print(n-i);     return;    }    else {     k--;    }   }   out.print(-1);       }    }
4,public class QA {     static long MOD = 1000000007;   static boolean b[], b1[], check;   static ArrayList<Integer>[] amp, pa;   static ArrayList<Pair>[] amp1;   static ArrayList<Pair>[][] damp;   static int left[],right[],end[],sum[],dist[],cnt[],start[],color[],parent[],prime[],size[];   static int ans = 0,k;   static int p = 0;   static FasterScanner sc = new FasterScanner(System.in);     static BufferedWriter log;   static HashSet<Pair> hs;   static HashMap<Pair,Integer> hm;   static PriorityQueue<Integer> pri[];   static ArrayList<Integer>[] level;   static Stack<Integer> st;   static boolean boo[][];   static Pair prr[];   static long parent1[],parent2[],size1[],size2[],arr1[],SUM[],lev[], fibo[];   static int arr[], ver[][];   static private PrintWriter out = new PrintWriter(System.out);   public static void main(String[] args) throws Exception {    new Thread(null, new Runnable() {    public void run() {    try {   soln();    } catch (Exception e) {     System.out.println(e);    }    }   }, "1", 1 << 26).start();      }   private static boolean oj = System.getProperty("ONLINE_JUDGE") != null;   private static void tr(Object... o) {   if (!oj)    System.out.println(Arrays.deepToString(o));   }   static int dp[][];   static int N,K,T,A,B;   static long time;   static int cost[][];   static boolean b11[];   static HashMap<Integer,Integer> h = new HashMap<>();   static HashSet<Pair> chec;   static long ans1; static long ans2;   static int BLOCK, MAX = 1000001;   static double pi = Math.PI;   static int Arr[], Brr[], pow[], M;   static long fact[] = new long[100000+1];   static HashMap<Integer,Long> hm1;   static HashSet<Integer> hs1[], hs2[];   static String[] str2;   static char[] ch1, ch2;   static int[] s,f,D;   static int tf,ts;   static int see[][] = new int[2050][2050];   static boolean bee[][] = new boolean[2050][2050];   static Queue<Pair> q = new LinkedList<>();     public static void soln() throws IOException {         FasterScanner sc = new FasterScanner(new FileInputStream("input.txt"));      PrintWriter log = new PrintWriter("output.txt");      int n = sc.nextInt() , m = sc.nextInt();   int k = sc.nextInt();   for(int i = 1; i <= n ; i++) for(int j =1;j<=m;j++) see[i][j]= 100000000;   for(int i = 0; i < k; i++){    int x = sc.nextInt(), y = sc.nextInt();    bee[x][y] = true;    see[x][y] = 0;    q.add(new Pair(x,y));   }   while(!q.isEmpty()){       int x = q.peek().u, y = q.poll().v;    if(x>1){    see[x-1][y] = min(see[x][y]+1,see[x-1][y]);    if(!bee[x-1][y]) q.add(new Pair(x-1,y));    bee[x-1][y] = true;    }    if(x<n){    see[x+1][y] = min(see[x][y]+1,see[x+1][y]);    if(!bee[x+1][y]) q.add(new Pair(x+1,y));    bee[x+1][y] = true;    }    if(y>1){    see[x][y-1] = min(see[x][y]+1,see[x][y-1]);    if(!bee[x][y-1]) q.add(new Pair(x,y-1));    bee[x][y-1] = true;    }    if(y<m){    see[x][y+1] = min(see[x][y]+1,see[x][y+1]);    if(!bee[x][y+1]) q.add(new Pair(x,y+1));    bee[x][y+1] = true;    }   }   int ans = -1;   Pair temp = null;   for(int i = 1;i<=n;i++){    for(int j = 1;j<=m;j++){    if(see[i][j]>ans) {     ans = see[i][j];     temp = new Pair(i,j);    }    }   }   log.write(temp.u+" "+temp.v);   log.close();   }   static int min(int a, int b){   if(a>b) return b;   return a;   }   private static double dfs(int cur,int prev){   double r=0,n=0;   for(int i : amp[cur]){    if(i!=prev){    r+=(1+dfs(i,cur));    n++;    }   }   if(n!=0){    r=r/n;   }   return r;   }   static double fa1 = 0;   static int fa = -1;   static long nCr1(int n, int r){   if(n<r) return 0;   return (((fact[n] * modInverse(fact[n-r], MOD))%MOD)*modInverse(fact[r], MOD))%MOD;   }   static class Node{   Node arr[] = new Node[2];    int cnt[] = new int[2];   }   public static class Trie{   Node root;   public Trie(){    root = new Node();   }   public void insert(String x){    Node n = root;    for(int i = 0;i < x.length() ;i++){    int a1 = x.charAt(i)-'0';    if(n.arr[a1]!=null){     n.cnt[a1]++;     n = n.arr[a1];     continue;    }    n.arr[a1] = new Node();    n.cnt[a1]++;    n = n.arr[a1];    }   }   public void delete(String x){    Node n = root;    for(int i = 0;i < x.length() ;i++){    int a1 = x.charAt(i)-'0';    if(n.cnt[a1]==1){     n.arr[a1] = null;     return;    }    else {     n.cnt[a1]--;     n = n.arr[a1];    }    }   }   public long get(String x){    Node n = root;    long ans = 0;    for(int i = 0;i < x.length() ;i++){    int a1 = '1' - x.charAt(i);    if(n.arr[a1]!=null){     ans += Math.pow(2, 30-i);     n = n.arr[a1];    }    else n = n.arr[1-a1];       }    return ans;   }   }   public static class FenwickTree {       int[] array;     public FenwickTree(int size) {     array = new int[size + 1];    }    public int rsq(int ind) {     assert ind > 0;     int sum = 0;     while (ind > 0) {      sum += array[ind];           ind -= ind & (-ind);     }     return sum;    }    public int rsq(int a, int b) {     assert b >= a && a > 0 && b > 0;     return rsq(b) - rsq(a - 1);    }    public void update(int ind, int value) {     assert ind > 0;     while (ind < array.length) {      array[ind] += value;           ind += ind & (-ind);     }    }     public int size() {     return array.length - 1;    }   }   static double power(double x, long y)   {    if (y == 0)     return 1;    double p = power(x, y/2);    p = (p * p);       return (y%2 == 0)? p : (x * p);   }   static int Dfs(int x, int val){   b[x] = true;   for(int p:hs2[x]){    if(!b[p]){    if(!hs1[x].contains(p)) val++;    val += Dfs(p,0);    }   }   return val;   }   static long nCr(int n, int r){   if(n<r) return 0;   else return (((fact[n]*modInverse(fact[r], MOD))%MOD)*modInverse(fact[n-r], MOD))%MOD;   }   static void dfs1(int x, int p){   arr1[x] += lev[x];   for(int v:amp[x]){    if(v!=p){    dfs1(v,x);    }   }   }     static void bfs(int x){      }   public static void seive(int n){   b = new boolean[(n+1)];   Arrays.fill(b, true);   b[1] = true;   for(int i = 2;i*i<=n;i++){    if(b[i]){    for(int p = 2*i;p<=n;p+=i){     b[p] = false;    }    }   }      }     static class Graph{   int vertex;   int weight;   Graph(int v, int w){    vertex = v;    weight = w;   }   }   static class Pair implements Comparable<Pair> {   int u;   int v;   int ans;   public Pair(){    u = 0;    v = 0;   }   public Pair(int u, int v) {    this.u = u;    this.v = v;   }   public int hashCode() {    return Objects.hash();   }   public boolean equals(Object o) {    Pair other = (Pair) o;    return ((u == other.u && v == other.v && ans == other.ans));   }      public int compareTo(Pair other) {       return Long.compare(u, other.u);    }      public String toString() {    return "[u=" + u + ", v=" + v + "]";   }   }     public static void buildGraph(int n){   for(int i =0;i<n;i++){    int x = sc.nextInt()-1, y = sc.nextInt()-1;    amp[x].add(y);    amp[y].add(x);   }   }        public static int getParent(long x){   while(parent[(int) x]!=x){    parent[ (int) x] = parent[(int) parent[ (int) x]];    x = parent[ (int) x];   }   return (int) x;   }   static long min(long a, long b, long c){   if(a<b && a<c) return a;   if(b<c) return b;   return c;   }      static void KMPSearch(String pat, String txt)    {     int M = pat.length();     int N = txt.length();                 int lps[] = new int[M];     int j = 0;                 computeLPSArray(pat,M,lps);        int i = 0;     while (i < N)     {      if (pat.charAt(j) == txt.charAt(i))      {       j++;       i++;      }      if (j == M)      {             j = lps[j-1];      }              else if (i < N && pat.charAt(j) != txt.charAt(i))      {                    if (j != 0)        j = lps[j-1];       else        i = i+1;      }     }    }   static void computeLPSArray(String pat, int M, int lps[])    {         int len = 0;     int i = 1;     lps[0] = 0;             while (i < M)     {      if (pat.charAt(i) == pat.charAt(len))      {       len++;       lps[i] = len;       i++;      }      else      {                          if (len != 0)       {        len = lps[len-1];                         }       else       {        lps[i] = len;        i++;       }      }     }    }   private static void permutation(String prefix, String str) {    int n = str.length();    if (n == 0);    else {     for (int i = 0; i < n; i++)      permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i+1, n));    }   }     public static void buildTree(int n){   int arr[] = sc.nextIntArray(n);   for(int i = 0;i<n;i++){    int x = arr[i]-1;    amp[i+1].add(x);    amp[x].add(i+1);   }   }     static class SegmentTree {   boolean st[];   boolean lazy[];     SegmentTree(int n) {    int size = 4 * n;    st = new boolean[size];    Arrays.fill(st, true);    lazy = new boolean[size];    Arrays.fill(lazy, true);       }           void update(int si, int ss, int se, int idx, long x) {    if (ss == se) {        st[si]=false;    }    else {    int mid = (ss + se) / 2;    if(ss <= idx && idx <= mid)     {       update(2*si, ss, mid, idx, x);     }     else     { update(2*si+1, mid+1, se, idx, x);     }    st[si] = st[2*si]|st[2*si+1];    }   }      void updateRange(int node, int start, int end, int l, int r, boolean val)   {    if(!lazy[node])    {           st[node] = lazy[node];      if(start != end)     {      lazy[node*2] = lazy[node];           lazy[node*2+1] = lazy[node];         }     lazy[node] = true;             }    if(start > end || start > r || end < l)         return;    if(start >= l && end <= r)    {          st[node] = val;     if(start != end)     {            lazy[node*2] = val;      lazy[node*2+1] = val;     }     return;    }    int mid = (start + end) / 2;    updateRange(node*2, start, mid, l, r, val);      updateRange(node*2 + 1, mid + 1, end, l, r, val);     st[node] = st[node*2] | st[node*2+1];     }     boolean queryRange(int node, int start, int end, int l, int r)   {    if(start > end || start > r || end < l)     return false;       if(!lazy[node])    {          st[node] = lazy[node];        if(start != end)     {      lazy[node*2] = lazy[node];         lazy[node*2+1] = lazy[node];      }     lazy[node] = true;         }    if(start >= l && end <= r)         return st[node];    int mid = (start + end) / 2;    boolean p1 = queryRange(node*2, start, mid, l, r);       boolean b = queryRange(node*2 + 1, mid + 1, end, l, r);     return (p1 | b);   }   void print() {    for (int i = 0; i < st.length; i++) {    System.out.print(st[i]+" ");    }    System.out.println();   }   }   static int convert(int x){   int cnt = 0;   String str = Integer.toBinaryString(x);      for(int i = 0;i<str.length();i++){    if(str.charAt(i)=='1'){    cnt++;    }   }   int ans = (int) Math.pow(3, 6-cnt);   return ans;   }   static class Node2{   Node2 left = null;   Node2 right = null;   Node2 parent = null;   int data;   }   static boolean check(char ch[][], int i, int j){   if(ch[i][j]=='O') return false;   char c = ch[i][j];   ch[i][j] = 'X';   if(c=='X'){   if(i>=4){    int x = 0;    int l = 0;    for(x = 0;x<=4;x++){    if(ch[i-x][j]!='X'){ if(ch[i-x][j]!='.') break;else l++;}    }    if(x==5 && l<=1) return true;    l = 0;    if(j>=4){    for(x = 0;x<=4;x++){     if(ch[i-x][j-x]!='X'){ if(ch[i-x][j-x]!='.') break; else l++;}    }    if(x==5 && l<=1) return true;     l =0;    for(x = 0;x<=4;x++){     if(ch[i][j-x]!='X'){ if(ch[i][j-x]!='.') break; else l++;}    }    if(x==5 && l<=1) return true;    }    if(j<=5){    l = 0;    for(x = 0;x<=4;x++){     if(ch[i][j+x]!='X'){ if(ch[i][j+x]!='.') break; else l++;}    }    if(x==5 && l<=1) return true;    l = 0;    for(x = 0;x<=4;x++){     if(ch[i-x][j+x]!='X'){ if(ch[i-x][j+x]!='.') break; else l++;}    }    if(x==5 && l<=1) return true;    }   }   if(i<=5){    int x = 0;    int l = 0;    for(x = 0;x<=4;x++){    if(ch[i+x][j]!='X'){ if(ch[i+x][j]!='.') break; else l++;}    }    if(x==5 && l<=1) return true;    l = 0;    if(j>=4){    for(x = 0;x<=4;x++){     if(ch[i+x][j-x]!='X'){ if(ch[i+x][j-x]!='.') break; else l++;}    }    if(x==5 && l<=1) return true;     l =0;    for(x = 0;x<=4;x++){     if(ch[i][j-x]!='X'){ if(ch[i][j-x]!='.') break; else l++;}    }    if(x==5 && l<=1) return true;    }    if(j<=5){    l = 0;    for(x = 0;x<=4;x++){     if(ch[i][j+x]!='X'){ if(ch[i][j+x]!='.') break; else l++;}    }    if(x==5 && l<=1) return true;    l = 0;    for(x = 0;x<=4;x++){     if(ch[i+x][j+x]!='X'){ if(ch[i+x][j+x]!='.') break; else l++;}    }    if(x==5 && l<=1) return true;    }   }   }   else{    if(i>=4){    int x = 0;    int l = 0;    for(x = 0;x<=4;x++){     if(ch[i-x][j]!='X'){ if(ch[i-x][j]!='.') break;else l++;}    }    if(x==5 && l<=0) return true;    l = 0;    if(j>=4){     for(x = 0;x<=4;x++){     if(ch[i-x][j-x]!='X'){ if(ch[i-x][j-x]!='.') break; else l++;}     }     if(x==5 && l<=0) return true;     l =0;     for(x = 0;x<=4;x++){     if(ch[i][j-x]!='X'){ if(ch[i][j-x]!='.') break; else l++;}     }     if(x==5 && l<=0) return true;    }    if(j<=5){     l = 0;     for(x = 0;x<=4;x++){     if(ch[i][j+x]!='X'){ if(ch[i][j+x]!='.') break; else l++;}     }     if(x==5 && l<=0) return true;     l = 0;     for(x = 0;x<=4;x++){     if(ch[i-x][j+x]!='X'){ if(ch[i-x][j+x]!='.') break; else l++;}     }     if(x==5 && l<=0) return true;    }    }    if(i<=5){    int x = 0;    int l = 0;    for(x = 0;x<=4;x++){     if(ch[i+x][j]!='X'){ if(ch[i+x][j]!='.') break; else l++;}    }    if(x==5 && l<=0) return true;    l = 0;    if(j>=4){     for(x = 0;x<=4;x++){     if(ch[i+x][j-x]!='X'){ if(ch[i+x][j-x]!='.') break; else l++;}     }     if(x==5 && l<=0) return true;     l =0;     for(x = 0;x<=4;x++){     if(ch[i][j-x]!='X'){ if(ch[i][j-x]!='.') break; else l++;}     }     if(x==5 && l<=0) return true;    }    if(j<=5){     l = 0;     for(x = 0;x<=4;x++){     if(ch[i][j+x]!='X'){ if(ch[i][j+x]!='.') break; else l++;}     }     if(x==5 && l<=0) return true;     l = 0;     for(x = 0;x<=4;x++){     if(ch[i+x][j+x]!='X'){ if(ch[i+x][j+x]!='.') break; else l++;}     }     if(x==5 && l<=0) return true;    }    }   }   ch[i][j] = c;      return false;   }   static class BinarySearchTree{   Node2 root = null;   int height = 0;   int max = 0;   int cnt = 1;   ArrayList<Integer> parent = new ArrayList<>();   HashMap<Integer, Integer> hm = new HashMap<>();   public void insert(int x){    Node2 n = new Node2();    n.data = x;    if(root==null){    root = n;    }    else{    Node2 temp = root,temb = null;    while(temp!=null){     temb = temp;     if(x>temp.data) temp = temp.right;     else temp = temp.left;    }    if(x>temb.data) temb.right = n;    else temb.left = n;    n.parent = temb;    parent.add(temb.data);    }   }   public Node2 getSomething(int x, int y, Node2 n){    if(n.data==x || n.data==y) return n;    else if(n.data>x && n.data<y) return n;    else if(n.data<x && n.data<y) return getSomething(x,y,n.right);    else return getSomething(x,y,n.left);   }   public Node2 search(int x,Node2 n){    if(x==n.data){    max = Math.max(max, n.data);    return n;    }    if(x>n.data){    max = Math.max(max, n.data);    return search(x,n.right);    }    else{    max = Math.max(max, n.data);    return search(x,n.left);    }   }   public int getHeight(Node2 n){    if(n==null) return 0;    height = 1+ Math.max(getHeight(n.left), getHeight(n.right));    return height;   }   }   static long findDiff(long[] arr, long[] brr, int m){   int i = 0, j = 0;   long fa = 1000000000000L;   while(i<m && j<m){    long x = arr[i]-brr[j];    if(x>=0){    if(x<fa) fa = x;    j++;    }    else{    if((-x)<fa) fa = -x;    i++;    }   }   return fa;   }   public static long max(long x, long y, long z){   if(x>=y && x>=z) return x;   if(y>=x && y>=z) return y;   return z;   }     static long modInverse(long a, long mOD2){      return power(a, mOD2-2, mOD2);   }   static long power(long x, long y, long m)   {    if (y == 0)     return 1;    long p = power(x, y/2, m) % m;    p = (p * p) % m;       return (y%2 == 0)? p : (x * p) % m;   }   static long d,x,y;   public static void extendedEuclidian(long a, long b){   if(b == 0) {     d = a;     x = 1;     y = 0;    }    else {     extendedEuclidian(b, a%b);     int temp = (int) x;     x = y;     y = temp - (a/b)*y;    }   }     public static long gcd(long n, long m){   if(m!=0) return gcd(m,n%m);   else return n;   }     static BufferedReader reader;   static StringTokenizer tokenizer;   static PrintWriter writer;          static class FasterScanner {     private final InputStream stream;   private final byte[] buf = new byte[8192];   private int curChar, snumChars;   private SpaceCharFilter filter;     public FasterScanner(InputStream stream) {    this.stream = stream;   }     public int snext() {    if (snumChars == -1)    throw new InputMismatchException();    if (curChar >= snumChars) {    curChar = 0;    try {     snumChars = stream.read(buf);    } catch (IOException e) {     throw new InputMismatchException();    }    if (snumChars <= 0)     return -1;    }    return buf[curChar++];   }     public int nextInt() {    int c = snext();    while (isSpaceChar(c)) {    c = snext();    }    int sgn = 1;    if (c == '-') {    sgn = -1;    c = snext();    }    int res = 0;    do {    if (c < '0' || c > '9')     throw new InputMismatchException();    res *= 10;    res += c - '0';    c = snext();    } while (!isSpaceChar(c));    return res * sgn;   }     public long nextLong() {    int c = snext();    while (isSpaceChar(c)) {    c = snext();    }    int sgn = 1;    if (c == '-') {    sgn = -1;    c = snext();    }    long res = 0;    do {    if (c < '0' || c > '9')     throw new InputMismatchException();    res *= 10;    res += c - '0';    c = snext();    } while (!isSpaceChar(c));    return res * sgn;   }     public int[] nextIntArray(int n) {    int a[] = new int[n];    for (int i = 0; i < n; i++) {    a[i] = nextInt();    }    return a;   }     public long[] nextLongArray(int n) {    long a[] = new long[n];    for (int i = 0; i < n; i++) {    a[i] = nextLong();    }    return a;   }         public String readString() {    int c = snext();    while (isSpaceChar(c)) {    c = snext();    }    StringBuilder res = new StringBuilder();    do {    res.appendCodePoint(c);    c = snext();    } while (!isSpaceChar(c));    return res.toString();   }     public String nextLine() {    int c = snext();    while (isSpaceChar(c))    c = snext();    StringBuilder res = new StringBuilder();    do {    res.appendCodePoint(c);    c = snext();    } while (!isEndOfLine(c));    return res.toString();   }     public boolean isSpaceChar(int c) {    if (filter != null)    return filter.isSpaceChar(c);    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }     private boolean isEndOfLine(int c) {    return c == '\n' || c == '\r' || c == -1;   }     public interface SpaceCharFilter {    public boolean isSpaceChar(int ch);   }   }  }
0,public class p84a {  public static void main(String[] args) {   Scanner in = new Scanner(System.in);   int n = in.nextInt();     System.out.println((n/2)*3);    } }
4,public class Main{  static PrintWriter out; static int c[][]; static int x[] , y[] , n; static int degIn[]; static ArrayList< ArrayList<Integer> >a = new ArrayList< ArrayList<Integer> >(); static int cnt = 0; static boolean b[]; private static boolean dfs(int i) { if (i == -1) return true; if (b[i]) return false; b[i] = true; for(Integer j : a.get(i) )  if ( dfs( y[j] ) ) {  x[i] = j;  y[j] = i;  return true;  } return false; } private static void find(int k) { int _cnt = -1; if (k>=0) { x[k] = k; y[k] = k; } while (_cnt != cnt) {  _cnt = cnt;  Arrays.fill( b , false );  if (k>=0) b[k] = true;  for(int i = 0; i < n; ++i)   if (x[i] == -1 && dfs(i) ) ++cnt; } if (k>=0) { x[k] = -1; y[k] = -1; } } public static void solve() { n = in.nextInt(); int m = in.nextInt();  b = new boolean[n]; c = new int [n][n]; degIn = new int[n]; x = new int[n]; y = new int[n];  Arrays.fill(x , -1); Arrays.fill(y , -1); for(int i = 0; i < n; ++i) a. add( new ArrayList< Integer > () );  while (m-- > 0) {  int i = in.nextInt()-1 , j = in.nextInt()-1;  a.get(i).add(j);  degIn[j]++;  c[i][j] = 1; }  find(-1); int kq = Integer.MAX_VALUE;  for(int k = 0; k < n; ++k) {  if (x[k] != -1) {y[ x[k] ] = -1; x[k] = -1; cnt--; }  if (y[k] != -1) {x[ y[k] ] = -1; y[k] = -1; cnt--; }  find(k);   int t = n*2 - 1 - a.get(k).size() - degIn[k] + c[k][k];  for(int i = 0; i < n; ++i)  if (i!=k)   t = t + a.get(i).size() - c[i][k];   t = t - cnt + (n-1) - cnt;  if (kq > t) kq = t;  } out.println(kq);  }  public static void main (String[] args) throws java.lang.Exception {  long startTime = System.currentTimeMillis();  out = new PrintWriter(System.out); solve();   out.close(); }  static class in { static BufferedReader reader = new BufferedReader( new InputStreamReader(System.in) ) ; static StringTokenizer tokenizer = new StringTokenizer("");   static String next() {   while ( !tokenizer.hasMoreTokens() )  try { tokenizer = new StringTokenizer( reader.readLine() ); }  catch (IOException e){   throw new RuntimeException(e);    }   return tokenizer.nextToken(); } static int nextInt() { return Integer.parseInt( next() ); }  static double nextDouble(){ return Double.parseDouble( next() ); } } }
2,public class NitsLocal {  static ArrayList<String> s1;  static boolean[] prime;  static int n = (int)1e7;  static void sieve() { Arrays.fill(prime , true); prime[0] = prime[1] = false; for(int i = 2 ; i * i <= n ; ++i) { if(prime[i]) { for(int k = i * i; k<= n ; k+=i) { prime[k] = false; } } } }  public static void main(String[] args) {   InputReader sc = new InputReader(System.in);      prime = new boolean[n + 1]; sieve();     prime[1] = false;          long n = sc.nl();    long k = sc.nl();    long b = 2*n + 3;    long c = n*n - 2*k + n;    long q1 = (b + (long)Math.sqrt(b*b - 4*c))/2;    long q2 = (b - (long)Math.sqrt(b*b - 4*c))/2;    if(q1 >= q2 && q1 <= n)     w.println(q1);    else     w.println(q2);                   w.close();    }  static int nextPowerOf2(int n)  {   int count = 0;            if (n > 0 && (n & (n - 1)) == 0)    return n;    while(n != 0)   {    n >>= 1;    count += 1;   }    return 1 << count;  }    static long sum1(int t1,int t2,int x,int []t)  {   int mid = (t2-t1+1)/2; if(t1==t2)  return 0;   else  return sum1(t1,mid-1,x,t) + sum1(mid,t2,x,t);     }    static String replace(String s,int a,int n)  {   char []c = s.toCharArray();   for(int i=1;i<n;i+=2)   {    int num = (int) (c[i] - 48);    num += a;    num%=10;    c[i] = (char) (num+48);   }   return new String(c);  }  static String move(String s,int h,int n)  {   h%=n;   char []c = s.toCharArray();   char []temp = new char[n];   for(int i=0;i<n;i++)   {    temp[(i+h)%n] = c[i];   }   return new String(temp);  }    public static int ip(String s){ return Integer.parseInt(s); }  static class multipliers implements Comparator<Long>{     public int compare(Long a,Long b) {  if(a<b)  return 1;  else if(b<a)  return -1;  else  return 0; } }  static class multipliers1 implements Comparator<Student>{  public int compare(Student a,Student b) {  if(a.y<b.y)  return 1;  else if(b.y<a.y)  return -1;  else  {   if(a.id < b.id)    return 1;   else if(b.id<a.id)    return -1;   else    return 0;       } } }         static class InputReader {  private final InputStream stream; private final byte[] buf = new byte[8192]; private int curChar, snumChars;  public InputReader(InputStream st) { this.stream = st; }  public int read() { if (snumChars == -1) throw new InputMismatchException(); if (curChar >= snumChars) { curChar = 0; try { snumChars = stream.read(buf); } catch (IOException e) { throw new InputMismatchException(); } if (snumChars <= 0) return -1; } return buf[curChar++]; }  public int ni() { int c = read(); while (isSpaceChar(c)) { c = read(); } int sgn = 1; if (c == '-') { sgn = -1; c = read(); } int res = 0; do { res *= 10; res += c - '0'; c = read(); } while (!isSpaceChar(c)); return res * sgn; }  public long nl() { int c = read(); while (isSpaceChar(c)) { c = read(); } int sgn = 1; if (c == '-') { sgn = -1; c = read(); } long res = 0; do { res *= 10; res += c - '0'; c = read(); } while (!isSpaceChar(c)); return res * sgn; }  public int[] nia(int n) { int a[] = new int[n]; for (int i = 0; i < n; i++) { a[i] = ni(); } return a; }  public String rs() { int c = read(); while (isSpaceChar(c)) { c = read(); } StringBuilder res = new StringBuilder(); do { res.appendCodePoint(c); c = read(); } while (!isSpaceChar(c)); return res.toString(); }  public String nextLine() { int c = read(); while (isSpaceChar(c)) c = read(); StringBuilder res = new StringBuilder(); do { res.appendCodePoint(c); c = read(); } while (!isEndOfLine(c)); return res.toString(); }  public boolean isSpaceChar(int c) { return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; }  private boolean isEndOfLine(int c) { return c == '\n' || c == '\r' || c == -1; }  }     static PrintWriter w = new PrintWriter(System.out);     static class Student  {   int id;        int y;        Student(int id,int y)   {    this.id = id;           this.y = y;                 }    } }
2,public class ProblemC {  public static final String FILE_IN = "std.in";  public static final String FILE_OUT = "std.out";  private static boolean debugMode = true;  private static final long MOD = 1000 * 1000 * 1000 + 9;  public static void main(String[] args) throws IOException {   final Scanner reader = new Scanner(new InputStreamReader(debugMode ? System.in : new FileInputStream(FILE_IN)));   final PrintWriter writer = new PrintWriter(debugMode ? System.out : new FileOutputStream(FILE_OUT));    solveTheProblem(reader, writer);    reader.close();   writer.close();  }  private static void solveTheProblem(final Scanner reader, final PrintWriter writer) {   final long n = reader.nextLong();   final long m = reader.nextLong();   final long k = reader.nextLong();   if (n - n/k >= m) {    writer.println(m);    return;   } else {    long sum = 1;    long maxK = m - n + n/k;    sum = fastPow(2, maxK);    sum = 2 * (sum - 1);    sum = sum % MOD;    sum *= k;    sum += m - maxK * k;    writer.println(sum % MOD);   }  }  private static long fastPow(final int exp, final long deg) {   if (deg == 0) {    return 1;   } else if (deg == 1) {    return exp;   } else if (deg % 2 == 0) {    long temp = fastPow(exp, deg / 2);    temp = (temp * temp) % MOD;    return temp;   } else {    long temp = fastPow(exp, deg / 2);    temp = (temp * temp) % MOD;    return (temp * exp) % MOD;   }  }  }
1,public class B {  static class InputReader {   BufferedReader buffreader;   StringTokenizer strtokenizer;   public InputReader(InputStream inputstr) {    buffreader = new BufferedReader(new InputStreamReader(inputstr), 1000000);strtokenizer = null; }     String next() {    while (strtokenizer == null || !strtokenizer.hasMoreTokens()) {     try { strtokenizer = new StringTokenizer(buffreader.readLine()); }     catch (IOException e) { throw new RuntimeException(e); }    }    return strtokenizer.nextToken(); }     public int nextInt() { return Integer.parseInt(next()); }   public long nextLong() { return Long.parseLong(next()); }   public double nextDouble() { return Double.parseDouble(next()); }   public int[] nextIntArr(int n){    int[] arr=new int[n];    for (int i=0;i<n;i++){arr[i]=nextInt();}    return arr;}   public long[] nextLongArr(int n){    long[] arr=new long[n];    for (int i=0;i<n;i++){arr[i]=nextLong();}    return arr;}   public String[] nextStringArr(int n){    String[] arr=new String[n];    for (int i=0;i<n;i++){arr[i]=next();}    return arr;}  }  static InputReader r = new InputReader(System.in);  static PrintWriter pw = new PrintWriter(System.out);  public static void main(String[] args){   int t=r.nextInt();   for (int v=0;v<t;v++){    int n=r.nextInt();    if (n%2==1){     pw.println("NO");    }    else{     int x=n/2;     boolean check=false;     for (int i=1;i<=(int)Math.sqrt(x)+1;i++){      if (i*i*2==x||i*i==x){       pw.println("YES");check=true;break;      }     }     if (!check){      pw.println("NO");     }    }    }   pw.close();   } }
3,public class B implements Runnable { FastReader scn; PrintWriter out; String INPUT = "";  void solve() {  int n = scn.nextInt();  int[] arr = scn.nextIntArray(n);  int[][] a = new int[n * (n + 1) / 2][];  int[] need = new int[a.length];  int pos = 0;  for (int l = 0; l < n; l++) {  int sum = 0;  for (int r = l; r < n; r++) {   sum += arr[r];   a[pos] = new int[] { l, r, sum };   need[pos++] = sum;  }  }  need = scn.uniq(need);  int[][][] list = new int[need.length][][];  int[] size = new int[list.length];  for (int i = 0; i < pos; i++) {  size[Arrays.binarySearch(need, a[i][2])]++;  }  for (int i = 0; i < list.length; i++) {  list[i] = new int[size[i]][];  }  for (int i = 0; i < pos; i++) {  int ind = Arrays.binarySearch(need, a[i][2]);  list[ind][--size[ind]] = new int[] { a[i][0], a[i][1] };  }  int ind = -1, max = 0;  for (int i = 0; i < list.length; i++) {  if(list[i].length == 0) {   continue;  }  Arrays.sort(list[i], (o1, o2) -> o1[1] - o2[1]);   int count = 1, last = list[i][0][1];  for(int j = 1; j < list[i].length; j++) {   if(list[i][j][0] > last) {   count++;   last = list[i][j][1];   }  }    if (count > max) {   max = count;   ind = i;  }  }   out.println(max);  int last = list[ind][0][1];  out.println((list[ind][0][0] + 1) + " " + (list[ind][0][1] + 1));   for(int i = 1; i < list[ind].length; i++) {  if(list[ind][i][0] > last) {   out.println((list[ind][i][0] + 1) + " " + (list[ind][i][1] + 1));   last = list[ind][i][1];  }  } }  public void run() {  long time = System.currentTimeMillis();  boolean oj = System.getProperty("ONLINE_JUDGE") != null;  out = new PrintWriter(System.out);  scn = new FastReader(oj);  solve();  out.flush();  if (!oj) {  System.out.println(Arrays.deepToString(new Object[] { System.currentTimeMillis() - time + " ms" }));  } }  public static void main(String[] args) {  new Thread(null, new B(), "Main", 1 << 26).start(); }  class FastReader {  InputStream is;  public FastReader(boolean onlineJudge) {  is = onlineJudge ? System.in : new ByteArrayInputStream(INPUT.getBytes());  }  byte[] inbuf = new byte[1024];  public int lenbuf = 0, ptrbuf = 0;  int readByte() {  if (lenbuf == -1)   throw new InputMismatchException();  if (ptrbuf >= lenbuf) {   ptrbuf = 0;   try {   lenbuf = is.read(inbuf);   } catch (IOException e) {   throw new InputMismatchException();   }   if (lenbuf <= 0)   return -1;  }  return inbuf[ptrbuf++];  }  boolean isSpaceChar(int c) {  return !(c >= 33 && c <= 126);  }  int skip() {  int b;  while ((b = readByte()) != -1 && isSpaceChar(b))   ;  return b;  }  double nextDouble() {  return Double.parseDouble(next());  }  char nextChar() {  return (char) skip();  }  String next() {  int b = skip();  StringBuilder sb = new StringBuilder();  while (!(isSpaceChar(b))) {   sb.appendCodePoint(b);   b = readByte();  }  return sb.toString();  }  String nextLine() {  int b = skip();  StringBuilder sb = new StringBuilder();  while ((!isSpaceChar(b) || b == ' ')) {   sb.appendCodePoint(b);   b = readByte();  }  return sb.toString();  }  char[] next(int n) {  char[] buf = new char[n];  int b = skip(), p = 0;  while (p < n && !(isSpaceChar(b))) {   buf[p++] = (char) b;   b = readByte();  }  return n == p ? buf : Arrays.copyOf(buf, p);  }  int nextInt() {  int num = 0, b;  boolean minus = false;  while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))   ;  if (b == '-') {   minus = true;   b = readByte();  }   while (true) {   if (b >= '0' && b <= '9') {   num = num * 10 + (b - '0');   } else {   return minus ? -num : num;   }   b = readByte();  }  }  long nextLong() {  long num = 0;  int b;  boolean minus = false;  while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))   ;  if (b == '-') {   minus = true;   b = readByte();  }   while (true) {   if (b >= '0' && b <= '9') {   num = num * 10 + (b - '0');   } else {   return minus ? -num : num;   }   b = readByte();  }  }  char[][] nextMatrix(int n, int m) {  char[][] map = new char[n][];  for (int i = 0; i < n; i++)   map[i] = next(m);  return map;  }  int[] nextIntArray(int n) {  int[] a = new int[n];  for (int i = 0; i < n; i++)   a[i] = nextInt();  return a;  }  long[] nextLongArray(int n) {  long[] a = new long[n];  for (int i = 0; i < n; i++)   a[i] = nextLong();  return a;  }  int[][] next2DInt(int n, int m) {  int[][] arr = new int[n][];  for (int i = 0; i < n; i++) {   arr[i] = nextIntArray(m);  }  return arr;  }  long[][] next2DLong(int n, int m) {  long[][] arr = new long[n][];  for (int i = 0; i < n; i++) {   arr[i] = nextLongArray(m);  }  return arr;  }  int[] shuffle(int[] arr) {  Random r = new Random();  for (int i = 1, j; i < arr.length; i++) {   j = r.nextInt(i);   arr[i] = arr[i] ^ arr[j];   arr[j] = arr[i] ^ arr[j];   arr[i] = arr[i] ^ arr[j];  }  return arr;  }  int[] uniq(int[] arr) {  Arrays.sort(arr);  int[] rv = new int[arr.length];  int pos = 0;  rv[pos++] = arr[0];  for (int i = 1; i < arr.length; i++) {   if (arr[i] != arr[i - 1]) {   rv[pos++] = arr[i];   }  }  return Arrays.copyOf(rv, pos);  }  int[] reverse(int[] arr) {  int l = 0, r = arr.length - 1;  while (l < r) {   arr[l] = arr[l] ^ arr[r];   arr[r] = arr[l] ^ arr[r];   arr[l] = arr[l] ^ arr[r];   l++;   r--;  }  return arr;  }  } }
6,public class C { public static void main(String[] args) {  new C().run(); }  class FastScanner {  BufferedReader br;  StringTokenizer st;  boolean eof;  String buf;  public FastScanner(String fileName) throws FileNotFoundException {  br = new BufferedReader(new FileReader(fileName));  nextToken();  }  public FastScanner(InputStream stream) {  br = new BufferedReader(new InputStreamReader(stream));  nextToken();  }  String nextToken() {  while (st == null || !st.hasMoreTokens()) {   try {   st = new StringTokenizer(br.readLine());   } catch (Exception e) {   eof = true;   break;   }  }  String ret = buf;  buf = eof ? "-1" : st.nextToken();  return ret;  }  int nextInt() {  return Integer.parseInt(nextToken());  }  long nextLong() {  return Long.parseLong(nextToken());  }  double nextDouble() {  return Double.parseDouble(nextToken());  }  void close() {  try {   br.close();  } catch (Exception e) {   }  }  boolean isEOF() {  return eof;  } }  FastScanner sc; PrintWriter out;  public void run() {  Locale.setDefault(Locale.US);  try {  sc = new FastScanner(System.in);  out = new PrintWriter(System.out);  solve();  sc.close();  out.close();  } catch (Throwable e) {  e.printStackTrace();  System.exit(1);  } }  long nextLong() {  return sc.nextLong(); }  double nextDouble() {  return sc.nextDouble(); }  int nextInt() {  return sc.nextInt(); }  String nextToken() {  return sc.nextToken(); }  static class Point {  int x, y;  public Point(int x, int y) {  super();  this.x = x;  this.y = y;  }  int dist(Point p) {  return (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y);  } }  void solve() {  Point p0 = new Point(nextInt(), nextInt());  int n = nextInt();  Point[] p = new Point[n];  for (int i = 0; i < n; i++) {  p[i] = new Point(nextInt(), nextInt());  }  int[][] d = new int[n][n];  for (int i = 0; i < n; i++) {  for (int j = 0; j < n; j++) {   d[i][j] = p[i].dist(p[j]);  }  }  int[] d0 = new int[n];  for (int i = 0; i < n; i++) {  d0[i] = p0.dist(p[i]);  }  int[] dp = new int[1 << n];  Arrays.fill(dp, 1 << 30);  dp[0] = 0;  int[] from = new int[1 << n];  for (int i = 0; i + 1 < 1 << n; i++) {  int j = Integer.numberOfTrailingZeros(Integer.lowestOneBit(~i));  int cnt = dp[i] + 2 * d0[j];  if (dp[i ^ (1 << j)] > cnt) {   dp[i ^ (1 << j)] = cnt;   from[i ^ (1 << j)] = i;  }  for (int k = j + 1; k < n; k++) {   if (((i >> k) & 1) == 0) {   cnt = dp[i] + d0[j] + d0[k] + d[j][k];   if (dp[i ^ (1 << j) ^ (1 << k)] > cnt) {    dp[i ^ (1 << j) ^ (1 << k)] = cnt;    from[i ^ (1 << j) ^ (1 << k)] = i;   }   }  }  }  ArrayList<Integer> ans = new ArrayList<Integer>();  ans.add(0);  int mask = (1 << n) - 1;  while (mask > 0) {  int xor = mask ^ from[mask];  while (xor > 0) {   ans.add(Integer    .numberOfTrailingZeros(Integer.lowestOneBit(xor)) + 1);   xor = xor & (xor - 1);  }  ans.add(0);  mask = from[mask];  }  out.println(dp[(1 << n) - 1]);  for (int i : ans) {  out.print(i + " ");  } } }
6,public class E { public static void main(String[] args) {  MyScanner sc = new MyScanner();  int t = sc.nextInt();  for(int w = 0; w < t; w++) {  int n = sc.nextInt(), m = sc.nextInt();  TreeSet<X> set = new TreeSet<X>();  int[][] grid = new int[n][m];  for(int i = 0; i < n; i++)   for(int j = 0; j < m; j++) {   grid[i][j] = sc.nextInt();   set.add(new X(i, j, grid[i][j]));   }  Y[] top4 = new Y[n];  int sum = 0;  for(int i = 0; i < n; i++) {   top4[i] = new Y(set.pollLast());   sum += top4[i].a;  }  Arrays.sort(top4);  HashSet<String> strs = new HashSet<String>();  AAA[] sss = new AAA[n];  boolean[] used = new boolean[n];  if(n == 4) {   for(int i = 0; i < 4; i++) {   int max = -1, jj = -1;   for(int j = 0; j < 4; j++) {    if(!used[j] && top4[j].a > max) {    max = top4[j].a;    jj = j;    }   }   used[jj] = true;   sss[i] = new AAA(max, jj);   }   for(int i = 0; i < n; i++)   strs.add(top4[i].i + " " + top4[i].j);  }  int ans = sum;  if(n == 4 && top4[0].j == top4[1].j && top4[2].j == top4[3].j && top4[0].j != top4[2].j) {   if(two(top4[0], top4[1]) != two(top4[2], top4[3])) {   ans = 0;   int oneCol = two(top4[0], top4[1]) ? top4[2].j : top4[0].j;   for(int i = 0; i < n; i++)    for(int j = 0; j < m; j++)    if(!strs.contains(i + " " + j)){     int no = -1;     for(int k = 0; k < 4; k++)     if(j == oneCol && top4[k].j == oneCol && two(top4[k], new Y(new X(i, j, 0))))      no = k;     ans = max(ans, sum - sss[no == sss[3].i ? 2 : 3].a + grid[i][j]);    }   }  }  out.println(ans);  }  out.close(); } static class AAA {  int a, i;  public AAA(int A, int I) {  a = A;   i = I;  } } static boolean two(Y y1, Y y2) {  return (y1.i - y2.i + 4) % 4 == 2; } static class Y implements Comparable<Y> {  int i, j, a;  public Y(X x) {  i = x.i;  j = x.j;  a = x.a;  }  public int compareTo(Y x) {  if(j == x.j)   return i - x.i;  return j - x.j;  } } static class X implements Comparable<X> {  int i, j, a;  public X(int I, int J, int A) {  i = I;  j = J;  a = A;  }  public int compareTo(X x) {  if(a == x.a && i == x.i)   return j - x.j;  else if(a == x.a)   return i - x.i;  return a - x.a;  } } public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out)); public static class MyScanner {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st;  String next() {  while (st == null || !st.hasMoreElements())   try {   st = new StringTokenizer(br.readLine());   } catch (IOException e) {   e.printStackTrace();   }  return st.nextToken();  }  int nextInt() {  return Integer.parseInt(next());  }  long nextLong() {  return Long.parseLong(next());  }  double nextDouble() {  return Double.parseDouble(next());  }  String nextLine() {  String str = "";  try {   str = br.readLine();  } catch (IOException e) {   e.printStackTrace();  }  return str;  } } }
1,public class lets_do {  InputReader in;  PrintWriter out;  Helper_class h;  final long mod=1000000007;  public static void main(String[] args) throws java.lang.Exception{   new lets_do().run();  }  void run() throws Exception{   in=new InputReader();   out = new PrintWriter(System.out);   h = new Helper_class();   int t=1;   while(t-->0)    solve();   out.flush();    out.close();  }  long[] arr;  int n;  HashMap<Integer,Integer> hmap=new HashMap<Integer,Integer>();  HashSet<Integer> hset=new HashSet<Integer>();  void solve(){   n=h.ni();   long d=h.nl();   int i=0;   arr=new long[n];   for(i=0;i<n;i++)    arr[i]=h.nl();   int count=2;   for(i=0;i<n-1;i++){    if(Math.abs(arr[i]-arr[i+1])>(2*d))     count+=2;    else if(Math.abs(arr[i]-arr[i+1])==(2*d))     count+=1;   }   h.pn(count);  }  class Helper_class{   long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}   int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}   int bitcount(long n){return (n==0)?0:(1+bitcount(n&(n-1)));}   void p(Object o){out.print(o);}   void pn(Object o){out.println(o);}   void pni(Object o){out.println(o);out.flush();}   String n(){return in.next();}   String nln(){return in.nextLine();}   int ni(){return Integer.parseInt(in.next());}   long nl(){return Long.parseLong(in.next());}   double nd(){return Double.parseDouble(in.next());}   long mul(long a,long b){    if(a>=mod)a%=mod;    if(b>=mod)b%=mod;    a*=b;    if(a>=mod)a%=mod;    return a;   }   long modPow(long a, long p){    long o = 1;    while(p>0){     if((p&1)==1)o = mul(o,a);     a = mul(a,a);     p>>=1;    }    return o;   }   long add(long a, long b){    if(a>=mod)a%=mod;    if(b>=mod)b%=mod;    if(b<0)b+=mod;    a+=b;    if(a>=mod)a-=mod;    return a;   }  }  class InputReader{   BufferedReader br;   StringTokenizer st;   public InputReader(){    br = new BufferedReader(new InputStreamReader(System.in));   }    public InputReader(String s) throws Exception{    br = new BufferedReader(new FileReader(s));   }    String next(){    while (st == null || !st.hasMoreElements()){     try{      st = new StringTokenizer(br.readLine());     }catch (IOException e){      e.printStackTrace();     }    }    return st.nextToken();   }    String nextLine(){    String str = "";    try{     str = br.readLine();    }catch (IOException e){     e.printStackTrace();    }     return str;   }  } }
5,public class A {   public static void main(String[] args) throws Exception {   int n = nextInt(), b = nextInt(), a = nextInt();     int[] mas = new int[n];   for(int i = 0; i<n; i++) {    mas[i] = nextInt();   }   Arrays.sort(mas);     if(mas[a - 1] == mas[a]) {    exit(0);   }     println(mas[a] - mas[a-1]);  }        private static StreamTokenizer in;  private static PrintWriter out;  private static BufferedReader inB;   private static boolean FILE=false;   private static int nextInt() throws Exception{   in.nextToken();   return (int)in.nval;  }   private static String nextString() throws Exception{   in.nextToken();   return in.sval;  }   static{   try {    out = new PrintWriter(FILE ? (new FileOutputStream("output.txt")) : System.out);    inB = new BufferedReader(new InputStreamReader(FILE ? new FileInputStream("input.txt") : System.in));   } catch(Exception e) {e.printStackTrace();}   in = new StreamTokenizer(inB);  }         private static void println(Object o) throws Exception {   out.println(o);   out.flush();  }  private static void exit(Object o) throws Exception {   println(o);   exit();  }  private static void exit() {   System.exit(0);  }  private static final int INF = Integer.MAX_VALUE;  private static final int MINF = Integer.MIN_VALUE;  }
0,public class Test { public static void main(String[] args) throws IOException{ BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));  int n=Integer.parseInt(bf.readLine());  if(n%2==0) System.out.println(4+" "+(n-4)); else System.out.println(9+" "+(n-9));  } }
0,public class Main implements Runnable {      public void solve() throws Throwable {   long a = sc.nextLong();   long b = sc.nextLong();   long ans = 0;   while (a > 0 && b > 0) {    if (a > b) {     ans += a/b;     a %= b;    } else {     ans += b/a;     b %= a;    }   }   out.println(ans);  }   static Throwable t;   BufferedReader reader;  FastScanner sc;  PrintWriter out;   public static void main(String[] args) throws Throwable {   Thread thread = new Thread(null, new Main(), "", 1 << 26);   thread.start();   thread.join();   if (Main.t != null)    throw t;  }  @Override  public void run() {   try {    reader = new BufferedReader(new InputStreamReader(System.in));    out = new PrintWriter(System.out);    sc = new FastScanner(reader);    solve();   } catch (Throwable t) {    Main.t = t;   } finally {    out.close();   }  } } class FastScanner {  BufferedReader reader;  StringTokenizer strtok;  public FastScanner(BufferedReader reader) {   this.reader = reader;     }   public String nextToken() throws IOException{   while (strtok == null || !strtok.hasMoreTokens()) {    strtok = new StringTokenizer(reader.readLine());   }   return strtok.nextToken();  }   public int nextInt() throws IOException {   return Integer.parseInt(nextToken());  }   public double nextDouble() throws IOException {   return Double.parseDouble(nextToken());  }   public long nextLong() throws IOException {   return Long.parseLong(nextToken());  } }
0,public class a {  public static class Pair implements Comparable<Pair> {   int f, s;   public Pair(int f, int s) {    this.f = f;    this.s = s;   }   @Override   public int compareTo(Pair o) {    return s - o.s;   }  };  public static void main(String[] args) throws IOException {   PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));   BufferedReader in = new BufferedReader(new InputStreamReader(System.in));   String s[] = in.readLine().split(" ");   long r = Long.parseLong(s[0]);   long l = Long.parseLong(s[1]);   if (r % 2 == 0) {    if (l - r+1 < 3) {     out.println(-1);    } else {     out.println(r + " " + (r + 1) + " " + (r + 2));    }   } else {    if (l - r+1 < 4) {     out.println(-1);    } else {     out.println((r + 1) + " " + (r + 2) + " " + (r + 3));    }   }   out.close();  } }
2,public class DigitSequence {  public static PrintWriter out;    public static void main(String[] args) throws IOException  {   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));   StringTokenizer token = new StringTokenizer("");   String temp[] = br.readLine().split(" ");   long pos = Long.parseLong(temp[0]);   out = new PrintWriter(new BufferedOutputStream(System.out));   if (pos<10)   {    out.println(pos);   }   else   {    out.println(findDigitSequence(pos));   }   out.close();  }  private static char findDigitSequence(long pos)  {     long min = 0;   long max = 9;   long dig = 1;   while (pos>max)   {    dig++;    min = max+1;    max=(long) (max+9*Math.pow(10, dig-1)*dig);   }   pos = pos-min;   long num = (long) (pos/dig+Math.pow(10, dig-1));   String st = String.valueOf(num);   if (dig==1)   {    return st.charAt(0);   }   char result = st.charAt((int) (pos%dig));   return result;  }   }
0,public class CF1068A { public CF1068A() {  FS scan = new FS();  long n = scan.nextLong(), m = scan.nextLong(), k = scan.nextLong(), l = scan.nextLong();  long ceil = (k + l + m - 1) / m;  if(k + l <= n && ceil * m <= n) System.out.println(ceil);  else System.out.println(-1); } class FS {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer("");  public String next() {  while(!st.hasMoreTokens()) {   try { st = new StringTokenizer(br.readLine()); }   catch(Exception e) { e.printStackTrace(); }  }  return st.nextToken();  }  public int nextInt() { return Integer.parseInt(next()); }  public long nextLong() { return Long.parseLong(next()); } } public static void main(String[] args) { new CF1068A(); } }
4,public class Sol{ static class Pair implements Comparable<Pair>{   int x;int y;int value;   public Pair(int x,int y,int value) {      this.x=x;   this.y=y;   this.value=value;   }   @Override   public int compareTo(Pair p){return Long.compare(y,p.y); }    } public static void main(String []args){ int t=1; while(t-->0){ int n=ni();mod=nl(); precomp(); long dp[][]=new long[405][405];dp[0][0]=1l; for(int i=0;i<n;i++){  for(int j=0;j<=i;j++){   for(int k=1;k+i<=n;k++){       dp[i+k+1][j+k]+=((dp[i][j]*p2[k-1])%mod)*Comb[k+j][k];   dp[i+k+1][j+k]%=mod;  }  } } long sum=0l; for(int i=0;i<=n;i++)sum=(sum+dp[n+1][i])%mod; out.println(sum); }out.close();}  static long Comb[][]=new long[405][405]; static long p2[]=new long[405]; static long inv[]=new long[405]; static long factorial[]=new long[405]; static void precomp(){ inv[0]=1;factorial[0]=1l; for(long i=1;i<405;i++){factorial[(int)i]=i*factorial[(int)i-1];factorial[(int)i]%=mod;} for(int i=1;i<405;i++){ inv[i]=power(factorial[i],mod-2);} for(int i=0;i<405;i++){   for(int j=0;j<=i;j++){  Comb[i][j]=(((factorial[i]*inv[j])%mod)*inv[i-j])%mod;  } } for(int i=0;i<405;i++)p2[i]=power(2,i); } static int Max=Integer.MAX_VALUE; static long mod=1000000007; static int v(char c){return (int)(c-'a')+1;} public static long power(long x, long y )  {     long res = 1L;   x = x%mod;   while(y > 0)   {    if((y&1)==1)     res = (res*x)%mod;    y >>= 1;    x = (x*x)%mod;   }   return res;  }  static InputStream inputStream = System.in; static OutputStream outputStream = System.out; static FastReader in=new FastReader(inputStream); static PrintWriter out=new PrintWriter(outputStream); static class FastReader {  BufferedReader br;  StringTokenizer st;    FastReader(InputStream is) {    br = new BufferedReader(new InputStreamReader(is));   }  public String next()  {   while (st == null || !st.hasMoreElements())   {    try   {     st = new StringTokenizer(br.readLine());    }    catch (IOException e)    {     e.printStackTrace();    }   }   return st.nextToken();  }   public int nextInt()  {   return Integer.parseInt(next());  }   public long nextLong()  {   return Long.parseLong(next());  }   public double nextDouble()  {   return Double.parseDouble(next());  }    String nextLine()  {   String str = "";   try  {    str = br.readLine();   }   catch (IOException e)   {    e.printStackTrace();   }   return str;  } } static int ni(){return in.nextInt();} static long nl(){return in.nextLong();} static String ns(){return in.nextLine();} static int[] na(int n){int a[]=new int[n];for(int i=0;i<n;i++){a[i]=ni();} return a;} }
3,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskC solver = new TaskC();   solver.solve(1, in, out);   out.close();  }  static class TaskC {   long mod = (long) 1e9 + 7;   public void solve(int testNumber, InputReader in, PrintWriter out) {    int n = in.nextInt();    char ar[] = new char[n];    for (int i = 0; i < n; i++) {     ar[i] = in.readString().charAt(0);    }    long dp[][] = new long[n + 1][n + 1];    for (int i = 0; i < n; i++) {     dp[n - 1][i] = 1;    }    long prev = n;    for (int i = n - 2; i >= 0; i--) {     if (ar[i] == 'f') {      if (ar[i + 1] == 's') {       for (int j = n - 2; j >= 0; j--) {        dp[i][j] = dp[i + 1][j + 1];       }      } else {       for (int j = n - 2; j >= 0; j--) {        dp[i][j] = dp[i + 1][j + 1];       }      }     } else {      for (int j = n - 1; j >= 0; j--) {       if (prev < 0) {        prev += mod;       }       dp[i][j] = prev;       prev = prev - dp[i + 1][j];      }     }     prev = 0;     for (int j = 0; j < n; j++) {      prev += dp[i][j];      prev = prev % mod;     }    }    out.println(dp[0][0] % mod);   }  }  static class InputReader {   private final InputStream stream;   private final byte[] buf = new byte[8192];   private int curChar;   private int snumChars;   public InputReader(InputStream st) {    this.stream = st;   }   public int read() {        if (snumChars == -1)     throw new InputMismatchException();    if (curChar >= snumChars) {     curChar = 0;     try {      snumChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (snumChars <= 0)      return -1;    }    return buf[curChar++];   }   public int nextInt() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   public String readString() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    StringBuilder res = new StringBuilder();    do {     res.appendCodePoint(c);     c = read();    } while (!isSpaceChar(c));    return res.toString();   }   public boolean isSpaceChar(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }  } }
4,public class Main{   private static int[] T;   public static void main(String[] args){     Scanner in = new Scanner(System.in);   char[] input = in.nextLine().toCharArray();   int length = input.length;   int max = 0;   for(int i=0; i<length; i++){    char[] subString = Arrays.copyOfRange(input, 1, input.length);    int temp = solve(input, subString);    if(temp > max) max = temp;    input = Arrays.copyOfRange(input, 1, input.length);   }   System.out.println(max);    }  private static int solve(char[] P, char[] S) {     T = new int[P.length+1];     preKmp(P, P.length, T);   int max = 0;   int i = 0, j = 0;   while (j < S.length) {    while (i > -1 && (P[i] != S[j]))     i = T[i];    i++;    j++;    if ( i > max) max = i;    if (i >= P.length) {     i = T[i];    }   }     return max;       }  private static void preKmp(char[] x, int m, int[] kmpNext) {    int i = 0, j = kmpNext[0] = -1;       while (i < m-1) {    while (j > -1 && x[i] != x[j])     j = kmpNext[j];    i++;    j++;    if (x[i] == x[j])     kmpNext[i] = kmpNext[j];    else     kmpNext[i] = j;    }     } }
4,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskC solver = new TaskC();   solver.solve(1, in, out);   out.close();  }  static class TaskC {   private static final int MOD = (int) 1e9 + 7;   public void solve(int testNumber, InputReader in, PrintWriter out) {    int n = in.nextInt();    int[] primes = getPrimes(40_000);    int[][] a = new int[n][];    for (int i = 0; i < n; ++i) {     int x = in.nextInt();     IntList divs = new IntList();     for (int j : primes) {      if (j * j > x) {       break;      }      int cnt = 0;      while (x % j == 0) {       cnt++;       x /= j;      }      if (cnt % 2 == 1) {       divs.add(j);      }     }     if (x > 1) {      divs.add(x);     }     a[i] = divs.toArray();    }    Comparator<int[]> cmp = ((o1, o2) -> {     for (int i = 0; i < o1.length && i < o2.length; ++i) {      if (o1[i] < o2[i]) {       return -1;      } else if (o2[i] < o1[i]) {       return 1;      }     }     return Integer.compare(o1.length, o2.length);    });    Arrays.sort(a, cmp);    IntList freqsList = new IntList();    int cnt = 1;    for (int i = 1; i < n; ++i) {     if (cmp.compare(a[i], a[i - 1]) == 0) {      cnt++;     } else {      freqsList.add(cnt);      cnt = 1;     }    }    freqsList.add(cnt);    int[][] comb = new int[2 * n + 1][2 * n + 1];    for (int i = 0; i < comb.length; ++i) {     comb[i][0] = 1;     for (int j = 1; j <= i; ++j) {      comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD;     }    }    int[] dp = new int[n];    int[] ndp = new int[n];    dp[0] = 1;    int total = 0;    int ans = 1;    for (int x : freqsList.toArray()) {     Arrays.fill(ndp, 0);     for (int bad = 0; bad < n; ++bad) {      if (dp[bad] == 0) {       continue;      }      for (int putSeparately = 1; putSeparately <= x; ++putSeparately) {       for (int breakEq = 0; breakEq <= putSeparately; ++breakEq) {        int nState = bad + x - putSeparately - breakEq;        if (nState < 0 || nState >= n) {         continue;        }        int rem = total + 1 - bad;        int notBreak = putSeparately - breakEq;        if (breakEq > bad || notBreak > rem) {         continue;        }        int add = (int) ((long) comb[bad][breakEq] * comb[rem][notBreak] % MOD *          comb[x - 1][putSeparately - 1] % MOD * dp[bad] % MOD);        ndp[nState] += add;        ndp[nState] %= MOD;       }      }     }     total += x;     int[] aux = dp;     dp = ndp;     ndp = aux;     ans = (int) ((long) ans * fact(x) % MOD);    }    ans = (int) ((long) ans * dp[0] % MOD);    out.println(ans);   }   private int fact(int n) {    int res = 1;    for (int i = 2; i <= n; ++i) {     res = (int) ((long) res * i % MOD);    }    return res;   }   private int[] getPrimes(int n) {    boolean[] isPrime = new boolean[n + 1];    Arrays.fill(isPrime, 2, isPrime.length, true);    for (int i = 2; i * i <= n; ++i) {     if (isPrime[i]) {      for (int j = i * i; j <= n; j += i) {       isPrime[j] = false;      }     }    }    IntList primes = new IntList();    for (int i = 2; i <= n; ++i) {     if (isPrime[i]) {      primes.add(i);     }    }    return primes.toArray();   }  }  static class InputReader {   private InputStream stream;   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   public InputReader(InputStream stream) {    this.stream = stream;   }   public int read() {    if (numChars == -1)     throw new UnknownError();    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (IOException e) {      throw new UnknownError();     }     if (numChars <= 0)      return -1;    }    return buf[curChar++];   }   public int nextInt() {    return Integer.parseInt(next());   }   public String next() {    int c = read();    while (isSpaceChar(c))     c = read();    StringBuffer res = new StringBuffer();    do {     res.appendCodePoint(c);     c = read();    } while (!isSpaceChar(c));    return res.toString();   }   private boolean isSpaceChar(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }  }  static interface IntIterator extends Iterator<Integer> {  }  static class IntList implements Iterable<Integer> {   int[] elem;   int size;   public IntList() {    this(0, 0, 1);   }   public IntList(int size) {    this(size, 0, Math.max(1, size));   }   public IntList(int size, int value) {    this(size, value, Math.max(1, size));   }   public IntList(int size, int value, int capacity) {    elem = new int[capacity];    Arrays.fill(elem, 0, size, value);    this.size = size;   }   private IntList(int... e) {    elem = e.clone();    size = e.length;   }   public void add(int e) {    if (size + 1 > elem.length) {     increaseCapacity();    }    elem[size++] = e;   }   private void increaseCapacity() {    changeCapacity(3 * elem.length / 2 + 1);   }   private void changeCapacity(int newCapacity) {    int[] nElem = new int[newCapacity];    System.arraycopy(elem, 0, nElem, 0, Math.min(elem.length, newCapacity));    elem = nElem;   }   public IntIterator iterator() {    return new IntIterator() {     int pos = 0;      public Integer next() {      return IntList.this.elem[pos++];     }      public boolean hasNext() {      return pos < IntList.this.size;     }      public int nextInt() {      return IntList.this.elem[pos++];     }    };   }   public int[] toArray() {    return Arrays.copyOf(elem, size);   }   public int hashCode() {    int hashCode = 0;    for (int i = 0; i < size; ++i) {     hashCode = 31 * hashCode + elem[i];    }    return hashCode;   }  } }
1,public class Main implements Runnable {  public void _main() throws IOException {  int n = nextInt();  int even = 0, odd = 0, atEven = -1, atOdd = -1;  for (int i = 0; i < n; i++) {  if (nextInt() % 2 == 0) {   atEven = i;   ++even;  }  else {   atOdd = i;   ++odd;  }  }  if (odd == 1)  out.print(atOdd + 1);  else  out.print(atEven + 1); }  private BufferedReader in; private PrintWriter out; private StringTokenizer st;  private String next() throws IOException {  while (st == null || !st.hasMoreTokens()) {  String rl = in.readLine();  if (rl == null)   return null;  st = new StringTokenizer(rl);  }  return st.nextToken(); }  private int nextInt() throws IOException {  return Integer.parseInt(next()); }  private long nextLong() throws IOException {  return Long.parseLong(next()); }  private double nextDouble() throws IOException {  return Double.parseDouble(next()); }  public static void main(String[] args) {  new Thread(new Main()).start(); }  public void run() {  try {  in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);   _main();   out.close();  } catch (Exception e) {  e.printStackTrace();  System.exit(202);  } } }
3,public class Main {  static final long mod=(int)1e9+7;  public static void main(String[] args) throws Exception  {  FastReader in=new FastReader();  PrintWriter pw=new PrintWriter(System.out);  int n=in.nextInt();  int[] arr=new int[n+1];  for(int i=1;i<=n;i++)   arr[i]=in.nextInt();  Map<Integer,TreeMap<Integer,Integer>> map=new HashMap();  for(int i=1;i<=n;i++)  {   int sum=0;   for(int j=i;j<=n;j++)   {   sum+=arr[j];   if(map.containsKey(sum))   {    TreeMap<Integer,Integer> t=map.get(sum);       Map.Entry<Integer,Integer> e=t.lastEntry();    if(e.getKey()>j)    {    t.remove(e.getKey());    t.put(j,i);    map.put(sum,t);    }    else if(e.getKey()<i)    {    t.put(j,i);    map.put(sum,t);    }   }   else   {    TreeMap<Integer,Integer> t=new TreeMap();    t.put(j,i);    map.put(sum,t);   }   }  }  int ans=0,size=0;  for(Map.Entry<Integer,TreeMap<Integer,Integer>> e:map.entrySet())  {   if(e.getValue().size()>size)   {   ans=e.getKey();   size=e.getValue().size();   }  }  pw.println(size);  for(Map.Entry e:map.get(ans).entrySet())   pw.println(e.getValue()+" "+e.getKey());  pw.flush();  } } class pair { int f,s; } class FastReader {  BufferedReader br;  StringTokenizer st;   public FastReader()  {   br=new BufferedReader(new InputStreamReader(System.in));  }   public String next() throws IOException  {   if(st==null || !st.hasMoreElements())   {    st=new StringTokenizer(br.readLine());   }   return st.nextToken();  }   public int nextInt() throws IOException  {   return Integer.parseInt(next());  }   public long nextLong() throws IOException  {   return Long.parseLong(next());  } }
5,public class Main2 {   public static void main(String args[]){   Scanner input = new Scanner(System.in);   int n = input.nextInt();   int m = input.nextInt();   int k = input.nextInt();   int[] num = new int[n];   for(int i = 0 ; i < n ; i++){   num[i] = input.nextInt();   }     System.out.println(str(n,m,k,num));  }  static int str(int n,int m,int k,int[] num){  Arrays.sort(num);  int total = k;  int count = 0;  while(k < m){  if(count == num.length)return -1;  k += num[num.length-count-1]-1;  count++;  }  return count; }  }
3,public class DD { public static void main(String[] args)throws Throwable {  MyScanner sc=new MyScanner();  PrintWriter pw=new PrintWriter(System.out);   int n=sc.nextInt();  int [] a=new int [n];  for(int i=0;i<n;i++)  a[i]=sc.nextInt();  int c=0;  for(int i=0;i<n;i++)  for(int j=i+1;j<n;j++)   if(a[i]>a[j])   c^=1;  int m=sc.nextInt();  while(m-->0){  int l=sc.nextInt()-1;  int r=sc.nextInt()-1;  int d=r-l+1;  d=d*(d-1)/2;  c^=(d%2);  pw.println(c==0? "even" : "odd");  }   pw.flush();  pw.close(); }  static class MyScanner {  BufferedReader br;  StringTokenizer st;  public MyScanner() {  br = new BufferedReader(new InputStreamReader(System.in));  }  String next() {while (st == null || !st.hasMoreElements()) {  try {st = new StringTokenizer(br.readLine());}  catch (IOException e) {e.printStackTrace();}}  return st.nextToken();}  int nextInt() {return Integer.parseInt(next());}  long nextLong() {return Long.parseLong(next());}  double nextDouble() {return Double.parseDouble(next());}  String nextLine(){String str = "";  try {str = br.readLine();}  catch (IOException e) {e.printStackTrace();}  return str;} } }
0,public class Main {  public static void main(String [] args) throws IOException {   BufferedReader f = new BufferedReader(new InputStreamReader(System.in));  PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));     int N = Integer.parseInt(f.readLine());     if (N%2==0) out.println("4 "+(N-4));  if (N%2==1) out.println("9 "+(N-9));     out.close();  System.exit(0); } }
1,public class IQTest implements Runnable {  BufferedReader in;  PrintWriter out;  StringTokenizer tok;  public static void main(String[] args) {   new Thread(new IQTest()).start();  }  void solve() throws IOException {   int n = nextInt();   List<Integer> l1 = new ArrayList<Integer>();   List<Integer> l2 = new ArrayList<Integer>();   for (int i = 0; i < n; ++i) {    int k = nextInt();    if (k % 2 == 0) l1.add(i + 1);    else l2.add(i + 1);   }   if (l1.size() == 1)    out.println(l1.get(0));   else out.println(l2.get(0));  }  public void run() {   try {    in = new BufferedReader(new InputStreamReader(System.in));       out = new PrintWriter(System.out);       solve();    out.flush();    out.close();    in.close();   } catch (IOException e) {       e.printStackTrace();   }  }  String nextLine() throws IOException {   tok = null;   return in.readLine();  }  double nextDouble() throws IOException {   return Double.parseDouble(nextToken());  }  int nextInt() throws IOException {   return Integer.parseInt(nextToken());  }  String nextToken() throws IOException {   while (tok == null || !tok.hasMoreTokens()) {    tok = new StringTokenizer(in.readLine());   }   return tok.nextToken();  } }
3,public class Codechef {  static BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); static ArrayList<ArrayList<Integer>> list;  static HashSet<Integer> hs;  static ArrayList<Integer> tmp;      public static double cal(int a,double b,int x,int r)  {   r*=2;   double dis=(r*r) - Math.pow(Math.abs(a-x),2);     dis=Math.sqrt(dis);     dis+=b;     return dis;    } public static void main (String[] args) throws java.lang.Exception {  int n,r;  StringTokenizer st = new StringTokenizer(br.readLine());  n=Integer.parseInt(st.nextToken());  r=Integer.parseInt(st.nextToken());    int arr[] = new int[n+1];  double cen[] = new double[n+1];    int i,j;    for(i=1;i<=n;i++)  cen[i]=-1.0;    st = new StringTokenizer(br.readLine());  for(i=1;i<=n;i++)arr[i]=Integer.parseInt(st.nextToken());    for(i=1;i<=n;i++)  {   int f=0;   double max=-1.0;   for(j=1;j<=n;j++)   {    if(i!=j && cen[j]!=-1.0 && (Math.abs(arr[i]-arr[j])<=2*r))    {     max=Math.max(max,cal(arr[j],cen[j],arr[i],r));     f=1;         }   }      if(f==1)   cen[i]=max;   else   cen[i]=r*1.0;  }  for(i=1;i<=n;i++)  System.out.print(cen[i]+" "); } }
1,public class A { static Scanner sc = new Scanner(System.in);  public static void main(String[] args) throws Exception {  BitSet primes = primes(1001);  int N = sc.nextInt();  int K = sc.nextInt();  int count = 0;  for (int i = 2; i <= N; ++i) {  if (!primes.get(i)) continue;  int res = i - 1;  boolean found = false;  for (int j = 2; j <= i / 2; ++j) {   if (primes.get(j) && primes.nextSetBit(j + 1) == res - j) {   found = true;   break;   }  }  if (found) {   ++count;  }  }  System.out.println(count >= K ? "YES" : "NO"); }  public static BitSet primes(int max) {  BitSet primeSet = new BitSet(max + 1);  if (max < 2) {  return primeSet;  }  int limit = (int) Math.sqrt(max + 1);  primeSet.set(2);  for (int i = 3; i < max + 1; i += 2) {  primeSet.set(i);  }  for (int i = 3; i <= limit; i += 2) {  if (!primeSet.get(i)) {   continue;  }  for (int j = i * i; j < max; j += i) {   primeSet.clear(j);  }  }  return primeSet; } }
4,public class Main {  static BufferedReader br;  static PrintWriter out;  static StringTokenizer st;   static int[][] moves = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};   static boolean correct(int x, int y, int n, int m) {   return (x >= 0 && x < n && y >= 0 && y < m);  }   static void solve() throws Exception {   int n = nextInt();   int m = nextInt();   int k = nextInt();   int[][] order = new int[n][m];   boolean[][] used = new boolean[n][m];   Queue<Integer[]> q = new LinkedList<>();   Set<String> set = new HashSet<String>();   for(int i = 0; i < k; i++) {    int x = nextInt() - 1;    int y = nextInt() - 1;    order[x][y] = 1;    used[x][y] = true;    q.add(new Integer[] {x, y});    set.add(x + "" + y);   }   while(!q.isEmpty()) {    Integer[] v = q.remove();    for(int[] move : moves) {     int x = v[0] + move[0];     int y = v[1] + move[1];      if(correct(x, y, n, m) && !used[x][y]) {      q.add(new Integer[] {x, y});      used[x][y] = true;      order[x][y] = order[v[0]][v[1]] + 1;     }    }   }   int max = Integer.MIN_VALUE;   int maxI = -1;   int maxJ = -1;   for(int i = 0; i < n; i++) {    for(int j = 0; j < m; j++) {     if(order[i][j] > max) {      max = order[i][j];      maxI = i;      maxJ = j;     }    }   }   maxI++;   maxJ++;   out.println(maxI + " " + maxJ);  }    static int nextInt() throws IOException {   return Integer.parseInt(next());  }  static long nextLong() throws IOException {   return Long.parseLong(next());  }  static double nextDouble() throws IOException {   return Double.parseDouble(next());  }  static String next() throws IOException {   while (st == null || !st.hasMoreTokens()) {    String line = br.readLine();    if (line == null) {     return null;    }    st = new StringTokenizer(line);   }   return st.nextToken();  }  public static void main(String[] args) {   try {    InputStream input = System.in;    OutputStream output = System.out;    br = new BufferedReader(new InputStreamReader(new FileInputStream(new File("input.txt"))));    out = new PrintWriter(new PrintStream(new File("output.txt")));    solve();    out.close();    br.close();   } catch (Throwable t) {    t.printStackTrace();   }  } }
3,public class PaintTheNumbers {  public static void main(String[] args) throws IOException {   int[] colors = new int[101];   BufferedReader f = new BufferedReader(new InputStreamReader(System.in));   StringTokenizer st = new StringTokenizer(f.readLine());   int N = Integer.parseInt(st.nextToken());   st = new StringTokenizer(f.readLine());   for (int i = 0; i < N; i++) {    colors[Integer.parseInt(st.nextToken())]++;   }   int colorCount = 0;   for (int i = 1; i <= 100; i++) {    if (colors[i] != 0) {     colors[i] = 0;     for (int multiple = 2; multiple * i <= 100; multiple++) {      colors[i*multiple] = 0;     }     colorCount++;    }   }   System.out.println(colorCount);  } }
5,public class Solution {  private BufferedReader in; private PrintWriter out; private StringTokenizer st;  static class House implements Comparable<House> {  int x, a;  @Override  public int compareTo(House o) {  return x - o.x;  }  public House(int x, int a) {  this.x = x;  this.a = a;  } }  void solve() throws IOException {  int n = nextInt();  int t = nextInt();  House[] hs = new House[n];  for (int i = 0; i < n; ++i) {  hs[i] = new House(nextInt(), nextInt());  }  Arrays.sort(hs);  int ans = 2;  for (int i = 0; i < n - 1; ++i) {  if (hs[i].a + hs[i + 1].a + 2 * t < 2 * (hs[i + 1].x - hs[i].x)) {   ans += 2;  } else if (hs[i].a + hs[i + 1].a + 2 * t == 2 * (hs[i + 1].x - hs[i].x)) {   ans++;  }  }  out.println(ans); }  Solution() throws IOException {  in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);   eat("");   solve();   in.close();  out.close(); }  private void eat(String str) {  st = new StringTokenizer(str); }  String next() throws IOException {  while (!st.hasMoreTokens()) {  String line = in.readLine();  if (line == null) {   return null;  }  eat(line);  }  return st.nextToken(); }  int nextInt() throws IOException {  return Integer.parseInt(next()); }  long nextLong() throws IOException {  return Long.parseLong(next()); }  double nextDouble() throws IOException {  return Double.parseDouble(next()); }  public static void main(String[] args) throws IOException {  new Solution(); } }
6,public class Main { public static int n, x, y; public static int[] a,b; public static int dp[], before[]; public static int dx[]; public static int d[][]; public static final int INF = 24 * 201 * 201;  public static void main(String[] argv) {  FastScanner scan = new FastScanner(System.in);  PrintWriter out = new PrintWriter(System.out);   x = scan.nextInt();  y = scan.nextInt();   n = scan.nextInt();   a = new int[n+1];  b = new int[n+1];  dx = new int[n+1];  d = new int[n+1][n+1];  for(int i = 0; i < n; ++i){  a[i] = scan.nextInt();  b[i] = scan.nextInt();  }   for(int i = 0; i < n; ++i){  dx[i] = dist(i);  }  for(int i = 0; i < n; ++i){  for(int j = 0; j < n; ++j){   d[i][j] = dist(i,j);  }  }   dp = new int[1 << n];  before = new int[1 << n];  Arrays.fill(dp, INF);  dp[0] = 0;  for(int state = 0; state < (1<<n); state++){    for(int i = 0; i < n; ++i){   int ii = (1 << i);   if((state & ii) > 0){   if(dp[state - ii] == INF) continue;   int newdist = dp[state - ii] + dx[i] + dx[i];   if(dp[state] > newdist){    dp[state] = newdist;    before[state] = state - ii;   }      } else continue;     for(int j = i + 1; j < n; ++j){   if(i == j) continue;   int jj = (1 << j);   if((state & jj) > 0){    if(dp[state - ii - jj] == INF) continue;    int newdist = dp[state - ii - jj] + dx[i] + d[i][j] + dx[j];    if(dp[state] > newdist){    dp[state] = newdist;    before[state] = state - ii - jj;    }       }   }   break;  }  }  System.out.println(dp[(1<<n)-1]);  int state = (1<<n) - 1;  StringBuffer ret = new StringBuffer();  while(state > 0){  int nstate = before[state];  boolean find = false;  String made = "";  for(int i = 0; i < n; ++i){   if(((state & (1<<i)) > 0) && ((nstate & (1<<i)) == 0)){   find = true;   made = made + " " + (i + 1);   }  }  if(find){   made = made + " 0";   ret.append(made, 0, made.length());  }  state = nstate;  }  out.println("0" + ret.toString());  out.close(); } public static int dist(int to){  return Math.abs(a[to] - x) * Math.abs(a[to] - x) + Math.abs(b[to] - y) * Math.abs(b[to] - y); } public static int dist(int from, int to){  return Math.abs(a[from]-a[to]) * Math.abs(a[from]-a[to]) + Math.abs(b[from]-b[to]) * Math.abs(b[from]-b[to]); }  static class FastScanner {  BufferedReader br;  StringTokenizer st;  FastScanner(InputStream is) {  try {   br = new BufferedReader(new InputStreamReader(is));  } catch (Exception e) {   e.printStackTrace();  }  }  String next() {  while (st == null || !st.hasMoreTokens()) {   try {   st = new StringTokenizer(br.readLine());   } catch (Exception e) {   return null;   }  }  return st.nextToken();  }  int nextInt() {  return Integer.parseInt(next());  }  long nextLong() {  return Long.parseLong(next());  }  double nextDouble() {  return Double.valueOf(next());  } } }
2,public class P287B{ Scanner sc=new Scanner(System.in);  int INF=1<<28; double EPS=1e-9;  long n, k;  void run(){  n=sc.nextLong();  k=sc.nextLong();  solve(); }  void solve(){  long left=-1, right=k+1;  for(; right-left>1;){  long m=(left+right)/2;  long lb=k*(k+1)/2-(k-m)*(k-m+1)/2-(m-1);  if(lb>=n){   right=m;  }else{   left=m;  }  }  println(""+(right>k?-1:right)); }  void println(String s){  System.out.println(s); }  void print(String s){  System.out.print(s); }  void debug(Object... os){  System.err.println(deepToString(os)); }  public static void main(String[] args){  Locale.setDefault(Locale.US);  new P287B().run(); } }
0,public class a { public static void main(String[] args) {  Scanner input = new Scanner(System.in);  int n = input.nextInt();  if(n%2 == 0) System.out.println(4+" "+(n-4));  else System.out.println(9+" " +(n-9)); } }
3,public class Main { public static void main(String args[]) {new Main().run();}  FastReader in = new FastReader(); PrintWriter out = new PrintWriter(System.out); void run(){  work();  out.flush(); } long mod=998244353; long gcd(long a,long b) {  return b==0?a:gcd(b,a%b); } void work() {  int n=in.nextInt();  int[] A=new int[n];  for(int i=0;i<n;i++)A[i]=in.nextInt();  HashMap<Integer,Integer> map=new HashMap<>();  HashMap<Integer,ArrayList<int[]>> rec=new HashMap<>();  for(int i=0;i<n;i++) {  for(int j=i,cur=0;j>=0;j--) {   cur+=A[j];   if(map.get(cur)==null) {   map.put(cur,i);   rec.put(cur,new ArrayList<>());   rec.get(cur).add(new int[] {j,i});   }else if(map.get(cur)<j) {   map.put(cur,i);   rec.get(cur).add(new int[] {j,i});   }  }  }  ArrayList<int[]> ret=null;  for(ArrayList<int[]> list:rec.values()) {  if(ret==null||ret.size()<list.size()) {   ret=list;  }  }  out.println(ret.size());  for(int[] r:ret) {  out.println((r[0]+1)+" "+(r[1]+1));  } } }   class FastReader { BufferedReader br; StringTokenizer st;  public FastReader() {  br=new BufferedReader(new InputStreamReader(System.in)); }  public String next()  {  if(st==null || !st.hasMoreElements())  {  try {   st = new StringTokenizer(br.readLine());  } catch (IOException e) {   e.printStackTrace();  }  }  return st.nextToken(); }  public int nextInt()  {  return Integer.parseInt(next()); }  public long nextLong() {  return Long.parseLong(next()); } }
4,public class A { private Scanner in; private PrintWriter out;  private String INPUT = "";  public void solve() {  String str = in.next();  int n = str.length();  for(int k = n - 1;k >= 1;k--){  HashSet<String> set = new HashSet<String>();  for(int i = 0;i < str.length() - k + 1;i++){   if(!set.add(str.substring(i, i + k))){   out.println(k);   return;   }  }  }  out.println(0); }  public void run() throws Exception {  in = INPUT.isEmpty() ? new Scanner(System.in) : new Scanner(new StringReader(INPUT));  out = new PrintWriter(System.out);   solve();  out.flush(); }  public static String add(String str, int k) {  StringBuilder mul = new StringBuilder(str);  StringBuilder ret = new StringBuilder();  for(int i = k;i > 0;i >>= 1){  if((i & 1) == 1)ret.append(mul);  mul.append(mul);  }  return ret.toString(); }  public static void main(String[] args) throws Exception {  new A().run(); }  private int ni() { return Integer.parseInt(in.next()); } private static void tr(Object... o) { System.out.println(o.length == 1 ? o[0] : Arrays.toString(o)); } }
4,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   OutputWriter out = new OutputWriter(outputStream);   TaskC solver = new TaskC();   solver.solve(1, in, out);   out.close();  }  static class TaskC {   public void solve(int testNumber, InputReader in, OutputWriter out) {    int tests = in.nextInt();    for (int t = 0; t < tests; t++) {     int numLines = in.nextInt();         int stackIdx = -1;     int[] stack = new int[10000];     String prev = "";     for (int x = 0; x < numLines; x++) {      int depth = 0;      int next = in.nextInt();      boolean found = false;      for (int i = stackIdx; i >= 0; i--) {       if (next == stack[i] + 1) {        depth = i;        found = true;        break;       }      }      if (found == true) {       stackIdx = depth;       stack[depth] = next;       for (int i = 0; i <= depth; i++) {        if (i != 0) {         out.print(".");        }        out.print(stack[i]);       }       out.println();      } else if (next == 1) {       stackIdx++;       stack[stackIdx] = 1;       for (int i = 0; i <= stackIdx; i++) {        if (i != 0) {         out.print(".");        }        out.print(stack[i]);       }       out.println();      } else {             stackIdx = 0;       stack[0] = next;       out.println(next);      }      }    }   }  }  static class OutputWriter {   private final PrintWriter writer;   public OutputWriter(OutputStream outputStream) {    writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));   }   public OutputWriter(Writer writer) {    this.writer = new PrintWriter(writer);   }   public void print(Object... objects) {    for (int i = 0; i < objects.length; i++) {     if (i != 0) {      writer.print(' ');     }     writer.print(objects[i]);    }   }   public void println() {    writer.println();   }   public void close() {    writer.close();   }   public void print(int i) {    writer.print(i);   }   public void println(int i) {    writer.println(i);   }  }  static class InputReader {   private InputStream stream;   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   private InputReader.SpaceCharFilter filter;   public InputReader(InputStream stream) {    this.stream = stream;   }   public int read() {    if (numChars == -1) {     throw new InputMismatchException();    }    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (numChars <= 0) {      return -1;     }    }    return buf[curChar++];   }   public int nextInt() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if (c < '0' || c > '9') {      throw new InputMismatchException();     }     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   public boolean isSpaceChar(int c) {    if (filter != null) {     return filter.isSpaceChar(c);    }    return isWhitespace(c);   }   public static boolean isWhitespace(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   public interface SpaceCharFilter {    public boolean isSpaceChar(int ch);   }  } }
6,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   inputClass in = new inputClass(inputStream);   PrintWriter out = new PrintWriter(outputStream);   G1PlaylistForPolycarpEasyVersion solver = new G1PlaylistForPolycarpEasyVersion();   solver.solve(1, in, out);   out.close();  }  static class G1PlaylistForPolycarpEasyVersion {   static final int mod = (int) 1e9 + 7;   public void solve(int testNumber, inputClass sc, PrintWriter out) {    int n = sc.nextInt();    int t = sc.nextInt();    G1PlaylistForPolycarpEasyVersion.Song[] songs = new G1PlaylistForPolycarpEasyVersion.Song[n];    for (int i = 0; i < n; i++) {     songs[i] = new G1PlaylistForPolycarpEasyVersion.Song(sc.nextInt(), sc.nextInt());    }    long ans = 0;    for (int mask = 1; mask < (1 << n); mask++) {     int nb = 0;     int tot = 0;     int type1 = 0;     int type2 = 0;     int type3 = 0;     for (int j = 0; j < n; j++) {      if (((1 << j) & mask) > 0) {       nb++;       tot += songs[j].l;       if (songs[j].type == 1) {        type1++;       } else if (songs[j].type == 2) {        type2++;       } else {        type3++;       }      }     }     if (tot == t) {      long[][][][][] dp = new long[nb + 1][3][type1 + 1][type2 + 1][type3 + 1];      boolean[][][][][] go = new boolean[nb + 1][3][type1 + 1][type2 + 1][type3 + 1];      if (type1 > 0) {       go[1][0][type1 - 1][type2][type3] = true;       dp[1][0][type1 - 1][type2][type3] = type1;      }      if (type2 > 0) {       go[1][1][type1][type2 - 1][type3] = true;       dp[1][1][type1][type2 - 1][type3] = type2;      }      if (type3 > 0) {       go[1][2][type1][type2][type3 - 1] = true;       dp[1][2][type1][type2][type3 - 1] = type3;      }      for (int i = 0; i < nb; i++) {       for (int m = 0; m < 3; m++) {        for (int j = 0; j <= type1; j++) {         for (int k = 0; k <= type2; k++) {          for (int l = 0; l <= type3; l++) {           if (go[i][m][j][k][l]) {            if (m == 0) {             if (k > 0) {              dp[i + 1][1][j][k - 1][l] += dp[i][m][j][k][l] * k;              dp[i + 1][1][j][k - 1][l] %= mod;              go[i + 1][1][j][k - 1][l] = true;             }             if (l > 0) {              dp[i + 1][2][j][k][l - 1] += dp[i][m][j][k][l] * l;              dp[i + 1][2][j][k][l - 1] %= mod;              go[i + 1][2][j][k][l - 1] = true;             }            } else if (m == 1) {             if (j > 0) {              dp[i + 1][0][j - 1][k][l] += dp[i][m][j][k][l] * j;              dp[i + 1][0][j - 1][k][l] %= mod;              go[i + 1][0][j - 1][k][l] = true;             }             if (l > 0) {              dp[i + 1][2][j][k][l - 1] += dp[i][m][j][k][l] * l;              dp[i + 1][2][j][k][l - 1] %= mod;              go[i + 1][2][j][k][l - 1] = true;             }            } else {             if (j > 0) {              dp[i + 1][0][j - 1][k][l] += dp[i][m][j][k][l] * j;              dp[i + 1][0][j - 1][k][l] %= mod;              go[i + 1][0][j - 1][k][l] = true;             }             if (k > 0) {              dp[i + 1][1][j][k - 1][l] += dp[i][m][j][k][l] * k;              dp[i + 1][1][j][k - 1][l] %= mod;              go[i + 1][1][j][k - 1][l] = true;             }            }           }          }         }        }       }      }      long toadd = 0;      for (int i = 0; i < 3; i++) {       toadd += dp[nb][i][0][0][0];      }      ans += toadd;      ans %= (int) 1e9 + 7;     }    }    out.println(ans);   }   static class Song {    int l;    int type;    public Song(int x, int y) {     l = x;     type = y;    }   }  }  static class inputClass {   BufferedReader br;   StringTokenizer st;   public inputClass(InputStream in) {    br = new BufferedReader(new InputStreamReader(in));   }   public String next() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }  } }
3,public class CC { public static void main(String[] args)throws Throwable {  MyScanner sc=new MyScanner();  PrintWriter pw=new PrintWriter(System.out);   int n=sc.nextInt();  int r=sc.nextInt();  int [] x=new int [n];  for(int i=0;i<n;i++)  x[i]=sc.nextInt();  double [] ans=new double [n];  ans[0]=r;  for(int i=1;i<n;i++){  ans[i]=r;  for(int j=0;j<i;j++){   double dx=Math.abs(x[i]-x[j]);   if(dx>2*r)   continue;   double y=Math.sqrt((4*r*r)-(dx*dx));   ans[i]=Math.max(ans[i], ans[j]+y);  }  }     for(double z : ans)  pw.print(z+" ");  pw.flush();  pw.close(); }  static class MyScanner {  BufferedReader br;  StringTokenizer st;  public MyScanner() {  br = new BufferedReader(new InputStreamReader(System.in));  }  String next() {while (st == null || !st.hasMoreElements()) {  try {st = new StringTokenizer(br.readLine());}  catch (IOException e) {e.printStackTrace();}}  return st.nextToken();}  int nextInt() {return Integer.parseInt(next());}  long nextLong() {return Long.parseLong(next());}  double nextDouble() {return Double.parseDouble(next());}  String nextLine(){String str = "";  try {str = br.readLine();}  catch (IOException e) {e.printStackTrace();}  return str;} } }
1,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  FastScanner in = new FastScanner(inputStream);  FastPrinter out = new FastPrinter(outputStream);  TaskB solver = new TaskB();  solver.solve(1, in, out);  out.close(); } } class TaskB {   static nn[] B;  static int n,a,b;  public void solve(int testNumber, FastScanner in, FastPrinter out) {  n=in.nextInt();a=in.nextInt();b=in.nextInt();   int ccc=0;   if (a==b)ccc=1;  int[] A=in.readIntArray(n);  B=new nn[n];   for (int i = 0; i < n; i++) {    B[i]=new nn(A[i],i);   }   ArrayUtils.shuffle(B);   Arrays.sort(B);   int chk=1;   for (int i = 0; i < n; i++) {    if (B[i].assign>=0)continue;    int v=B[i].val;    int cc=0;    int pos1=Arrays.binarySearch(B,new nn(a-v,0));    if (pos1>=0&&B[pos1].assign==-1)cc++;    if (a!=b){    int pos2=Arrays.binarySearch(B,new nn(b-v,0));    if (pos2>=0&&B[pos2].assign==-1)cc++; }    if (cc==0){     chk=0;     break;    }    if (cc==1){    go(i);    }   }   if (chk==0){    out.println("NO");    return;   }   int[] ans= new int[n];   for (int i = 0; i < n; i++) {    ans[B[i].pos]=B[i].assign;   }   out.println("YES");   for (int i = 0; i < n; i++) {   out.print(ans[i] + " ");   }   out.println();   }  static void go (int i){   int v=B[i].val;   int pos1=Arrays.binarySearch(B,new nn(a-v,0));   if (pos1>=0&&B[pos1].assign==-1){    B[i].assign=0;    B[pos1].assign=0;    int vv=B[pos1].val;    int np=Arrays.binarySearch(B,new nn(b-vv,0));    if (np>=0)go(np);   }   if (a!=b){   int pos2=Arrays.binarySearch(B,new nn(b-v,0));   if (pos2>=0&&B[pos2].assign==-1){    B[i].assign=1;    B[pos2].assign=1;    int vv=B[pos2].val;    int np=Arrays.binarySearch(B,new nn(a-vv,0));    if (np>=0)go(np);   } }  } } class nn implements Comparable<nn> {   int val,pos;   public String toString() {    return "nn{" +      "val=" + val +      ", pos=" + pos +      ", assign=" + assign +      ", ct=" + ct +      '}';   }   int assign=-1;   int ct=0;   nn(int val, int pos) {    this.val = val;    this.pos = pos;   }   public int compareTo(nn o) {    return this.val-o.val;   } } class FastScanner extends BufferedReader {  public FastScanner(InputStream is) {   super(new InputStreamReader(is));  }  public int read() {   try {    int ret = super.read();      return ret;   } catch (IOException e) {    throw new InputMismatchException();   }  }  static boolean isWhiteSpace(int c) {   return c >= 0 && c <= 32;  }  public int nextInt() {   int c = read();   while (isWhiteSpace(c)) {    c = read();   }   int sgn = 1;   if (c == '-') {    sgn = -1;    c = read();   }   int ret = 0;   while (c >= 0 && !isWhiteSpace(c)) {    if (c < '0' || c > '9') {     throw new NumberFormatException("digit expected " + (char) c       + " found");    }    ret = ret * 10 + c - '0';    c = read();   }   return ret * sgn;  }  public String readLine() {   try {    return super.readLine();   } catch (IOException e) {    return null;   }  }  public int[] readIntArray(int n) {   int[] ret = new int[n];   for (int i = 0; i < n; i++) {    ret[i] = nextInt();   }   return ret;  } } class FastPrinter extends PrintWriter {  public FastPrinter(OutputStream out) {   super(out);  }  public FastPrinter(Writer out) {   super(out);  }  } class ArrayUtils {   static final long seed = System.nanoTime();  static final Random rand = new Random(seed);   public static <T> void shuffle(T[] a) {   for (int i = 0; i < a.length; i++) {    int j = rand.nextInt(i + 1);    T t = a[i];    a[i] = a[j];    a[j] = t;   }  } }
0,public class LuckyDivision {  public final String check (String s) {   String result = "NO";   StringTokenizer stringTokenizer = new StringTokenizer(s, "47");   if(!stringTokenizer.hasMoreTokens()) return "YES";   int S = Integer.parseInt(s);   generateSimpleAndDivide(S, 4, 4, 7);   generateSimpleAndDivide(S, 7, 4, 7);   if(lucky) return "YES";   return result;  }  public static final void main(String[] args) {   Scanner scanner = new Scanner(System.in);   System.out.print(new LuckyDivision().check(scanner.next()));  }  public void generateSimpleAndDivide(int divided, int n, int n1, int n2) {   if(lucky || n >= divided) return;   if(divided % n == 0) lucky = true;   generateSimpleAndDivide(divided, Integer.parseInt(n + "" + n1), n1, n2);   generateSimpleAndDivide(divided, Integer.parseInt(n + "" + n2), n1, n2);  }  private boolean lucky = false; }
3,public class A1209 {  public static void main(String[] args) throws IOException {   try (Input input = new StandardInput(); PrintWriter writer = new PrintWriter(System.out)) {    int n = input.nextInt();    int[] arr = input.readIntArray(n);    Arrays.sort(arr);    int ans =0;    boolean[] vis = new boolean[n];    for(int i=0;i<n;i++){     if(!vis[i]){      vis[i]=true;      for(int j=i+1;j<n;j++){       if(!vis[j] && arr[j]%arr[i]==0){        vis[j]=true;     }      }      ans++;     }    }    System.out.println(ans);   }  }  interface Input extends Closeable {   String next() throws IOException;   default int nextInt() throws IOException {    return Integer.parseInt(next());   }   default long nextLong() throws IOException {    return Long.parseLong(next());   }   default double nextDouble() throws IOException {    return Double.parseDouble(next());   }   default int[] readIntArray() throws IOException {    return readIntArray(nextInt());   }   default int[] readIntArray(int size) throws IOException {    int[] array = new int[size];    for (int i = 0; i < array.length; i++) {     array[i] = nextInt();    }    return array;   }   default long[] readLongArray(int size) throws IOException {    long[] array = new long[size];    for (int i = 0; i < array.length; i++) {     array[i] = nextLong();    }    return array;   }  }  private static class StandardInput implements Input {   private final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));   private StringTokenizer stringTokenizer;   @Override   public void close() throws IOException {    reader.close();   }   @Override   public String next() throws IOException {    if (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {     stringTokenizer = new StringTokenizer(reader.readLine());    }    return stringTokenizer.nextToken();   }  } }
0,public class Main {  public static void main(String[] args) {   Scanner in = new Scanner(System.in);   int n = in.nextInt();   if (n < 3)    System.out.println(n);   else if (n % 2 != 0)    System.out.println((long)n * (n - 1) * (n - 2));   else if(n % 3 != 0)    System.out.println((long)n * (n - 1) * (n - 3));   else    System.out.println((long)(n - 1) * (n - 2) * (n - 3));   in.close();     } }
2,public class B { public static void main(String[] args) throws IOException {    Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));     int n = sc.nextInt();  int l1 = 1;  int r1 = n;  int b1 = 1;  int t1 = n;  int min = b1;  int max = t1;  while (min != max) {  int mid = (min+max)/2;  System.out.println("? "+l1+" "+b1+" "+r1+" "+mid);  System.out.flush();  if (sc.nextInt() >= 1)   max = mid;  else   min = mid+1;  }  t1 = min;  min = l1;  max = r1;  while (min != max) {  int mid = (min+max)/2;  System.out.println("? "+l1+" "+b1+" "+mid+" "+t1);  System.out.flush();  if (sc.nextInt() >= 1)   max = mid;  else   min = mid+1;  }  r1 = min;  min = b1;  max = t1;  while (min != max) {  int mid = (min+max+1)/2;  System.out.println("? "+l1+" "+mid+" "+r1+" "+t1);  System.out.flush();  if (sc.nextInt() >= 1)   min = mid;  else   max = mid-1;  }  b1 = min;  min = l1;  max = r1;  while (min != max) {  int mid = (min+max+1)/2;  System.out.println("? "+mid+" "+b1+" "+r1+" "+t1);  System.out.flush();  if (sc.nextInt() >= 1)   min = mid;  else   max = mid-1;  }  l1 = min;  int l2 = 1;  int r2 = n;  int b2 = 1;  int t2 = n;  min = b2;  max = t2;  while (min != max) {  int mid = (min+max+1)/2;  System.out.println("? "+l2+" "+mid+" "+r2+" "+t2);  System.out.flush();  if (sc.nextInt() >= 1)   min = mid;  else   max = mid-1;  }  b2 = min;  min = l2;  max = r2;  while (min != max) {  int mid = (min+max+1)/2;  System.out.println("? "+mid+" "+b2+" "+r2+" "+t2);  System.out.flush();  if (sc.nextInt() >= 1)   min = mid;  else   max = mid-1;  }  l2 = min;  min = b2;  max = t2;  while (min != max) {  int mid = (min+max)/2;  System.out.println("? "+l2+" "+b2+" "+r2+" "+mid);  System.out.flush();  if (sc.nextInt() >= 1)   max = mid;  else   min = mid+1;  }  t2 = min;  min = l2;  max = r2;  while (min != max) {  int mid = (min+max)/2;  System.out.println("? "+l2+" "+b2+" "+mid+" "+t2);  System.out.flush();  if (sc.nextInt() >= 1)   max = mid;  else   min = mid+1;  }  r2 = min;  System.out.println("! "+l1+" "+b1+" "+r1+" "+t1+" "+l2+" "+b2+" "+r2+" "+t2);  System.out.flush(); } }
1,public class CF224B {   public static void main(String[] args) throws Exception {   new CF224B().solve();  }  private void solve() throws Exception {   Scanner sc = new Scanner(System.in);   int n = sc.nextInt();   int k = sc.nextInt();   int[] a = new int[n];   for (int i = 0; i < n; i++) {    a[i] = sc.nextInt();   }   final int MAX_A = 100000;   int[] freq = new int[MAX_A+1];   int numDistinct = 0;   int r = -1;   for (int i = 0; i < n; i++) {    int t = a[i];    freq[t]++;    if (freq[t] == 1) {     numDistinct++;    }    if (numDistinct == k) {     r = i;     break;    }   }   if (r == -1) {    System.out.println("-1 -1");    return;   }   int l;   for (l = 0; l < r; l++) {    int t = a[l];    freq[t]--;    if (freq[t] == 0) {     break;    }   }   System.out.println((l+1) + " " + (r+1));  } }
2,public class SportMafia {  int n,k; int nCand;  private void readData(BufferedReader bin) throws IOException {  String s = bin.readLine();  String []ss = s.split(" ");  n = Integer.parseInt(ss[0]);  k = Integer.parseInt(ss[1]); }  void printRes() {  System.out.println(nCand); }   private void calculate() {   double p;  p = -1.5 + Math.sqrt(2.25 + 2.0*(n+k));  nCand = (int)Math.round(n-p); }  public static void main(String[] args) throws IOException {   BufferedReader bin = new BufferedReader(   new InputStreamReader(System.in));  SportMafia l = new SportMafia();  l.readData(bin);  l.calculate();  l.printRes(); } }
4,public class GeorgeInterestingGraph {   int N = 505;  int INF = (int) 1e9;   List<Integer>[] G = new List[N];  int[] match = new int[N];  int[] used = new int[N];  int cur = 0;   {   for (int i = 0; i < N; i++) G[i] = new ArrayList<>(1);  }   void solve() {   int n = in.nextInt(), m = in.nextInt();   int[] fr = new int[m], to = new int[m];   for (int i = 0; i < m; i++) {    fr[i] = in.nextInt() - 1;    to[i] = in.nextInt() - 1;   }     int ans = INF;   for (int i = 0; i < n; i++) {    int cnt = 0;    for (int j = 0; j < n; j++) {     G[j].clear();     match[j] = -1;    }    for (int j = 0; j < m; j++) {     if (fr[j] == i || to[j] == i) {      cnt++;     } else {      G[fr[j]].add(to[j]);     }    }       int other = m - cnt;       int max = 0;    for (int j = 0; j < n; j++) {     cur++;     augment(j);    }    for (int j = 0; j < n; j++) if (match[j] >= 0) max++;       ans = Math.min(ans, 2 * (n - 1) + 1 - cnt + other - max + (n - 1) - max);   }   out.println(ans);  }   boolean augment(int u) {   if (used[u] == cur) return false;   used[u] = cur;   for (int v : G[u]) {    if (match[v] < 0 || augment(match[v])) {     match[v] = u;     return true;    }   }   return false;  }   public static void main(String[] args) {   in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));   out = new PrintWriter(System.out);   new GeorgeInterestingGraph().solve();   out.close();  }   static FastScanner in;  static PrintWriter out;   static class FastScanner {   BufferedReader in;   StringTokenizer st;     public FastScanner(BufferedReader in) {    this.in = in;   }     public String nextToken() {    while (st == null || !st.hasMoreTokens()) {     try {      st = new StringTokenizer(in.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }     public int nextInt() {    return Integer.parseInt(nextToken());   }     public long nextLong() {    return Long.parseLong(nextToken());   }     public double nextDouble() {    return Double.parseDouble(nextToken());   }  } }
5,public class Main {  StreamTokenizer in;  PrintWriter out;  static public void main(String[] args) throws IOException {   new Main().run();  }  int ni() throws IOException {   in.nextToken(); return (int) in.nval;  }  void run() throws IOException {   in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));   out = new PrintWriter(new OutputStreamWriter(System.out));   int n = ni(), t = ni();   if(n == 0) {    out.println(0); out.flush(); return;   }   House[] h = new House[n];   for(int i = 0; i < n; i++) {    h[i] = new House();    h[i].x = ni(); h[i].a = ni();   }   Arrays.sort(h);   int ret = 2;   for(int i = 0; i < n - 1; i++) {    if(2*(h[i + 1].x - h[i].x) - h[i].a - h[i + 1].a > 2*t) ret+=2;    else if(2*(h[i + 1].x - h[i].x) - h[i].a - h[i + 1].a == 2*t) ret++;   }   out.println(ret);   out.flush();  }  void run1() throws IOException {    in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));    out = new PrintWriter(new OutputStreamWriter(System.out));    int t = ni();    long n = ni(), m = ni();    long x1 = ni(), y1 = ni(), x2 = ni(), y2 = ni();   long tx1 = Math.min(x1, x2), tx2 = x1 + x2 - tx1;   long ty1 = Math.min(y1, y2), ty2 = y1 + y2 - ty1;   long dx = tx2 - tx1;   long dy = ty2 - ty1;    }  class House implements Comparable<House> {   int x, a;   public int compareTo(House h) {    return x < h.x ? -1 : 1;   }  } }
1,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  OutputWriter out = new OutputWriter(outputStream);  TaskD solver = new TaskD();  solver.solve(1, in, out);  out.close(); } } class TaskD {  public void solve(int testNumber, InputReader jin, OutputWriter jout) {   int n = jin.int32();   int a = jin.int32();   int b = jin.int32();    Set<Integer> present = new HashSet<Integer>();   int[] arr = new int[n];   int[] sarr = new int[n];   for(int i = 0; i < n; i++) {    sarr[i] = arr[i] = jin.int32();    present.add(arr[i]);   }   boolean rev = b < a;   if(b < a) {b ^= a; a ^= b; b ^= a; }   Arrays.sort(sarr);   Set<Integer> set1 = new HashSet<Integer>();   Set<Integer> set2 = new HashSet<Integer>();   for(int i = 0; i < n; i++) {    if(set1.contains(sarr)) continue;    if(set2.contains(sarr)) continue;    int comp1 = b - sarr[i];    if(present.contains(comp1)) {     set2.add(sarr[i]);     set2.add(comp1);     present.remove(comp1);    } else {     int comp2 = a - sarr[i];     if(present.contains(comp2)) {      set1.add(sarr[i]);      set1.add(comp2);      present.remove(comp2);     } else {      jout.println("NO");      return;     }    }   }   jout.println("YES");   for(int i = 0; i < n; i++) {    if(i != 0) jout.print(' ');    if(rev) jout.print(set2.contains(arr[i])? 0 : 1);    else jout.print(set1.contains(arr[i])? 0 : 1);   }  } } class InputReader {  private static final int bufferMaxLength = 1024;  private InputStream in;  private byte[] buffer;  private int currentBufferSize;  private int currentBufferTop;  private static final String tokenizers = " \t\r\f\n";   public InputReader(InputStream stream) {   this.in = stream;   buffer = new byte[bufferMaxLength];   currentBufferSize = 0;   currentBufferTop = 0;  }   private boolean refill() {   try {    this.currentBufferSize = this.in.read(this.buffer);    this.currentBufferTop = 0;   } catch(Exception e) {}   return this.currentBufferSize > 0;  }     private Byte readChar() {   if(currentBufferTop < currentBufferSize) {    return this.buffer[this.currentBufferTop++];   } else {    if(!this.refill()) {     return null;    } else {     return readChar();    }   }  }  public String token() {   StringBuffer tok = new StringBuffer();   Byte first;   while((first = readChar()) != null && (tokenizers.indexOf((char) first.byteValue()) != -1));   if(first == null) return null;   tok.append((char)first.byteValue());   while((first = readChar()) != null && (tokenizers.indexOf((char) first.byteValue()) == -1)) {    tok.append((char)first.byteValue());   }   return tok.toString();  }   public Integer int32() throws NumberFormatException {   String tok = token();   return tok == null? null : Integer.parseInt(tok);  }  } class OutputWriter {  private final int bufferMaxOut = 1024;  private PrintWriter out;  private StringBuilder output;  private boolean forceFlush = false;  public OutputWriter(OutputStream outStream) {   out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outStream)));   output = new StringBuilder(2 * bufferMaxOut);  }  public OutputWriter(Writer writer) {   forceFlush = true;   out = new PrintWriter(writer);   output = new StringBuilder(2 * bufferMaxOut);  }  private void autoFlush() {   if(forceFlush || output.length() >= bufferMaxOut) {    flush();   }  }  public void print(Object... tokens) {   for(int i = 0; i < tokens.length; i++) {    if(i != 0) output.append(' ');    output.append(tokens[i]);   }   autoFlush();  }  public void println(Object... tokens) {   print(tokens);   output.append('\n');   autoFlush();  }  public void flush() {   out.print(output);   output.setLength(0);  }  public void close() {   flush();   out.close();  } }
4,public class C_Round_35_Div2 {  public static long MOD = 1000000007;  static int[] X = {0, 1, 0, -1};  static int[] Y = {1, 0, -1, 0};  static int[][][] dp;  public static void main(String[] args) throws FileNotFoundException {   PrintWriter out = new PrintWriter(new FileOutputStream(new File(     "output.txt")));     Scanner in = new Scanner();   int n = in.nextInt();   int m = in.nextInt();   int k = in.nextInt();   int[][] map = new int[n][m];   LinkedList<Point> q = new LinkedList();   int reX = -1;   int reY = -1;   for (int i = 0; i < k; i++) {    int x = in.nextInt() - 1;    int y = in.nextInt() - 1;    reX = x;    reY = y;    map[x][y] = 1;    q.add(new Point(x, y));   }   while (!q.isEmpty()) {    Point p = q.poll();       for (int i = 0; i < 4; i++) {     int x = p.x + X[i];     int y = p.y + Y[i];     if (x >= 0 && y >= 0 && x < n && y < m && map[x][y] == 0) {      map[x][y] = 1 + map[p.x][p.y];      if (map[x][y] > map[reX][reY]) {       reX = x;       reY = y;      }      q.add(new Point(x, y));     }    }   }   out.println((reX + 1) + " " + (reY + 1));   out.close();  }  public static int[] KMP(String val) {   int i = 0;   int j = -1;   int[] result = new int[val.length() + 1];   result[0] = -1;   while (i < val.length()) {    while (j >= 0 && val.charAt(j) != val.charAt(i)) {     j = result[j];    }    j++;    i++;    result[i] = j;   }   return result;  }  public static boolean nextPer(int[] data) {   int i = data.length - 1;   while (i > 0 && data[i] < data[i - 1]) {    i--;   }   if (i == 0) {    return false;   }   int j = data.length - 1;   while (data[j] < data[i - 1]) {    j--;   }   int temp = data[i - 1];   data[i - 1] = data[j];   data[j] = temp;   Arrays.sort(data, i, data.length);   return true;  }  public static int digit(long n) {   int result = 0;   while (n > 0) {    n /= 10;    result++;   }   return result;  }  public static double dist(long a, long b, long x, long y) {   double val = (b - a) * (b - a) + (x - y) * (x - y);   val = Math.sqrt(val);   double other = x * x + a * a;   other = Math.sqrt(other);   return val + other;   }  public static class Point implements Comparable<Point> {   int x, y;   public Point(int start, int end) {    this.x = start;    this.y = end;   }   @Override   public int hashCode() {    int hash = 5;    hash = 47 * hash + this.x;    hash = 47 * hash + this.y;    return hash;   }   @Override   public boolean equals(Object obj) {    if (obj == null) {     return false;    }    if (getClass() != obj.getClass()) {     return false;    }    final Point other = (Point) obj;    if (this.x != other.x) {     return false;    }    if (this.y != other.y) {     return false;    }    return true;   }   @Override   public int compareTo(Point o) {    return x - o.x;   }  }  public static class FT {   long[] data;   FT(int n) {    data = new long[n];   }   public void update(int index, long value) {    while (index < data.length) {     data[index] += value;     index += (index & (-index));    }   }   public long get(int index) {    long result = 0;    while (index > 0) {     result += data[index];     index -= (index & (-index));    }    return result;   }  }  public static long gcd(long a, long b) {   if (b == 0) {    return a;   }   return gcd(b, a % b);  }  public static long pow(long a, long b) {   if (b == 0) {    return 1;   }   if (b == 1) {    return a;   }   long val = pow(a, b / 2);   if (b % 2 == 0) {    return val * val % MOD;   } else {    return val * (val * a % MOD) % MOD;    }  }  static class Scanner {   BufferedReader br;   StringTokenizer st;   public Scanner() throws FileNotFoundException {           br = new BufferedReader(new InputStreamReader(new FileInputStream(new File("input.txt"))));   }   public String next() {    while (st == null || !st.hasMoreTokens()) {     try {      st = new StringTokenizer(br.readLine());     } catch (Exception e) {      throw new RuntimeException();     }    }    return st.nextToken();   }   public long nextLong() {    return Long.parseLong(next());   }   public int nextInt() {    return Integer.parseInt(next());   }   public double nextDouble() {    return Double.parseDouble(next());   }   public String nextLine() {    st = null;    try {     return br.readLine();    } catch (Exception e) {     throw new RuntimeException();    }   }   public boolean endLine() {    try {     String next = br.readLine();     while (next != null && next.trim().isEmpty()) {      next = br.readLine();     }     if (next == null) {      return true;     }     st = new StringTokenizer(next);     return st.hasMoreTokens();    } catch (Exception e) {     throw new RuntimeException();    }   }  } }
5,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  OutputWriter out = new OutputWriter(outputStream);  TaskA solver = new TaskA();  solver.solve(1, in, out);  out.close(); } } class TaskA {  public void solve(int testNumber, InputReader in, OutputWriter out) {   int n = in.readInt();   int m = in.readInt();   int k = in.readInt();    int [] filters = new int[n];   for(int i = 0; i < n; ++i) filters[i] = in.readInt();   Arrays.sort(filters);   int nS = 0, tN = k;   while(tN < m && nS < n) {    tN += filters[n-1-nS] - 1;    nS++;   }   if(tN >= m) out.printLine(nS);   else out.printLine(-1);  } } class InputReader {  private InputStream stream;  private byte[] buf = new byte[1024];  private int curChar;  private int numChars;  private SpaceCharFilter filter;  public InputReader(InputStream stream) {   this.stream = stream;  }  public int read() {   if (numChars == -1)    throw new InputMismatchException();   if (curChar >= numChars) {    curChar = 0;    try {     numChars = stream.read(buf);    } catch (IOException e) {     throw new InputMismatchException();    }    if (numChars <= 0)     return -1;   }   return buf[curChar++];  }   public int readInt() {   int c = read();   while (isSpaceChar(c))    c = read();   int sgn = 1;   if (c == '-') {    sgn = -1;    c = read();   }   int res = 0;   do {    if (c < '0' || c > '9')     throw new InputMismatchException();    res *= 10;    res += c - '0';    c = read();   } while (!isSpaceChar(c));   return res * sgn;  }  public boolean isSpaceChar(int c) {   if (filter != null)    return filter.isSpaceChar(c);   return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;  }  public interface SpaceCharFilter {   public boolean isSpaceChar(int ch);  } } class OutputWriter {  private final PrintWriter writer;  public OutputWriter(OutputStream outputStream) {   writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));  }  public OutputWriter(Writer writer) {   this.writer = new PrintWriter(writer);  }  public void print(Object...objects) {   for (int i = 0; i < objects.length; i++) {    if (i != 0)     writer.print(' ');    writer.print(objects[i]);   }  }  public void printLine(Object...objects) {   print(objects);   writer.println();  }  public void close() {   writer.close();  } }
0,public class A{ public static BufferedReader k; public static BufferedWriter z;    public static void main(String [] args)throws IOException{  k = new BufferedReader(new InputStreamReader(System.in));  z = new BufferedWriter(new OutputStreamWriter(System.out));      String[] dat = k.readLine().split(" ");    long l = Long.parseLong(dat[0]);   long r = Long.parseLong(dat[1]);    if(r-l<=1){   z.write(-1+"\n");  }  else if(r-l == 2){        if((l&1)!=0){   z.write(-1+"\n");   }   else{   z.write(l+" "+(l+1)+" "+r+"\n");   }     }  else{   if((l&1)==0){   z.write(l+" "+(l+1)+" "+(l+2)+"\n");   }   else{   z.write((l+1)+" "+(l+2)+" "+(l+3)+"\n");   }  }           z.flush();  } }
4,public class StringRepeat { static Scanner in = new Scanner( new BufferedReader( new InputStreamReader( System.in ) ) );  public static void main( String[] args ) {  String s = in.next();  int n = s.length(), ans = 0;  for( int i = 0; i < n; i++ ) for( int j = i+1; j < n; j++ )  {  int l = 0;  while( j+l<n && s.charAt(i+l)==s.charAt(j+l) ) l++;  ans = Math.max( ans, l );  }  System.out.println( ans ); } }
0,public class HexTheorem {  public static void main(String[] args) throws NumberFormatException, IOException {   BufferedReader read = new BufferedReader(new InputStreamReader(System.in));   int x = Integer.parseInt(read.readLine());   System.out.println("0 0 "+x);  } }
0,public class Task275A {  public static Scanner in = new Scanner(System.in);  public static PrintStream out = System.out;  public static void main(String[] args) {   long l = in.nextLong();   long r = in.nextLong();   if (l % 2 == 1) {    l++;   }   if (r - l < 2) {    out.print(-1);   }   else {    out.print(l + " " + (l + 1) + " " + (l + 2));   }  } }
4,public class C {  public static void main(String[] args) throws Exception {   BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in));   StringBuilder sb = new StringBuilder();   int t = Integer.parseInt(buffer.readLine());   while (t-- > 0) {    int n = Integer.parseInt(buffer.readLine());    ArrayList<Integer>list = new ArrayList<>();    for (int i = 0; i < n; i++) {     int a = Integer.parseInt(buffer.readLine());     if (a == 1)      list.add(1);     else {      for (int j = list.size()-1; j >= 0; j--) {       if (list.get(j)+1 == a)        break;       list.remove(list.size()-1);      }      list.remove(list.size()-1);      list.add(a);     }     for (int j = 0; j < list.size(); j++) {      sb.append(list.get(j));      if (j == list.size()-1)       sb.append("\n");      else       sb.append(".");     }    }   }   System.out.println(sb);  } }
0,public class EER_A {  public static void main(String[] args) {   Scanner scanner = new Scanner(System.in);   scanner.nextLine();   System.out.println(25);  } }
3,public class C909 {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskA solver = new TaskA();   solver.solve(1, in, out);   out.close();  }  static class TaskA {   public void solve(int testNumber, InputReader in, PrintWriter out) {    int n = in.nextInt();    int ar[] = new int[n+1];    int count = 1;    ar[0] = 1;    for(int i=0;i<n;i++){     char c = in.next().charAt(0);     if(c == 'f')      count++;     else{      for(int j=1;j<count;j++){       ar[j] = (ar[j] + ar[j-1])% (int)(1e9+7);      }     }     }    out.println(ar[count-1]);   }  }  static class InputReader {   public BufferedReader reader;   public StringTokenizer tokenizer;   public InputReader(InputStream stream) {    reader = new BufferedReader(new InputStreamReader(stream), 32768);    tokenizer = null;   }   public String next() {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      tokenizer = new StringTokenizer(reader.readLine());     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return tokenizer.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }   public long nextLong() {    return Long.parseLong(next());   }   public double nextDouble() {    return Double.parseDouble(next());   }   public String nextLine() {    String str = "";    try    {     str = reader.readLine();    }    catch (IOException e)    {     e.printStackTrace();    }    return str;   }  } }
0,public class Solution{  public static void main(String[] args){   Scanner in = new Scanner(System.in);   int pairs = in.nextInt();   while (pairs > 0){    in.nextLine();    int a = in.nextInt();    int b = in.nextInt();    int count = 0;    while (a != 0 && b != 0){     if (b >= a && a != 0){      count += b/a;      b = b%a;     }     if (a > b && b != 0){      count += a/b;      a = a%b;     }    }    System.out.println(count);    pairs--;   }  } }
6,public class CF8C { public static void main(String[] args) throws IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  String s = br.readLine();  int si = s.indexOf(' ', 0);  int x = Integer.parseInt(s.substring(0, si));  int y = Integer.parseInt(s.substring(si + 1));  int n = Integer.parseInt(br.readLine());  int[] xx = new int[n + 1];  int[] yy = new int[n + 1];  for (int i = 0; i < n; i++) {  s = br.readLine();  si = s.indexOf(' ', 0);  xx[i] = Integer.parseInt(s.substring(0, si));  yy[i] = Integer.parseInt(s.substring(si + 1));  }  xx[n] = x;  yy[n] = y;  int[][] dd = new int[n + 1][n + 1];  for (int i = 0; i <= n; i++)  for (int j = i + 1; j <= n; j++) {   int dx = xx[i] - xx[j];   int dy = yy[i] - yy[j];   dd[i][j] = dx * dx + dy * dy;  }  int[] aa = new int[1 << n];  int[] bb = new int[1 << n];  for (int k = 1; k < 1 << n; k++) {  int a = -1;  for (int b = 0; b < n; b++)   if ((k & 1 << b) > 0) {   a = b;   break;   }  int l = k ^ 1 << a;  int d = dd[a][n] + dd[a][n];  aa[k] = aa[l] + d;  bb[k] = l;  for (int b = a + 1; b < n; b++)   if ((k & 1 << b) > 0) {   l = k ^ 1 << a ^ 1 << b;   d = dd[a][n] + dd[b][n] + dd[a][b];   if (aa[l] + d < aa[k]) {    aa[k] = aa[l] + d;    bb[k] = l;   }   }  }  int k = (1 << n) - 1;  System.out.println(aa[k]);  StringBuilder sb = new StringBuilder();  sb.append(0);  while (k != 0) {  int l = bb[k];  int m = k ^ l;  for (int b = 0; b < n; b++)   if ((m & 1 << b) > 0)   sb.append(' ').append(b + 1);  sb.append(' ').append(0);  k = l;  }  System.out.println(sb); } }
3,public class A {  public static void main(String[] args) {   FastScanner scanner = new FastScanner();   PrintWriter out = new PrintWriter(System.out, false);   int n = scanner.nextInt();   int[] arr = new int[n];   for(int i = 0; i < n; i++) {    arr[i] = scanner.nextInt();   }     Arrays.sort(arr);   int[] cols = new int[n];   Arrays.fill(cols, -1);   int ans = 0;   for(int i = 0; i < n; i++) {    if (cols[i] == -1) {     cols[i] = ans++;     for(int j = i + 1; j < n; j++) {      if (arr[j] % arr[i] == 0) cols[j] = cols[i];     }    }   }   out.println(ans);   out.flush();  }   public static class FastScanner {   BufferedReader br;   StringTokenizer st;     public FastScanner(Reader in) {    br = new BufferedReader(in);   }     public FastScanner() {    this(new InputStreamReader(System.in));   }     String next() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }     int nextInt() {    return Integer.parseInt(next());   }     long nextLong() {    return Long.parseLong(next());   }     double nextDouble() {    return Double.parseDouble(next());   }     String readNextLine() {    String str = "";    try {     str = br.readLine();    } catch (IOException e) {     e.printStackTrace();    }    return str;   }  } }
5,public class A {  static int[] parent;  public static int find(int x) {   if (x == parent[x])    return x;   return parent[x] = find(parent[x]);  }  public static void union(int x, int y) {   int px = find(x);   int py = find(y);   if (px != py) {    parent[py] = px;   }  }  public static void main(String[] args) throws Exception {   int numCnt = (int) nextLong();   long k = nextLong();   parent = new int[numCnt];   for (int i = 0; i < parent.length; i++) {    parent[i] = i;   }   Long[] ar=new Long[numCnt];   for (int i = 0; i < numCnt; i++) {    ar[i] = nextLong();   }   Arrays.sort(ar);   for (int i = 0; i < ar.length; i++) {    long req = ar[i] * k;    int l=0,h=ar.length,mid;    while(l<h){     mid=l+(h-l)/2;     if(ar[mid]<req){      l=mid+1;     }else{      h=mid;     }    }    if(l<ar.length&&ar[l]==req){     union(i,l);    }   }   int[] count = new int[numCnt];   for (int i = 0; i < parent.length; i++) {    count[find(i)]++;   }   int res = 0;   for (int i = 0; i < numCnt; i++) {    res += (int) ((count[i] + 1) / 2.0);   }   System.out.println(res);  }  static BufferedReader br = new BufferedReader(new InputStreamReader(    System.in));  static StringTokenizer tokenizer = new StringTokenizer("");  static long nextLong() throws Exception {   return Long.parseLong(next());  }  static double nextDouble() throws Exception {   return Double.parseDouble(next());  }  static String next() throws Exception {   while (true) {    if (tokenizer.hasMoreTokens()) {     return tokenizer.nextToken();    }    String s = br.readLine();    if (s == null) {     return null;    }    tokenizer = new StringTokenizer(s);   }  } }
2,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  Reader in = new Reader(inputStream);  OutputWriter out = new OutputWriter(outputStream);  TaskA solver = new TaskA();  solver.solve(1, in, out);  out.close(); } } class TaskA {  private static final long MOD = 1000000009;  public void solve(int testNumber, Reader in, OutputWriter out) {   long answer = 0;   int n = in.nextInt();   int m = in.nextInt();   int k = in.nextInt();   long l = -1;   long r = n + 1;   while (l + 1 < r) {    long c = (l + r) / 2;    if(n < c * k || canAchieve(n - c * k, k) >= m - c * k) {     r = c;    }    else     l = c;   }      long c = r;   answer = ((IntegerUtils.power(2, c + 1, MOD) - 2 + MOD) % MOD) * k % MOD;   n -= k * c;   m -= k * c;   answer += m;   answer %= MOD;   out.println(answer);  }  private long canAchieve(long n, long k) {   return n - n / k;  } } class Reader {  private BufferedReader reader;  private StringTokenizer tokenizer;  public Reader(BufferedReader reader) {   this.reader = reader;  }  public Reader(InputStream stream) {   this(new BufferedReader(new InputStreamReader(stream)));  }  public String nextString() {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    tokenizer = new StringTokenizer(readLine());   }   return tokenizer.nextToken();  }  public int nextInt() {   return Integer.parseInt(nextString());  }  private String readLine() {   try {    return reader.readLine();   } catch (IOException e) {    throw new RuntimeException(e);   }  } } class OutputWriter extends PrintWriter {  public OutputWriter(OutputStream out) {  super(out); }  public OutputWriter(java.io.Writer writer){  super(writer); }  } class IntegerUtils {  public static long power(long base, long power, long mod) {  long result = 1 % mod;  base %= mod;  while (power > 0) {  if (power % 2 == 1) {   result *= base;   result %= mod;  }  base *= base;  base %= mod;  power >>= 1;  }  return result; }  }
2,public class Training {  public static void main(String[] args) {   Scanner in = new Scanner(System.in);   long index = in.nextLong();   if (index < 10) {       System.out.println(index);   } else if (index < 190) {       solve(2, index, 10, 10);   } else if (index < 2890) {       solve(3, index, 190, 100);   } else if (index < 38890) {       solve(4, index, 2890, 1000);       } else if (index < 488890) {       solve(5, index, 38890, 10000);   } else if (index < 5888890) {       solve(6, index, 488890, 100000);   } else if (index < 68888890) {       solve(7, index, 5888890, 1000000);   } else if (index < 788888890) {       solve(8, index, 68888890, 10000000);   } else if (index < 8888888890l) {       solve(9, index, 788888890, 100000000);   } else if (index < 98888888890l) {       solve(10, index, 8888888890l, 1000000000);   } else {    solve(11, index, 98888888890l, 10000000000l);   }  }  static void solve(int length, long index, long lastPoint, long num) {   String s = "";   num += (index - lastPoint) / length;   s += num;   int mod = (int) ((index - lastPoint) % length);   System.out.println(s.charAt(mod));  } }
0,public class Tester { public static long mod=(long)1e9+7;  public static void main(String[] args)  {  InputReader s=new InputReader(System.in);   OutputStream outputStream = System.out;        String str=s.nextLine();   System.out.println("25");         }   static long gcd(long a,long b) {  if(b==0)  return a;  a%=b;  return gcd(b,a); }  static long exp(long a, long b) {  if(b==0)  return 1;  if(b==1)  return a;  if(b==2)  return a*a;   if(b%2==0)  return exp(exp(a,b/2),2);  else  return a*exp(exp(a,(b-1)/2),2); }  static class Pair implements Comparable<Pair> {  long x,f;  Pair(long ii, long cc)  {  x=ii;  f=cc;  }   public int compareTo(Pair o)  {  return Long.compare(this.x, o.x);  }   }  public static class InputReader  {  public BufferedReader reader;  public StringTokenizer tokenizer;    public InputReader(InputStream inputstream)   {    reader = new BufferedReader(new InputStreamReader(inputstream));    tokenizer = null;  }     public String nextLine()  {   String fullLine=null;   while (tokenizer == null || !tokenizer.hasMoreTokens())    {    try {      fullLine=reader.readLine();     }     catch (IOException e)     {      throw new RuntimeException(e);    }    return fullLine;    }    return fullLine;  }   public String next()   {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {    try {     tokenizer = new StringTokenizer(reader.readLine());    } catch (IOException e) {     throw new RuntimeException(e);    }    }    return tokenizer.nextToken();   }   public long nextLong() {    return Long.parseLong(next());    }   public int nextInt() {    return Integer.parseInt(next());   }   }  }
5,public class A {   public static void main(String[] args) throws Exception {   Scanner in = new Scanner(System.in);   int n = in.nextInt();   int m = in.nextInt();   int k = in.nextInt();   int so[]= new int[n];   for(int i=0;i<n;i++) so[i]=in.nextInt();   Arrays.sort(so);   if(m<=k) {    System.out.println("0");    return;   }   int sum=0;   int socUsed=0;   int cont=0;   for(int i=n-1;i>=0;i--){    cont++;    sum+=so[i];    if(sum>=m || sum+(k-1)>=m){     System.out.println(cont);     return;    }     sum--;   }    System.out.println("-1");  } }
2,public class Main {  private final static int Max = (int) (1e5 + 10); private static long n,s;  public static void main(String[] args) {  InitData();  GetAns(); }  private static void InitData() {  Scanner cin = new Scanner(System.in);  n=cin.nextLong();  s=cin.nextLong(); }; private static void GetAns() {  long i;  long ans=0;  for(i=s;i<=n;i++){    long k=i-sum(i);  if(k>=s){   if(i%10==9){   break;   }   ans++;  }  }  if(n>=s){  System.out.println(ans-i+n+1);  }else{  System.out.println(0);  } }; private static long sum(long ans){  long sum=0;  while(ans>0){  sum+=(ans%10);  ans/=10;  }  return sum; } }
6,public class C8 {  public static long mod = 1000000007; public static long INF = (1L << 60); static FastScanner2 in = new FastScanner2(); static OutputWriter out = new OutputWriter(System.out); static int n; static int x,y; static int[] xx; static int[] yy; static int[] dist; static int[][] g; static int[] dp; public static int square(int x) {  return abs(x*x); } static class Pair {  int x,y;  Pair(int x,int y)  {  this.x=x;  this.y=y;  } } public static void main(String[] args)  {  x=in.nextInt();  y=in.nextInt();  n=in.nextInt();  xx=new int[n];  yy=new int[n];  dp=new int[1<<n];  for(int i=0;i<n;i++)  {  xx[i]=in.nextInt();  yy[i]=in.nextInt();  }  dist=new int[n];  g=new int[n][n];  for(int i=0;i<n;i++)  {  dist[i]=square(abs(xx[i]-x))+square(abs(yy[i]-y));  }  for(int i=0;i<n;i++)  {  for(int j=0;j<n;j++)  {   g[i][j]=square(abs(xx[i]-xx[j]))+square(yy[i]-yy[j]);     }  }  Arrays.fill(dp, Integer.MAX_VALUE/2);  dp[0]=0;  for(int i=0;i<(1<<n);i++)  {    for(int j=0;j<n;j++)  {   if((i&(1<<j))>0)    continue;   dp[i|(1<<j)]=min(dp[i|(1<<j)], dp[i]+2*dist[j]);   for(int k=j+1;k<n;k++)   {   if((i&(1<<k))>0)    continue;   dp[i|(1<<j)|(1<<k)]=min(dp[i|(1<<j)|(1<<k)], dp[i]+dist[j]+dist[k]+g[j][k]);   }   break;  }  }  out.println(dp[(1<<n)-1]);  Stack<Integer> stack=new Stack<>();  stack.push(0);  int i=(1<<n)-1;  while(i>0)  {  boolean tocontinue=false;  for(int a=0;a<n;a++)  {   if((i&(1<<a))==0)   continue;   if(dp[i]==(dp[i^(1<<a)]+2*dist[a]))   {   stack.push(a+1);   stack.push(0);   i-=(1<<a);   tocontinue=true;   }   if(tocontinue)   continue;   for(int b=a+1;b<n;b++)   {   if((i & (1<<b)) == 0) continue;   if(dp[i]==(dp[i^(1<<a)^(1<<b)]+dist[a]+dist[b]+g[a][b]))   {    i-=(1<<a);    i-=(1<<b);    stack.push(a+1);    stack.push(b+1);    stack.push(0);    tocontinue=true;   }   if(tocontinue)    break;   }   if(tocontinue)   break;  }    }  for(int ii : stack)  out.print(ii+" ");  out.close();  }  public static long pow(long x, long n, long mod)  {  long res = 1;  for (long p = x; n > 0; n >>= 1, p = (p * p) % mod)  {  if ((n & 1) != 0)   {   res = (res * p % mod);  }  }  return res; }  public static long gcd(long n1, long n2) {  long r;  while (n2 != 0)  {  r = n1 % n2;  n1 = n2;  n2 = r;  }  return n1; }  public static long lcm(long n1, long n2)  {  long answer = (n1 * n2) / (gcd(n1, n2));  return answer; }  static class FastScanner2  {  private byte[] buf = new byte[1024];  private int curChar;  private int snumChars;  public int read()  {  if (snumChars == -1)   throw new InputMismatchException();  if (curChar >= snumChars)   {   curChar = 0;   try   {   snumChars = System.in.read(buf);   } catch (IOException e)   {   throw new InputMismatchException();   }   if (snumChars <= 0)   return -1;  }  return buf[curChar++];  }  public String nextLine()  {  int c = read();  while (isSpaceChar(c))   c = read();  StringBuilder res = new StringBuilder();  do   {   res.appendCodePoint(c);   c = read();  }   while (!isEndOfLine(c));  return res.toString();  }  public String nextString()  {  int c = read();  while (isSpaceChar(c))   c = read();  StringBuilder res = new StringBuilder();  do   {   res.appendCodePoint(c);   c = read();  }   while (!isSpaceChar(c));  return res.toString();  }  public long nextLong()  {  int c = read();  while (isSpaceChar(c))   c = read();  int sgn = 1;  if (c == '-') {   sgn = -1;   c = read();  }  long res = 0;  do   {   if (c < '0' || c > '9')   throw new InputMismatchException();   res *= 10;   res += c - '0';   c = read();  }   while (!isSpaceChar(c));  return res * sgn;  }  public int nextInt()  {  int c = read();  while (isSpaceChar(c))   c = read();  int sgn = 1;  if (c == '-') {   sgn = -1;   c = read();  }  int res = 0;  do   {   if (c < '0' || c > '9')   throw new InputMismatchException();   res *= 10;   res += c - '0';   c = read();  }   while (!isSpaceChar(c));  return res * sgn;  }  public int[] nextIntArray(int n)  {  int[] arr = new int[n];  for (int i = 0; i < n; i++)   {   arr[i] = nextInt();  }  return arr;  }  public long[] nextLongArray(int n)  {  long[] arr = new long[n];  for (int i = 0; i < n; i++)   {   arr[i] = nextLong();  }  return arr;  }  private boolean isSpaceChar(int c)  {  return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;  }  private boolean isEndOfLine(int c)  {  return c == '\n' || c == '\r' || c == -1;  } }  static class InputReader  {  public BufferedReader reader;  public StringTokenizer tokenizer;  public InputReader(InputStream inputstream)  {  reader = new BufferedReader(new InputStreamReader(inputstream));  tokenizer = null;  }  public String nextLine()  {  String fullLine = null;  while (tokenizer == null || !tokenizer.hasMoreTokens())  {   try   {   fullLine = reader.readLine();   } catch (IOException e)   {   throw new RuntimeException(e);   }   return fullLine;  }  return fullLine;  }  public String next()  {  while (tokenizer == null || !tokenizer.hasMoreTokens())   {   try   {   tokenizer = new StringTokenizer(reader.readLine());   } catch (IOException e)   {   throw new RuntimeException(e);   }  }  return tokenizer.nextToken();  }  public long nextLong()  {  return Long.parseLong(next());  }  public int[] nextIntArray(int n)  {  int a[] = new int[n];  for (int i = 0; i < n; i++)   {   a[i] = nextInt();  }  return a;  }  public long[] nextLongArray(int n)  {  long a[] = new long[n];  for (int i = 0; i < n; i++)   {   a[i] = nextLong();  }  return a;  }  public int nextInt()  {  return Integer.parseInt(next());  } }  static class OutputWriter  {  private final PrintWriter writer;  public OutputWriter(OutputStream outputStream)  {  writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));  }  public OutputWriter(Writer writer)  {  this.writer = new PrintWriter(writer);  }  public void print(Object... objects)  {  for (int i = 0; i < objects.length; i++)   {   if (i != 0)   writer.print(' ');   writer.print(objects[i]);  }  }  public void println(Object... objects)  {  print(objects);  writer.println();  }  public void close()  {  writer.close();  }  public void flush()  {  writer.flush();  } } }
6,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   OutputWriter out = new OutputWriter(outputStream);   TaskC solver = new TaskC();   solver.solve(1, in, out);   out.close();  }  static class TaskC {   int BAD = 11111;   int rows;   int cols;   HashMap<IntIntPair, Integer>[] mem;   boolean contains(int mem, int index) {    if(index < 0) return false;    return ((mem >> index) & 1) == 1;   }   int add(int mem, int index) {    if(((mem >> index) & 1) == 0) {     mem += (1 << index);    }    return mem;   }   int size(int mem) {    int res = 0;    while(mem > 0) {     if(mem % 2 == 1) res++;     mem /= 2;    }    return res;   }   void test() {    if(contains(5, 0) == false) throw new RuntimeException();    if(contains(5, 1) == true) throw new RuntimeException();    if(contains(5, -1) == true) throw new RuntimeException();    if(contains(5, 2) == false) throw new RuntimeException();    if(contains(5, 3) == true) throw new RuntimeException();    if(add(0, 2) != 4) throw new RuntimeException();    if(add(4, 0) != 5) throw new RuntimeException();    if(add(5, 0) != 5) throw new RuntimeException();    if(size(5) != 2) throw new RuntimeException();   }   int dp(int row, int remabove, int squareabove) {    if(row == rows) {     if(remabove == 0) return 0;     return BAD;    }    if(mem[row].containsKey(new IntIntPair(remabove, squareabove)))     return mem[row].get(new IntIntPair(remabove, squareabove));    int res = BAD;    int possibilities = 1 << cols;    for(int poss = 0; poss < possibilities; poss++) {     int have = 0;     for(int j = 0; j < cols; j++)      if(((poss >> j) & 1) == 1) {       have += 1 << j;      }     boolean works = true;     for(int above = 0; above < cols; above++)      if(((remabove >> above) & 1) == 1) {       if(((have >> above) & 1) == 0) {        works = false;        break;       }      }     if(works) {      int remhere = 0;      for(int j = 0; j < cols; j++) {       if(!contains(have, j - 1) && !contains(have, j) && !contains(have, j + 1) && !contains(squareabove, j)) {        remhere = add(remhere, j);       }      }      res = Math.min(res, size(have) + dp(row + 1, remhere, have));     }    }    mem[row].put(new IntIntPair(remabove, squareabove), res);    return res;   }   public void solve(int testNumber, InputReader in, OutputWriter out) {    test();    int n = in.readInt(), m = in.readInt();    cols = Math.min(n, m);    rows = Math.max(n, m);    mem = new HashMap[rows];    for(int i = 0; i < mem.length; i++) mem[i] = new HashMap<>();    int res = dp(0, 0, 0);    out.printLine(cols * rows - res);   }  }  static class IntIntPair implements Comparable<IntIntPair> {   public final int first;   public final int second;   public IntIntPair(int first, int second) {    this.first = first;    this.second = second;   }    public boolean equals(Object o) {    if(this == o) return true;    if(o == null || getClass() != o.getClass()) return false;    IntIntPair pair = (IntIntPair) o;    return first == pair.first && second == pair.second;   }    public int hashCode() {    int result = Integer.hashCode(first);    result = 31 * result + Integer.hashCode(second);    return result;   }    public String toString() {    return "(" + first + "," + second + ")";   }   @SuppressWarnings({"unchecked"})   public int compareTo(IntIntPair o) {    int value = Integer.compare(first, o.first);    if(value != 0) {     return value;    }    return Integer.compare(second, o.second);   }  }  static class InputReader {   private InputStream stream;   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   private SpaceCharFilter filter;   public InputReader(InputStream stream) {    this.stream = stream;   }   public int read() {    if(numChars == -1)     throw new InputMismatchException();    if(curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch(IOException e) {      throw new InputMismatchException();     }     if(numChars <= 0)      return -1;    }    return buf[curChar++];   }   public int readInt() {    int c = read();    while(isSpaceChar(c))     c = read();    int sgn = 1;    if(c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if(c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    } while(!isSpaceChar(c));    return res * sgn;   }   public boolean isSpaceChar(int c) {    if(filter != null)     return filter.isSpaceChar(c);    return isWhitespace(c);   }   public static boolean isWhitespace(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   public interface SpaceCharFilter {    public boolean isSpaceChar(int ch);   }  }  static class OutputWriter {   private final PrintWriter writer;   public OutputWriter(OutputStream outputStream) {    writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));   }   public OutputWriter(Writer writer) {    this.writer = new PrintWriter(writer);   }   public void close() {    writer.close();   }   public void printLine(int i) {    writer.println(i);   }  } }
1,public class B {  private static StreamTokenizer in;  private static PrintWriter out;   private static int nextInt() throws Exception{   in.nextToken();   return (int)in.nval;  }   private static String nextString() throws Exception{   in.nextToken();   return in.sval;  }   static{   in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));   out = new PrintWriter(System.out);  }   public static void main(String[] args)throws Exception{   int n = nextInt();   char[] c = nextString().toCharArray();     int tc = 0, hc = 0;   for(int i = 0;i<c.length; i++){    if(c[i] == 'T')tc++; else hc++;   }        int max = -1;   int pos = 0;   for(int i = 0; i<c.length; i++){    int a = 0;    for(int j = 0; j<tc;j++){     int k = i+j;     if(k>=n)k-=n;     if(c[k] == 'T'){      a++;     }    }    if(a>max){     max = a;     pos = i;    }   }   int min1 = tc - max;     max = -1;   pos = 0;   for(int i = 0; i<c.length; i++){    int a = 0;    for(int j = 0; j<hc;j++){     int k = i+j;     if(k>=n)k-=n;     if(c[k] == 'H'){      a++;     }    }    if(a>max){     max = a;     pos = i;    }   }   int min2 = hc - max;     out.println(Math.min(min1, min2));   out.flush();  } }
0,public class HelloWorld {  public static void main (String args [])  {   Scanner read = new Scanner(System.in);   int n = read.nextInt();   int n1 = n; boolean q = true;   while (n1 > 0)   {    if (n % n1 == 0)    {     if (check(n1))     {      System.out.print("YES");      q = false;      break;     }     }    n1--;   }   if (q) System.out.print("NO");    }  public static boolean check (int n)  {   int n1 = n;   while (n1 != 0)   {    if (n1 % 10 != 4 && n1 % 10 != 7) return false;    n1 /= 10;   }   return true;  } }
1,public class B {   static final boolean DBG = false; static StreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); static PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));  static int[] e = new int[100001];  public static void main(String[] args) throws IOException {  int n = i(), k = i(), cnt = 0;  int[] a = new int[n+1];  for (int i=1; i<=n; i++){  a[i] = i();  if (e[a[i]] == 0)   cnt++;  e[a[i]]++;  }  if (k > cnt){  pw.println("-1 -1");  pw.close();  return;  }  if (cnt == n){  pw.print("1 " + k);  pw.close();  return;  }  if (k == 1){  pw.println("1 1");  pw.close();  return;  }  Arrays.fill(e, 0);  int i = 1, j = 0, unik = 0, start = 0, end = 0, len = n, m = 0;   if (e[a[i]] == 0){  unik++;  }  e[a[i]]++;  while (i+1<=n && a[i+1] == a[i]){  i = i+1;  }    j = i+1;   while (j <= n){  if (e[a[j]] == 0){   unik++;   if (unik == k){   while (e[a[i]] > 1){    e[a[i]]--;    i++;    while (i+1<=n && a[i+1] == a[i]){    i = i+1;    }    }   m = j - i + 1;   if (m < len){    start = i; end = j; len = m;    if (m == k)    break;   }      while (i <=n && unik == k){    e[a[i]]--;    if (e[a[i]] == 0)    unik--;    i++;       while (i+1<=n && a[i+1] == a[i]){    i = i+1;    }      }   }  }  e[a[j]]++;  while (j+1<=n && a[j+1] == a[j]){   j++;  }    j++;  }  pw.println(start + " " + end);  pw.close(); }  static int i() throws IOException{  st.nextToken();  return (int)st.nval; }  static long l() throws IOException {  st.nextToken();  return (long)st.nval; }  static double d() throws IOException {  st.nextToken();  return st.nval; } static String s() throws IOException{  st.nextToken();  return st.sval; } }
3,public class Mainn {  public static class InputReader {  public BufferedReader reader;  public StringTokenizer tokenizer;  public InputReader() {  reader = new BufferedReader(new InputStreamReader(System.in), 32768);  tokenizer = null;  }  public InputReader(InputStream stream) {  reader = new BufferedReader(new InputStreamReader(System.in), 32768);  tokenizer = null;  }  public String next() {  while (tokenizer == null || !tokenizer.hasMoreTokens()) {   try {   tokenizer = new StringTokenizer(reader.readLine());   } catch (IOException e) {   throw new RuntimeException(e);   }  }  return tokenizer.nextToken();  }  public char nextChar() {  return next().charAt(0);  }  public int nextInt() {  return Integer.parseInt(next());  }  public long nextLong() {  return Long.parseLong(next());  }  public double nextDouble() {  return Double.parseDouble(next());  }  public int[] nextIntArr(int n) {  int[] arr = new int[n];  for (int i = 0; i < n; i++) {   arr[i] = this.nextInt();  }  return arr;  }  public Integer[] nextIntegerArr(int n) {  Integer[] arr = new Integer[n];  for (int i = 0; i < n; i++) {   arr[i] = new Integer(this.nextInt());  }  return arr;  }  public int[][] next2DIntArr(int n, int m) {  int[][] arr = new int[n][m];  for (int i = 0; i < n; i++) {   for (int j = 0; j < m; j++) {   arr[i][j] = this.nextInt();   }  }  return arr;  }  public int[] nextSortedIntArr(int n) {  int[] arr = new int[n];  for (int i = 0; i < n; i++) {   arr[i] = this.nextInt();  }  Arrays.sort(arr);  return arr;  }  public long[] nextLongArr(int n) {  long[] arr = new long[n];  for (int i = 0; i < n; i++) {   arr[i] = this.nextLong();  }  return arr;  }  public char[] nextCharArr(int n) {  char[] arr = new char[n];  for (int i = 0; i < n; i++) {   arr[i] = this.nextChar();  }  return arr;  } }  public static InputReader scn = new InputReader(); public static PrintWriter out = new PrintWriter(System.out);  public static void main(String[] args) {        int n = scn.nextInt(), inv = 0;  int[] arr = scn.nextIntArr(n);  for(int i = 0; i < n; i++) {  for(int j = i + 1; j < n; j++) {   if(arr[i] > arr[j]) {   inv++;   }  }  }   int ans = inv % 2;   int m = scn.nextInt();  while(m-- > 0) {  int l = scn.nextInt(), r = scn.nextInt();    int change = ((r - l + 1) / 2) % 2;    if(change == 1) {   ans = 1 - ans;  }    if(ans == 0) {   out.println("even");  } else {   out.println("odd");  }  }   out.close(); } }
2,public class DigitSeq {  static class FastReader {  BufferedReader br;  StringTokenizer st;   public FastReader()  {   br = new BufferedReader(new   InputStreamReader(System.in));  }   String next()  {   while (st == null || !st.hasMoreElements())   {   try   {    st = new StringTokenizer(br.readLine());   }   catch (IOException e)   {    e.printStackTrace();   }   }   return st.nextToken();  }   int nextInt()  {   return Integer.parseInt(next());  }   long nextLong()  {   return Long.parseLong(next());  }   double nextDouble()  {   return Double.parseDouble(next());  }   String nextLine()  {   String str = "";   try  {   str = br.readLine();   }   catch (IOException e)   {   e.printStackTrace();   }   return str;  }  }  public static void main(String[] args) {  FastReader sc = new FastReader();  OutputStream outputstream = System.out;  PrintWriter out = new PrintWriter(outputstream);  long n = sc.nextLong();  long[] arr = new long[14];  for(int i = 1; i <= 13; i++){  arr[i] = (long)Math.pow(10, i)-(long)Math.pow(10, i-1);  }  long total = 0;   for(int i = 1; i <= 13; i++){  if(total+(long)i*arr[i]>=n){   long ans = n-total;   long rest = ans;     if(ans%i!=0){   ans /= i;   ans++;   } else {   ans /= i;   }   ans += (long)Math.pow(10, i-1)-1;   String str = Long.toString(ans);   int ind = (rest%i==0) ? i-1 : (int)(rest%i)-1;     out.println(str.charAt(ind));   break;  }  total = total+(long)i*arr[i];    }  out.close(); } }
3,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   OutputWriter out = new OutputWriter(outputStream);   ARaskrashivanieChisel solver = new ARaskrashivanieChisel();   solver.solve(1, in, out);   out.close();  }  static class ARaskrashivanieChisel {   public void solve(int testNumber, InputReader in, OutputWriter out) {    final int MAX = 100;    int n = in.nextInt();    int[] a = in.nextSortedIntArray(n);    int ret = 0;    boolean[] used = new boolean[MAX + 1];    for (int i = 0; i < n; i++) {     if (!used[a[i]]) {      used[a[i]] = true;      ret++;      for (int j = i + 1; j < n; j++) {       if (a[j] % a[i] == 0 && !used[a[j]]) {        used[a[j]] = true;       }      }     }    }    out.println(ret);   }  }  static class OutputWriter {   private final PrintWriter writer;   public OutputWriter(OutputStream outputStream) {    writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));   }   public OutputWriter(Writer writer) {    this.writer = new PrintWriter(writer);   }   public void close() {    writer.close();   }   public void println(int i) {    writer.println(i);   }  }  static class InputReader {   private InputStream stream;   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   private InputReader.SpaceCharFilter filter;   public InputReader(InputStream stream) {    this.stream = stream;   }   public int read() {    if (numChars == -1) {     throw new InputMismatchException();    }    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (numChars <= 0) {      return -1;     }    }    return buf[curChar++];   }   public int nextInt() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if (c < '0' || c > '9') {      throw new InputMismatchException();     }     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   public boolean isSpaceChar(int c) {    if (filter != null) {     return filter.isSpaceChar(c);    }    return isWhitespace(c);   }   public static boolean isWhitespace(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   public int[] nextIntArray(int n) {    int[] array = new int[n];    for (int i = 0; i < n; ++i) array[i] = nextInt();    return array;   }   public int[] nextSortedIntArray(int n) {    int array[] = nextIntArray(n);    Arrays.sort(array);    return array;   }   public interface SpaceCharFilter {    public boolean isSpaceChar(int ch);   }  } }
0,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskA solver = new TaskA();   solver.solve(1, in, out);   out.close();  }  static class TaskA {   public void solve(int testNumber, InputReader in, PrintWriter out) {    int N = in.nextInt();     if (N == 1) {     out.println(1);    } else if (N == 2) {     out.println(2);    } else if (N == 3) {     out.println(6);    } else {     long best = Long.MIN_VALUE;     best = Math.max(best, lcm(N, lcm(N - 1, N - 2)));     best = Math.max(best, lcm(N, lcm(N - 2, N - 3)));     best = Math.max(best, lcm(N, lcm(N - 1, N - 3)));     best = Math.max(best, lcm(N - 1, lcm(N - 2, N - 3)));     out.println(best);    }   }   private long lcm(long a, long b) {    return a * (b / gcd(a, b));   }   private long gcd(long a, long b) {    return b == 0 ? a : gcd(b, a % b);   }  }  static class InputReader {   public BufferedReader reader;   public StringTokenizer tokenizer;   public InputReader(InputStream stream) {    reader = new BufferedReader(new InputStreamReader(stream), 32768);    tokenizer = null;   }   public String next() {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      tokenizer = new StringTokenizer(reader.readLine());     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return tokenizer.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }  } }
5,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  OutputWriter out = new OutputWriter(outputStream);  TaskA solver = new TaskA();  solver.solve(1, in, out);  out.close(); } } class TaskA { public void solve(int testNumber, InputReader in, OutputWriter out) {  int count = in.readInt();  int[] array = IOUtils.readIntArray(in, count);  int[] sorted = array.clone();  ArrayUtils.sort(sorted, IntComparator.DEFAULT);  int differs = 0;  for (int i = 0; i < count; i++) {  if (array[i] != sorted[i])   differs++;  }  if (differs <= 2)  out.printLine("YES");  else  out.printLine("NO"); } } class InputReader {  private InputStream stream; private byte[] buf = new byte[1024]; private int curChar; private int numChars; private SpaceCharFilter filter;  public InputReader(InputStream stream) {  this.stream = stream; }  public int read() {  if (numChars == -1)  throw new InputMismatchException();  if (curChar >= numChars) {  curChar = 0;  try {   numChars = stream.read(buf);  } catch (IOException e) {   throw new InputMismatchException();  }  if (numChars <= 0)   return -1;  }  return buf[curChar++]; }  public int readInt() {  int c = read();  while (isSpaceChar(c))  c = read();  int sgn = 1;  if (c == '-') {  sgn = -1;  c = read();  }  int res = 0;  do {  if (c < '0' || c > '9')   throw new InputMismatchException();  res *= 10;  res += c - '0';  c = read();  } while (!isSpaceChar(c));  return res * sgn; }  public boolean isSpaceChar(int c) {  if (filter != null)  return filter.isSpaceChar(c);  return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; }  public interface SpaceCharFilter {  public boolean isSpaceChar(int ch); } } class OutputWriter { private final PrintWriter writer;  public OutputWriter(OutputStream outputStream) {  writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream))); }  public OutputWriter(Writer writer) {  this.writer = new PrintWriter(writer); }  public void print(Object...objects) {  for (int i = 0; i < objects.length; i++) {  if (i != 0)   writer.print(' ');  writer.print(objects[i]);  } }  public void printLine(Object...objects) {  print(objects);  writer.println(); }  public void close() {  writer.close(); }  } class IOUtils {  public static int[] readIntArray(InputReader in, int size) {  int[] array = new int[size];  for (int i = 0; i < size; i++)  array[i] = in.readInt();  return array; }  } class ArrayUtils {  private static int[] tempInt = new int[0];  public static int[] sort(int[] array, IntComparator comparator) {   return sort(array, 0, array.length, comparator);  }  public static int[] sort(int[] array, int from, int to, IntComparator comparator) {   ensureCapacityInt(to - from);   System.arraycopy(array, from, tempInt, 0, to - from);   sortImpl(array, from, to, tempInt, 0, to - from, comparator);   return array;  }  private static void ensureCapacityInt(int size) {   if (tempInt.length >= size)    return;   size = Math.max(size, tempInt.length << 1);   tempInt = new int[size];  }  private static void sortImpl(int[] array, int from, int to, int[] temp, int fromTemp, int toTemp, IntComparator comparator) {   if (to - from <= 1)    return;   int middle = (to - from) >> 1;   int tempMiddle = fromTemp + middle;   sortImpl(temp, fromTemp, tempMiddle, array, from, from + middle, comparator);   sortImpl(temp, tempMiddle, toTemp, array, from + middle, to, comparator);   int index = from;   int index1 = fromTemp;   int index2 = tempMiddle;   while (index1 < tempMiddle && index2 < toTemp) {    if (comparator.compare(temp[index1], temp[index2]) <= 0)     array[index++] = temp[index1++];    else     array[index++] = temp[index2++];   }   if (index1 != tempMiddle)    System.arraycopy(temp, index1, array, index, tempMiddle - index1);   if (index2 != toTemp)    System.arraycopy(temp, index2, array, index, toTemp - index2);  }  } interface IntComparator {  public static final IntComparator DEFAULT = new IntComparator() {   public int compare(int first, int second) {    if (first < second)     return -1;    if (first > second)     return 1;    return 0;   }  };  public int compare(int first, int second); }
1,public class Main implements Runnable { private boolean _ReadFromFile = false; private boolean _WriteToFile = false; static final String TASK_ID = "in"; static final String IN_FILE = TASK_ID + ".in"; static final String OUT_FILE = TASK_ID + ".out"; BufferedReader reader; StringTokenizer tokenizer; PrintWriter writer; private String alphabet;  private void core() throws Exception {  int n = nextInt();  alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";  for (int test = 0; test < n; test++) {  String input = reader.readLine();  StringTokenizer st = new StringTokenizer(input, alphabet);    ArrayList<Integer> have = new ArrayList<Integer>();  while (st.hasMoreElements()) {   String kString = st.nextToken();   have.add(Integer.parseInt(kString));  }  if (have.size() == 2)   writer.println(twoInts(have.get(0), have.get(1)));  else {   String row = "";   int col = 0;   for (int i = 0; i < input.length(); i++) {   if (Character.isDigit(input.charAt(i))) {    row = input.substring(0, i);    col = Integer.parseInt(input.substring(i));    break;   }   }   writer.println(oneInt(row, col));  }  } } private String oneInt(String row, int col) {  return "R" + col + "C" + toNum(row); } private int toNum(String row) {  int res = 0;  for (int i = 0; i < row.length(); i++) {  res = res * 26 + row.charAt(i) - 'A' + 1;  }  return res; } private String twoInts(Integer row, Integer col) {  return toAlpha(col) + row; } private String toAlpha(Integer col) {  String res = "";  while (col > 0) {  if (col % 26 > 0) {   res = alphabet.charAt(col % 26 - 1) + res;   col /= 26;  }  else {   res = "Z" + res;   col -= 26;   col /= 26;  }  }  return res; } void debug(Object...os) {  System.out.println(Arrays.deepToString(os)); }   public static void main(String[] args) throws InterruptedException {   Thread thread = new Thread(new Main());   thread.start();   thread.join();  } public void run() {   try {   reader = _ReadFromFile ? new BufferedReader(new FileReader(IN_FILE)) : new BufferedReader(new InputStreamReader(System.in));   writer = _WriteToFile ? new PrintWriter(OUT_FILE) : new PrintWriter(new BufferedOutputStream(System.out));    tokenizer = null;    core();    reader.close();    writer.close();   } catch (Exception e) {    e.printStackTrace();    System.exit(1);   }  }  int nextInt() throws Exception {   return Integer.parseInt(nextToken());  }  long nextLong() throws Exception {   return Long.parseLong(nextToken());  }  double nextDouble() throws Exception {   return Double.parseDouble(nextToken());  }  String nextToken() throws Exception {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    tokenizer = new StringTokenizer(reader.readLine());   }   return tokenizer.nextToken();  } }
5,public class Round111ProbA {    public static void main(String[] args) {   Scanner in = new Scanner(System.in);     int n = in.nextInt();   int[]a = new int[n];   int s =0;   for(int i =0 ; i < n;i++)   {    a[i] = in.nextInt();    s += a[i];   }   Arrays.sort(a);   int x =0;   int c =0;   for(int i =n-1 ; i >-1;i-- )   {    x +=a[i];    s -= a[i];    c++;    if(x > s)break;   }   System.out.println(c);  }  }
6,public class Main { public static void main(String[] args) throws Exception {  Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 27);  thread.start();  thread.join(); }  static class TaskAdapter implements Runnable {  @Override  public void run() {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   FastInput in = new FastInput(inputStream);   FastOutput out = new FastOutput(outputStream);   FElongatedMatrix solver = new FElongatedMatrix();   solver.solve(1, in, out);   out.close();  } }  static class FElongatedMatrix {  public void solve(int testNumber, FastInput in, FastOutput out) {  int n = in.readInt();  int m = in.readInt();  int[][] mat = new int[n][m];  for (int i = 0; i < n; i++) {   for (int j = 0; j < m; j++) {   mat[i][j] = in.readInt();   }  }   int[][] minDist = new int[n][n];  SequenceUtils.deepFill(minDist, (int) 1e9);  for (int i = 0; i < n; i++) {   for (int j = 0; j < n; j++) {   for (int k = 0; k < m; k++) {    minDist[i][j] = Math.min(minDist[i][j], Math.abs(mat[i][k] - mat[j][k]));   }   }  }  int[][] minDistBetweenHeadAndTail = new int[n][n];  SequenceUtils.deepFill(minDistBetweenHeadAndTail, (int) 1e9);  for (int i = 0; i < n; i++) {   for (int j = 0; j < n; j++) {   for (int k = 1; k < m; k++) {    minDistBetweenHeadAndTail[i][j] = Math.min(minDistBetweenHeadAndTail[i][j], Math.abs(mat[i][k] - mat[j][k - 1]));   }   }  }   Log2 log2 = new Log2();  BitOperator bo = new BitOperator();  int[][][] dp = new int[1 << n][n][n];  for (int i = 1; i < (1 << n); i++) {   if (i == Integer.lowestOneBit(i)) {   dp[i][log2.floorLog(i)][log2.floorLog(i)] = (int) 1e9;   continue;   }   for (int j = 0; j < n; j++) {   for (int k = 0; k < n; k++) {    if (bo.bitAt(i, j) == 0) {    continue;    }    for (int t = 0; t < n; t++) {    dp[i][j][k] = Math.max(dp[i][j][k],     Math.min(dp[bo.setBit(i, j, false)][t][k],      minDist[j][t]));    }   }   }  }   int ans = 0;  for (int i = 0; i < n; i++) {   for (int j = 0; j < n; j++) {   ans = Math.max(ans, Math.min(dp[(1 << n) - 1][i][j], minDistBetweenHeadAndTail[j][i]));   }  }  out.println(ans);  }  }  static class SequenceUtils {  public static void deepFill(Object array, int val) {  if (!array.getClass().isArray()) {   throw new IllegalArgumentException();  }  if (array instanceof int[]) {   int[] intArray = (int[]) array;   Arrays.fill(intArray, val);  } else {   Object[] objArray = (Object[]) array;   for (Object obj : objArray) {   deepFill(obj, val);   }  }  }  }  static class Log2 {  public int floorLog(int x) {  return 31 - Integer.numberOfLeadingZeros(x);  }  }  static class FastInput {  private final InputStream is;  private byte[] buf = new byte[1 << 13];  private int bufLen;  private int bufOffset;  private int next;  public FastInput(InputStream is) {  this.is = is;  }  private int read() {  while (bufLen == bufOffset) {   bufOffset = 0;   try {   bufLen = is.read(buf);   } catch (IOException e) {   bufLen = -1;   }   if (bufLen == -1) {   return -1;   }  }  return buf[bufOffset++];  }  public void skipBlank() {  while (next >= 0 && next <= 32) {   next = read();  }  }  public int readInt() {  int sign = 1;   skipBlank();  if (next == '+' || next == '-') {   sign = next == '+' ? 1 : -1;   next = read();  }   int val = 0;  if (sign == 1) {   while (next >= '0' && next <= '9') {   val = val * 10 + next - '0';   next = read();   }  } else {   while (next >= '0' && next <= '9') {   val = val * 10 - next + '0';   next = read();   }  }   return val;  }  }  static class BitOperator {  public int bitAt(int x, int i) {  return (x >> i) & 1;  }  public int setBit(int x, int i, boolean v) {  if (v) {   x |= 1 << i;  } else {   x &= ~(1 << i);  }  return x;  }  }  static class FastOutput implements AutoCloseable, Closeable {  private StringBuilder cache = new StringBuilder(10 << 20);  private final Writer os;  public FastOutput(Writer os) {  this.os = os;  }  public FastOutput(OutputStream os) {  this(new OutputStreamWriter(os));  }  public FastOutput println(int c) {  cache.append(c).append('\n');  return this;  }  public FastOutput flush() {  try {   os.append(cache);   os.flush();   cache.setLength(0);  } catch (IOException e) {   throw new UncheckedIOException(e);  }  return this;  }  public void close() {  flush();  try {   os.close();  } catch (IOException e) {   throw new UncheckedIOException(e);  }  }  public String toString() {  return cache.toString();  }  } }
4,public class CF1187G extends PrintWriter { CF1187G() { super(System.out); } static class Scanner {  Scanner(InputStream in) { this.in = in; } InputStream in;  int k, l; byte[] bb = new byte[1 << 15];  byte getc() {  if (k >= l) {   k = 0;   try { l = in.read(bb); } catch (IOException e) { l = 0; }   if (l <= 0) return -1;  }  return bb[k++];  }  int nextInt() {  byte c = 0; while (c <= 32) c = getc();  int a = 0;  while (c > 32) { a = a * 10 + c - '0'; c = getc(); }  return a;  } } Scanner sc = new Scanner(System.in); public static void main(String[] $) {  CF1187G o = new CF1187G(); o.main(); o.flush(); }  static final int INF = 0x3f3f3f3f; ArrayList[] aa_; int n_, m_; int[] pi, dd, bb; int[] uu, vv, uv, cost; int[] cc; void init() {  aa_ = new ArrayList[n_];  for (int u = 0; u < n_; u++)  aa_[u] = new ArrayList<Integer>();  pi = new int[n_];  dd = new int[n_];  bb = new int[n_];  qq = new int[nq];  iq = new boolean[n_];  uu = new int[m_];  vv = new int[m_];  uv = new int[m_];  cost = new int[m_];  cc = new int[m_ * 2];  m_ = 0; } void link(int u, int v, int cap, int cos) {  int h = m_++;  uu[h] = u;  vv[h] = v;  uv[h] = u ^ v;  cost[h] = cos;  cc[h << 1 ^ 0] = cap;  aa_[u].add(h << 1 ^ 0);  aa_[v].add(h << 1 ^ 1); } int[] qq; int nq = 1, head, cnt; boolean[] iq; void enqueue(int v) {  if (iq[v])  return;  if (head + cnt == nq) {  if (cnt * 2 <= nq)   System.arraycopy(qq, head, qq, 0, cnt);  else {   int[] qq_ = new int[nq *= 2];   System.arraycopy(qq, head, qq_, 0, cnt);   qq = qq_;  }  head = 0;  }  qq[head + cnt++] = v; iq[v] = true; } int dequeue() {  int u = qq[head++]; cnt--; iq[u] = false;  return u; } boolean spfa(int s, int t) {  Arrays.fill(pi, INF);  pi[s] = 0;  head = cnt = 0;  enqueue(s);  while (cnt > 0) {  int u = dequeue();  int d = dd[u] + 1;  ArrayList<Integer> adj = aa_[u];  for (int h_ : adj)   if (cc[h_] > 0) {   int h = h_ >> 1;   int p = pi[u] + ((h_ & 1) == 0 ? cost[h] : -cost[h]);   int v = u ^ uv[h];   if (pi[v] > p || pi[v] == p && dd[v] > d) {    pi[v] = p;    dd[v] = d;    bb[v] = h_;    enqueue(v);   }   }  }  return pi[t] != INF; } void push(int s, int t) {  int c = INF;  for (int u = t, h_, h; u != s; u ^= uv[h]) {  h = (h_ = bb[u]) >> 1;  c = Math.min(c, cc[h_]);  }  for (int u = t, h_, h; u != s; u ^= uv[h]) {  h = (h_ = bb[u]) >> 1;  cc[h_] -= c; cc[h_ ^ 1] += c;  } } void push1(int s, int t) {  for (int u = t, h_, h; u != s; u ^= uv[h]) {  h = (h_ = bb[u]) >> 1;  cc[h_]--; cc[h_ ^ 1]++;  } } int edmonds_karp(int s, int t) {  while (spfa(s, t))  push1(s, t);  int c = 0;  for (int h = 0; h < m_; h++)  c += cost[h] * cc[h << 1 ^ 1];  return c; } void main() {  int n = sc.nextInt();  int m = sc.nextInt();  int k = sc.nextInt();  int c = sc.nextInt();  int d = sc.nextInt();  int[] ii = new int[k];  for (int h = 0; h < k; h++)  ii[h] = sc.nextInt() - 1;  ArrayList[] aa = new ArrayList[n];  for (int i = 0; i < n; i++)  aa[i] = new ArrayList<Integer>();  for (int h = 0; h < m; h++) {  int i = sc.nextInt() - 1;  int j = sc.nextInt() - 1;  aa[i].add(j);  aa[j].add(i);  }  int t = n + k + 1;  n_ = n * t + 1;  m_ = k + (m * 2 * k + n) * (t - 1);  init();  for (int i = 0; i < n; i++) {  ArrayList<Integer> adj = aa[i];  for (int s = 0; s < t - 1; s++) {   int u = i * t + s;   for (int j : adj) {   int v = j * t + s + 1;   for (int x = 1; x <= k; x++)    link(u, v, 1, c + (x * 2 - 1) * d);   }  }  }  for (int i = 0; i < n; i++)  for (int s = 0; s < t - 1; s++) {   int u = i * t + s, v = u + 1;   link(u, v, k, i == 0 ? 0 : c);  }  for (int h = 0; h < k; h++)  link(n_ - 1, ii[h] * t + 0, 1, 0);  println(edmonds_karp(n_ - 1, 0 * t + t - 1)); } }
5,public class Solution {  public static void main(String[] args) throws IOException {   Scanner sc = new Scanner(System.in);    int n = sc.nextInt();   int t = sc.nextInt();   TreeMap<Integer, Integer> h = new TreeMap<Integer, Integer>();   for (int i=0; i < n; i++) {    int key = sc.nextInt();    h.put(key, sc.nextInt());   }   int ans = 2;   Integer lastKey = h.firstKey();   Integer last = h.get(lastKey);   h.remove(lastKey);   for (int i=1; i < n; i++) {    int key = h.firstKey();    int val = h.get(key);       if (Math.abs(key-val*1.0/2 - (lastKey + last*1.0/2)) == t) {     ans++;    } else if (Math.abs(key-val*1.0/2 - (lastKey + last*1.0/2)) > t) {     ans += 2;    }    lastKey = key;    last = val;    h.remove(lastKey);   }   System.out.println(ans);     sc.close();  }  }
3,public class D {  int [][] adjList ;  int dfs(int u , int p )  {   int size = 1 ;   for(int v : adjList[u])    if(v != p )    {     int curr = dfs(v, u) ;     size += curr ;    }   return size ;  }  void main() throws Exception  {   Scanner sc = new Scanner(System.in);   PrintWriter out = new PrintWriter(System.out);   int n = sc.nextInt() ;   int [] a = new int [n] ;   boolean [] vis = new boolean[n] ;   int cnt = 0 ;   for(int i = 0 ;i < n ; i++)    a[i] = sc.nextInt() ;   sort(a);   for(int i = 0 ;i < n ; i ++)   {    if(!vis[i])    {     for(int j= i ; j < n ; j++)      if(a[j] % a[i] == 0)       vis[j] = true ;     cnt ++ ;    }   }   out.println(cnt);   out.flush();   out.close();  }  class SegmentTree  {   int [] sTree ;   int [] lazy ;   int N ;   SegmentTree(int n)   {    N = 1 << (32 - Integer.numberOfLeadingZeros(n - 1)) ;    sTree = new int [N << 1] ;    lazy= new int [N << 1] ;   }   void push(int node , int b , int e , int mid)   {    sTree[node << 1] += (mid - b + 1) * lazy[node] ;    sTree[node << 1 | 1] += (e - mid) * lazy[node] ;    lazy[node << 1] += lazy[node] ;    lazy[node << 1 | 1] += lazy[node] ;    lazy[node] = 0 ;   }   void updateRange(int node , int b , int e , int i , int j , int val)   {    if(i > e || j < b)return;    if(i <= b && e <= j)    {     sTree[node] += (e - b + 1) * val ;     lazy[node] += val ;     return;    }    int mid = b + e >> 1 ;    push(node , b , e , mid) ;    updateRange(node << 1 , b , mid , i , j , val);    updateRange(node << 1 | 1 , mid + 1 , e , i , j , val);    sTree[node] = sTree[node << 1] + sTree[node << 1 | 1] ;   }   int query(int node , int b , int e , int i , int j)   {    if(i > e || j < b)     return 0 ;    if(i <= b && e <= j)     return sTree[node] ;    int mid = b + e >> 1 ;    push(node , b , e , mid);    return query(node << 1 , b , mid , i , j) + query(node << 1 | 1 , mid + 1 , e , i , j) ;   }  }  class Compressor  {   TreeSet<Integer> set = new TreeSet<>() ;   TreeMap<Integer ,Integer> map = new TreeMap<>() ;   void add(int x)   {    set.add(x) ;   }   void fix()   {    for(int x : set)     map.put(x , map.size() + 1) ;   }   int get(int x)   {    return map.get(x) ;   }  }  class Scanner  {   BufferedReader br ;   StringTokenizer st ;   Scanner(InputStream in)   {    br = new BufferedReader(new InputStreamReader(in)) ;   }   String next() throws Exception   {    while (st == null || !st.hasMoreTokens())     st = new StringTokenizer(br.readLine()) ;    return st.nextToken() ;   }   int nextInt() throws Exception   {    return Integer.parseInt(next()) ;   }   long nextLong() throws Exception   {    return Long.parseLong(next()) ;   }   double nextDouble() throws Exception   {    return Double.parseDouble(next()) ;   }  }  public static void main (String [] args) throws Exception {(new D()).main();} }
3,public class c {  static boolean seq[]; static long memo[][], mod = (long)1e9 + 7; static long go(int n, int d) {  long ans = 0;  if(d < 0) return 0;  if(n == seq.length) return 1;  int f = 1;  if(n > 0) f = seq[n-1]?1:0;  if(memo[n][d] != -1) return memo[n][d];  if(f == 0) {  ans += go(n + 1, d + (seq[n]?1:0));  ans %= mod;  ans += go(n, d-1);  ans %= mod;  }  if(f == 1) {  ans += go(n + 1, d + (seq[n]?1:0));  ans %= mod;  }  return memo[n][d] = ans; }  public static void main(String args[]) throws IOException {  FastScanner in = new FastScanner(System.in);  PrintWriter out = new PrintWriter(System.out);   int n = in.nextInt();  seq = new boolean[n];  for (int i = 0; i < n; i++ ) {  seq[i] = (in.next().charAt(0) == 'f');  }  memo = new long[n][n+1];  for(int i = 0; i < n; i++) {   Arrays.fill(memo[i], -1);  }  System.out.println(go(0, 0));  out.close(); }  static class FastScanner {  BufferedReader br;  StringTokenizer st;  public FastScanner(InputStream i) {  br = new BufferedReader(new InputStreamReader(i));  st = null;  }  public String next() throws IOException {  while (st == null || !st.hasMoreTokens())   st = new StringTokenizer(br.readLine());  return st.nextToken();  }  public String nextLine() throws IOException {  if (st == null) {   st = new StringTokenizer(br.readLine());  }  String line = st.nextToken("\n");  st = null;  return line;  }  public int nextInt() throws IOException {  return Integer.parseInt(next());  }  public long nextLong() throws IOException {  return Long.parseLong(next());  }  public double nextDouble() throws IOException {  return Double.parseDouble(next());  } }  public static class combinatorics {  static long modInv(long a, long b) {  return 1 < a ? b - modInv(b % a, a) * b / a : 1;  }  static long factorial[], mod;  combinatorics(int n, long MOD) {  mod = MOD;  factorial = new long[n + 1];  factorial[0] = 1;  for (int i = 1; i <= n; i++) {   factorial[i] = i * factorial[i - 1];   factorial[i] %= mod;  }  }  static long nCr(int n, int r) {  if (r > n)   return 0;  return (factorial[n] * modInv((factorial[n - r] * factorial[r]) % mod, mod)) % mod;  } }  public static class DisjointSet {  int p[], r[], s[];  int numDisjoint;  DisjointSet(int N) {  numDisjoint = N;  r = new int[N];  s = new int[N];  p = new int[N];  for (int i = 0; i < N; i++)   p[i] = i;  }  int findSet(int i) {  return (p[i] == i) ? i : (p[i] = findSet(p[i]));  }  boolean isSameSet(int i, int j) {  return findSet(i) == findSet(j);  }  void unionSet(int i, int j) {  if (!isSameSet(i, j))   {   numDisjoint--;   int x = findSet(i), y = findSet(j);   if (r[x] > r[y]) {   p[y] = x;    s[x] += s[y];   } else {   p[x] = y;   if (r[x] == r[y])    r[y]++;   s[y] += s[x];   }  }  }  int sizeOfSet(int i) {  return s[findSet(i)];  } }; }
0,public class TaskA {  public void run() {   InputReader reader = new InputReader(System.in);   PrintWriter writer = new PrintWriter(System.out, true);   reader.nextLine();   String statement = reader.next();   if (!statement.startsWith("-")) {    writer.println(statement);   } else {    try {     int statement1 = Integer.parseInt(statement.substring(0, statement.length() - 1));     int statement2 = Integer.parseInt(statement.substring(0, statement.length() - 2) + statement.charAt(statement.length() - 1));     writer.println(Math.max(statement1, statement2));    } catch (Exception e) {     writer.println(statement);    }   }   writer.close();  }  public static void main(String[] args) {   new TaskA().run();  }  private class InputReader {   BufferedReader reader;   StringTokenizer token;   private InputReader(InputStream stream) {    reader = new BufferedReader(new InputStreamReader(stream));   }   private String next() {    return token.nextToken();   }   private int nextInt() {    return Integer.parseInt(this.next());   }   private double nextDouble() {    return Double.parseDouble(this.next());   }   private long nextLong() {    return Long.parseLong(this.next());   }   private String nextLine() {    String line = "";    try {     line = reader.readLine();     token = new StringTokenizer(line, " ");    } catch(IOException e) {    }    return line;   }  } }
2,public class _817C {  static long sum = 0;  static long BSearch2(long st, long end, long lim) {   if (st > end) return 0;   long mid = (st + end) >> 1;   if (mid - sumDigit(mid) >= lim) {    sum = mid;    return BSearch2(st, mid - 1, lim);   }   if (mid - sumDigit(mid) < lim)    return BSearch2(mid + 1, end, lim);   return 0;  }  public static void main(String[] args) throws IOException {   BufferedReader in = new BufferedReader(new InputStreamReader(System.in));   StringTokenizer st = new StringTokenizer(in.readLine());   long s = Long.parseLong(st.nextToken());   long n = Long.parseLong(st.nextToken());   BSearch2(1, s, n);   if (sum == 0) System.out.println("0");   else System.out.println(s - sum + 1);  }  static long sumDigit(long z) {   String s = "" + z;   int c = 0;   for (int i = 0; i < s.length(); i++) c += s.charAt(i);   return c - s.length() * 0x30;  } }
2,public class Solution {  static long n, x, y, c;  static boolean can (long len)  {   BigInteger blen = BigInteger.valueOf(len);        BigInteger sum = BigInteger.ONE;   sum = sum.add(blen.multiply(blen.add(BigInteger.ONE)).shiftLeft(1));     long a1 = Math.max(0, len - x);   sum = sum.subtract(BigInteger.valueOf(a1).multiply(BigInteger.valueOf(a1)));     long a2 = Math.max(0, len - y);   sum = sum.subtract(BigInteger.valueOf(a2).multiply(BigInteger.valueOf(a2)));   long a3 = Math.max(0, len - (n - 1 - x));   sum = sum.subtract(BigInteger.valueOf(a3).multiply(BigInteger.valueOf(a3)));     long a4 = Math.max(0, len - (n - 1 - y));   sum = sum.subtract(BigInteger.valueOf(a4).multiply(BigInteger.valueOf(a4)));     if (y - a1 + 1 < 0)   {    long b1 = Math.abs(y - a1 + 1);    sum = sum.add(BigInteger.valueOf(b1).multiply(BigInteger.valueOf(b1 + 1)).shiftRight(1));   }     if (y - a3 + 1 < 0)   {    long b1 = Math.abs(y - a3 + 1);    sum = sum.add(BigInteger.valueOf(b1).multiply(BigInteger.valueOf(b1 + 1)).shiftRight(1));   }     if (y + a1 - 1 >= n)   {    long b1 = y + a1 - n;    sum = sum.add(BigInteger.valueOf(b1).multiply(BigInteger.valueOf(b1 + 1)).shiftRight(1));   }     if (y + a3 - 1 >= n)   {    long b1 = y + a3 - n;    sum = sum.add(BigInteger.valueOf(b1).multiply(BigInteger.valueOf(b1 + 1)).shiftRight(1));   }     return sum.compareTo(BigInteger.valueOf(c)) >= 0;  }  public static void main (String argv[])  {   Scanner in = new Scanner(System.in);     n = in.nextLong();   x = in.nextLong();   y = in.nextLong();   c = in.nextLong();   x--; y--;     long lf = 0, rg = 2 * 1000 * 1000 * 1000 + 3;     while (lf != rg)   {    long mid = (lf + rg) >> 1;       if (can(mid))     rg = mid;    else     lf = mid + 1;   }     System.out.println(lf);  } }
4,public class D_CF {  public static void main(String[] args) {   FastScanner58 fs = new FastScanner58();   PrintWriter pw = new PrintWriter(System.out);     int t = 1;     for (int tc = 0; tc < t; tc++) {    int n = fs.ni();    int m = fs.ni();    int k = fs.ni();    int[][] a = new int[n][m - 1];    int[][] b = new int[n - 1][m];    for (int i = 0; i < n; i++) {     a[i] = fs.intArray(m - 1);    }    for (int i = 0; i < n - 1; i++) {     b[i] = fs.intArray(m);    }    int[][] res = new int[n][m];    Integer[][][] dp = new Integer[n][m][k / 2 + 1];    for (int i = 0; i < n; i++) {     for (int j = 0; j < m; j++) {      res[i][j] = recur(i, j, k / 2, dp, a, b) * 2;     }    }    StringBuilder sb = new StringBuilder();    for (int i = 0; i < res.length; i++) {     for (int j = 0; j < m; j++) {           if (k%2==1) {       sb.append(-1 + " ");      } else {       sb.append(res[i][j] + " ");      }     }     sb.append("\n");    }    pw.println(sb);   }   pw.close();  }  public static int recur(int i, int j, int k, Integer[][][] dp, int[][] a, int[][] b) {   if (k == 0) {    return 0;   }   int n = (int) (1e9);   if (dp[i][j][k] != null) {    return dp[i][j][k];   }   if (i != 0) {    n = Math.min(n, recur(i - 1, j, k - 1, dp, a, b) + b[i - 1][j]);   }   if (j != 0) {    n = Math.min(n, recur(i, j - 1, k - 1, dp, a, b) + a[i][j - 1]);   }   if (i != a.length - 1) {    n = Math.min(n, recur(i + 1, j, k - 1, dp, a, b) + b[i][j]);   }   if (j != b[0].length - 1) {    n = Math.min(n, recur(i, j + 1, k - 1, dp, a, b) + a[i][j]);   }   return dp[i][j][k] = n;  } } class FastScanner58 {  BufferedReader br;  StringTokenizer st;  public FastScanner58() {   br = new BufferedReader(new InputStreamReader(System.in), 32768);   st = null;  }  String next() {   while (st == null || !st.hasMoreElements()) {    try {     st = new StringTokenizer(br.readLine());    } catch (IOException e) {     e.printStackTrace();    }   }   return st.nextToken();  }  int ni() {   return Integer.parseInt(next());  }  int[] intArray(int N) {   int[] ret = new int[N];   for (int i = 0; i < N; i++) {    ret[i] = ni();   }   return ret;  }  long nl() {   return Long.parseLong(next());  }  long[] longArray(int N) {   long[] ret = new long[N];   for (int i = 0; i < N; i++) {    ret[i] = nl();   }   return ret;  }  double nd() {   return Double.parseDouble(next());  }  String nextLine() {   String str = "";   try {    str = br.readLine();   } catch (IOException e) {    e.printStackTrace();   }   return str;  } } class UnionFind17 {  int[] id;  public UnionFind17(int size) {   id = new int[size];   for (int i = 0; i < size; i++) {    id[i] = i;   }  }  public int find(int p) {   int root = p;   while (root != id[root]) {    root = id[root];   }   while (p != root) {    int next = id[p];    id[p] = root;    p = next;   }   return root;  }  public void union(int p, int q) {   int a = find(p), b = find(q);   if (a == b) {    return;   }   id[b] = a;  } }
6,public class Main{  static PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  static long mod=(long)1e9+7;  static long mod1=998244353;  static boolean sieve[];  static ArrayList<Integer> primes;  static long factorial[],invFactorial[];  static ArrayList<Pair> graph[];  static boolean oj = System.getProperty("ONLINE_JUDGE") != null;   static int n,m;  static long cost[][],dp[];  public static void main(String[] args) throws Exception{   String st[]=nl();   n=pi(st[0]);   m=pi(st[1]);   st=nl();   String str=st[0];   int mn=10000;   for(int i=0;i<n;i++){    mn=Math.min(mn,str.charAt(i));   }   cost=new long[m][m];   for(int i=1;i<n;i++){    int a1=str.charAt(i-1)-mn;    int a2=str.charAt(i)-mn;    if(a1==a2)continue;    cost[a1][a2]++;    cost[a2][a1]++;   }   int mm=1<<m;   dp=new long[mm];   Arrays.fill(dp,Long.MAX_VALUE/2);   dp[0]=0;     long cntbit[]=new long[mm];   int minbit[]=new int[mm];   for(int mask=1;mask<mm;mask++){    cntbit[mask]=1+cntbit[(mask&(mask-1))];    for(int i=0;i<m;i++){     if(((mask>>i)&1)!=0){      minbit[mask]=i;      break;     }    }   }   long cntcost[][]=new long[mm][m];   for(int mask=0;mask<mm;mask++){    for(int i=0;i<m;i++){     int b=minbit[mask];     cntcost[mask][i]=cntcost[mask^(1<<b)][i]+cost[i][b];    }   }   int yy=mm-1;   for(int mask=0;mask<mm;mask++){    long cnt=cntbit[mask];    for(int i=0;i<m;i++){     if(((mask>>i)&1)!=0){      long ans=cnt*(cntcost[mask][i]-cntcost[yy^mask][i]);      dp[mask]=Math.min(dp[mask],dp[mask^(1<<i)]+ans);     }    }   }   out.println(dp[mm-1]);   out.flush();   out.close();  }  static String[] nl() throws Exception{   return br.readLine().split(" ");  }  static String[] nls() throws Exception{   return br.readLine().split("");  }  static int pi(String str) {   return Integer.parseInt(str);  }  static long pl(String str){   return Long.parseLong(str);  }  static double pd(String str){   return Double.parseDouble(str);  }  static void printPrecision(double d){   DecimalFormat ft = new DecimalFormat("0.000000000000000000000");   out.println(ft.format(d));  }  static void printMask(long mask){   System.out.println(Long.toBinaryString(mask));  }  static int countBit(long mask){   int ans=0;   while(mask!=0){    if(mask%2==1){     ans++;    }    mask/=2;   }   return ans;  }  static void Makegraph(int n){   graph=new ArrayList[n];   for(int i=0;i<n;i++){    graph[i]=new ArrayList<>();   }  }  static void addEdge(int a,int b){   graph[a].add(new Pair(b,1));  }  static void addEdge(int a,int b,int c){   graph[a].add(new Pair(b,c));  }   static class PairComp implements Comparator<Pair>{   public int compare(Pair p1,Pair p2){    return p1.u-p2.u;   }  }  static class Pair implements Comparable<Pair> {   int u;   int v;   int index=-1;   public Pair(int u, int v) {    this.u = u;    this.v = v;   }   public int hashCode() {    int hu = (int) (u ^ (u >>> 32));    int hv = (int) (v ^ (v >>> 32));    return 31 * hu + hv;   }   public boolean equals(Object o) {    Pair other = (Pair) o;    return u == other.u && v == other.v;   }   public int compareTo(Pair other) {    if(index!=other.index)     return Long.compare(index, other.index);    return Long.compare(v, other.v)!=0?Long.compare(v, other.v):Long.compare(u, other.u);   }   public String toString() {    return "[u=" + u + ", v=" + v + "]";   }  }  static class PairCompL implements Comparator<Pairl>{   public int compare(Pairl p1,Pairl p2){    long a=p1.u*p2.v;    long b=p2.u*p1.v;    if(a>b){     return -1;    }    else if(a<b){     return 1;    }    else{     return 0;    }   }  }  static class Pairl implements Comparable<Pairl> {    long u;    long v;    int index=-1;    public Pairl(long u, long v) {     this.u = u;     this.v = v;    }     public int hashCode() {     int hu = (int) (u ^ (u >>> 32));     int hv = (int) (v ^ (v >>> 32));     return 31 * hu + hv;    }     public boolean equals(Object o) {     Pairl other = (Pairl) o;     return u == other.u && v == other.v;    }     public int compareTo(Pairl other) {     if(index!=other.index)      return Long.compare(index, other.index);     return Long.compare(v, other.v)!=0?Long.compare(v, other.v):Long.compare(u, other.u);    }     public String toString() {     return "[u=" + u + ", v=" + v + "]";    }   }  public static void debug(Object... o) {   if(!oj)   System.out.println(Arrays.deepToString(o));  }  static long modulo(long a,long b,long c) {   long x=1;   long y=a%c;   while(b > 0){    if(b%2 == 1){     x=(x*y)%c;    }    y = (y*y)%c;    b /= 2;   }   return x%c;  }  static long gcd(long x, long y)  {   if(x==0)    return y;   if(y==0)    return x;   long r=0, a, b;   a = (x > y) ? x : y;   b = (x < y) ? x : y;   r = b;   while(a % b != 0)   {    r = a % b;    a = b;    b = r;   }   return r;  }  static void sieveMake(int n){   sieve=new boolean[n];   Arrays.fill(sieve,true);   sieve[0]=false;   sieve[1]=false;   for(int i=2;i*i<n;i++){    if(sieve[i]){     for(int j=i*i;j<n;j+=i){      sieve[j]=false;     }    }   }   primes=new ArrayList<Integer>();   for(int i=0;i<n;i++){    if(sieve[i]){     primes.add(i);    }   }    } }
6,public class e1 {  static int n; static int m; static int[][] mat;  public static void main(String[] args){  JS scan = new JS();  PrintWriter out = new PrintWriter(System.out);  int t = scan.nextInt();  for(int q = 1; q <= t; q++){  ans = 0;  n = scan.nextInt();  m = scan.nextInt();  mat = new int[n][m];  for(int i = 0; i < n; i++){   for(int j = 0; j < m; j++){   mat[i][j] = scan.nextInt();   }  }  int[] max = new int[m];  PriorityQueue<Item> pq = new PriorityQueue<Item>();  for(int i = 0; i < m; i++){   for(int j = 0; j < n; j++){   max[i] = Math.max(max[i], mat[j][i]);   }   pq.add(new Item(i, max[i]));  }  ArrayList<Item> guys = new ArrayList<Item>();  while(!pq.isEmpty() && guys.size() < 8){   Item tt = pq.poll();   guys.add(tt);  }  perm(guys, 0, new int[guys.size()]);  out.println(ans);  }  out.flush(); }  static int ans = 0;  static void perm(ArrayList<Item> guys, int me, int[] shift){  if(me == guys.size()){    int res = 0;  int[] best = new int[n];  for(int j = 0; j < guys.size(); j++){   Item g = guys.get(j);   int pp = g.a;   for(int i = 0; i < n; i++){   best[(i+shift[j])%n] = Math.max(best[(i+shift[j])%n], mat[i][pp]);   }  }  for(int i = 0; i < n; i++) res += best[i];  ans = Math.max(res, ans);  return;  }  for(int i = 0; i < n; i++){  shift[me] = i;  perm(guys, me+1, shift);  } }  static class Item implements Comparable<Item>{  int a;  int b;  public Item(int a, int b){  this.a = a;  this.b = b;  }  public int compareTo(Item o){  return o.b-this.b;  } }  static class JS{  public int BS = 1<<16;  public char NC = (char)0;  byte[] buf = new byte[BS];  int bId = 0, size = 0;  char c = NC;  double num = 1;  BufferedInputStream in;   public JS() {  in = new BufferedInputStream(System.in, BS);  }   public JS(String s) throws FileNotFoundException {  in = new BufferedInputStream(new FileInputStream(new File(s)), BS);  }   public char nextChar(){  while(bId==size) {   try {   size = in.read(buf);   }catch(Exception e) {   return NC;   }     if(size==-1)return NC;   bId=0;  }  return (char)buf[bId++];  }   public int nextInt() {  return (int)nextLong();  }   public long nextLong() {  num=1;  boolean neg = false;  if(c==NC)c=nextChar();  for(;(c<'0' || c>'9'); c = nextChar()) {   if(c=='-')neg=true;  }  long res = 0;  for(; c>='0' && c <='9'; c=nextChar()) {   res = (res<<3)+(res<<1)+c-'0';   num*=10;  }  return neg?-res:res;  }   public double nextDouble() {  double cur = nextLong();  return c!='.' ? cur:cur+nextLong()/num;  }   public String next() {  StringBuilder res = new StringBuilder();  while(c<=32)c=nextChar();  while(c>32) {   res.append(c);   c=nextChar();  }  return res.toString();  }   public String nextLine() {  StringBuilder res = new StringBuilder();  while(c<=32)c=nextChar();  while(c!='\n') {   res.append(c);   c=nextChar();  }  return res.toString();  }   public boolean hasNext() {  if(c>32)return true;  while(true) {   c=nextChar();   if(c==NC)return false;   else if(c>32)return true;  }  } } }
3,public class NewYearsCurling { public static void main(String[] args) {  Scanner sc = new Scanner(System.in);  PrintWriter pw = new PrintWriter(System.out);  StringTokenizer st = new StringTokenizer(sc.nextLine());  int n = Integer.parseInt(st.nextToken());  int r = Integer.parseInt(st.nextToken());  ArrayList<Integer> centers = new ArrayList<Integer>();  st = new StringTokenizer(sc.nextLine());  for (int i = 0; i < n; i++) {  centers.add(Integer.parseInt(st.nextToken()));  }  sc.close();  ArrayList<Point> finalpoints = new ArrayList<Point>();  for (int i = 0; i < n; i++) {  double maxy = r;  for (int j = 0; j < finalpoints.size(); j++) {   if (finalpoints.get(j).x - centers.get(i) > 2 * r || centers.get(i) - finalpoints.get(j).x > 2 * r)   continue;   double dist = Math.sqrt(    4 * r * r - (finalpoints.get(j).x - centers.get(i)) * (finalpoints.get(j).x - centers.get(i)))    + finalpoints.get(j).y;   if(dist > maxy)   maxy = dist;  }    pw.print(maxy + " ");  finalpoints.add(new Point(centers.get(i), maxy));  }   pw.close(); }  public static class Point {  double x;  double y;  public Point(double x, double y) {  this.x = x;  this.y = y;  } } }
3,public class init { static class p{ int i; int c; public p(int i,int c) {  this.i=i;this.c=c;   } } static int mod=1000000007; public static void main(String[] args) {   Scanner s=new Scanner(System.in); int n=s.nextInt(); int a[]=new int[n]; for(int i=0;i<n;i++) { char c=s.next().charAt(0); if(c=='f')  a[i]=1;  } int dp[][]=new int[n+1][n+1]; for(int i=0;i<=n;i++) { for(int j=0;j<=n;j++)  dp[i][j]=-1; } System.out.println(ans(dp,1,0,a,n)); } public static int ans(int dp[][],int i,int j,int a[],int n) {  if(i==n) {    return 1;  }  if(dp[i][j]!=-1) {  return dp[i][j];  }  if(a[i-1]==1) {  int x=ans(dp,i+1,j+1,a,n);  if(x!=-1)   dp[i][j]=x%mod;  }  else {  int x=-1;  if(j!=0)  x=ans(dp,i,j-1,a,n);  int y=ans(dp,i+1,j,a,n);  if(x!=-1)   dp[i][j]=x%mod;  if(y!=-1) {   if(dp[i][j]==-1)   dp[i][j]=y%mod;   else   dp[i][j]+=y%mod;}  }  return dp[i][j]; } }
4,public class x1497E {  static final int MAX = 10000000;  public static void main(String hi[]) throws Exception  {   int[] prime = new int[MAX+1];   for(int d=2; d <= MAX; d++)    if(prime[d] == 0)     for(int v=d; v <= MAX; v+=d)      if(prime[v] == 0)       prime[v] = d;   FastScanner infile = new FastScanner();   int T = infile.nextInt();   StringBuilder sb = new StringBuilder();   int[] freq = new int[MAX+1];   int[] ts = new int[MAX+1];   int time = 0;   while(T-->0)   {    int N = infile.nextInt();    int K = infile.nextInt();    int[] arr = infile.nextInts(N);    for(int i=0; i < N; i++)    {     int key = 1;     while(arr[i] > 1)     {      int p = prime[arr[i]];      int cnt = 0;      while(arr[i]%p == 0)      {       arr[i] /= p;       cnt ^= 1;      }      if(cnt == 1)       key *= p;     }     arr[i] = key;    }    int[][] right = new int[N][K+1];    for(int k=0; k <= K; k++)    {     int dex = 0;     int cnt = 0;     for(int i=0; i < N; i++)     {      while(dex < N && cnt <= k)      {       if(ts[arr[dex]] == time && freq[arr[dex]] >= 1 && cnt+1 > k)        break;       if(ts[arr[dex]] == time && freq[arr[dex]] >= 1)        cnt++;       if(ts[arr[dex]] < time)       {        ts[arr[dex]] = time;        freq[arr[dex]] = 0;       }       freq[arr[dex]]++;       dex++;      }      right[i][k] = dex;      if(freq[arr[i]] >= 2)       cnt--;      freq[arr[i]]--;     }     time++;    }    int[][] dp = new int[N+1][K+1];    for(int i=1; i <= N; i++)     Arrays.fill(dp[i], N);    for(int i=0; i < N; i++)     for(int a=0; a <= K; a++)     {      dp[i+1][a] = min(dp[i+1][a], dp[i][a]+1);      for(int b=0; b <= K-a; b++)       dp[right[i][b]][a+b] = min(dp[right[i][b]][a+b], dp[i][a]+1);     }    int res = dp[N][0];    for(int k=1; k <= K; k++)     res = min(res, dp[N][k]);    sb.append(res+"\n");   }   System.out.print(sb);  } } class FastScanner {  private int BS = 1 << 16;  private char NC = (char) 0;  private byte[] buf = new byte[BS];  private int bId = 0, size = 0;  private char c = NC;  private double cnt = 1;  private BufferedInputStream in;  public FastScanner() {   in = new BufferedInputStream(System.in, BS);  }  public FastScanner(String s) {   try {    in = new BufferedInputStream(new FileInputStream(new File(s)), BS);   } catch (Exception e) {    in = new BufferedInputStream(System.in, BS);   }  }  private char getChar() {   while (bId == size) {    try {     size = in.read(buf);    } catch (Exception e) {     return NC;    }    if (size == -1) return NC;    bId = 0;   }   return (char) buf[bId++];  }  public int nextInt() {   return (int) nextLong();  }  public int[] nextInts(int N) {   int[] res = new int[N];   for (int i = 0; i < N; i++) {    res[i] = (int) nextLong();   }   return res;  }  public long[] nextLongs(int N) {   long[] res = new long[N];   for (int i = 0; i < N; i++) {    res[i] = nextLong();   }   return res;  }  public long nextLong() {   cnt = 1;   boolean neg = false;   if (c == NC) c = getChar();   for (; (c < '0' || c > '9'); c = getChar()) {    if (c == '-') neg = true;   }   long res = 0;   for (; c >= '0' && c <= '9'; c = getChar()) {    res = (res << 3) + (res << 1) + c - '0';    cnt *= 10;   }   return neg ? -res : res;  }  public double nextDouble() {   double cur = nextLong();   return c != '.' ? cur : cur + nextLong() / cnt;  }  public double[] nextDoubles(int N) {   double[] res = new double[N];   for (int i = 0; i < N; i++) {    res[i] = nextDouble();   }   return res;  }  public String next() {   StringBuilder res = new StringBuilder();   while (c <= 32) c = getChar();   while (c > 32) {    res.append(c);    c = getChar();   }   return res.toString();  }  public String nextLine() {   StringBuilder res = new StringBuilder();   while (c <= 32) c = getChar();   while (c != '\n') {    res.append(c);    c = getChar();   }   return res.toString();  }  public boolean hasNext() {   if (c > 32) return true;   while (true) {    c = getChar();    if (c == NC) return false;    else if (c > 32) return true;   }  } }
5,public class Main { public static void main (String[] args) throws java.lang.Exception {  BufferedReader br=new BufferedReader(new InputStreamReader(System.in));  int n=Integer.parseInt(br.readLine());  int[] A=new int[n];  String[] s=br.readLine().split(" ");  for(int i=0;i<n;i++){  A[i]=Integer.parseInt(s[i]);  }  Map memo=new HashMap();  int[] f=new int[n];  for(int i=0;i<n;i++){  if(!memo.containsKey(A[i])){   memo.put(A[i],1);  }  else{   int ct=(int)memo.get(A[i]);   memo.put(A[i],ct+1);  }  int tot=0;  if(memo.containsKey(A[i]-1)){   tot+=(int)memo.get(A[i]-1);  }  if(memo.containsKey(A[i]+1)){   tot+=(int)memo.get(A[i]+1);  }  tot+=(int)memo.get(A[i]);  f[i]=tot;  }  BigInteger res=new BigInteger("0");  for(int i=0;i<n;i++){  int tot1=i+1-f[i];  int tot2=0;  if(memo.containsKey(A[i]-1)){   tot2+=(int)memo.get(A[i]-1);  }  if(memo.containsKey(A[i]+1)){   tot2+=(int)memo.get(A[i]+1);  }  tot2+=(int)memo.get(A[i]);  tot2=n-i-1-(tot2-f[i]);    res=res.add(BigInteger.valueOf((long)(tot1-tot2)*(long)A[i]));  }  System.out.println(res); } }
2,public class B implements Runnable{  private final static Random rnd = new Random();          int n;  private void solve() {   this.query = 0;   this.n = readInt();   int left1 = 0;   int l = 1, r = n;   while (l <= r) {    int m = (l + r) / 2;    int answer = getAnswer(m, 1, n, n);    if (answer < 2) {     r = m - 1;    } else {     left1 = m;     l = m + 1;    }   }   int left2 = left1;   l = left1 + 1;   r = n;   while (l <= r) {    int m = (l + r) / 2;    int answer = getAnswer(m, 1, n, n);    if (answer < 1) {     r = m - 1;    } else {     left2 = m;     l = m + 1;    }   }   int right2 = n + 1;   l = 1;   r = n;   while (l <= r) {    int m = (l + r) / 2;    int answer = getAnswer(1, 1, m, n);    if (answer < 2) {     l = m + 1;    } else {     right2 = m;     r = m - 1;    }   }   int right1 = right2;   l = 1;   r = right2 - 1;   while (l <= r) {    int m = (l + r) / 2;    int answer = getAnswer(1, 1, m, n);    if (answer < 1) {     l = m + 1;    } else {     right1 = m;     r = m - 1;    }   }   int bottom1 = 0;   l = 1;   r = n;   while (l <= r) {    int m = (l + r) / 2;    int answer = getAnswer(1, m, n, n);    if (answer < 2) {     r = m - 1;    } else {     bottom1 = m;     l = m + 1;    }   }   int bottom2 = bottom1;   l = bottom1 + 1;   r = n;   while (l <= r) {    int m = (l + r) / 2;    int answer = getAnswer(1, m, n, n);    if (answer < 1) {     r = m - 1;    } else {     bottom2 = m;     l = m + 1;    }   }   int top2 = n + 1;   l = 1;   r = n;   while (l <= r) {    int m = (l + r) / 2;    int answer = getAnswer(1, 1, n, m);    if (answer < 2) {     l = m + 1;    } else {     top2 = m;     r = m - 1;    }   }   int top1 = top2;   l = 1;   r = top2 - 1;   while (l <= r) {    int m = (l + r) / 2;    int answer = getAnswer(1, 1, n, m);    if (answer < 1) {     l = m + 1;    } else {     top1 = m;     r = m - 1;    }   }   int ansLeftRightMask = -1, ansBottomTopMask = -1;   long answerS = 2L * n * n;   for (int leftRightMask = 0; leftRightMask < 4; ++leftRightMask) {    int left = (checkBit(leftRightMask, 0) ? left1 : left2);    int right = (checkBit(leftRightMask, 1) ? right1 : right2);    for (int bottomTopMask = 0; bottomTopMask < 4; ++bottomTopMask) {     int bottom = (checkBit(bottomTopMask, 0) ? bottom1 : bottom2);     int top = (checkBit(bottomTopMask, 1) ? top1 : top2);     int curTry = getAnswer(left, bottom, right, top);     if (curTry == 1) {      long s = (right - left + 1L) * (top - bottom + 1L);      if (s < answerS) {       answerS = s;       ansLeftRightMask = leftRightMask;       ansBottomTopMask = bottomTopMask;      }     }    }   }   int left = (checkBit(ansLeftRightMask, 0) ? left1 : left2);   int right = (checkBit(ansLeftRightMask, 1) ? right1 : right2);   int bottom = (checkBit(ansBottomTopMask, 0) ? bottom1 : bottom2);   int top = (checkBit(ansBottomTopMask, 1) ? top1 : top2);   printAnswer(left, bottom, right, top,     left1 + left2 - left, bottom1 + bottom2 - bottom,     right1 + right2 - right, top1 + top2 - top);  }  private void printAnswer(int... values) {   printQuery("!", values);  }  private void printQuery(String sign, int... values) {   out.print(sign);   for (int value : values) {    out.print(" " + value);   }   out.println();   out.flush();  }  int query = 0;  final int MAX_QUERY = 200;  private int getAnswer(int left, int bottom, int right, int top) {   if (left < 1 || right > n) {    while (true);   }   if (bottom < 1 || top > n) {    throw new RuntimeException();   }   if (left > right || bottom > top) {    return 0;   }   if (query == MAX_QUERY) {    throw new RuntimeException();   }   ++query;   printQuery("?", left, bottom, right, top);   int answer = readInt();   return answer;  }    private final static boolean FIRST_INPUT_STRING = false;  private final static boolean MULTIPLE_TESTS = true;  private final static boolean INTERACTIVE = true;  private final boolean ONLINE_JUDGE = System.getProperty("ONLINE_JUDGE") != null;  private final static int MAX_STACK_SIZE = 128;  private final static boolean OPTIMIZE_READ_NUMBERS = false;    public void run(){   try{    timeInit();    Locale.setDefault(Locale.US);    init();    if (ONLINE_JUDGE) {     solve();    } else {     do {      try {       timeInit();       solve();       time();       out.println();      } catch (NumberFormatException e) {       break;      } catch (NullPointerException e) {       if (FIRST_INPUT_STRING) break;       else throw e;      }     } while (MULTIPLE_TESTS);    }    out.close();    time();   }catch (Exception e){    e.printStackTrace(System.err);    System.exit(-1);   }  }    private BufferedReader in;  private OutputWriter out;  private StringTokenizer tok = new StringTokenizer("");  public static void main(String[] args){   new Thread(null, new B(), "", MAX_STACK_SIZE * (1L << 20)).start();  }    private void init() throws FileNotFoundException{   Locale.setDefault(Locale.US);   if (INTERACTIVE || ONLINE_JUDGE){    in = new BufferedReader(new InputStreamReader(System.in));    out = new OutputWriter(System.out);   }else{    in = new BufferedReader(new FileReader("input.txt"));    out = new OutputWriter("output.txt");   }  }    private long timeBegin;  private void timeInit() {   this.timeBegin = System.currentTimeMillis();  }  private void time(){   long timeEnd = System.currentTimeMillis();   System.err.println("Time = " + (timeEnd - timeBegin));  }  private void debug(Object... objects){   if (ONLINE_JUDGE){    for (Object o: objects){     System.err.println(o.toString());    }   }  }    private String delim = " ";  private String readLine() {   try {    return in.readLine();   } catch (IOException e) {    throw new RuntimeIOException(e);   }  }  private String readString() {   try {    while(!tok.hasMoreTokens()){     tok = new StringTokenizer(readLine());    }    return tok.nextToken(delim);   } catch (NullPointerException e) {    return null;   }  }    private final char NOT_A_SYMBOL = '\0';  private char readChar() {   try {    int intValue = in.read();    if (intValue == -1){     return NOT_A_SYMBOL;    }    return (char) intValue;   } catch (IOException e) {    throw new RuntimeIOException(e);   }  }  private char[] readCharArray() {   return readLine().toCharArray();  }  private char[][] readCharField(int rowsCount) {   char[][] field = new char[rowsCount][];   for (int row = 0; row < rowsCount; ++row) {    field[row] = readCharArray();   }   return field;  }    private long optimizedReadLong() {   long result = 0;   boolean started = false;   while (true) {    try {     int j = in.read();     if (-1 == j) {      if (started) return result;      throw new NumberFormatException();     }     if ('0' <= j && j <= '9') {      result = result * 10 + j - '0';      started = true;     } else if (started) {      return result;     }    } catch (IOException e) {     throw new RuntimeIOException(e);    }   }  }  private int readInt() {   if (!OPTIMIZE_READ_NUMBERS) {    return Integer.parseInt(readString());   } else {    return (int) optimizedReadLong();   }  }  private int[] readIntArray(int size) {   int[] array = new int[size];   for (int index = 0; index < size; ++index){    array[index] = readInt();   }   return array;  }  private int[] readSortedIntArray(int size) {   Integer[] array = new Integer[size];   for (int index = 0; index < size; ++index) {    array[index] = readInt();   }   Arrays.sort(array);   int[] sortedArray = new int[size];   for (int index = 0; index < size; ++index) {    sortedArray[index] = array[index];   }   return sortedArray;  }  private int[] readIntArrayWithDecrease(int size) {   int[] array = readIntArray(size);   for (int i = 0; i < size; ++i) {    array[i]--;   }   return array;  }    private int[][] readIntMatrix(int rowsCount, int columnsCount) {   int[][] matrix = new int[rowsCount][];   for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {    matrix[rowIndex] = readIntArray(columnsCount);   }   return matrix;  }  private int[][] readIntMatrixWithDecrease(int rowsCount, int columnsCount) {   int[][] matrix = new int[rowsCount][];   for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {    matrix[rowIndex] = readIntArrayWithDecrease(columnsCount);   }   return matrix;  }    private long readLong() {   if (!OPTIMIZE_READ_NUMBERS) {    return Long.parseLong(readString());   } else {    return optimizedReadLong();   }  }  private long[] readLongArray(int size) {   long[] array = new long[size];   for (int index = 0; index < size; ++index){    array[index] = readLong();   }   return array;  }    private double readDouble() {   return Double.parseDouble(readString());  }  private double[] readDoubleArray(int size) {   double[] array = new double[size];   for (int index = 0; index < size; ++index){    array[index] = readDouble();   }   return array;  }    private BigInteger readBigInteger() {   return new BigInteger(readString());  }  private BigDecimal readBigDecimal() {   return new BigDecimal(readString());  }    private Point readPoint() {   int x = readInt();   int y = readInt();   return new Point(x, y);  }  private Point[] readPointArray(int size) {   Point[] array = new Point[size];   for (int index = 0; index < size; ++index){    array[index] = readPoint();   }   return array;  }    private List<Integer>[] readGraph(int vertexNumber, int edgeNumber) {   @SuppressWarnings("unchecked")   List<Integer>[] graph = new List[vertexNumber];   for (int index = 0; index < vertexNumber; ++index){    graph[index] = new ArrayList<Integer>();   }   while (edgeNumber-- > 0){    int from = readInt() - 1;    int to = readInt() - 1;    graph[from].add(to);    graph[to].add(from);   }   return graph;  }    private static class IntIndexPair {   static Comparator<IntIndexPair> increaseComparator = new Comparator<B.IntIndexPair>() {    @Override    public int compare(B.IntIndexPair indexPair1, B.IntIndexPair indexPair2) {     int value1 = indexPair1.value;     int value2 = indexPair2.value;     if (value1 != value2) return value1 - value2;     int index1 = indexPair1.index;     int index2 = indexPair2.index;     return index1 - index2;    }   };   static Comparator<IntIndexPair> decreaseComparator = new Comparator<B.IntIndexPair>() {    @Override    public int compare(B.IntIndexPair indexPair1, B.IntIndexPair indexPair2) {     int value1 = indexPair1.value;     int value2 = indexPair2.value;     if (value1 != value2) return -(value1 - value2);     int index1 = indexPair1.index;     int index2 = indexPair2.index;     return index1 - index2;    }   };   int value, index;   IntIndexPair(int value, int index) {    super();    this.value = value;    this.index = index;   }   int getRealIndex() {    return index + 1;   }  }  private IntIndexPair[] readIntIndexArray(int size) {   IntIndexPair[] array = new IntIndexPair[size];   for (int index = 0; index < size; ++index) {    array[index] = new IntIndexPair(readInt(), index);   }   return array;  }    private static class OutputWriter extends PrintWriter {   final int DEFAULT_PRECISION = 12;   private int precision;   private String format, formatWithSpace;   {    precision = DEFAULT_PRECISION;    format = createFormat(precision);    formatWithSpace = format + " ";   }   OutputWriter(OutputStream out) {    super(out);   }   OutputWriter(String fileName) throws FileNotFoundException {    super(fileName);   }   int getPrecision() {    return precision;   }   void setPrecision(int precision) {    precision = max(0, precision);    this.precision = precision;    format = createFormat(precision);    formatWithSpace = format + " ";   }   String createFormat(int precision){    return "%." + precision + "f";   }   @Override   public void print(double d){    printf(format, d);   }   void printWithSpace(double d){    printf(formatWithSpace, d);   }   void printAll(double...d){    for (int i = 0; i < d.length - 1; ++i){     printWithSpace(d[i]);    }    print(d[d.length - 1]);   }   @Override   public void println(double d){    printlnAll(d);   }   void printlnAll(double... d){    printAll(d);    println();   }  }    private static class RuntimeIOException extends RuntimeException {      private static final long serialVersionUID = -6463830523020118289L;   RuntimeIOException(Throwable cause) {    super(cause);   }  }       private static final int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  private static final int[][] steps8 = {    {-1, 0}, {1, 0}, {0, -1}, {0, 1},    {-1, -1}, {1, 1}, {1, -1}, {-1, 1}  };  private static boolean checkCell(int row, int rowsCount, int column, int columnsCount) {   return checkIndex(row, rowsCount) && checkIndex(column, columnsCount);  }  private static boolean checkIndex(int index, int lim){   return (0 <= index && index < lim);  }    private static boolean checkBit(int mask, int bit){   return (mask & (1 << bit)) != 0;  }  private static boolean checkBit(long mask, int bit){   return (mask & (1L << bit)) != 0;  }    private static long getSum(int[] array) {   long sum = 0;   for (int value: array) {    sum += value;   }   return sum;  }  private static Point getMinMax(int[] array) {   int min = array[0];   int max = array[0];   for (int index = 0, size = array.length; index < size; ++index, ++index) {    int value = array[index];    if (index == size - 1) {     min = min(min, value);     max = max(max, value);    } else {     int otherValue = array[index + 1];     if (value <= otherValue) {      min = min(min, value);      max = max(max, otherValue);     } else {      min = min(min, otherValue);      max = max(max, value);     }    }   }   return new Point(min, max);  }    private static int[] getPrimes(int n) {   boolean[] used = new boolean[n];   used[0] = used[1] = true;   int size = 0;   for (int i = 2; i < n; ++i) {    if (!used[i]) {     ++size;     for (int j = 2 * i; j < n; j += i) {      used[j] = true;     }    }   }   int[] primes = new int[size];   for (int i = 0, cur = 0; i < n; ++i) {    if (!used[i]) {     primes[cur++] = i;    }   }   return primes;  }    private static long lcm(long a, long b) {   return a / gcd(a, b) * b;  }  private static long gcd(long a, long b) {   return (a == 0 ? b : gcd(b % a, a));  }    private static class IdMap<KeyType> extends HashMap<KeyType, Integer> {      private static final long serialVersionUID = -3793737771950984481L;   public IdMap() {    super();   }   int getId(KeyType key) {    Integer id = super.get(key);    if (id == null) {     super.put(key, id = size());    }    return id;   }  } }
4,public class A {  static int dx[] = { 1, -1, 0, 0 }; static int dy[] = { 0, 0, 1, -1 };  public static void main(String args[]) throws Exception {  Scanner sc = new Scanner("input.txt");  PrintWriter out = new PrintWriter("output.txt");  int n = sc.nextInt(), m = sc.nextInt();  int[][] grid = new int[n][m];  for (int[] i : grid)  Arrays.fill(i, -1);  Queue<Pair> q = new LinkedList<>();  int k = sc.nextInt();  for (int i = 0; i < k; i++) {  int x = sc.nextInt() - 1, y = sc.nextInt() - 1;  grid[x][y] = 0;  q.add(new Pair(x, y));  }  Pair p = new Pair(-1, -1);  while (!q.isEmpty()) {  p = q.poll();  for (int i = 0; i < dx.length; i++) {   int tx = p.x + dx[i], ty = p.y + dy[i];   if (tx >= 0 && tx < n && ty >= 0 && ty < m && grid[tx][ty] == -1) {   grid[tx][ty] = grid[p.x][p.y] + 1;   q.add(new Pair(tx, ty));   }  }  }  out.println(p);  out.flush();  out.close(); }  static class Pair {  int x, y;  public Pair(int a, int b) {  x = a;  y = b;  }  public String toString() {  return x + 1 + " " + (y + 1);  } }  static class Scanner {  StringTokenizer st;  BufferedReader br;  public Scanner(InputStream s) {  br = new BufferedReader(new InputStreamReader(s));  }  public Scanner(String r) throws FileNotFoundException {  br = new BufferedReader(new FileReader(r));  }  public String next() throws IOException {  while (st == null || !st.hasMoreTokens())   st = new StringTokenizer(br.readLine());  return st.nextToken();  }  public int nextInt() throws IOException {  return Integer.parseInt(next());  }  public long nextLong() throws IOException {  return Long.parseLong(next());  }  public String nextLine() throws IOException {  return br.readLine();  }  public boolean ready() throws IOException {  return br.ready();  } } }
4,public class P023A {  public static void main(String[] args)  {   Scanner in = new Scanner(System.in);   String line = in.next();     HashSet<String> hash = new HashSet<String>();     int ans = 0;   for (int len = line.length()-1; len > 0; --len)   {    for (int i = 0; i + len <= line.length(); ++i)    {     String sub = line.substring(i, i+len);     if (hash.contains(sub))     {      ans = Math.max(ans, sub.length());     }         hash.add(sub);    }   }     System.out.println(ans);  } }
3,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  PrintWriter out = new PrintWriter(outputStream);  TaskC solver = new TaskC();  solver.solve(1, in, out);  out.close(); }  static class TaskC {  private long MOD = (long) (1e9 + 7);  int[][] dp = new int[5001][5001];  public void solve(int testNumber, InputReader in, PrintWriter out) {  int n = in.nextInt();  ArrayList<Character> commands = new ArrayList<>();   for (int i = 0; i < n; i++) {   char ch = in.next().charAt(0);   commands.add(ch);  }  for (int a[] : dp) Arrays.fill(a, -1);   out.println(count(0, commands, 0));  }  public int count(int index, ArrayList<Character> commands, int deepCount) {  if (deepCount < 0) {   return 0;  }  if (index == commands.size()) {   return 1;  } else {   if (dp[index][deepCount] != -1) return dp[index][deepCount];   long result = 0;   char ch = commands.get(index);   result = count(index, commands, deepCount - 1);   if (ch == 's') {   result += count(index + 1, commands, deepCount);   } else {   result += count(index + 1, commands, deepCount + 1);   result -= count(index + 1, commands, deepCount);   }   if (result >= MOD) {   result -= MOD;   }   if (result < 0) {   result += MOD;   }   return dp[index][deepCount] = (int) result;  }  }  }  static class InputReader {  private InputStream stream;  private byte[] buf = new byte[1024];  private int curChar;  private int numChars;  private InputReader.SpaceCharFilter filter;  public InputReader(InputStream stream) {  this.stream = stream;  }  public int read() {  if (numChars == -1) {   throw new InputMismatchException();  }  if (curChar >= numChars) {   curChar = 0;   try {   numChars = stream.read(buf);   } catch (IOException e) {   throw new InputMismatchException();   }   if (numChars <= 0) {   return -1;   }  }  return buf[curChar++];  }  public int readInt() {  int c = read();  while (isSpaceChar(c)) {   c = read();  }  int sgn = 1;  if (c == '-') {   sgn = -1;   c = read();  }  int res = 0;  do {   if (c < '0' || c > '9') {   throw new InputMismatchException();   }   res *= 10;   res += c - '0';   c = read();  } while (!isSpaceChar(c));  return res * sgn;  }  public String readString() {  int c = read();  while (isSpaceChar(c)) {   c = read();  }  StringBuilder res = new StringBuilder();  do {   if (Character.isValidCodePoint(c)) {   res.appendCodePoint(c);   }   c = read();  } while (!isSpaceChar(c));  return res.toString();  }  public boolean isSpaceChar(int c) {  if (filter != null) {   return filter.isSpaceChar(c);  }  return isWhitespace(c);  }  public static boolean isWhitespace(int c) {  return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;  }  public String next() {  return readString();  }  public int nextInt() {  return readInt();  }  public interface SpaceCharFilter {  public boolean isSpaceChar(int ch);  }  } }
6,public class Main { public static void main(String args[]) {new Main().run();}  FastReader in = new FastReader(); PrintWriter out = new PrintWriter(System.out); void run(){  out.println(work());  out.flush(); } long mod=1000000007; long gcd(long a,long b) {  return b==0?a:gcd(b,a%b); } long work() {  int n=in.nextInt();  int m=in.nextInt();  String str=in.next();  long[] dp=new long[1<<m];  long[][] cnt=new long[m][m];  long[] rec=new long[1<<m];  for(int i=1;i<n;i++) {  int n1=str.charAt(i-1)-'a';  int n2=str.charAt(i)-'a';  cnt[n1][n2]++;  cnt[n2][n1]++;  }  for(int i=1;i<1<<m;i++) {  dp[i]=9999999999L;  long v=0;  int b=0;  for(int j=0;j<m;j++) {   if((i&(1<<j))>0) {   b=j;   break;   }  }  for(int j=0;j<m;j++) {   if((i&(1<<j))==0) {   v+=cnt[b][j];   }else {   if(b!=j)v-=cnt[b][j];   }  }  v+=rec[i-(1<<b)];  for(int j=0;j<m;j++) {   if((i&(1<<j))>0) {   dp[i]=Math.min(dp[i], dp[i-(1<<j)]+v);   }  }  rec[i]=v;  }   return dp[(1<<m)-1]; } }  class FastReader { BufferedReader br; StringTokenizer st;  public FastReader() {  br=new BufferedReader(new InputStreamReader(System.in)); }  public String next()  {  if(st==null || !st.hasMoreElements())  {  try {   st = new StringTokenizer(br.readLine());  } catch (IOException e) {   e.printStackTrace();  }  }  return st.nextToken(); }  public int nextInt()  {  return Integer.parseInt(next()); }  public long nextLong() {  return Long.parseLong(next()); } }
6,public class B {  private void solve() throws IOException {  int senators = nextInt();  int candies = nextInt();  scoreA = nextInt();  lvl = new int[senators];  unloyal = new int[senators];  for (int i = 0; i < senators; i++) {  lvl[i] = nextInt();  unloyal[i] = 10 - nextInt() / 10;  }  n = senators;  give = new int[n];  res = 0;  go(0, candies);  out.println(res); }  static double res; static int[] lvl; static int[] unloyal; static int[] give; static int n; static int scoreA;  static double probability() {  double res = 0;  for (int mask = 0; mask < 1 << n; mask++) {  double p = 1;  int scoreB = 0;  int cntGood = Integer.bitCount(mask);  for (int i = 0; i < n; i++) {   int cnt = unloyal[i] - give[i];   if ((mask & (1 << i)) == 0) {   scoreB += lvl[i];   p *= cnt * .1;   } else {   p *= (10 - cnt) * .1;   }  }  if (2 * cntGood > n) {   res += p;  } else {   res += p * scoreA / (scoreA + scoreB);  }  }  return res; }  static void go(int man, int candies) {  if (man == n) {  res = max(res, probability());  return;  }  give[man] = 0;  go(man + 1, candies);  for (int i = 1; i <= min(unloyal[man], candies); i++) {  give[man] = i;  go(man + 1, candies - i);  } }  public static void main(String[] args) {  try {  br = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);  new B().solve();  out.close();  } catch (Throwable e) {  e.printStackTrace();  System.exit(239);  } }  static BufferedReader br; static StringTokenizer st; static PrintWriter out;  static String nextToken() throws IOException {  while (st == null || !st.hasMoreTokens()) {  String line = br.readLine();  if (line == null) {   return null;  }  st = new StringTokenizer(line);  }  return st.nextToken(); }  static int nextInt() throws IOException {  return Integer.parseInt(nextToken()); }  static long nextLong() throws IOException {  return Long.parseLong(nextToken()); }  static double nextDouble() throws IOException {  return Double.parseDouble(nextToken()); } }
5,public class Problem220A {  static int[] numbers;  static int[] numbersCopy;  public static void main(String[] args) throws IOException {   BufferedReader in = new BufferedReader(new InputStreamReader(System.in));   int i = Integer.parseInt(in.readLine());   numbers = new int[i];   numbersCopy = new int[i];   StringTokenizer stringTokenizer = new StringTokenizer(in.readLine());   int numOutOfPlace = 0;   for (int j = 0; j < i; j++) {    numbers[j] = Integer.parseInt(stringTokenizer.nextToken());    numbersCopy[j] = numbers[j];   }   Arrays.sort(numbers);   for (int j = 0; j < i; j++) {    if (numbers[j] != numbersCopy[j]) {     numOutOfPlace++;     if (numOutOfPlace > 2) {      break;     }    }   }   if (numOutOfPlace == 0 || numOutOfPlace == 2) {    System.out.println("YES");   } else {    System.out.println("NO");   }  } }
6,public class f { static int n; static double[][] g; public static void main(String[] args) throws IOException { input.init(System.in); PrintWriter out = new PrintWriter(System.out); n = input.nextInt(); g = new double[n][n]; for(int i = 0; i<n; i++)  for(int j = 0; j<n; j++)  g[i][j] = input.nextDouble(); for(int i = 0; i<n; i++)  for(int j = 0; j<n; j++)  g[j][i] = 1 - g[i][j]; for(int i = 0; i<n; i++) {  double[] dp = new double[1<<n];  for(int mask = 0; mask < (1<<n); mask++)  {  if((mask & (1<<i)) == 0)  {   dp[mask] = 0;   continue;  }  if(mask == (1<<i))  {   dp[mask] = 1;   continue;  }  int count = Integer.bitCount(mask);  double prob = 1.0 / (count * (count-1)/2);  for(int a = 0; a<n; a++)  {   if((mask & (1<<a)) == 0) continue;   for(int b = a+1; b<n; b++)   {   if((mask & (1<<b)) == 0) continue;   double p = g[a][b] * dp[mask ^ (1<<b)] + g[b][a] * dp[mask ^ (1<<a)];   dp[mask] += p;   }  }  dp[mask] *= prob;  }  out.print(dp[(1<<n)-1]+" "); } out.close(); } public static class input { static BufferedReader reader; static StringTokenizer tokenizer;  static void init(InputStream input) {  reader = new BufferedReader(new InputStreamReader(input));  tokenizer = new StringTokenizer(""); }  static String next() throws IOException {  while (!tokenizer.hasMoreTokens())  tokenizer = new StringTokenizer(reader.readLine());  return tokenizer.nextToken(); }  static int nextInt() throws IOException {  return Integer.parseInt(next()); }  static double nextDouble() throws IOException {  return Double.parseDouble(next()); }  static long nextLong() throws IOException {  return Long.parseLong(next()); } } }
3,public class D911 {  public static void main(String[] args) throws IOException {   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));   PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));   StringTokenizer st;   int n = Integer.parseInt(br.readLine());   st = new StringTokenizer(br.readLine());   int[] num = new int[n];   for (int i = 0; i < n; i++) {    num[i] = Integer.parseInt(st.nextToken());   }   int count = 0;   for (int i = 0; i < n; i++) {    for (int j = 0; j < i; j++) {     if (num[i] < num[j]) {      count++;     }    }   }   boolean ans = count % 2 == 0;   for (int m = Integer.parseInt(br.readLine()); m-- > 0; ) {    st = new StringTokenizer(br.readLine());    int l = Integer.parseInt(st.nextToken());    int r = Integer.parseInt(st.nextToken());    if (((r - l + 1) / 2) % 2 != 0) {     ans = !ans;    }    out.println(ans ? "even" : "odd");   }   out.close();  } }
4,public class Codechef { public static void main (String[] args) throws java.lang.Exception {   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  int t = Integer.parseInt(br.readLine());  for(int q=0;q<t;q++){   String s = br.readLine();   int n = Integer.parseInt(s);   int a[] = new int[1000];   int index=0;   for(int i=0;i<n;i++){     int x = Integer.parseInt(br.readLine());     for(int j=index;j>=0;j--){      if(x-1==a[j]){        a[j]=x;            for(int k=0;k<j;k++){        System.out.print(a[k]+".");      }      System.out.print(a[j]);      System.out.println();      for(int k=j+1;k<1000;k++){        if(a[k]!=0)        a[k]=0;        else        break;      }      index=j+1;            break;      }     }   }  } } }
2,public class B713{   public static BufferedReader f;  public static PrintWriter out;    public static void main(String[] args)throws IOException{  f = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);    int n = Integer.parseInt(f.readLine());      int l;  int r;  int mid;  int ans;      l = 1;  r = n;  ans = -1;      while(l <= r){   mid = l + (r-l)/2;   if(mid == n) break;      int il = query(1,1,n,mid);   int ir = query(1,mid+1,n,n);      if(il == 1 && ir == 1){    ans = mid;    break;   }      if(il > ir){    r = mid-1;   } else {    l = mid+1;   }  }    int x11 = -1;  int y11 = -1;  int x12 = -1;  int y12 = -1;  int x21 = -1;  int y21 = -1;  int x22 = -1;  int y22 = -1;  if(ans == -1){      l = 1;   r = n;   ans = -1;     while(l <= r){    mid = l + (r-l)/2;          int il = query(1,1,mid,n);    int ir = query(mid+1,1,n,n);       if(il == 1 && ir == 1){     ans = mid;     break;    }       if(il > ir){     r = mid-1;    } else {     l = mid+1;    }   }     int bar = ans;           l = 1;   r = bar;   ans = -1;   while(l <= r){    mid = l + (r-l)/2;       int i = query(mid,1,bar,n);    if(i == 1){     ans = mid;     l = mid+1;    } else {     r = mid-1;    }   }      x11 = ans;         l = 1;   r = bar;   ans = -1;   while(l <= r){    mid = l + (r-l)/2;       int i = query(1,1,mid,n);    if(i == 1){     ans = mid;     r = mid-1;    } else {     l = mid+1;    }   }      x12 = ans;            l = 1;   r = n;   ans = -1;   while(l <= r){    mid = l + (r-l)/2;       int i = query(1,mid,bar,n);       if(i == 1){     ans = mid;     l = mid+1;    } else {     r = mid-1;    }   }      y11 = ans;         l = 1;   r = n;   ans = -1;   while(l <= r){    mid = l + (r-l)/2;       int i = query(1,1,bar,mid);       if(i == 1){     ans = mid;     r = mid-1;    } else {     l = mid+1;    }   }      y12 = ans;                     l = bar+1;   r = n;   ans = -1;   while(l <= r){    mid = l + (r-l)/2;       int i = query(mid,1,n,n);    if(i == 1){     ans = mid;     l = mid+1;    } else {     r = mid-1;    }   }      x21 = ans;         l = bar+1;   r = n;   ans = -1;   while(l <= r){    mid = l + (r-l)/2;       int i = query(bar+1,1,mid,n);    if(i == 1){     ans = mid;     r = mid-1;    } else {     l = mid+1;    }   }      x22 = ans;            l = 1;   r = n;   ans = -1;   while(l <= r){    mid = l + (r-l)/2;       int i = query(bar+1,mid,n,n);       if(i == 1){     ans = mid;     l = mid+1;    } else {     r = mid-1;    }   }      y21 = ans;         l = 1;   r = n;   ans = -1;   while(l <= r){    mid = l + (r-l)/2;       int i = query(bar+1,1,n,mid);       if(i == 1){     ans = mid;     r = mid-1;    } else {     l = mid+1;    }   }      y22 = ans;                    } else {      int bar = ans;      l = 1;   r = bar;   ans = -1;   while(l <= r){    mid = l + (r-l)/2;       int i = query(1,mid,n,bar);    if(i == 1){     ans = mid;     l = mid+1;    } else {     r = mid-1;    }   }      y11 = ans;         l = 1;   r = bar;   ans = -1;   while(l <= r){    mid = l + (r-l)/2;       int i = query(1,1,n,mid);    if(i == 1){     ans = mid;     r = mid-1;    } else {     l = mid+1;    }   }      y12 = ans;            l = 1;   r = n;   ans = -1;   while(l <= r){    mid = l + (r-l)/2;       int i = query(mid,1,n,bar);       if(i == 1){     ans = mid;     l = mid+1;    } else {     r = mid-1;    }   }      x11 = ans;         l = 1;   r = n;   ans = -1;   while(l <= r){    mid = l + (r-l)/2;       int i = query(1,1,mid,bar);       if(i == 1){     ans = mid;     r = mid-1;    } else {     l = mid+1;    }   }      x12 = ans;                     l = bar+1;   r = n;   ans = -1;   while(l <= r){    mid = l + (r-l)/2;       int i = query(1,mid,n,n);    if(i == 1){     ans = mid;     l = mid+1;    } else {     r = mid-1;    }   }      y21 = ans;         l = bar+1;   r = n;   ans = -1;   while(l <= r){    mid = l + (r-l)/2;       int i = query(1,bar+1,n,mid);    if(i == 1){     ans = mid;     r = mid-1;    } else {     l = mid+1;    }   }      y22 = ans;            l = 1;   r = n;   ans = -1;   while(l <= r){    mid = l + (r-l)/2;       int i = query(mid,bar+1,n,n);       if(i == 1){     ans = mid;     l = mid+1;    } else {     r = mid-1;    }   }      x21 = ans;         l = 1;   r = n;   ans = -1;   while(l <= r){    mid = l + (r-l)/2;       int i = query(1,bar+1,mid,n);       if(i == 1){     ans = mid;     r = mid-1;    } else {     l = mid+1;    }   }      x22 = ans;       }    out.println("! " + x11 + " " + y11 + " " + x12 + " " + y12 + " " + x21 + " " + y21 + " " + x22 + " " + y22);          out.close();  }   public static int query(int a,int b, int c, int d)throws IOException{  out.println("? " + a + " " + b + " " + c + " " + d);  out.flush();    return Integer.parseInt(f.readLine());  }    }
0,public class Main {  public static void main(String[] args) throws IOException {   BufferedReader in = new BufferedReader(new InputStreamReader(System.in));              StringBuilder out = new StringBuilder();   StringTokenizer tk;      long n = parseLong(in.readLine());     if(n <= 2) System.out.println(n);   else if(n%2 == 1)System.out.println(n*(n-1)*(n-2));   else {    long ans = (n-1)*(n-2)*(n-3);       if(gcd(n*(n-1),n-3)==1) ans = max(ans, n*(n-1)*(n-3));       System.out.println(ans);   }  }   static long gcd(long a,long b) {   return b==0 ? a : gcd(b, a%b);  } }
1,public class A {  public static void main(String[] args) throws Exception {   BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));          StringTokenizer st = new StringTokenizer(bf.readLine());     int n = Integer.parseInt(st.nextToken());   int d = Integer.parseInt(st.nextToken());   st = new StringTokenizer(bf.readLine());   int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());   int ans = 2;   for(int i=0; i<n-1; i++) {   int diff = a[i+1]-a[i];   if(diff == 2*d) ans++;   else if(diff > 2*d) ans += 2;   }   System.out.println(ans);       } }
2,public class P1177A {  public static void main(String[] args) throws FileNotFoundException {   Scanner in = new Scanner(System.in);     System.out.println(solve(in.nextLong()));  }  private static String solve(long k) {   long digitCnt = 1;   long nine = 9;   while (k > nine * digitCnt) {    k -= nine * digitCnt;    nine *= 10;    digitCnt++;   }   long num = nine / 9 - 1 + (k - 1) / digitCnt + 1;   return String.valueOf(String.valueOf(num).charAt((int) ((k - 1) % digitCnt)));  } }
1,public class B {   static char[] digits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}; static HashMap<Character, Integer> val = new HashMap<Character, Integer>(); static HashMap<Integer, Character> ch = new HashMap<Integer, Character>(); static StringBuffer strcol = new StringBuffer(); static String s;  static boolean isDigit(char a) {  boolean found = false;  for (int i = 0; i < digits.length; i++)  {  if (found = a == digits[i]) break;  }   return found; }  static String ABtoRC(int pos) {  do  {  ++pos;  }  while(!isDigit(s.charAt(pos)));   int res = 0;  for (int i = pos - 1, pow = 1; i >= 0; i--, pow *= 26)  {  res += val.get(s.charAt(i)) * pow;  }   return new String("R" + s.substring(pos, s.length()) + "C" + String.valueOf(res)); }  static String RCtoAB(int cpos) {  int col = Integer.valueOf(s.substring(cpos + 1, s.length()));  int mod = 0;  strcol.delete(0, strcol.length());   while (col >= 26)  {  int tmp = col / 26;  mod = col - 26 * tmp;  if (mod == 0)   {   mod += 26;   tmp -= 1;     }  col = tmp;  strcol.append(ch.get(mod));  }  if(col != 0)strcol.append(ch.get(col));  strcol.reverse();   return strcol.toString() + s.substring(1, cpos);  } public static void main(String[] args) throws IOException  {    BufferedReader input = new BufferedReader(new InputStreamReader(System.in));  PrintWriter output = new PrintWriter(new OutputStreamWriter(System.out));  StreamTokenizer in = new StreamTokenizer(input);  in.nextToken();  int n = (int)in.nval;   for (int i = 0; i < 26; i++)  {  val.put((char)('A' + i), i + 1);  }   for (int i = 0; i < 26; i++)  {  ch.put(i + 1, (char)('A' + i));  }   input.readLine();  for (int i = 0; i < n; i++) {  s = input.readLine();  int cpos;  if( ((cpos = s.indexOf('C')) > 1) && (isDigit(s.charAt(cpos - 1))) )   {   output.println(RCtoAB(cpos));   }  else  {   output.println(ABtoRC(cpos));  }  }   output.close();  input.close(); } }
3,@SuppressWarnings("Duplicates") public class solveLOL {  FastScanner in;  PrintWriter out;  boolean systemIO = true, multitests = false;  int INF = Integer.MAX_VALUE / 2;   void solve() {   int n = in.nextInt();   int arr[] = new int[n];   for (int i = 0; i < n; i++) {    arr[i] = in.nextInt();   }   Arrays.sort(arr);   boolean used[] = new boolean[n];   int k = 0;   for (int i = 0; i < n; i++) {    if (!used[i]) {     used[i] = true;     for (int j = i + 1; j < n; j++) {      if (!used[j] && arr[j] % arr[i] == 0) {       used[j] = true;      }     }     k++;    }   }   System.out.println(k);   }  class pair implements Comparable<pair> {   int a;   int b;   pair(int A, int B) {    this.a = A;    this.b = B;   }   public int compareTo(pair o) {    return a != o.a ? Double.compare(a, o.a) : b - o.b;   }  }  void shuffleArray(long[] ar) {   Random rnd = ThreadLocalRandom.current();   for (int i = ar.length - 1; i > 0; i--) {    int index = rnd.nextInt(i + 1);    long a = ar[index];    ar[index] = ar[i];    ar[i] = a;   }  }  void printArray(long[] ar) {   for (long k : ar) {    System.out.print(k + " ");   }   System.out.println();  }  void reverseArray(long[] ar) {   for (int i = 0, j = ar.length - 1; i < j; i++, j--) {    long a = ar[i];    ar[i] = ar[j];    ar[j] = a;   }  }  private void run() throws IOException {   if (systemIO) {    in = new solveLOL.FastScanner(System.in);    out = new PrintWriter(System.out);   } else {    in = new solveLOL.FastScanner(new File("input.txt"));    out = new PrintWriter(new File("output.txt"));   }   for (int t = multitests ? in.nextInt() : 1; t-- > 0; )    solve();   out.close();  }  class FastScanner {   BufferedReader br;   StringTokenizer st;   FastScanner(File f) {    try {     br = new BufferedReader(new FileReader(f));    } catch (FileNotFoundException e) {     e.printStackTrace();    }   }   FastScanner(InputStream f) {    br = new BufferedReader(new InputStreamReader(f));   }   String nextLine() {    try {     return br.readLine();    } catch (IOException e) {     return null;    }   }   String next() {    while (st == null || !st.hasMoreTokens()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }   int nextInt() {    return Integer.parseInt(next());   }   long nextLong() {    return Long.parseLong(next());   }   double nextDouble() {    return Double.parseDouble(next());   }  }  public static void main(String[] arg) throws IOException {   new solveLOL().run();  } }
4,public class LRS {    public static String lcp(String s, String t) {   int n = Math.min(s.length(), t.length());   for (int i = 0; i < n; i++) {    if (s.charAt(i) != t.charAt(i))     return s.substring(0, i);   }   return s.substring(0, n);  }    public static String lrs(String s) {      int N = s.length();   String[] suffixes = new String[N];   for (int i = 0; i < N; i++) {    suffixes[i] = s.substring(i, N);   }      Arrays.sort(suffixes);      String lrs = "";   for (int i = 0; i < N - 1; i++) {    String x = lcp(suffixes[i], suffixes[i+1]);    if (x.length() > lrs.length())     lrs = x;   }   return lrs;  }      public static void main(String[] args) throws IOException {   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));   String s = br.readLine();   s = s.replaceAll("\\s+", " ");   System.out.println(lrs(s).length());  } }
2,public class pr169D implements Runnable {  BufferedReader in; PrintWriter out; StringTokenizer str;  public void solve() throws IOException {  long l = nextLong();  long r = nextLong();  long x = l ^ r;  long i = 1;  while (x >= i)  i *= 2;  out.println(x > i ? x : i - 1); }  public String nextToken() throws IOException {  while (str == null || !str.hasMoreTokens()) {  str = new StringTokenizer(in.readLine());  }  return str.nextToken(); }  public int nextInt() throws IOException {  return Integer.parseInt(nextToken()); }  public double nextDouble() throws IOException {  return Double.parseDouble(nextToken()); }  public long nextLong() throws IOException {  return Long.parseLong(nextToken()); }  public void run() {  try {  in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);  solve();  in.close();  out.close();  } catch (IOException e) {  } }  public static void main(String[] args) {  new Thread(new pr169D()).start(); } }
6,public class Main { private void run() throws IOException {  int cx = in.nextInt();  int cy = in.nextInt();  int n = in.nextInt();  int[] x = new int[n];  int[] y = new int[n];  for (int i = 0; i < n; ++i) {  x[i] = in.nextInt() - cx;  y[i] = in.nextInt() - cy;  }  int[] dp = new int[1 << n];  Arrays.fill(dp, Integer.MAX_VALUE);  dp[0] = 0;  int[] prev = new int[1 << n];  for (int mask = 0; mask < (1 << n); ++mask) {  if (dp[mask] == Integer.MAX_VALUE) {   continue;  }  for (int i = 0; i < n; ++i) {   if (((mask >> i) & 1) == 0) {   if (dp[mask | (1 << i)] > dp[mask] + dist(x[i], y[i])) {    dp[mask | (1 << i)] = dp[mask] + dist(x[i], y[i]);    prev[mask | (1 << i)] = mask;   }   for (int j = i + 1; j < n; ++j) {    if (((mask >> j) & 1) == 0) {    if (dp[mask | (1 << i) | (1 << j)] > dp[mask] + dist(x[i], y[i], x[j], y[j])) {     dp[mask | (1 << i) | (1 << j)] = dp[mask] + dist(x[i], y[i], x[j], y[j]);     prev[mask | (1 << i) | (1 << j)] = mask;    }    }   }   break;   }  }  }  out.println(dp[(1 << n) - 1]);  int mask = (1 << n) - 1;  out.print(0);  while (mask != 0) {  int p = prev[mask];  int cur = p ^ mask;  List<Integer> who = new ArrayList<Integer>();  for (int i = 0; i < n; ++i) {   if (((cur >> i) & 1) != 0) {   who.add(i + 1);   }  }  for (int t : who) {   out.print(" " + t);  }  out.print(" " + 0);  mask = p;  }  out.flush(); }  private int dist(int x, int y, int x2, int y2) {  return x * x + y * y + x2 * x2 + y2 * y2 + (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y); }  private int dist(int x, int y) {  return 2 * (x * x + y * y); }  private class Scanner {  private StringTokenizer tokenizer;  private BufferedReader reader;  public Scanner(Reader in) {  reader = new BufferedReader(in);  tokenizer = new StringTokenizer("");  }  public double nextDouble() throws IOException {  return Double.parseDouble(next());  }  public boolean hasNext() throws IOException {  while (!tokenizer.hasMoreTokens()) {   String next = reader.readLine();   if (next == null)   return false;   tokenizer = new StringTokenizer(next);  }  return true;  }  public String next() throws IOException {  hasNext();  return tokenizer.nextToken();  }  public String nextLine() throws IOException {  tokenizer = new StringTokenizer("");  return reader.readLine();  }  public int nextInt() throws IOException {  return Integer.parseInt(next());  } }  public static void main(String[] args) throws IOException {  new Main().run(); } Scanner in = new Scanner(new InputStreamReader(System.in)); PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out))); }
4,public class GeorgeInterestingGraph {   int N = 505;  int INF = (int) 1e9;   List<Integer>[] G = new List[N];  int[] match = new int[N];  int[] used = new int[N];  int cur = 0;   {   for (int i = 0; i < N; i++) G[i] = new ArrayList<>(1);  }   void solve() {   int n = in.nextInt(), m = in.nextInt();   int[] fr = new int[m], to = new int[m];   for (int i = 0; i < m; i++) {    fr[i] = in.nextInt() - 1;    to[i] = in.nextInt() - 1;   }     int ans = INF;   for (int i = 0; i < n; i++) {    int cnt = 0;    for (int j = 0; j < n; j++) {     G[j].clear();     match[j] = -1;    }    for (int j = 0; j < m; j++) {     if (fr[j] == i || to[j] == i) {      cnt++;     } else {      G[fr[j]].add(to[j]);     }    }       int other = m - cnt;       int max = 0;    for (int j = 0; j < n; j++) {     cur++;     if (augment(j)) max++;    }       ans = Math.min(ans, 2 * (n - 1) + 1 - cnt + other - max + (n - 1) - max);   }   out.println(ans);  }   boolean augment(int u) {   if (used[u] == cur) return false;   used[u] = cur;   for (int v : G[u]) {    if (match[v] < 0 || augment(match[v])) {     match[v] = u;     return true;    }   }   return false;  }   public static void main(String[] args) {   in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));   out = new PrintWriter(System.out);   new GeorgeInterestingGraph().solve();   out.close();  }   static FastScanner in;  static PrintWriter out;   static class FastScanner {   BufferedReader in;   StringTokenizer st;     public FastScanner(BufferedReader in) {    this.in = in;   }     public String nextToken() {    while (st == null || !st.hasMoreTokens()) {     try {      st = new StringTokenizer(in.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }     public int nextInt() {    return Integer.parseInt(nextToken());   }     public long nextLong() {    return Long.parseLong(nextToken());   }     public double nextDouble() {    return Double.parseDouble(nextToken());   }  } }
4,public class Codechef {     public static void main (String[] args) throws IOException {   BufferedReader br=new BufferedReader(new InputStreamReader(System.in));   int t=Integer.parseInt(br.readLine());   PrintWriter p=new PrintWriter(System.out);   while(t-->0)   {       int n=Integer.parseInt(br.readLine());    String a[]=new String[n];    for(int i=0;i<n;i++)    {     a[i]=br.readLine();    }    String pre="1";    for(int i=1;i<n;i++)    {     if(a[i].equals("1"))     {      a[i]=pre+".1";      pre=a[i];      continue;     }     int li=pre.lastIndexOf('.');     while(li!=-1 && Integer.parseInt(pre.substring(li+1))+1!=Integer.parseInt(a[i]))     {      pre=pre.substring(0,li);      li=pre.lastIndexOf('.');     }         if(li!=-1)     a[i]=pre.substring(0,li+1)+a[i];     pre=a[i];    }    for(int i=0;i<n;i++)    {     p.println(a[i]);    }    p.flush();   } } }
1,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   FastReader in = new FastReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskB solver = new TaskB();   solver.solve(1, in, out);   out.close();  } } class TaskB {  int val[];  int p[];  int aneigh[], bneight[], deg[];  Deque<Integer> mycycle;  boolean loops = false;  public void solve(int testNumber, FastReader in, PrintWriter out)  {   int n = in.ni ();   val = new int[n];   int a = in.ni ();   int b = in.ni ();   Map<Integer, Integer> set = new TreeMap<Integer, Integer> ();   p = in.iArr (n);   for (int i = 0; i < n; i++)   {    set.put (p[i], i);   }   aneigh = new int[n];   bneight = new int[n];   deg = new int[n];   for (int i = 0; i < n; i++)   {    aneigh[i] = val[i] = bneight[i] = -1;    deg[i] = 0;   }   Queue<Integer> queue = new ArrayDeque<Integer> ();   for (int i = 0; i < n; i++)   {    Integer x1 = set.get (a - p[i]);    Integer x2 = set.get (b - p[i]);    if (x1 != null)    {     aneigh[i] = x1;     deg[i]++;    }    if (x2 != null && a != b)    {     bneight[i] = x2;     deg[i]++;    }    if (deg[i] == 1)    {     queue.add (i);    }   }   while (!queue.isEmpty ())   {    int idx = queue.remove ();    if (deg[idx] != 1)    {     continue;    }    int aa = aneigh[idx];    int bb = bneight[idx];    if (aa != -1)    {     val[idx] = val[aa] = 0;     deg[aa]--;     deg[idx]--;     aneigh[aa] = -1;     aneigh[idx] = -1;     if (deg[aa] == 1)     {      int zz = bneight[aa];      bneight[zz] = -1;      deg[zz]--;      if(deg[zz] == 1)      queue.add (zz);     }    }    else    {     val[idx] = val[bb] = 1;     deg[bb]--;     deg[idx]--;     bneight[idx] = bneight[bb] = -1;     if (deg[bb] == 1)     {           int zz = aneigh[bb];      aneigh[zz] = -1;      deg[zz]--;      if(deg[zz] == 1)       queue.add (zz);     }    }   }   for (int i = 0; i < n; i++)   {    if (val[i] == -1 && cantBePaired(i))    {     out.println ("NO");     return;    }   }         for (int i = 0; i < n; i++)   {    if (val[i] == -1)    {     mycycle = new ArrayDeque<Integer> ();     loops = false;     cycle (i);     if (loops || mycycle.size () % 2 == 0)     {      doEvenCycle ();      continue;     }     out.println ("NO");     return;    }   }   out.println ("YES");   for (int i = 0; i < n; i++)   {    out.print (val[i] + " ");   }   out.println ();  }  private boolean cantBePaired(int i)  {   int aa = aneigh[i];   int bb = bneight[i];   if (aa != -1 && val[aa] == -1)   {    return false;   }   if (bb != -1 && val[bb] == -1)   {    return false;   }   return true;  }   private void doEvenCycle()  {   for (int x : mycycle)   {    val[x] = 0;   }  }  private void cycle(int i)  {   boolean aa = false;   int prev = i;   mycycle.addLast (i);   System.out.println (i);   int j = aneigh[i];   while (j != i)   {    if (j == prev)    {     loops = true;     break;    }    mycycle.addLast (j);    System.out.println (j);    prev = j;    j = aa ? aneigh[j] : bneight[j];      aa = !aa;   }   if (loops)   {    j = bneight[i];    prev = i;    aa = true;    while (prev != j)    {     mycycle.addFirst (j);     prev = j;     j = aa ? aneigh[j] : bneight[j];     aa = !aa;    }   }   System.out.println ("XXX");  } } class FastReader {  public InputStream stream;  private byte[] buf = new byte[1024];  private int curChar;  private int numChars;  private SpaceCharFilter filter;  public FastReader(InputStream stream)  {   this.stream = stream;  }  public FastReader()  {  }  public int read()  {   if (numChars == -1)   {    throw new InputMismatchException ();   }   if (curChar >= numChars)   {    curChar = 0;    try    {     numChars = stream.read (buf);    } catch (IOException e)    {     throw new InputMismatchException ();    }    if (numChars <= 0)    {     return -1;    }   }   return buf[curChar++];  }  public int ni()  {   int c = read ();   while (isSpaceChar (c))    c = read ();   int sgn = 1;   if (c == '-')   {    sgn = -1;    c = read ();   }   int res = 0;   do   {    if (c < '0' || c > '9')    {     throw new InputMismatchException ();    }    res *= 10;    res += c - '0';    c = read ();   } while (!isSpaceChar (c));   return res * sgn;  }  public boolean isSpaceChar(int c)  {   if (filter != null)   {    return filter.isSpaceChar (c);   }   return isWhitespace (c);  }  public static boolean isWhitespace(int c)  {   return c==' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;  }  public int[] iArr(int n)  {   int a[] = new int[n];   for (int i = 0; i < n; i++)   {    a[i] = ni ();   }   return a;  }  public interface SpaceCharFilter  {   public boolean isSpaceChar(int ch);  } }
0,public class A { static BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in)); static StringTokenizer st = new StringTokenizer("");  static String readString() throws Exception {  while(!st.hasMoreTokens())  st = new StringTokenizer(stdin.readLine());  return st.nextToken(); }  static int readInt() throws Exception {  return Integer.parseInt(readString()); }  static long readLong() throws Exception {  return Long.parseLong(readString()); } public static void main(String[] args) throws Exception{  long a = readLong();  long b = readLong();   System.out.println(rec(a,b));  }  private static long rec(long a, long b) {  if(a == 1){  return b;  }  if(a >= b){  return a/b + rec(a%b, b);  }  return rec(b, a); } }
5,public class Train_A {  public static void main(String[] args) {   Scanner sc = new Scanner(System.in);   int n = sc.nextInt();   int a = sc.nextInt();   int b = sc.nextInt();   int [] h = new int[n];   for (int i = 0; i < n; i++) {    h[i] = sc.nextInt();   }   Arrays.sort(h);   System.out.println(h[n-a] - h[b-1]);  } }
3,public class codeforces implements Runnable {   final static long mod = (long)1e9 + 7;  public void run() {   InputReader s = new InputReader(System.in);  PrintWriter w = new PrintWriter(System.out);   int n = s.nextInt();   char[] c = new char[n];   for(int i = 0; i < n; i++)  c[i] = s.next().charAt(0);     long[][] dp = new long[n][n];  dp[0][0] = 1;   for(int i = 0; i < n - 1; i++) {      if(c[i] == 'f') {     for(int j = 1; j < n; j++)   dp[i + 1][j] = dp[i][j - 1];  }      else {     dp[i + 1][n - 1] = dp[i][n - 1];      for(int j = n - 2; j >= 0; j--)   dp[i + 1][j] = (dp[i + 1][j + 1] + dp[i][j]) % mod;  }  }   long res = 0;   for(int i = 0; i < n; i++)  res = (res + dp[n - 1][i]) % mod;   w.println(res);   w.close(); }   static class InputReader {  private InputStream stream;  private byte[] buf = new byte[1024];  private int curChar;  private int numChars;  private SpaceCharFilter filter;   public InputReader(InputStream stream)  {  this.stream = stream;  }   public int read()  {  if (numChars==-1)   throw new InputMismatchException();    if (curChar >= numChars)  {   curChar = 0;   try   {   numChars = stream.read(buf);   }   catch (IOException e)   {   throw new InputMismatchException();   }     if(numChars <= 0)     return -1;  }  return buf[curChar++];  }   public String nextLine()  {  BufferedReader br=new BufferedReader(new InputStreamReader(System.in));  String str = "";    try    {     str = br.readLine();    }    catch (IOException e)    {     e.printStackTrace();    }    return str;  }  public int nextInt()  {  int c = read();    while(isSpaceChar(c))   c = read();    int sgn = 1;    if (c == '-')   {   sgn = -1;   c = read();  }    int res = 0;  do   {   if(c<'0'||c>'9')    throw new InputMismatchException();   res *= 10;   res += c - '0';   c = read();  }  while (!isSpaceChar(c));     return res * sgn;  }   public long nextLong()  {  int c = read();  while (isSpaceChar(c))   c = read();  int sgn = 1;  if (c == '-')   {   sgn = -1;   c = read();  }  long res = 0;    do   {   if (c < '0' || c > '9')   throw new InputMismatchException();   res *= 10;   res += c - '0';   c = read();  }  while (!isSpaceChar(c));   return res * sgn;  }   public double nextDouble()  {  int c = read();  while (isSpaceChar(c))   c = read();  int sgn = 1;  if (c == '-')   {   sgn = -1;   c = read();  }  double res = 0;  while (!isSpaceChar(c) && c != '.')   {   if (c == 'e' || c == 'E')   return res * Math.pow(10, nextInt());   if (c < '0' || c > '9')   throw new InputMismatchException();   res *= 10;   res += c - '0';   c = read();  }  if (c == '.')   {   c = read();   double m = 1;   while (!isSpaceChar(c))   {   if (c == 'e' || c == 'E')    return res * Math.pow(10, nextInt());   if (c < '0' || c > '9')    throw new InputMismatchException();   m /= 10;   res += (c - '0') * m;   c = read();   }  }  return res * sgn;  }   public String readString()  {  int c = read();  while (isSpaceChar(c))   c = read();  StringBuilder res = new StringBuilder();  do   {   res.appendCodePoint(c);   c = read();  }   while (!isSpaceChar(c));    return res.toString();  }   public boolean isSpaceChar(int c)  {  if (filter != null)   return filter.isSpaceChar(c);  return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;  }   public String next()  {  return readString();  }   public interface SpaceCharFilter  {  public boolean isSpaceChar(int ch);  } }   public static void main(String args[]) throws Exception {  new Thread(null, new codeforces(),"codeforces",1<<26).start(); }   }
4,public class uo{ public static void main(String[] args) throws IOException{  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer(br.readLine());  int testcases = Integer.parseInt(st.nextToken());  for(int lmn=0;lmn<testcases;lmn++){  st = new StringTokenizer(br.readLine());  int n = Integer.parseInt(st.nextToken());      ArrayList<Integer> a = new ArrayList<>();  for(int lmn1 = 0;lmn1<n;lmn1++){   st = new StringTokenizer(br.readLine());   int a1 = Integer.parseInt(st.nextToken());   if(a.size()>0 && (a1==1)){      }   else if(a.size()>0){   if(a.size()==1){    a.remove(0);   }   else{    int i = a.size()-1;    while(a.size()>0 && i>=0 && a.get(i)+1 != a1){    a.remove(i);    i--;    }    a.remove(a.size()-1);       }   }          if(a.size()==0){   a.add(a1);   }   else{   a.add(a1);   }   if(a.size()==1){   System.out.println(a.get(0));   }   else{   for(int i=0;i<a.size()-1;i++){       System.out.print(a.get(i)+".");   }   System.out.println(a.get(a.size()-1));   }     }  }   } }
3,public class Main {  private static void solve(InputReader in, OutputWriter out) {   int n = in.nextInt();   int m = in.nextInt();   String[] sa = new String[n];   for (int i = 0; i < n; i++) {    sa[i] = in.next();   }   Set<Integer> switches = new HashSet<>();   for (int i = 0; i < m; i++) {    int cnt = 0, swtch = -1;    for (int j = 0; j < n; j++) {     if (sa[j].charAt(i) == '1') {      cnt++;      swtch = j;      if (cnt > 1)       break;     }    }    if (cnt == 1) {     switches.add(swtch);    }   }   out.print(switches.size() == n ? "NO" : "YES");  }  private static void shuffleArray(int[] array) {   int index;   Random random = new Random();   for (int i = array.length - 1; i > 0; i--) {    index = random.nextInt(i + 1);    if (index != i) {     array[index] ^= array[i];     array[i] ^= array[index];     array[index] ^= array[i];    }   }  }  public static void main(String[] args) {   InputReader in = new InputReader(System.in);   OutputWriter out = new OutputWriter(System.out);   solve(in, out);   in.close();   out.close();  }  private static class InputReader {   private BufferedReader br;   private StringTokenizer st;   InputReader(InputStream is) {    br = new BufferedReader(new InputStreamReader(is));    st = null;   }   String nextLine() {    String line = null;    try {     line = br.readLine();    } catch (IOException e) {     e.printStackTrace();    }    return line;   }   String next() {    while (st == null || !st.hasMoreTokens()) {     String line = nextLine();     if (line == null) return null;     st = new StringTokenizer(line);    }    return st.nextToken();   }   int nextInt() {    return Integer.parseInt(next());   }   long nextLong() {    return Long.parseLong(next());   }   double nextDouble() {    return Double.parseDouble(next());   }   void close() {    try {     br.close();    } catch (IOException e) {     e.printStackTrace();    }   }  }  private static class OutputWriter {   BufferedWriter bw;   OutputWriter(OutputStream os) {    bw = new BufferedWriter(new OutputStreamWriter(os));   }   void print(int i) {    print(Integer.toString(i));   }   void println(int i) {    println(Integer.toString(i));   }   void print(long l) {    print(Long.toString(l));   }   void println(long l) {    println(Long.toString(l));   }   void print(double d) {    print(Double.toString(d));   }   void println(double d) {    println(Double.toString(d));   }   void print(boolean b) {    print(Boolean.toString(b));   }   void println(boolean b) {    println(Boolean.toString(b));   }   void print(char c) {    try {     bw.write(c);    } catch (IOException e) {     e.printStackTrace();    }   }   void println(char c) {    println(Character.toString(c));   }   void print(String s) {    try {     bw.write(s);    } catch (IOException e) {     e.printStackTrace();    }   }   void println(String s) {    print(s);    print('\n');   }   void close() {    try {     bw.close();    } catch (IOException e) {     e.printStackTrace();    }   }  } }
3,public class A {  public static void main(String[] args) {  FastReader scan = new FastReader();  PrintWriter out = new PrintWriter(System.out);  Task solver = new Task();  int t = 1;  while(t-->0) solver.solve(1, scan, out);  out.close(); }  static class Task {   public void solve(int testNumber, FastReader scan, PrintWriter out) {  int n = scan.nextInt();  int[] a = new int[n];  boolean[] b = new boolean[n];  int count = 0;  for(int i = 0; i < n; i++) a[i] = scan.nextInt();  Arrays.sort(a);  for(int i = 0; i < n; i++) {   if(b[i]) continue;   count++;   for(int j = i; j < n; j++) {   if(a[j]%a[i] == 0) b[j] = true;   }  }  out.println(count);  } }  static void shuffle(int[] a) {  Random get = new Random();  for(int i = 0; i < a.length; i++) {  int r = get.nextInt(a.length);  int temp = a[i];  a[i] = a[r];  a[r] = temp;  } }  static void shuffle(long[] a) {  Random get = new Random();  for(int i = 0; i < a.length; i++) {  int r = get.nextInt(a.length);  long temp = a[i];  a[i] = a[r];  a[r] = temp;  } }   static class FastReader {  BufferedReader br;  StringTokenizer st;   public FastReader() {  br = new BufferedReader(new InputStreamReader(System.in));  }  public FastReader(String s) throws FileNotFoundException {  br = new BufferedReader(new FileReader(new File(s)));  }   String next() {  while (st == null || !st.hasMoreElements()) {   try {   st = new StringTokenizer(br.readLine());   } catch (IOException e) {   e.printStackTrace();   }  }  return st.nextToken();  }   int nextInt() {  return Integer.parseInt(next());  }   long nextLong() {  return Long.parseLong(next());  }   double nextDouble() {  return Double.parseDouble(next());  }   String nextLine() {  String str = "";  try {   str = br.readLine();  } catch (IOException e) {   e.printStackTrace();  }  return str;  } }  }
0,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  Scanner in = new Scanner(inputStream);  PrintWriter out = new PrintWriter(outputStream);  TaskA solver = new TaskA();  solver.solve(1, in, out);  out.close(); } } class TaskA {  public void solve(int testNumber, Scanner in, PrintWriter out) {   String n = in.nextLine();   int a = Integer.parseInt(n);   int b = Integer.parseInt(n.substring(0, n.length() - 1));   int c = Integer.parseInt(n.substring(0, n.length() - 2) + n.charAt(n.length() - 1));   out.println(Math.max(a, Math.max(b, c)));  } }
5,public class A implements Runnable { static BufferedReader in; static PrintWriter out; static StringTokenizer st; static Random rnd;  void solve() throws IOException {  int n = nextInt();  long k = nextLong();  if (k == 1) {  out.println(n);  } else {   TreeMap<Long, ArrayList<Integer>> numbers = new TreeMap<Long, ArrayList<Integer>>();   for (int i = 0; i < n; i++) {   long m = nextLong();   int howMuch = 0;   while (m % k == 0) {   m /= k;   ++howMuch;   }   if (!numbers.containsKey(m)) {   numbers.put(m, new ArrayList<Integer>());   }   numbers.get(m).add(howMuch);  }   int res = 0;   for (ArrayList<Integer> oneGroup : numbers.values()) {   res += parseOneGroup(oneGroup);  }   out.println(res);  } }  private int parseOneGroup(ArrayList<Integer> oneGroup) {  Collections.sort(oneGroup);  int res = 0, prevValue = Integer.MIN_VALUE;  for (int i = 0; i < oneGroup.size(); i++) {  int curValue = oneGroup.get(i);   if (prevValue + 1 != curValue) {   ++res;   prevValue = curValue;  }  }  return res; }  public static void main(String[] args) {  new A().run(); }  public void run() {  try {  in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);   rnd = new Random();   solve();   out.close();  } catch (IOException e) {  e.printStackTrace();  System.exit(42);  } }  String nextToken() throws IOException {  while (st == null || !st.hasMoreTokens()) {  String line = in.readLine();   if (line == null)   return null;   st = new StringTokenizer(line);  }  return st.nextToken(); }  int nextInt() throws IOException {  return Integer.parseInt(nextToken()); }  long nextLong() throws IOException {  return Long.parseLong(nextToken()); }  double nextDouble() throws IOException {  return Double.parseDouble(nextToken()); } }
2,public class CodeforcesC {  public static void main(String[] args) {  Scanner ob = new Scanner(System.in);  long n = ob.nextLong();  long s = ob.nextLong();  long l = 1;  long r = n;  while(l<=r){  long mid = (l + r)/2;  if(reallybignumber(mid,s)){   r = mid-1;  }else{   l = mid +1;  }  }   System.out.println(n-l+1);  }  private static boolean reallybignumber(long n,long s) {  long m = n;  long sum=0;  int d=1;  while(m>0){  long rem = m % 10;  sum = rem * d + sum;  m = m / 10;  }  if(n-sum >= s) return true;  else return false; } }
4,public class Main {  static BufferedReader reader;  static StringTokenizer st;  private static void setReader() {   reader = new BufferedReader(new InputStreamReader(System.in));  }  private static void updateST() throws IOException {   if (st==null || !st.hasMoreElements()) st = new StringTokenizer(reader.readLine());  }  private static int nextInt() throws IOException {   updateST();   return Integer.parseInt(st.nextToken());  }  public static void main(String[] args) throws IOException {   setReader();   int n = nextInt(), MOD = nextInt();   long[] pow = new long[n+2];   pow[0] = 1;   for (int i=1; i<=n+1; i++) pow[i] = (pow[i-1] * 2) % MOD;   long[][] C = new long[n+2][n+2];   for (int i=0; i<=n+1; i++) {    C[i][0] = 1;    for (int j=1; j<=i; j++) {     C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;    }   }   long[][] dp = new long[n+2][n+1];   dp[0][0] = 1;   for (int i=0; i<=n; i++) {    for (int j=0; j<=i; j++) {     for (int k=1; i + k + 1 <= n + 1; k++) {      dp[i + k + 1][j + k]+=(((dp[i][j] * C[j + k][k]) % MOD * pow[k-1]) % MOD);      dp[i + k + 1][j + k]%=MOD;     }    }   }   long res = 0;   for (int i=0; i<=n; i++) res = (res + dp[n+1][i]) % MOD;   System.out.println(res);  } }
3,public class lets_do {  FastReader in;  PrintWriter out;  Helper_class h;  final long mod = 1000000009;  final int MAXN = 1000005;  final int lgN = 20;  final long INF = (long)1e18;  final long MAX_Ai = (long)1e12;  public static void main(String[] args) throws java.lang.Exception{   new lets_do().run();  }  void run() throws Exception{   in=new FastReader(System.in);   out = new PrintWriter(System.out);   h = new Helper_class();   int t = 1;   while(t--> 0)    solve();   out.flush();   out.close();  }  void solve(){   int n = h.ni();   long[] arr = new long[n];   int i = 0, j = 0;   for(i = 0; i < n; i++)    arr[i] = h.nl();   HashMap<Long, Integer> hmap = new HashMap<Long, Integer>();   int cnt = 0;   for(i = 0; i < n; i++){    long sum = 0;    for(j = i; j < n; j++){     sum += arr[j];     Integer x = hmap.get(sum);     if(x == null)      hmap.put(sum, cnt++);    }   }   TreeSet<Pair>[] tset = new TreeSet[cnt];   for(i = 0; i < cnt; i++)    tset[i] = new TreeSet<Pair>(com);   for(i = 0; i < n; i++){    long sum = 0;    for(j = i; j < n; j++){     sum += arr[j];     tset[hmap.get(sum)].add(new Pair(i, j));    }   }   int max = 0;   int ind = -1;   int max_x = 0, max_y = 0;   for(i = 0; i < cnt; i++){   int curr_y = tset[i].first().y;   int cnt1 = 1;    for(Pair yo : tset[i]){     if(yo.x > curr_y) {     cnt1++;     curr_y = yo.y;     }    }    if(max < cnt1) {    max = cnt1;    ind = i;    }   }   h.pn(max);   Pair hola_yee = new Pair(tset[ind].first().x, tset[ind].first().y);   h.pn((tset[ind].first().x + 1) +" "+(tset[ind].first().y + 1));   int curr_y = tset[ind].first().y;   for(Pair yo : tset[ind]){    if(yo.x > curr_y) {    curr_y = yo.y;    h.pn((yo.x + 1) +" "+(yo.y + 1));    }   }  }   static final Comparator<Pair> com=new Comparator<Pair>(){   public int compare(Pair a, Pair b){    if(Integer.compare(a.y, b.y) != 0)     return Integer.compare(a.y, b.y);    else     return Integer.compare(a.x, b.x);   }  };  class Pair{   int x;   int y;   Pair(int p, int q){    x = p;    y = q;   }  }  class Edge{   int u , v;   long wt;   Edge(int a, int b, long w){    u = a;    v = b;    wt = w;   }   int other(int x) {    return u ^ v ^ x;   }  }   class Helper_class{   long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}   int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}   int bitcount(long n){return (n==0)?0:(1+bitcount(n&(n-1)));}   void p(Object o){out.print(o);}   void pn(Object o){out.println(o);}   void pni(Object o){out.println(o);out.flush();}   String n(){return in.next();}   String nln(){return in.nextLine();}   int ni(){return Integer.parseInt(in.next());}   long nl(){return Long.parseLong(in.next());}   double nd(){return Double.parseDouble(in.next());}   long mul(long a,long b){    if(a>=mod)a%=mod;    if(b>=mod)b%=mod;    a*=b;    if(a>=mod)a%=mod;    return a;   }   long modPow(long a, long p){    long o = 1;    while(p>0){     if((p&1)==1)o = mul(o,a);     a = mul(a,a);     p>>=1;    }    return o;   }   long add(long a, long b){    if(a>=mod)a%=mod;    if(b>=mod)b%=mod;    if(b<0)b+=mod;    a+=b;    if(a>=mod)a-=mod;    return a;   }  }  class FastReader{   private InputStream stream;   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   public FastReader(InputStream stream) {    this.stream = stream;   }   public int read() {    if (numChars == -1)     throw new UnknownError();    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (IOException e) {      throw new UnknownError();     }     if (numChars <= 0)      return -1;    }    return buf[curChar++];   }   public int peek() {    if (numChars == -1)     return -1;    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (IOException e) {      return -1;     }     if (numChars <= 0)      return -1;    }    return buf[curChar];   }   public void skip(int x) {    while (x-- > 0)     read();   }   public int nextInt() {    return Integer.parseInt(next());   }   public long nextLong() {    return Long.parseLong(next());   }   public String nextString() {    return next();   }   public String next() {    int c = read();    while (isSpaceChar(c))     c = read();    StringBuffer res = new StringBuffer();    do {     res.appendCodePoint(c);     c = read();    } while (!isSpaceChar(c));    return res.toString();   }   public String nextLine() {    StringBuffer buf = new StringBuffer();    int c = read();    while (c != '\n' && c != -1) {     if (c != '\r')      buf.appendCodePoint(c);     c = read();    }    return buf.toString();   }   public double nextDouble() {    int c = read();    while (isSpaceChar(c))     c = read();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    double res = 0;    while (!isSpaceChar(c) && c != '.') {     if (c == 'e' || c == 'E')      return res * Math.pow(10, nextInt());     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    }    if (c == '.') {     c = read();     double m = 1;     while (!isSpaceChar(c)) {      if (c == 'e' || c == 'E')       return res * Math.pow(10, nextInt());      if (c < '0' || c > '9')       throw new InputMismatchException();      m /= 10;      res += (c - '0') * m;      c = read();     }    }    return res * sgn;   }   public boolean hasNext() {    int value;    while (isSpaceChar(value = peek()) && value != -1)     read();    return value != -1;   }   private boolean isSpaceChar(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }  } }
3,public class _908C { public void solve() throws FileNotFoundException {  InputStream inputStream = System.in;  InputHelper in = new InputHelper(inputStream);    int n = in.readInteger();  double r = in.readInteger();  double[] x = new double[n];  for (int i = 0; i < n; i++) {  x[i] = in.readInteger();  }  double[] ans = new double[n];  ans[0] = r;  for (int i = 1; i < n; i++) {  double cans = r;  for (int j = 0; j < i; j++) {   double dis = Math.abs(x[j] - x[i]);   if (dis <= 2 * r) {    if (dis == 2 * r) {    cans = Math.max(cans, ans[j]);    continue;   } else if (x[i] == x[j]) {    cans = Math.max(cans, ans[j] + 2 * r);    continue;   }   cans = Math.max(cans, ans[j] + Math.sqrt((4 * (r * r)) - dis * dis));   }  }   ans[i] = cans;  }  for (int i = 0; i < n; i++) {  System.out.print(ans[i] + " ");  }   }  public static void main(String[] args) throws FileNotFoundException {  (new _908C()).solve(); }  class InputHelper {  StringTokenizer tokenizer = null;  private BufferedReader bufferedReader;  public InputHelper(InputStream inputStream) {  InputStreamReader inputStreamReader = new InputStreamReader(inputStream);  bufferedReader = new BufferedReader(inputStreamReader, 16384);  }  public String read() {  while (tokenizer == null || !tokenizer.hasMoreTokens()) {   try {   String line = bufferedReader.readLine();   if (line == null) {    return null;   }   tokenizer = new StringTokenizer(line);   } catch (IOException e) {   e.printStackTrace();   }  }   return tokenizer.nextToken();  }  public Integer readInteger() {  return Integer.parseInt(read());  }  public Long readLong() {  return Long.parseLong(read());  } } }
5,public class Testt {  final boolean ONLINE_JUDGE = System.getProperty("ONLINE_JUDGE") != null;  BufferedReader in;  PrintWriter out;  StringTokenizer tok = new StringTokenizer("");  void init() throws FileNotFoundException {   if (ONLINE_JUDGE) {    in = new BufferedReader(new InputStreamReader(System.in));    out = new PrintWriter(System.out);   } else {    in = new BufferedReader(new FileReader("input.txt"));    out = new PrintWriter("output.txt");   }  }  String readString() throws IOException {   while (!tok.hasMoreTokens()) {    tok = new StringTokenizer(in.readLine());   }   return tok.nextToken();  }  int readInt() throws IOException {   return Integer.parseInt(readString());  }  long readLong() throws IOException {   return Long.parseLong(readString());  }  double readDouble() throws IOException {   return Double.parseDouble(readString());  }  public static void main(String[] args) {   new Testt().run();  }  public static void mergeSort(int[] a) {   mergeSort(a, 0, a.length - 1);  }  private static void mergeSort(int[] a, int leftIndex, int rightIndex) {   final int MAGIC_VALUE = 50;   if (leftIndex < rightIndex) {    if (rightIndex - leftIndex <= MAGIC_VALUE) {     insertionSort(a, leftIndex, rightIndex);    } else {     int middleIndex = (leftIndex + rightIndex) / 2;     mergeSort(a, leftIndex, middleIndex);     mergeSort(a, middleIndex + 1, rightIndex);     merge(a, leftIndex, middleIndex, rightIndex);    }   }  }  private static void merge(int[] a, int leftIndex, int middleIndex,    int rightIndex) {   int length1 = middleIndex - leftIndex + 1;   int length2 = rightIndex - middleIndex;   int[] leftArray = new int[length1];   int[] rightArray = new int[length2];   System.arraycopy(a, leftIndex, leftArray, 0, length1);   System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);   for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {    if (i == length1) {     a[k] = rightArray[j++];    } else if (j == length2) {     a[k] = leftArray[i++];    } else {     a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++]       : rightArray[j++];    }   }  }  private static void insertionSort(int[] a, int leftIndex, int rightIndex) {   for (int i = leftIndex + 1; i <= rightIndex; i++) {    int current = a[i];    int j = i - 1;    while (j >= leftIndex && a[j] > current) {     a[j + 1] = a[j];     j--;    }    a[j + 1] = current;   }  }  public void run() {   try {    long t1 = System.currentTimeMillis();    init();    solve();    out.close();    long t2 = System.currentTimeMillis();    System.err.println("Time = " + (t2 - t1));   } catch (Exception e) {    e.printStackTrace(System.err);    System.exit(-1);   }  }   public void solve() throws IOException {     int n = readInt();   int [] a = new int [n];   for (int i = 0; i < n; i++){    a[i] = readInt();   }   mergeSort(a);     int sum = 0;   for (int i = 0; i <n; i++){    sum+=a[i];   }   int sum2 = 0;   int ans = 0;   for (int i = n-1; i >=0; i-- ){    sum2+=a[i];    sum-=a[i];    ans++;    if (sum2>sum){     break;    }   }     out.print(ans);  } }
3,public class Solution {  public static void main(String[] args) {   FastReader in = new FastReader();   int n = in.nextInt();   int[] a = new int[101];   for (int i = 0; i < n; i++) {    a[in.nextInt()]++;   }   int count = 0;   for (int i = 1; i < 101; i++) {    if (a[i] > 0) {     count++;     for (int j = i; j < 101; j += i) {      a[j] = 0;     }    }   }   System.out.println(count);  }  static class FastReader {   BufferedReader br;   StringTokenizer st;   public FastReader() {    br = new BufferedReader(new      InputStreamReader(System.in));   }   public int[] nextIntArray(int n) {    int[] array = new int[n];    for (int i = 0; i < n; ++i) array[i] = nextInt();    return array;   }   public int[] nextSortedIntArray(int n) {    int array[] = nextIntArray(n);    Arrays.sort(array);    return array;   }   public int[] nextSumIntArray(int n) {    int[] array = new int[n];    array[0] = nextInt();    for (int i = 1; i < n; ++i) array[i] = array[i - 1] + nextInt();    return array;   }   public long[] nextLongArray(int n) {    long[] array = new long[n];    for (int i = 0; i < n; ++i) array[i] = nextLong();    return array;   }   public long[] nextSumLongArray(int n) {    long[] array = new long[n];    array[0] = nextInt();    for (int i = 1; i < n; ++i) array[i] = array[i - 1] + nextInt();    return array;   }   public long[] nextSortedLongArray(int n) {    long array[] = nextLongArray(n);    Arrays.sort(array);    return array;   }   String next() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }   int nextInt() {    return Integer.parseInt(next());   }   long nextLong() {    return Long.parseLong(next());   }   double nextDouble() {    return Double.parseDouble(next());   }   String nextLine() {    String str = "";    try {     str = br.readLine();    } catch (IOException e) {     e.printStackTrace();    }    return str;   }  } }
6,public class E4 { InputStream is; PrintWriter out; String INPUT = "";   void solve() {  for(int T = ni(); T> 0;T--){  int n = ni(), m = ni();  int[][] a = new int[n][];  for(int i = 0;i < n;i++)a[i] = na(m);    int[][] mx = new int[m][];  for(int i = 0;i < m;i++){   int u = 0;   for(int j = 0;j < n;j++){   u = Math.max(u, a[j][i]);   }   mx[i] = new int[]{u, i};  }  Arrays.sort(mx, new Comparator<int[]>() {   public int compare(int[] a, int[] b) {   return -(a[0] - b[0]);   }  });  int[] dp = new int[1<<n];  for(int i = 0;i < n && i < m;i++){   int c = mx[i][1];   int[] ls = new int[1<<n];   for(int j = 1;j < 1<<n;j++){   ls[j] = ls[j&j-1] + a[Integer.numberOfTrailingZeros(j)][c];   }   for(int j = 1;j < 1<<n;j++){   int r = rot(j, n);   ls[r] = Math.max(ls[r], ls[j]);   }   int[] ndp = new int[1<<n];   for(int j = 0;j < 1<<n;j++){   if(rot(j, n) == j){    int cur = j;    for(int sh = 0;sh < n;sh++){    cur = cur>>1|(cur&1)<<n-1;    int mask = (1<<n)-1^cur;    for(int k = mask;k >= 0;k--){     k &= mask;         ndp[k|cur] = Math.max(      ndp[k|cur], dp[k] + ls[j]);    }    }   }   }   dp = ndp;  }  out.println(dp[(1<<n)-1]);  } }  int rot(int x, int n) {  int ret = x;  for(int i = 0;i < n;i++){  x = x>>>1|(x&1)<<n-1;   ret = Math.min(ret, x);  }  return ret; }  void run() throws Exception {          is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());  out = new PrintWriter(System.out);   long s = System.currentTimeMillis();  solve();  out.flush();  tr(System.currentTimeMillis()-s+"ms"); }  public static void main(String[] args) throws Exception { new E4().run(); }  private byte[] inbuf = new byte[1024]; public int lenbuf = 0, ptrbuf = 0;  private int readByte() {  if(lenbuf == -1)throw new InputMismatchException();  if(ptrbuf >= lenbuf){  ptrbuf = 0;  try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }  if(lenbuf <= 0)return -1;  }  return inbuf[ptrbuf++]; }  private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }  private double nd() { return Double.parseDouble(ns()); } private char nc() { return (char)skip(); }  private String ns() {  int b = skip();  StringBuilder sb = new StringBuilder();  while(!(isSpaceChar(b))){   sb.appendCodePoint(b);  b = readByte();  }  return sb.toString(); }  private char[] ns(int n) {  char[] buf = new char[n];  int b = skip(), p = 0;  while(p < n && !(isSpaceChar(b))){  buf[p++] = (char)b;  b = readByte();  }  return n == p ? buf : Arrays.copyOf(buf, p); }  private char[][] nm(int n, int m) {  char[][] map = new char[n][];  for(int i = 0;i < n;i++)map[i] = ns(m);  return map; }  private int[] na(int n) {  int[] a = new int[n];  for(int i = 0;i < n;i++)a[i] = ni();  return a; }  private int ni() {  int num = 0, b;  boolean minus = false;  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));  if(b == '-'){  minus = true;  b = readByte();  }   while(true){  if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');  }else{   return minus ? -num : num;  }  b = readByte();  } }  private long nl() {  long num = 0;  int b;  boolean minus = false;  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));  if(b == '-'){  minus = true;  b = readByte();  }   while(true){  if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');  }else{   return minus ? -num : num;  }  b = readByte();  } }  private boolean oj = System.getProperty("ONLINE_JUDGE") != null; private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); } }
3,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskA solver = new TaskA();   solver.solve(1, in, out);   out.close();  }  static class TaskA {   public void solve(int testNumber, InputReader in, PrintWriter out) {    int n = in.nextInt();    int[] ar = new int[n];    for (int i = 0; i < n; i++)     ar[i] = in.nextInt();    Arrays.sort(ar);    boolean[] u = new boolean[n];    int ans = 0;    for (int i = 0; i < n; i++) {     if (!u[i]) {      u[i] = true;      ans++;      for (int j = 0; j < n; j++) {       if (!u[j] && ar[j] % ar[i] == 0) {        u[j] = true;       }      }     }    }    out.println(ans);   }  }  static class InputReader {   public BufferedReader reader;   public StringTokenizer tokenizer;   public InputReader(InputStream stream) {    reader = new BufferedReader(new InputStreamReader(stream), 32768);    tokenizer = null;   }   public String next() {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      tokenizer = new StringTokenizer(reader.readLine());     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return tokenizer.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }  } }
6,public class CF1185G2 { static final int MD = 1000000007; static int[][] solve1(int[] aa, int t, int n) {  int[][] da = new int[t + 1][n + 1];  da[0][0] = 1;  for (int i = 0; i < n; i++) {  int a = aa[i];  for (int s = t - 1; s >= 0; s--)   for (int m = 0; m < n; m++) {   int x = da[s][m];   if (x != 0) {    int s_ = s + a;    if (s_ <= t)    da[s_][m + 1] = (da[s_][m + 1] + x) % MD;   }   }  }  return da; } static int[][][] solve2(int[] aa, int[] bb, int t, int na, int nb) {  int[][] da = solve1(aa, t, na);  int[][][] dab = new int[t + 1][na + 1][nb + 1];  for (int s = 0; s <= t; s++)  for (int ma = 0; ma <= na; ma++)   dab[s][ma][0] = da[s][ma];  for (int i = 0; i < nb; i++) {  int b = bb[i];  for (int s = t - 1; s >= 0; s--)   for (int ma = 0; ma <= na; ma++)   for (int mb = 0; mb < nb; mb++) {    int x = dab[s][ma][mb];    if (x != 0) {    int s_ = s + b;    if (s_ <= t)     dab[s_][ma][mb + 1] = (dab[s_][ma][mb + 1] + x) % MD;    }   }  }  return dab; } static int[][][] init(int n, int na, int nb, int nc) {  int[][][] dp = new int[na + 1][nb + 1][nc + 1];  int[][][][] dq = new int[na + 1][nb + 1][nc + 1][3];  for (int ma = 0; ma <= na; ma++)  for (int mb = 0; mb <= nb; mb++)   for (int mc = 0; mc <= nc; mc++)   if (ma == 0 && mb == 0 && mc == 0) {    dp[ma][mb][mc] = 1;    dq[ma][mb][mc][0] = dq[ma][mb][mc][1] = dq[ma][mb][mc][2] = 1;   } else {    int x0 = ma > 0 ? (int) ((long) dq[ma - 1][mb][mc][0] * ma % MD) : 0;    int x1 = mb > 0 ? (int) ((long) dq[ma][mb - 1][mc][1] * mb % MD) : 0;    int x2 = mc > 0 ? (int) ((long) dq[ma][mb][mc - 1][2] * mc % MD) : 0;    dp[ma][mb][mc] = (int) (((long) x0 + x1 + x2) % MD);    dq[ma][mb][mc][0] = (x1 + x2) % MD;    dq[ma][mb][mc][1] = (x2 + x0) % MD;    dq[ma][mb][mc][2] = (x0 + x1) % MD;   }  return dp; } public static void main(String[] args) throws IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer(br.readLine());  int n = Integer.parseInt(st.nextToken());  int t = Integer.parseInt(st.nextToken());  int[] aa = new int[n];  int[] bb = new int[n];  int[] cc = new int[n];  int na = 0, nb = 0, nc = 0;  for (int i = 0; i < n; i++) {  st = new StringTokenizer(br.readLine());  int a = Integer.parseInt(st.nextToken());  int g = Integer.parseInt(st.nextToken());  if (g == 1)   aa[na++] = a;  else if (g == 2)   bb[nb++] = a;  else   cc[nc++] = a;  }  int[][][] dp = init(n, na, nb, nc);  int[][][] dab = solve2(aa, bb, t, na, nb);  int[][] dc = solve1(cc, t, nc);  int ans = 0;  for (int tab = 0; tab <= t; tab++) {  int tc = t - tab;  for (int ma = 0; ma <= na; ma++)   for (int mb = 0; mb <= nb; mb++) {   int xab = dab[tab][ma][mb];   if (xab == 0)    continue;   for (int mc = 0; mc <= nc; mc++) {    int xc = dc[tc][mc];    if (xc == 0)    continue;    ans = (int) ((ans + (long) xab * xc % MD * dp[ma][mb][mc]) % MD);   }   }  }  System.out.println(ans); } }
2,public class Main {  public static void main(String[] args) {   FastScanner in = new FastScanner();   long []a = new long[16];   a[0] = 0;   for(int i=1; i<16; ++i)    a[i] = a[i-1]+((9*(long)Math.pow(10, i-1))*i);   long N = in.nextLong();   int pos = 0;   for(int i=0; i<16; ++i){    if(N<=a[i]){     pos = i;     break;    }   }   if(pos==1){    System.out.println(N);    System.exit(0);   }   long prev = a[pos-1];   long curr = N;   long rem = curr - prev;   long ans = 0;   for(int i=1; i<pos; ++i){    ans = ans*10 + 9;   }   long g = (rem+(pos-1))/pos;   long take = (rem+(pos-1))%pos;   long number = ans + g;   String str = Long.toString(number);   System.out.println(str.charAt((int)take));  }  static void sort(int[] a) {   ArrayList<Integer> l=new ArrayList<>();   for (int i:a) l.add(i);   Collections.sort(l);   for (int i=0; i<a.length; i++) a[i]=l.get(i);  }  static class FastScanner {   BufferedReader br=new BufferedReader(new InputStreamReader(System.in));   StringTokenizer st=new StringTokenizer("");   String next() {    while (!st.hasMoreTokens())     try {      st=new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    return st.nextToken();   }   int nextInt() {    return Integer.parseInt(next());   }   int[] readArray(int n) {    int[] a=new int[n];    for (int i=0; i<n; i++) a[i]=nextInt();    return a;   }   long nextLong() {    return Long.parseLong(next());   }   double nextDouble() {    return Double.parseDouble(next());   }  } }
6,public class Main {  private static int[] x = new int[26], y = new int[26], dp = new int[1<<24], pre = new int[1<<24];  private static int dis(int i, int j) {   return (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);  }  public static void main(String[] args) {   Scanner in = new Scanner(System.in);   int x0 = in.nextInt(), y0 = in.nextInt(), n = in.nextInt();   for (int i = 0; i < n; i++) {    x[i] = in.nextInt();    y[i] = in.nextInt();   }   x[n] = x0;   y[n] = y0;   int[][] gra = new int[26][26];   for (int i = 0; i < n + 1; i++) {    for (int j = i+1; j < n+1; j++) {     gra[i][j] = gra[j][i] = dis(i,j);    }   }   Arrays.fill(dp, -1);   dp[0] = 0;   for (int i = 0; i < 1 << n; i++) {    if (dp[i] != -1) {     for (int j = 0; j < n; j++) {      if (((1<<j)&i) == 0) {       int t = i | (1<<j), tmp = dp[i] + 2*gra[j][n];       if (dp[t] == -1 || dp[t] > tmp) {        dp[t] = tmp;        pre[t] = i;       }       for (int k = 0; k < n; k++) {        if ((t&(1<<k)) == 0) {         int t2 = t | (1<<k), tmp2 = dp[i] + gra[n][j] + gra[j][k] + gra[k][n];         if (dp[t2] == -1 || dp[t2] > tmp2) {          dp[t2] = tmp2;          pre[t2] = i;         }        }       }       break;      }     }    }   }   int end = (1<<n)-1, cnt = 0;   int[] ans = new int[60];   System.out.println(dp[end]);   while (end != 0) {    int pr = pre[end];    int tem = pr^end;    int a = 0, b = 0;    for (int i = 0; i < n; i++) {     if (((1<<i)&tem)!=0) {      b=a;      a=i+1;     }    }    ans[cnt++] = 0;    ans[cnt++] = a;    if (b>0) {     ans[cnt++] = b;    }    end = pr;   }   ans[cnt++] = 0;   for (int i = cnt-1; i >= 0; i--) {    System.out.print(ans[i] + " ");   }   System.out.print("\n");  } }
6,public class P11D{ static long mod=1000000007;   public static void main(String[] args) throws Exception{      InputReader in = new InputReader(System.in);    PrintWriter pw=new PrintWriter(System.out);                 int n=in.readInt();   int m=in.readInt();   boolean v[][]=new boolean[n][n];   for(int i=0;i<m;i++)   {   int x=in.readInt()-1;   int y=in.readInt()-1;   v[x][y]=true;   v[y][x]=true;   }     long dp[][]=new long[1<<n][n];   for(int i=0;i<n;i++)   {   dp[1<<i][i]=1;   }   long ans=0;  for(int mask=1;mask<(1<<n);mask++)  {   int s=-1;   for(int i=0;i<n;i++)   {   if((mask&(1<<i))!=0)   {    s=i;    break;   }   }   for(int i=0;i<n;i++)   {   if(i!=s&&((1<<i)&mask)!=0)   {    for(int j=0;j<n;j++)    {    if((1<<j)!=0&&i!=j&&v[i][j])    {     int rem=(1<<i)^mask;     dp[mask][i]+=dp[rem][j];    }    }         int c=Integer.bitCount(mask);    if(c>=3&&v[i][s])    {    ans+=dp[mask][i];    }   }   }  }  ans/=2;  pw.println(ans);           pw.close();  }    public static long gcd(long x,long y) { if(x%y==0)  return y; else  return gcd(y,x%y); } public static int gcd(int x,int y) { if(x%y==0)  return y; else  return gcd(y,x%y); } public static int abs(int a,int b) { return (int)Math.abs(a-b); } public static long abs(long a,long b) { return (long)Math.abs(a-b); } public static int max(int a,int b) { if(a>b)  return a; else  return b; } public static int min(int a,int b) { if(a>b)  return b; else  return a; } public static long max(long a,long b) { if(a>b)  return a; else  return b; } public static long min(long a,long b) { if(a>b)  return b; else  return a; }  public static long pow(long n,long p,long m) {  long result = 1;  if(p==0)  return 1; if (p==1)  return n; while(p!=0) {  if(p%2==1)   result *= n;  if(result>=m)  result%=m;  p >>=1;  n*=n;  if(n>=m)  n%=m; } return result; } public static long pow(long n,long p) { long result = 1;  if(p==0)  return 1; if (p==1)  return n; while(p!=0) {  if(p%2==1)   result *= n;    p >>=1;  n*=n;   } return result; } static class Pair implements Comparable<Pair> { int a,b; Pair (int a,int b) {  this.a=a;  this.b=b; }  public int compareTo(Pair o) {   if(this.a!=o.a)  return Integer.compare(this.a,o.a);  else  return Integer.compare(this.b, o.b);   } public boolean equals(Object o) {   if (o instanceof Pair) {    Pair p = (Pair)o;    return p.a == a && p.b == b;   }   return false;  }  public int hashCode() {   return new Integer(a).hashCode() * 31 + new Integer(b).hashCode();  }  }   static long sort(int a[]) { int n=a.length; int b[]=new int[n];  return mergeSort(a,b,0,n-1);} static long mergeSort(int a[],int b[],long left,long right) { long c=0;if(left<right) { long mid=left+(right-left)/2;  c= mergeSort(a,b,left,mid);  c+=mergeSort(a,b,mid+1,right);  c+=merge(a,b,left,mid+1,right); }  return c; } static long merge(int a[],int b[],long left,long mid,long right) {long c=0;int i=(int)left;int j=(int)mid; int k=(int)left; while(i<=(int)mid-1&&j<=(int)right) { if(a[i]<=a[j]) {b[k++]=a[i++]; } else { b[k++]=a[j++];c+=mid-i;}} while (i <= (int)mid - 1) b[k++] = a[i++]; while (j <= (int)right) b[k++] = a[j++]; for (i=(int)left; i <= (int)right; i++)  a[i] = b[i]; return c; }  public static int[] radixSort(int[] f) { int[] to = new int[f.length]; {  int[] b = new int[65537];  for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;  for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];  for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];  int[] d = f; f = to;to = d; } {  int[] b = new int[65537];  for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;  for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];  for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];  int[] d = f; f = to;to = d; } return f; }  static class InputReader {  private InputStream stream;  private byte[] buf = new byte[1024];  private int curChar;  private int numChars;  private SpaceCharFilter filter;  public InputReader(InputStream stream)  {   this.stream = stream;  }  public int read()  {   if (numChars == -1)    throw new InputMismatchException();   if (curChar >= numChars)   {    curChar = 0;    try    {     numChars = stream.read(buf);    } catch (IOException e)    {     throw new InputMismatchException();    }    if (numChars <= 0)     return -1;   }   return buf[curChar++];  }  public int readInt()  {   int c = read();   while (isSpaceChar(c))    c = read();   int sgn = 1;   if (c == '-')   {    sgn = -1;    c = read();   }   int res = 0;   do   {    if (c < '0' || c > '9')     throw new InputMismatchException();    res *= 10;    res += c - '0';    c = read();   } while (!isSpaceChar(c));   return res * sgn;  }  public String readString()  {   int c = read();   while (isSpaceChar(c))    c = read();   StringBuilder res = new StringBuilder();   do   {    res.appendCodePoint(c);    c = read();   } while (!isSpaceChar(c));   return res.toString();  }  public String readLine() {   int c = read();   while (isSpaceChar(c))    c = read();   StringBuilder res = new StringBuilder();   do {    res.appendCodePoint(c);    c = read();   } while (!isEndOfLine(c));   return res.toString();  }    public double readDouble() {   int c = read();   while (isSpaceChar(c))    c = read();   int sgn = 1;   if (c == '-') {    sgn = -1;    c = read();   }   double res = 0;   while (!isSpaceChar(c) && c != '.') {    if (c == 'e' || c == 'E')     return res * Math.pow(10, readInt());    if (c < '0' || c > '9')     throw new InputMismatchException();    res *= 10;    res += c - '0';    c = read();   }   if (c == '.') {    c = read();    double m = 1;    while (!isSpaceChar(c)) {     if (c == 'e' || c == 'E')      return res * Math.pow(10, readInt());     if (c < '0' || c > '9')      throw new InputMismatchException();     m /= 10;     res += (c - '0') * m;     c = read();    }   }   return res * sgn;  }  public long readLong() {   int c = read();   while (isSpaceChar(c))    c = read();   int sgn = 1;   if (c == '-') {    sgn = -1;    c = read();   }   long res = 0;   do {    if (c < '0' || c > '9')     throw new InputMismatchException();    res *= 10;    res += c - '0';    c = read();   } while (!isSpaceChar(c));   return res * sgn;  }  public boolean isSpaceChar(int c)  {   if (filter != null)    return filter.isSpaceChar(c);   return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;  }  public String next()  {   return readString();  }  public interface SpaceCharFilter  {   public boolean isSpaceChar(int ch);  }  public boolean isEndOfLine(int c) {   return c == '\n' || c == '\r' || c == -1;  } }                           }
6,public class Main {  public static class Pair implements Comparable<Pair> {   int k, x;   public Pair(int k) {    this.k = k;   }   public void update(int x) {    this.x = Math.max(this.x, x);   }   public int compareTo(Pair other) {    if (x != other.x) {     return other.x - x;    }    return k - other.k;   }  }  public static int sum(int[] arr) {   int sum = 0;   for (int x : arr) {    sum += x;   }   return sum;  }  public static int[] join(int[] a, int[] b) {   int n = a.length;   int[] best = new int[n];   int sum = 0;   for (int shift = 0; shift < n; shift++) {    int[] curr = new int[n];    for (int i = 0; i < n; i++) {     curr[i] = Math.max(a[i], b[(i + shift) % n]);    }    int now = sum(curr);    if (now > sum) {     sum = now;     best = curr;    }   }   return best;  }  public static int n;  public static int[] pow;  public static int[][] dp, real;  public static void calc(int mask) {   int[] best = new int[n];   int sum = 0;   for (int i = 0; i < n; i++) {    if ((mask & pow[i]) != 0) {     int to = mask ^ pow[i];     int[] init = new int[n];     for (int j = 0; j < n; j++) {      init[j] = real[j][i];     }     int[] curr = join(dp[to], init);     int s = sum(curr);     if (s > sum) {      sum = s;      best = curr;     }    }   }   dp[mask] = best;  }  public static void main(String[] args) {   pow = new int[15];   pow[0] = 1;   for (int i = 1; i < pow.length; i++) {    pow[i] = pow[i - 1] * 2;   }   Scanner in = new Scanner(System.in);   int t = in.nextInt();   for (int i = 0; i < t; i++) {    n = in.nextInt();    int m = in.nextInt();    int[][] arr = new int[n][m];    for (int j = 0; j < n; j++) {     for (int k = 0; k < m; k++) {      arr[j][k] = in.nextInt();     }    }    Pair[] best = new Pair[m];    for (int j = 0; j < m; j++) {     best[j] = new Pair(j);     for (int k = 0; k < n; k++) {      best[j].update(arr[k][j]);     }    }    Arrays.sort(best);    real = new int[n][n];    for (int j = 0; j < n; j++) {     for (int k = 0; k < Math.min(n, m); k++) {      real[j][k] = arr[j][best[k].k];     }    }    dp = new int[1 << n][];    Stack<Integer>[] min = new Stack[n + 1];    for (int j = 0; j <= n; j++) {     min[j] = new Stack<>();    }    for (int j = 0; j < dp.length; j++) {     int cnt = 0;     for (int k = 0; k < n; k++) {      if ((j & pow[k]) != 0) {       cnt++;      }     }     min[cnt].add(j);    }    for (int j = 0; j < min.length; j++) {     for (int x : min[j]) {      if (j == 0) {       dp[x] = new int[n];      } else {       calc(x);      }     }    }    System.out.println(sum(dp[dp.length - 1]));   }  } }
4,public class Deltix {  static PrintWriter out;  public static void main(String[] args) {   MyScanner sc = new MyScanner();   out = new PrintWriter(new BufferedOutputStream(System.out));   int t = sc.nextInt();   while (t-- > 0) {    int n = sc.nextInt();    Stack<Integer> s = new Stack<>();    int [] a = new int[n];    for (int i = 0; i < n; ++i) a[i] = sc.nextInt();    for (int i = 0; i < n; i++) {     if (a[i] == 1) {      s.push(1);     } else {      while (s.peek() != a[i] - 1) {       s.pop();      }      s.pop();      s.push(a[i]);     }     print(s);    }   }   out.close();  }  static void print(Stack<Integer> s) {   ArrayDeque<Integer> a = new ArrayDeque<>();   while (!s.isEmpty()) {    a.addFirst(s.pop());   }   while (!a.isEmpty()) {    int x = a.pollFirst();    out.print(x);    s.push(x);    if (a.size() != 0) out.print(".");   }   out.println();  }   static void sort(int[] a) {   ArrayList<Integer> q = new ArrayList<>();   for (int i : a) q.add(i);   Collections.sort(q);   for (int i = 0; i < a.length; i++) a[i] = q.get(i);  }  static void sort(long[] a) {   ArrayList<Long> q = new ArrayList<>();   for (long i : a) q.add(i);   Collections.sort(q);   for (int i = 0; i < a.length; i++) a[i] = q.get(i);  }    public static class MyScanner {   BufferedReader br;   StringTokenizer st;   public MyScanner() {    br = new BufferedReader(new InputStreamReader(System.in));   }   String next() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }   int nextInt() {    return Integer.parseInt(next());   }   long nextLong() {    return Long.parseLong(next());   }   double nextDouble() {    return Double.parseDouble(next());   }   String nextLine() {    String str = "";    try {     str = br.readLine();    } catch (IOException e) {     e.printStackTrace();    }    return str;   }   } }
0,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputStreamReader in = new InputStreamReader(inputStream);  PrintWriter out = new PrintWriter(outputStream);  TaskA solver = new TaskA();  solver.solve(1, in, out);  out.close(); } } class TaskA {  public void solve(int testNumber, InputStreamReader inSt, PrintWriter out) {   InputReader in = new InputReader(inSt);   long a = in.nextLong();   long b = in.nextLong();   long result = 0;   while (b != 1) {    result += a / b;    long r = a % b;    long q = b;    long top = q % r;    long bottom = r;    result += q / r;    a = top;    b = bottom;   }   result += a;   out.println(result);  }  class InputReader {   public BufferedReader reader;   private String[] currentArray;   int curPointer;   public InputReader(InputStreamReader inputStreamReader) {    reader = new BufferedReader(inputStreamReader);   }   public String next() {    try {     currentArray = null;     return reader.readLine();    } catch (IOException e) {     throw new RuntimeException(e);    }   }   public void nextChars(char[] t) {    try {     currentArray = null;     reader.read(t);    } catch (IOException e) {     throw new RuntimeException(e);    }   }   public char nextChar() {    try {     currentArray = null;     return (char) reader.read();    } catch (IOException e) {     throw new RuntimeException(e);    }   }   public int nextInt() {    if ((currentArray == null) || (curPointer >= currentArray.length)) {     try {      currentArray = reader.readLine().split(" ");     } catch (IOException e) {      throw new RuntimeException(e);     }     curPointer = 0;    }    return Integer.parseInt(currentArray[curPointer++]);   }   public long nextLong() {    if ((currentArray == null) || (curPointer >= currentArray.length)) {     try {      currentArray = reader.readLine().split(" ");     } catch (IOException e) {      throw new RuntimeException(e);     }     curPointer = 0;    }    return Long.parseLong(currentArray[curPointer++]);   }  } }
6,public class Template implements Runnable {  private void solve() throws IOException {   int n = nextInt();   int m = nextInt();   boolean[][] g = new boolean[n][n];   for (int i = 0; i < m; ++i) {    int a = nextInt() - 1;    int b = nextInt() - 1;    g[a][b] = true;    g[b][a] = true;   }     long[] am = new long[n + 1];   long[][] ways = new long[1 << (n - 1)][n];   for (int start = 0; start < n; ++start) {    for (int mask = 0; mask < (1 << (n - start - 1)); ++mask)     for (int last = start; last < n; ++last) {      ways[mask][last - start] = 0;     }    ways[1 >> 1][0] = 1;    for (int mask = 1; mask < (1 << (n - start)); mask += 2) {     int cnt = 0;     int tmp = mask;     while (tmp > 0) {      ++cnt;      tmp = tmp & (tmp - 1);     }     for (int last = start; last < n; ++last)      if (ways[mask >> 1][last - start] > 0) {       long amm = ways[mask >> 1][last - start];       for (int i = start; i < n; ++i)        if ((mask & (1 << (i - start))) == 0 && g[last][i]) {         ways[(mask | (1 << (i - start))) >> 1][i - start] += amm;        }       if (g[last][start])        am[cnt] += ways[mask >> 1][last - start];      }    }   }   long res = 0;   for (int cnt = 3; cnt <= n; ++cnt) {    if (am[cnt] % (2) != 0)     throw new RuntimeException();    res += am[cnt] / (2);   }   writer.println(res);  }   public static void main(String[] args) {   new Template().run();  }  BufferedReader reader;  StringTokenizer tokenizer;  PrintWriter writer;  public void run() {   try {    reader = new BufferedReader(new InputStreamReader(System.in));    tokenizer = null;    writer = new PrintWriter(System.out);    solve();    reader.close();    writer.close();   } catch (Exception e) {    e.printStackTrace();    System.exit(1);   }  }  int nextInt() throws IOException {   return Integer.parseInt(nextToken());  }  long nextLong() throws IOException {   return Long.parseLong(nextToken());  }  double nextDouble() throws IOException {   return Double.parseDouble(nextToken());  }  String nextToken() throws IOException {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    tokenizer = new StringTokenizer(reader.readLine());   }   return tokenizer.nextToken();  } }
3,public class PTM {  public static void main(String[] args) throws Exception {   BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));   PrintWriter printWriter = new PrintWriter(System.out);   int N = Integer.parseInt(bufferedReader.readLine());   String[] strings = bufferedReader.readLine().split(" ");   int[] arr = new int[strings.length];   HashSet<Integer> set = new HashSet<>();   for (int i = 0; i < N; i++) {    arr[i] = Integer.parseInt(strings[i]);    set.add(arr[i]);   }   Arrays.sort(arr);   int c = 0;   for (int i = 0; i < N; i++) {    int value = arr[i];    if (!set.contains(value)) {     continue;    }    for (int j = 1; j <= 100; j++) {     if (set.contains(value * j)) {      set.remove(value * j);     }    }    c++;   }   printWriter.println(c);   printWriter.flush();  } }
4,public class E2 {  static ArrayList<Integer> primes;  static int[] mind;  final static int MAXA = (int) 1e7;  public static void main(String[] args) throws IOException {   BufferedReader f = new BufferedReader(new InputStreamReader(System.in));   StringTokenizer st = new StringTokenizer(f.readLine());   int t = Integer.parseInt(st.nextToken());   primes = new ArrayList<>();   mind = new int[MAXA + 1];   for (int i = 2; i <= MAXA; i++) {    if (mind[i] == 0) {     primes.add(i);     mind[i] = i;    }    for (int x : primes) {     if (x > mind[i] || x * i > MAXA) break;     mind[x * i] = x;    }   }   int[] count = new int[MAXA + 1];   for (int on8y = 0; on8y < t; on8y++) {    st = new StringTokenizer(f.readLine());    int n = Integer.parseInt(st.nextToken());    int k = Integer.parseInt(st.nextToken());    int[] a = new int[n];    Arrays.fill(a, 1);    st = new StringTokenizer(f.readLine());    for (int i = 0; i < n; i++) {     int x = Integer.parseInt(st.nextToken());     int cnt = 0;     int last = 0;     while (x > 1) {      int p = mind[x];      if (last == p) cnt++;      else {       if (cnt % 2 == 1) a[i] *= last;       last = p;       cnt = 1;      }      x /= p;     }     if (cnt % 2 == 1) a[i] *= last;    }    int[][] mnleft = new int[n][k + 1];    for (int j = 0; j < k + 1; j++) {     int l = n;     int now = 0;     for (int i = n - 1; i >= 0; i--) {      while (l - 1 >= 0 && now + ((count[a[l - 1]] > 0) ? 1 : 0) <= j) {       l--;       now += (count[a[l]] > 0) ? 1 : 0;       count[a[l]]++;      }      mnleft[i][j] = l;      if (count[a[i]] > 1) now--;      count[a[i]]--;     }    }    int[][] dp = new int[n + 1][k + 1];    for (int i = 0; i < n + 1; i++) {     Arrays.fill(dp[i], (int) 1e9 + 1);    }    for (int i = 0; i < k + 1; i++) dp[0][i] = 0;    for (int i = 1; i <= n; i++) {     for (int j = 0; j <= k; j++) {      if (j > 0) dp[i][j] = dp[i][j - 1];      for (int lst = 0; lst <= j; lst++) {       dp[i][j] = Math.min(dp[i][j], dp[mnleft[i - 1][lst]][j - lst] + 1);      }     }    }    int ans = (int) 1e9 + 1;    for (int c : dp[n]) ans = Math.min(ans, c);    System.out.println(ans);   }  } }
6,public class Fish extends Thread {  public Fish() {   this.input = new BufferedReader(new InputStreamReader(System.in));   this.output = new PrintWriter(System.out);   this.setPriority(Thread.MAX_PRIORITY);  }  static int getOnes(int mask) {   int result = 0;   while (mask != 0) {    mask &= mask - 1;    ++result;   }   return result;  }  private void solve() throws Throwable {   int n = nextInt();   double[][] a = new double[n][n];   double[] dp = new double[(1 << n)];   for (int i = 0; i < n; ++i) {    for (int j = 0; j < n; ++j) {     a[i][j] = nextDouble();    }   }   int limit = (1 << n) - 1;     dp[limit] = 1.0;   for (int mask = limit; mask > 0; --mask) {    int cardinality = getOnes(mask);    if (cardinality < 2) {     continue;    }    int probability = cardinality * (cardinality - 1) / 2;    for (int first = 0; first < n; ++first) {     if ((mask & powers[first]) != 0) {      for (int second = first + 1; second < n; ++second) {       if ((mask & powers[second]) != 0) {        dp[mask - powers[first]] += dp[mask] * a[second][first] / probability;        dp[mask - powers[second]] += dp[mask] * a[first][second] / probability;       }      }     }    }   }   for (int i = 0; i < n; ++i) {    output.printf("%.10f ", dp[powers[i]]);   }  }  public void run() {   try {    solve();   } catch (Throwable e) {    System.err.println(e.getMessage());    e.printStackTrace();    System.exit(666);   } finally {    output.flush();    output.close();   }  }   public static void main(String[] args) {   new Fish().start();  }  private String nextToken() throws IOException {   while (tokens == null || !tokens.hasMoreTokens()) {    tokens = new StringTokenizer(input.readLine());   }   return tokens.nextToken();  }  private int nextInt() throws IOException {   return Integer.parseInt(nextToken());  }  private double nextDouble() throws IOException {   return Double.parseDouble(nextToken());  }  private long nextLong() throws IOException {   return Long.parseLong(nextToken());  }  static final int powers[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144};  private BufferedReader input;  private PrintWriter output;  private StringTokenizer tokens = null; }
4,public class R035CRetry {  public void debug(Object... objects) { System.err.println(Arrays.deepToString(objects)); }  public static final int INF = 987654321;  public static final long LINF = 987654321987654321L;  public static final double EPS = 1e-9;   Scanner scanner;  PrintWriter out;  boolean[][] bss;   public R035CRetry() {   try {    this.scanner = new Scanner(new File("input.txt"));    this.out = new PrintWriter("output.txt");   } catch(FileNotFoundException ex) { ex.printStackTrace(); }  }   class Point implements Comparable<Point> {   int x, y, count;   Point(int x, int y) { this.x = x; this.y = y; }   public int hashCode() { return x * 17 + y; }   public boolean equals(Object o) {    if(!(o instanceof Point)) return false;    Point that = (Point)o;    return this.x == that.x && this.y == that.y;   }   public int compareTo(Point that) { return this.count - that.count; }   public String toString() { return "(" + x + ", " + y + ":" + count + ")"; }  }    int[] dx = new int[] { 0, 0, -1, 1 };  int[] dy= new int[] { -1, 1, 0, 0 };  int n, m;   Queue<Point> q;   Point bfs() {   int max = -INF;   Point p = null;   while(!q.isEmpty()) {    Point cur = q.remove();    if(max < cur.count) { max = cur.count; p = cur; }    for(int i=0; i<dx.length; i++) {     int nx = cur.x + dx[i];     int ny = cur.y + dy[i];     if(nx < 0 || nx >= n) { continue; }     if(ny < 0 || ny >= m) { continue; }     Point np = new Point(nx, ny);     if(bss[nx][ny] ) { continue; }     np.count = cur.count+1;     bss[nx][ny] = true;     q.add(np);    }   }   return p;  }   private void solve() {   this.n = scanner.nextInt();   this.m = scanner.nextInt();   this.bss = new boolean[n][m];   int k = scanner.nextInt();   q = new LinkedList<Point>();   for(int i=0; i<k; i++) {    int x = scanner.nextInt() - 1;    int y = scanner.nextInt() - 1;    Point init = new Point(x, y);    init.count = 1;    q.add(init);    bss[x][y] = true;   }   Point p = bfs();   out.println((p.x+1) + " " + (p.y+1));  }   private void finish() { this.out.close(); }   public static void main(String[] args) {   R035CRetry obj = new R035CRetry();   obj.solve();   obj.finish();  } }
2,public class Main{   static BigInteger n, x, y, c; static BigInteger mk[] = new BigInteger[8]; public static BigInteger f(BigInteger t) {  return t.multiply(t); }  public static BigInteger g(BigInteger t) {  return t.multiply(t.add(BigInteger.ONE)).shiftRight(1); }  public static int solve(BigInteger z) {  BigInteger ret = z.multiply(z.add(BigInteger.ONE)).shiftLeft(1);  ret = ret.add(BigInteger.ONE);   for(int i = 0; i < 8; i += 2) {  if(z.compareTo(mk[i]) > 0) {   ret = ret.subtract(f(z.subtract(mk[i])));  }  }  for(int i = 1; i < 8; i += 2) {  if(z.compareTo(mk[i]) > 0) {   ret = ret.add(g(z.subtract(mk[i])));  }  }   if(ret.compareTo(c) >= 0) return 1;  return 0; } public static void main(String[] args) {   Scanner cin = new Scanner(System.in);  while(cin.hasNext()) {  n = cin.nextBigInteger();  x = cin.nextBigInteger();  y = cin.nextBigInteger();  c = cin.nextBigInteger();  mk[0] = x.subtract(BigInteger.ONE);  mk[2] = n.subtract(y);  mk[4] = n.subtract(x);  mk[6] = y.subtract(BigInteger.ONE);  mk[1] = mk[0].add(mk[2]).add(BigInteger.ONE);  mk[3] = mk[2].add(mk[4]).add(BigInteger.ONE);  mk[5] = mk[4].add(mk[6]).add(BigInteger.ONE);  mk[7] = mk[6].add(mk[0]).add(BigInteger.ONE);  BigInteger beg = BigInteger.ZERO, end = mk[0], mid;  for(int i = 1; i < 8; ++i) if(end.compareTo(mk[i]) < 0) end = mk[i];  while(beg.compareTo(end) < 0) {   mid = beg.add(end).shiftRight(1);   if(solve(mid) == 1) end = mid;   else beg = mid.add(BigInteger.ONE);  }  System.out.println(end);  }  } }
6,public class E5 { InputStream is; PrintWriter out; String INPUT = "";   void solve() {  for(int T = ni(); T> 0;T--){  int n = ni(), m = ni();  int[][] a = new int[m][n];  for(int i = 0;i < n;i++){   for(int j = 0;j < m;j++){   a[j][i] = ni();   }  }    int[][] mx = new int[m][];  for(int i = 0;i < m;i++){   int u = 0;   for(int j = 0;j < n;j++){   u = Math.max(u, a[i][j]);   }   mx[i] = new int[]{u, i};  }  Arrays.sort(mx, new Comparator<int[]>() {   public int compare(int[] a, int[] b) {   return -(a[0] - b[0]);   }  });  int[] dp = new int[1<<n];  for(int i = 0;i < n && i < m;i++){   int c = mx[i][1];   int[] ls = new int[1<<n];   for(int j = 1;j < 1<<n;j++){   ls[j] = ls[j&j-1] + a[c][Integer.numberOfTrailingZeros(j)];   }   for(int j = 1;j < 1<<n;j++){   int r = rot(j, n);   ls[r] = Math.max(ls[r], ls[j]);   }   int[] ndp = new int[1<<n];   for(int j = 0;j < 1<<n;j++){   if(rot(j, n) == j){    int cur = j;    for(int sh = 0;sh < n;sh++){    cur = cur>>1|(cur&1)<<n-1;    int mask = (1<<n)-1^cur;    for(int k = mask;k >= 0;k--){     k &= mask;         ndp[k|cur] = Math.max(      ndp[k|cur], dp[k] + ls[j]);    }    }   }   }   dp = ndp;  }  out.println(dp[(1<<n)-1]);  } }  int rot(int x, int n) {  int ret = x;  for(int i = 0;i < n;i++){  x = x>>>1|(x&1)<<n-1;   ret = Math.min(ret, x);  }  return ret; }  void run() throws Exception {          is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());  out = new PrintWriter(System.out);   long s = System.currentTimeMillis();  solve();  out.flush();  tr(System.currentTimeMillis()-s+"ms"); }  public static void main(String[] args) throws Exception { new E5().run(); }  private byte[] inbuf = new byte[1024]; public int lenbuf = 0, ptrbuf = 0;  private int readByte() {  if(lenbuf == -1)throw new InputMismatchException();  if(ptrbuf >= lenbuf){  ptrbuf = 0;  try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }  if(lenbuf <= 0)return -1;  }  return inbuf[ptrbuf++]; }  private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }  private double nd() { return Double.parseDouble(ns()); } private char nc() { return (char)skip(); }  private String ns() {  int b = skip();  StringBuilder sb = new StringBuilder();  while(!(isSpaceChar(b))){   sb.appendCodePoint(b);  b = readByte();  }  return sb.toString(); }  private char[] ns(int n) {  char[] buf = new char[n];  int b = skip(), p = 0;  while(p < n && !(isSpaceChar(b))){  buf[p++] = (char)b;  b = readByte();  }  return n == p ? buf : Arrays.copyOf(buf, p); }  private char[][] nm(int n, int m) {  char[][] map = new char[n][];  for(int i = 0;i < n;i++)map[i] = ns(m);  return map; }  private int[] na(int n) {  int[] a = new int[n];  for(int i = 0;i < n;i++)a[i] = ni();  return a; }  private int ni() {  int num = 0, b;  boolean minus = false;  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));  if(b == '-'){  minus = true;  b = readByte();  }   while(true){  if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');  }else{   return minus ? -num : num;  }  b = readByte();  } }  private long nl() {  long num = 0;  int b;  boolean minus = false;  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));  if(b == '-'){  minus = true;  b = readByte();  }   while(true){  if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');  }else{   return minus ? -num : num;  }  b = readByte();  } }  private boolean oj = System.getProperty("ONLINE_JUDGE") != null; private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); } }
6,public class Main{  public static void main(String args[]){   Scanner sc=new Scanner(System.in);   int n=sc.nextInt();   int m=sc.nextInt();   int x,y;   boolean graph[][]=new boolean[n][n];   for(int i=0;i<m;i++){    x=sc.nextInt()-1;    y=sc.nextInt()-1;    graph[x][y]=graph[y][x]=true;   }   long dp[][]=new long[1<<n][n];   long res=0;   for(int i=0;i<n;i++){    dp[1<<i][i]=1;   }   for(int mask=1;mask<(1<<n);mask++){    int first=-1;    for(int f=0;f<n;f++){     if((mask&(1<<f))!=0){      first=f;      break;     }    }    for(int i=0;i<n;i++){     if((mask&(1<<i))!=0&&i!=first){      for(int j=0;j<n;j++){       if(graph[j][i]&&((mask&1<<j)!=0)){        dp[mask][i]+=dp[mask^1<<i][j];       }      }     }     if(Integer.bitCount(mask)>2&&graph[first][i]){      res+=dp[mask][i];     }    }   }     System.out.println(res/2);  }  }
5,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  Scanner in = new Scanner(inputStream);  PrintWriter out = new PrintWriter(outputStream);  TaskA solver = new TaskA();  solver.solve(1, in, out);  out.close(); } } class TaskA { public void solve(int testNumber, Scanner in, PrintWriter out) {   int n=in.nextInt(),i,sum=0;   int a[]=new int[n];   for(i=0;i<n;i++) {    a[i]=in.nextInt();    sum+=a[i];   }   Arrays.sort(a);   int s=0,c=0;   for(i=n-1;i>=0;i--)   {    if(s>sum)     break;    s+=a[i];    sum-=a[i];          c++;   }   out.println(c); } }
0,public class C125 { public static void main(String[] args) throws IOException {  BufferedReader r = new BufferedReader(new InputStreamReader(System.in));  String s = r.readLine();  int n = new Integer(s);  System.out.println("0 0 "+n); } }
2,public class P255D {  @SuppressWarnings("unchecked") public void run() throws Exception {  long n = nextLong();  long x = nextLong();  long y = nextLong();  long c = nextLong();  if ((n == 1) || (c == 1)) {  println(0);  return;  }  x = Math.min(x, n - x + 1);  y = Math.min(y, n - y + 1);  long t = 0;  long s = 1;  while (s < c) {  t++;   s += (t * 4) + ((t >= x + y) ? (t - x - y + 1) : 0)    - ((t >= x) ? (t - x) * 2 + 1 : 0)    - ((t >= y) ? (t - y) * 2 + 1 : 0)    + ((t >= x + n - y + 1) ? (t - x - n + y) : 0)    + ((t >= n - x + 1 + y) ? (t - n + x - y) : 0)    - ((t >= n - x + 1) ? (t - n + x - 1) * 2 + 1 : 0)    - ((t >= n - y + 1) ? (t - n + y - 1) * 2 + 1 : 0);  }  println(t); }  public static void main(String... args) throws Exception {  br = new BufferedReader(new InputStreamReader(System.in));  pw = new PrintWriter(new BufferedOutputStream(System.out));  new P255D().run();  br.close();  pw.close(); }  static BufferedReader br; static PrintWriter pw; StringTokenizer stok;  String nextToken() throws IOException {  while (stok == null || !stok.hasMoreTokens()) {  String s = br.readLine();  if (s == null) { return null; }  stok = new StringTokenizer(s);  }  return stok.nextToken(); }  void print(byte b) { print("" + b); } void print(int i) { print("" + i); } void print(long l) { print("" + l); } void print(double d) { print("" + d); } void print(char c) { print("" + c); } void print(Object o) {  if (o instanceof int[]) { print(Arrays.toString((int [])o));  } else if (o instanceof long[]) { print(Arrays.toString((long [])o));  } else if (o instanceof char[]) { print(Arrays.toString((char [])o));  } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));  } else if (o instanceof short[]) { print(Arrays.toString((short [])o));  } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));  } else if (o instanceof float[]) { print(Arrays.toString((float [])o));  } else if (o instanceof double[]) { print(Arrays.toString((double [])o));  } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));  } else { print("" + o); } } void print(String s) { pw.print(s); } void println() { println(""); } void println(byte b) { println("" + b); } void println(int i) { println("" + i); } void println(long l) { println("" + l); } void println(double d) { println("" + d); } void println(char c) { println("" + c); } void println(Object o) { print(o); println(""); } void println(String s) { pw.println(s); } int nextInt() throws IOException { return Integer.parseInt(nextToken()); } long nextLong() throws IOException { return Long.parseLong(nextToken()); } double nextDouble() throws IOException { return Double.parseDouble(nextToken()); } char nextChar() throws IOException { return (char) (br.read()); } String next() throws IOException { return nextToken(); } String nextLine() throws IOException { return br.readLine(); } int [] readInt(int size) throws IOException {  int [] array = new int [size];  for (int i = 0; i < size; i++) { array[i] = nextInt(); }  return array; } long [] readLong(int size) throws IOException {  long [] array = new long [size];  for (int i = 0; i < size; i++) { array[i] = nextLong(); }  return array; } double [] readDouble(int size) throws IOException {  double [] array = new double [size];  for (int i = 0; i < size; i++) { array[i] = nextDouble(); }  return array; } String [] readLines(int size) throws IOException {  String [] array = new String [size];  for (int i = 0; i < size; i++) { array[i] = nextLine(); }  return array; } }
2,public class Dj {  public static long run(long l, long r) {  if(l == r) {  return 0;  }  long[] sq2 = new long[62];  sq2[0] = 1;  for(int i = 1; i < 62; i++) sq2[i] = sq2[i-1]*2;    for(int i = sq2.length - 1; i >= 0; i--) {    if(l >= sq2[i] && r >= sq2[i]) {   l -= sq2[i];   r -= sq2[i];  } else if(l < sq2[i] && sq2[i] <= r) {   break;  }  }  for(int i = sq2.length - 1; i >= 0; i--) {    if(l < sq2[i] && sq2[i] <= r) {   return sq2[i+1]-1;  }  }  return -1; }  public static void log(String str) {  System.out.println(str); }  public static void main(String[] args) {  Scanner sc = new Scanner(System.in);  long l = sc.nextLong();  long r = sc.nextLong();  System.out.println(run(l, r));   } }
1,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   OutputWriter out = new OutputWriter(outputStream);   BPhoenixAndPuzzle solver = new BPhoenixAndPuzzle();   int testCount = Integer.parseInt(in.next());   for (int i = 1; i <= testCount; i++)    solver.solve(i, in, out);   out.close();  }  static class BPhoenixAndPuzzle {   public void solve(int testNumber, InputReader in, OutputWriter out) {    int n = in.nextInt();    if (n % 2 == 1) {     out.println("NO");     return;    }    n /= 2;    if (n == 1 || (int) Math.sqrt(n) * (int) (Math.sqrt(n)) == n) {     out.println("YES");    } else {     if (n % 2 == 0) {      n /= 2;      if ((int) Math.sqrt(n) * (int) (Math.sqrt(n)) == n) {       out.println("YES");       return;      }     }     out.println("NO");    }   }  }  static class InputReader {   BufferedReader reader;   StringTokenizer tokenizer;   public InputReader(InputStream stream) {    reader = new BufferedReader(new InputStreamReader(stream), 32768);    tokenizer = null;   }   public String next() {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      tokenizer = new StringTokenizer(reader.readLine());     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return tokenizer.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }  }  static class OutputWriter {   private final PrintWriter writer;   public OutputWriter(OutputStream outputStream) {    writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));   }   public OutputWriter(Writer writer) {    this.writer = new PrintWriter(writer);   }   public void print(Object... objects) {    for (int i = 0; i < objects.length; i++) {     if (i != 0) {      writer.print(' ');     }     writer.print(objects[i]);    }   }   public void println(Object... objects) {    print(objects);    writer.println();   }   public void close() {    writer.close();   }  } }
2,@SuppressWarnings("unused") public class round169D {  static PrintWriter out = new PrintWriter(System.out);  static BufferedReader br = new BufferedReader(new InputStreamReader(    System.in));  static StringTokenizer st = new StringTokenizer("");  static int nextInt() throws Exception {   return Integer.parseInt(next());  }  static String next() throws Exception {   while (true) {    if (st.hasMoreTokens()) {     return st.nextToken();    }    String s = br.readLine();    if (s == null) {     return null;    }    st = new StringTokenizer(s);   }  }  public static void main(String[] args)throws Exception {     long l = parseLong(next());   long r = parseLong(next());   long [] min = new long [61];   for(int i = 1 ; i <= 60 ; ++i){    min[i] = (long) pow(2, i - 1) - 1;     }   for(int i = 60 ; i >= 0 ; --i){    if(min[i] >= r)     continue;    if(min[i] >= l && min[i] + 1 <= r){        out.println((1L << i) - 1);     out.flush();     return;    }    if(min[i] < l){     long one_jump = (long) pow(2, i);     long jumps = (long) ceil((l - min[i]) / (one_jump * 1.0));        long cur = min[i] + (jumps * one_jump);     if(cur >= l && cur + 1 <= r){                out.println((1L << i) - 1);      out.flush();      return;     }        }   }   out.println(0);   out.flush();  } }
4,public class Main {  static FastScanner fs=new FastScanner();  static class FastScanner {   BufferedReader br=new BufferedReader(new InputStreamReader(System.in));   StringTokenizer st=new StringTokenizer("");   public String next() {    while (!st.hasMoreElements())     try {      st=new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    return st.nextToken();   }   int Int() {    return Integer.parseInt(next());   }   long Long() {    return Long.parseLong(next());   }   String Str(){    return next();   }  }   public static void main (String[] args) throws java.lang.Exception {   PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));   int T=1;   for(int t=0;t<T;t++){    int n=Int(),m=Int(),k=Int();    List<int[]>g[]=new ArrayList[n*m+1];    for(int i=0;i<g.length;i++){     g[i]=new ArrayList<>();    }    for(int i=0;i<n;i++){     for(int j=0;j<m-1;j++){      int w=Int();      int u=i*m+j;      int v=i*m+(j+1);      g[u].add(new int[]{v,w});      g[v].add(new int[]{u,w});     }    }    for(int i=0;i<n-1;i++){     for(int j=0;j<m;j++){      int w=Int();      int u=i*m+j;      int v=(i+1)*m+j;      g[u].add(new int[]{v,w});      g[v].add(new int[]{u,w});     }    }    Solution sol=new Solution(out);    sol.solution(n,m,k,g);   }   out.close();  }   public static int Int(){   return fs.Int();  }  public static long Long(){   return fs.Long();  }  public static String Str(){   return fs.Str();  } }    class Solution{  PrintWriter out;  public Solution(PrintWriter out){   this.out=out;  }    List<int[]>g[];  int n,m;  long INF=10000000000000000l;  int curr=-1,curc=-1;  long mn=Long.MAX_VALUE;  long dp[][];  public void solution(int n,int m,int k,List<int[]>g[]){     this.n=n;   this.m=m;   long res[][]=new long[n][m];   if(k%2==1){    for(int i=0;i<n;i++){     Arrays.fill(res[i],-1);    }    print(res);    return;   }   this.g=g;   dp=new long[n*m+1][k/2+2];   for(int i=0;i<dp.length;i++){    Arrays.fill(dp[i],-1);   }    for(int i=0;i<n;i++){    for(int j=0;j<m;j++){     int id=i*m+j;     dfs(id,k/2);    }   }   for(int i=0;i<n;i++){    for(int j=0;j<m;j++){     int id=i*m+j;     res[i][j]=dp[id][k/2];    }   }   print(res);  }  public long dfs(int id,int cnt){   if(cnt==0){    return 0;   }   if(dp[id][cnt]!=-1)return dp[id][cnt];   int r=id/m;   int c=id%m;   long res=Long.MAX_VALUE;   for(int p[]:g[id]){    int next=p[0],w=p[1];    res=Math.min(res,w*2+dfs(next,cnt-1));   }   dp[id][cnt]=res;   return res;  }  public int dis(int x1,int y1,int x2,int y2){   return Math.abs(x1-x2)+Math.abs(y1-y2);  }   public void print(long A[][]){   for(int i=0;i<A.length;i++){    for(int j=0;j<A[0].length;j++){     out.print(A[i][j]+" ");    }    out.println();   }  }    } class Solution1{  PrintWriter out;  public Solution1(PrintWriter out){   this.out=out;  }  public void solution(int A[]){  } }
1,public class Solution {  private BufferedReader in; private PrintWriter out; private StringTokenizer st;  void solve() throws IOException {  String s = next();  int u = s.indexOf('R');  int v = s.indexOf('C');  if (u == 0 && v != -1 && u < v) {  String a = s.substring(u + 1, v);  String b = s.substring(v + 1);  try {   int aa = Integer.parseInt(a);   int bb = Integer.parseInt(b) - 1;   int pow = 26, len = 1;   while (bb >= pow) {   bb -= pow;   pow *= 26;   ++len;   }   String r = "";   for (int i = 0; i < len; ++i) {   r = ((char)(bb % 26 + 'A')) + r;   bb /= 26;   }   out.println(r + aa);   return;  } catch (NumberFormatException e) {  }  }  u = 0;  while (u < s.length() && Character.isLetter(s.charAt(u))) {  ++u;  }  String a = s.substring(0, u);  String b = s.substring(u);  out.println("R" + b + "C" + toInt(a)); }  private int toInt(String a) {  int r = 0;  for (int i = 0; i < a.length(); ++i) {  r *= 26;  r += a.charAt(i) - 'A';  }  int pow = 1;  for (int i = 0; i < a.length(); ++i) {  r += pow;  pow *= 26;  }  return r; }  Solution() throws IOException {  in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);   eat("");   int tests = nextInt();  for (int test = 0; test < tests; ++test) {  solve();  }   in.close();  out.close(); }  private void eat(String str) {  st = new StringTokenizer(str); }  String next() throws IOException {  while (!st.hasMoreTokens()) {  String line = in.readLine();  if (line == null) {   return null;  }  eat(line);  }  return st.nextToken(); }  int nextInt() throws IOException {  return Integer.parseInt(next()); }  long nextLong() throws IOException {  return Long.parseLong(next()); }  double nextDouble() throws IOException {  return Double.parseDouble(next()); }  public static void main(String[] args) throws IOException {  new Solution(); } }
5,public class A implements Runnable {  private MyScanner in;  private PrintWriter out;  private void solve() {   int n = in.nextInt();   int[] a = new int[n];   int max = -1, maxp = -1;   for (int i = 0; i < n; ++i) {    a[i] = in.nextInt();    if (a[i] > max) {     max = a[i];     maxp = i;    }   }   if (max == 1) {    for (int i = 0; i < n - 1; ++i) {     out.print(1 + " ");    }    out.println(2);    return;   }   a[maxp] = 1;   Arrays.sort(a);   for (int i = 0; i < n; ++i) {    out.print(a[i] + " ");   }   out.println();  }  @Override  public void run() {   in = new MyScanner();   out = new PrintWriter(System.out);   solve();   in.close();   out.close();  }  public static void main(String[] args) {   new A().run();  }  static class MyScanner {   private BufferedReader br;   private StringTokenizer st;   public MyScanner() {    br = new BufferedReader(new InputStreamReader(System.in));   }   public void close() {    try {     br.close();    } catch (IOException e) {     e.printStackTrace();    }   }   private String nextToken() {    while (st == null || !st.hasMoreTokens()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();      return null;     }    }    return st.nextToken();   }   public String nextLine() {    try {     return br.readLine();    } catch (IOException e) {     e.printStackTrace();     return null;    }   }   public String next() {    return nextToken();   }   public int nextInt() {    return Integer.parseInt(nextToken());   }   public long nextLong() {    return Long.parseLong(nextToken());   }   public double nextDouble() {    return Double.parseDouble(nextToken());   }  } }
3,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   inputClass in = new inputClass(inputStream);   PrintWriter out = new PrintWriter(outputStream);   APaintTheNumbers solver = new APaintTheNumbers();   solver.solve(1, in, out);   out.close();  }  static class APaintTheNumbers {   public void solve(int testNumber, inputClass sc, PrintWriter out) {    int n = sc.nextInt();    Integer[] tab = new Integer[n];    for (int i = 0; i < n; i++) {     tab[i] = sc.nextInt();    }    Arrays.sort(tab);    boolean[] done = new boolean[n];    int ans = 0;    for (int i = 0; i < n; i++) {     if (!done[i]) {      ans++;      done[i] = true;      for (int j = i + 1; j < n; j++) {       if (!done[j] && tab[j] % tab[i] == 0) {        done[j] = true;       }      }     }    }    out.println(ans);   }  }  static class inputClass {   BufferedReader br;   StringTokenizer st;   public inputClass(InputStream in) {    br = new BufferedReader(new InputStreamReader(in));   }   public String next() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }  } }
5,public class Main {  public static void main(String[] args) {   Scanner r = new Scanner(System.in);   int N = r.nextInt();   int K = r.nextInt() - 1;     T[] a = new T[N];   for(int i = 0; i < N; i++)    a[i] = new T(r.nextInt(), r.nextInt());     Arrays.sort(a, new Comparator<T>() {    @Override    public int compare(T x, T y) {     if(x.p > y.p)return -1;     else if(x.p == y.p){      if(x.t < y.t)return -1;      else if(x.t == y.t)return 0;      else return 1;     }else return 1;    }   });     int ret = 0;   for(int i = 0; i < N; i++)    if(a[i].p == a[K].p && a[i].t == a[K].t)ret++;     System.out.println(ret);  } } class T{  int p, t;  public T(int pi, int ti){   p = pi;   t = ti;  } }
2,public class A {  public static boolean realbig (long num, long s) {  String str = num + "";  String[] digs = str.split("");  int sum = 0;  for(String dig : digs) {  sum+= Integer.parseInt(dig);  }  if(num-sum < s) {  return false;  } else {  return true;  } }   public static void main(String[] args) {  Scanner sc = new Scanner(System.in);  long n = sc.nextLong();  long s = sc.nextLong();  sc.close();  long count = 0;  long i = s;  for(; i < s+200 && i <= n; i++) {  if(realbig(i,s)) {   count++;  }  }  if(i <= n) {  count+=n-i+1;  }  System.out.println(count); } }
3,public class Main {  public static class node implements Comparable<node>{  int l,r;  node(){}  node(int l,int r) {  this.l=l;  this.r=r;  }  @Override  public int compareTo(node rhs) {  return r-rhs.r;  } }  public static void main(String args[]){  Scanner in = new Scanner(System.in);  int a = in.nextInt();  int x[] = new int[a];  for(int n=0;n<a;n++){  x[n] = in.nextInt();  }  int max = 1;  int t = 0;  HashMap<Integer, ArrayList<node>> map = new HashMap<Integer, ArrayList<node>>();  for(int n=0;n<a;n++){  int num = 0;  for(int m=n;m<a;m++){   num += x[m];   node node = new node(n, m);   if(!map.containsKey(num)){   ArrayList<node> list = new ArrayList<node>();   list.add(node);   map.put(num, list);   if(max == 1)t = num;   }   else{   ArrayList<node> list = map.get(num);   int left = 0;   int right = list.size()-1;     int res = list.size();   while(left <= right){    int mid = (left + right) >> 1;       if(list.get(mid).r >= n){    res = mid;    right = mid - 1;    }    else{    left = mid + 1;    }   }   if(res == list.size()){    list.add(node);    if(max < res+1){    max = res+1;    t = num;    }   }   else if(list.get(res).r>m){    list.set(res, node);    if(max < res){    max = list.size();    t = num;    }   }      }  }  }  System.out.println(max);  for(int n=0;n<max;n++){  System.out.println((map.get(t).get(n).l+1)+" "+(map.get(t).get(n).r+1));  }   } }
4,public class G { InputStream is; PrintWriter out; String INPUT = "";  void solve() {  int n = ni(), m = ni(), K = ni(), C = ni(), D = ni();  int[] a = na(K);  int[] from = new int[m];  int[] to = new int[m];  for (int i = 0; i < m; i++) {  from[i] = ni() - 1;  to[i] = ni() - 1;  }  int[][] g = packU(n, from, to);  List<Edge> es = new ArrayList<>();   int time = 100;  for(int i = 0;i < n;i++){  for(int j = 0;j < time-1;j++){   es.add(new Edge(i*time+j, i*time+j+1, 99, C));  }  }  for(int i = 0;i < n;i++){  for(int e : g[i]){   for(int j = 0;j < time-1;j++){   for(int k = 0;k < n;k++){    es.add(new Edge(i*time+j, e*time+j+1, 1, C+D*(2*k+1)));   }   }  }  }  int src = time*n, sink = src+1;  for(int i = 0;i < K;i++){  es.add(new Edge(src, (a[i]-1)*time+0, 1, 0));  }  for(int i = 0;i < time;i++){  es.add(new Edge(0*time+i, sink, 99, 0));  }   out.println(solveMinCostFlowWithSPFA(compileWD(sink+1, es), src, sink, 99)); }  public static class Edge {  public int from, to;  public int capacity;  public int cost;  public int flow;  public Edge complement;     public Edge(int from, int to, int capacity, int cost) {  this.from = from;  this.to = to;  this.capacity = capacity;  this.cost = cost;  } }  public static Edge[][] compileWD(int n, List<Edge> edges) {  Edge[][] g = new Edge[n][];   for(int i = edges.size()-1;i >= 0;i--){  Edge origin = edges.get(i);  Edge clone = new Edge(origin.to, origin.from, origin.capacity, -origin.cost);  clone.flow = origin.capacity;  clone.complement = origin;  origin.complement = clone;  edges.add(clone);  }   int[] p = new int[n];  for(Edge e : edges)p[e.from]++;  for(int i = 0;i < n;i++)g[i] = new Edge[p[i]];  for(Edge e : edges)g[e.from][--p[e.from]] = e;  return g; }   public static Edge[][] compileWU(int n, List<Edge> edges) {  Edge[][] g = new Edge[n][];   for(int i = edges.size()-1;i >= 0;i--){  Edge origin = edges.get(i);  Edge back = new Edge(origin.to, origin.from, origin.capacity, origin.cost);  edges.add(back);  }  for(int i = edges.size()-1;i >= 0;i--){  Edge origin = edges.get(i);  Edge clone = new Edge(origin.to, origin.from, origin.capacity, -origin.cost);  clone.flow = origin.capacity;  clone.complement = origin;  origin.complement = clone;  edges.add(clone);  }   int[] p = new int[n];  for(Edge e : edges)p[e.from]++;  for(int i = 0;i < n;i++)g[i] = new Edge[p[i]];  for(Edge e : edges)g[e.from][--p[e.from]] = e;  return g; }   public static class DQ {  public int[] q;  public int n;  protected int pt, ph;   public DQ(int n){ this.n = Integer.highestOneBit(n)<<1; q = new int[this.n]; pt = ph = 0; }   public void addLast(int x){ q[ph] = x; ph = ph+1&n-1; }  public void addFirst(int x){ pt = pt+n-1&n-1; q[pt] = x; }  public int pollFirst(){ int ret = q[pt]; pt = pt+1&n-1; return ret; }  public int pollLast(){ ph = ph+n-1&n-1; int ret = q[ph]; return ret; }  public int getFirst(){ return q[pt]; }  public int getFirst(int k){ return q[pt+k&n-1]; }  public int getLast(){ return q[ph+n-1&n-1]; }  public int getLast(int k){ return q[ph+n-k-1&n-1]; }  public void clear(){ pt = ph = 0; }  public int size(){ return ph-pt+n&n-1; }  public boolean isEmpty(){ return ph==pt; } }   public static long solveMinCostFlowWithSPFA(Edge[][] g, int source, int sink, long all) {  int n = g.length;  long mincost = 0;   final int[] d = new int[n];  DQ q = new DQ(n);  boolean[] inq = new boolean[n];  while(all > 0){    Edge[] inedge = new Edge[n];  Arrays.fill(d, Integer.MAX_VALUE / 2);  d[source] = 0;  q.addLast(source);  while(!q.isEmpty()){   int cur = q.pollFirst();   inq[cur] = false;   for(Edge ne : g[cur]){   if(ne.capacity - ne.flow > 0){    int nd = d[cur] + ne.cost;    if(d[ne.to] > nd){    inedge[ne.to] = ne;    d[ne.to] = nd;    if(!inq[ne.to]){     q.addLast(ne.to);     inq[ne.to] = true;    }    }   }   }  }    if(inedge[sink] == null)break;    long minflow = all;  long sumcost = 0;  for(Edge e = inedge[sink];e != null;e = inedge[e.from]){   if(e.capacity - e.flow < minflow)minflow = e.capacity - e.flow;   sumcost += e.cost;  }  mincost += minflow * sumcost;  for(Edge e = inedge[sink];e != null;e = inedge[e.from]){   e.flow += minflow;   e.complement.flow -= minflow;  }    all -= minflow;  }  return mincost; }  static int[][] packU(int n, int[] from, int[] to) {  int[][] g = new int[n][];  int[] p = new int[n];  for (int f : from)  p[f]++;  for (int t : to)  p[t]++;  for (int i = 0; i < n; i++)  g[i] = new int[p[i]];  for (int i = 0; i < from.length; i++) {  g[from[i]][--p[from[i]]] = to[i];  g[to[i]][--p[to[i]]] = from[i];  }  return g; }  void run() throws Exception {  is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());  out = new PrintWriter(System.out);   long s = System.currentTimeMillis();  solve();  out.flush();  tr(System.currentTimeMillis()-s+"ms"); }  public static void main(String[] args) throws Exception { new G().run(); }  private byte[] inbuf = new byte[1024]; public int lenbuf = 0, ptrbuf = 0;  private int readByte() {  if(lenbuf == -1)throw new InputMismatchException();  if(ptrbuf >= lenbuf){  ptrbuf = 0;  try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }  if(lenbuf <= 0)return -1;  }  return inbuf[ptrbuf++]; }  private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }  private double nd() { return Double.parseDouble(ns()); } private char nc() { return (char)skip(); }  private String ns() {  int b = skip();  StringBuilder sb = new StringBuilder();  while(!(isSpaceChar(b))){   sb.appendCodePoint(b);  b = readByte();  }  return sb.toString(); }  private char[] ns(int n) {  char[] buf = new char[n];  int b = skip(), p = 0;  while(p < n && !(isSpaceChar(b))){  buf[p++] = (char)b;  b = readByte();  }  return n == p ? buf : Arrays.copyOf(buf, p); }  private char[][] nm(int n, int m) {  char[][] map = new char[n][];  for(int i = 0;i < n;i++)map[i] = ns(m);  return map; }  private int[] na(int n) {  int[] a = new int[n];  for(int i = 0;i < n;i++)a[i] = ni();  return a; }  private int ni() {  int num = 0, b;  boolean minus = false;  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));  if(b == '-'){  minus = true;  b = readByte();  }   while(true){  if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');  }else{   return minus ? -num : num;  }  b = readByte();  } }  private long nl() {  long num = 0;  int b;  boolean minus = false;  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));  if(b == '-'){  minus = true;  b = readByte();  }   while(true){  if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');  }else{   return minus ? -num : num;  }  b = readByte();  } }  private boolean oj = System.getProperty("ONLINE_JUDGE") != null; private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); } }
4,public class A { public static void main(String[] args) throws IOException {  BufferedReader in = new BufferedReader(new InputStreamReader(System.in));  String s = new String(in.readLine());  int len=s.length();  int ans=0;  for (int i=0;i<len-1;i++) {  for (int j=i+1;j<len;j++) {   int score=0;   boolean flag=true;   for (int k=0;k+j<len && flag;k++) {   if (s.charAt(i+k)==s.charAt(j+k)) {    score++;   } else {    flag=false;   }   }   if (score>ans) {   ans=score;   }  }  }  System.out.println(ans); } }
1,public class AA{  public static void main(String[] args) {  Scanner sc=new Scanner(System.in);   int t=0;   if(sc.hasNextInt()) {   t=sc.nextInt();   }   while(t>0) {   t--;   int n=sc.nextInt();   String ans="NO";   if(n%2==0) {    int p=n/2;    if(Math.ceil(Math.sqrt((double)p)) == Math.floor(Math.sqrt((double)p))){    ans="YES";    }    else {    if(n%4==0) {     p=n/4;     if(Math.ceil(Math.sqrt((double)p)) == Math.floor(Math.sqrt((double)p))){     ans="YES";     }    }    }   }   System.out.println(ans);   }  } }
2,public class C {  public static void main(String[] args) throws IOException {  Scanner sc = new Scanner(System.in);  PrintWriter out = new PrintWriter(System.out);  long n = sc.nextLong();  Long S = sc.nextLong();   long l = 0;  long h = n;   long ans = n;   while(l <= h) {  long mid = (l + h) / 2;  long t = mid;  long sum = 0;    while(t > 0) {   sum += t % 10;   t /= 10;  }    if(mid - sum < S) {   ans = mid;   l = mid + 1;  }else   h = mid - 1;  }   out.println(n - ans);  out.flush();  out.close(); }   static class Scanner  {  StringTokenizer st;  BufferedReader br;  public Scanner(InputStream System){br = new BufferedReader(new InputStreamReader(System));}  public String next() throws IOException  {  while (st == null || !st.hasMoreTokens())   st = new StringTokenizer(br.readLine());  return st.nextToken();  }  public String nextLine()throws IOException{return br.readLine();}  public int nextInt() throws IOException {return Integer.parseInt(next());}  public double nextDouble() throws IOException {return Double.parseDouble(next());}  public char nextChar()throws IOException{return next().charAt(0);}  public Long nextLong()throws IOException{return Long.parseLong(next());}  public boolean ready() throws IOException{return br.ready();}  public void waitForInput(){for(long i = 0; i < 3e9; i++);} }  }
3,public class PythonIndentiation { PrintWriter pw = new PrintWriter(System.out); final static boolean debugmode = true; public static int k = 7;  public static int STMOD = 1000000000 + k;  public static Reader sc = new Reader();  public static void main(String[] args) throws IOException {  int commands = sc.nextInt();  int[][] dp = new int[5000][5000];  int interesting = 0;  String prgm = "";  while (interesting < commands){  byte q = sc.read();  if (q == 115 ){   interesting += 1;   prgm += "s";  }  else if (q == 102){   prgm += "f";   interesting += 1;  }  }   dp[0][0] = 1;  for(int line = 1;line<commands;line++){  if(prgm.charAt(line-1) == 'f'){   for(int indent = 1;indent<Math.min(2*line + 1, 5000);indent++){   dp[line][indent] = dp[line-1][indent-1];   }  }  else if(prgm.charAt(line-1) == 's'){   int w = 0;   for(int indent = Math.min(2*line + 1, 4999);indent >= 0;indent--){   w = (w + dp[line-1][indent])% STMOD;      dp[line][indent] = w ;   }  }  }  int q = 0;  for(int i = 0;i<5000;i++){  q = ( q + dp[commands-1][i] ) % STMOD;  }  System.out.println(q);     } public static String parseIt(int commands) throws IOException{  String c = "";  System.out.println(sc.read());  return c; } static class Reader  {   final private int BUFFER_SIZE = 1 << 16;   private DataInputStream din;   private byte[] buffer;   private int bufferPointer, bytesRead;    public Reader()   {    din = new DataInputStream(System.in);    buffer = new byte[BUFFER_SIZE];    bufferPointer = bytesRead = 0;   }    public Reader(String file_name) throws IOException   {    din = new DataInputStream(new FileInputStream(file_name));    buffer = new byte[BUFFER_SIZE];    bufferPointer = bytesRead = 0;   }    public String readLine() throws IOException   {    byte[] buf = new byte[64];    int cnt = 0, c;    while ((c = read()) != -1)    {     if (c == '\n')      break;     buf[cnt++] = (byte) c;    }    return new String(buf, 0, cnt);   }    public int nextInt() throws IOException   {    int ret = 0;    byte c = read();    while (c <= ' ')     c = read();    boolean neg = (c == '-');    if (neg)     c = read();    do    {     ret = ret * 10 + c - '0';    } while ((c = read()) >= '0' && c <= '9');     if (neg)     return -ret;    return ret;   }    public long nextLong() throws IOException   {    long ret = 0;    byte c = read();    while (c <= ' ')     c = read();    boolean neg = (c == '-');    if (neg)     c = read();    do {     ret = ret * 10 + c - '0';    }    while ((c = read()) >= '0' && c <= '9');    if (neg)     return -ret;    return ret;   }    public double nextDouble() throws IOException   {    double ret = 0, div = 1;    byte c = read();    while (c <= ' ')     c = read();    boolean neg = (c == '-');    if (neg)     c = read();     do {     ret = ret * 10 + c - '0';    }    while ((c = read()) >= '0' && c <= '9');     if (c == '.')    {     while ((c = read()) >= '0' && c <= '9')     {      ret += (c - '0') / (div *= 10);     }    }     if (neg)     return -ret;    return ret;   }    private void fillBuffer() throws IOException   {    bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);    if (bytesRead == -1)     buffer[0] = -1;   }    private byte read() throws IOException   {    if (bufferPointer == bytesRead)     fillBuffer();    return buffer[bufferPointer++];   }    public void close() throws IOException   {    if (din == null)     return;    din.close();   }  }   }
2,public class B {  static long n, k;  static long sum(long mid) {  long tmpSum = k * (k + 1) / 2;  long nsum = (mid - 1) * (mid) / 2;  return tmpSum - nsum; }  public static void main(String[] args) throws IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  PrintWriter out = new PrintWriter(System.out);  StringTokenizer sc = new StringTokenizer(br.readLine());  n = Long.parseLong(sc.nextToken()) - 1;  k = Long.parseLong(sc.nextToken()) - 1;  if (n == 0)  out.println(0);  else if (sum(1) < n)  out.println(-1);  else {  long lo = 1;  long hi = k;  long mid;  while (lo < hi) {   mid = (lo + hi) / 2;   long sum = sum(mid);   if (n - sum < 0)   lo = mid + 1;   else if (n - sum < mid) {   hi = mid;   } else   hi = mid - 1;  }  out.println((k - lo + 1) + (n - sum(lo) == 0 ? 0 : 1));  }  br.close();  out.close(); } }
1,public class B {  static class Scanner {  BufferedReader rd;  StringTokenizer tk;  public Scanner() throws IOException  {  rd=new BufferedReader(new InputStreamReader(System.in));  tk=new StringTokenizer(rd.readLine());  }  public String next() throws IOException  {  while(!tk.hasMoreTokens())   tk=new StringTokenizer(rd.readLine());  return tk.nextToken();  }  public int nextInt() throws NumberFormatException, IOException  {  return Integer.valueOf(this.next());  } }  static int N,K; static int[] array=new int[100010];  public static void main(String args[]) throws IOException{  Scanner sc=new Scanner();  N=sc.nextInt();  K=sc.nextInt();  for(int i=0;i<N;i++)  array[i]=sc.nextInt();  TreeMap<Integer,Integer> map=new TreeMap<Integer,Integer>();  boolean flag=false;  for(int i=0;i<N;i++){  if (!map.containsKey(array[i])){   map.put(array[i], i);   if (map.size()==K){   flag=true;   break;   }  }  else   map.put(array[i], i);  }  if (!flag)  System.out.println("-1 -1");  else{  Set<Integer> s=map.keySet();  int l=Integer.MAX_VALUE;  int r=Integer.MIN_VALUE;  for(int k: s){   int tmp=map.get(k);   l=Math.min(l, tmp);   r=Math.max(r, tmp);  }  System.out.println((l+1)+" "+(r+1));  } } }
3,public class Main {  public static void main(String[] args) throws IOException {   new Main().run();  }   private void run() throws IOException {   BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));   int n = Integer.parseInt(reader.readLine());   int[] arr = new int[n];   String[] line = reader.readLine().split("\\s");   for (int i = 0; i < n; i++) {    arr[i] = Integer.parseInt(line[i]);   }   Arrays.sort(arr);   Set<Integer> numbers = new HashSet<>();   for (int i = 0; i < arr.length; i++) {    Iterator<Integer> iter = numbers.iterator();    boolean contains = false;    while (iter.hasNext()){     int elem = iter.next();     if(gcd(elem, arr[i]) == elem){      contains = true;     }    }    if(!contains)     numbers.add(arr[i]);   }    System.out.println(numbers.size());  }  private int gcd(int a, int b){   while (a != b){    if(a > b)     a -= b;    else     b -= a;   }   return a;  }  }
0,public class Main{ public static void main(String[] args){  Scanner scan = new Scanner(System.in);  int n = scan.nextInt();  if (n % 4 == 0 || n % 7 == 0 || n % 47 == 0 || n % 77 == 0 || n % 74 == 0 || n % 447 == 0 || n % 474 == 0 || n % 477 == 0 || n % 747 == 0 || n % 774 == 0 || n % 777 == 0)  System.out.println("YES");  else  System.out.println("NO"); } }
1,public class A {  public static void main(String[] args) throws Exception {   BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));     PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));   int n = Integer.parseInt(bf.readLine());   ArrayList<String> s1 = new ArrayList<String>();   ArrayList<String> s2 = new ArrayList<String>();   for(int i=0; i<n; i++) s1.add(bf.readLine());   for(int i=0; i<n; i++) s2.add(bf.readLine());   Map<String, Integer> mp1 = new HashMap<String, Integer>();   Map<String, Integer> mp2 = new HashMap<String, Integer>();   for(String s : s1) mp1.put(s, 0);   for(String s : s1) mp1.put(s, mp1.get(s)+1);   for(String s : s2) mp2.put(s, 0);   for(String s : s2) mp2.put(s, mp2.get(s)+1);   for(String s : mp1.keySet()) {   while(mp1.get(s) > 0) {    if(mp2.containsKey(s)) {     if(mp2.get(s) > 0) {     mp1.put(s, mp1.get(s)-1);     mp2.put(s, mp2.get(s)-1);    }    else break;    }    else break;   }   }   for(String s : mp2.keySet()) {   while(mp2.get(s) > 0) {    if(mp1.containsKey(s)) {     if(mp1.get(s) > 0) {     mp2.put(s, mp2.get(s)-1);     mp1.put(s, mp1.get(s)-1);    }    else break;    }    else break;   }   }   long sum = 0;   for(String s : mp1.keySet()) sum += mp1.get(s);   out.println(sum);                  out.close(); System.exit(0);  } }
0,public class lcm { static int n;  public static void main(String[] args) throws IOException {  BufferedReader in = new BufferedReader(new InputStreamReader(System.in));   n = Integer.parseInt(in.readLine());  System.out.println(lcm(n));  in.close(); }  static long lcm(int n) {  if (n == 1) return 1;  if (n == 2) return 2;   if(n%6==0) {  long ans = n-1;  ans *= n-2;  ans *= n-3;  return ans;  }   if (n%2==0) {  long ans = n;  ans *= n-1;  ans *= n-3;  return ans;  }   long ans = n;  ans *= n-1;  ans *= n-2;  return ans; } }
2,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  OutputWriter out = new OutputWriter(outputStream);  TaskA solver = new TaskA();  solver.solve(1, in, out);  out.close(); } } class TaskA {  public static long MOD = 1000000009L;  public long pow(long n, long p) {   if (p == 0)    return 1L;   if (p == 1)    return n;   long ret = 1L;   if (p % 2L != 0)    ret = n;   long tmp = pow(n, p / 2L);   ret = (ret * tmp) % MOD;   ret = (ret * tmp) % MOD;   return ret;  }  public long func(long n, long k) {   long times = n / k;   long ret = n - times * k;   ret += ((pow(2L, times + 1L) + MOD - 2L) % MOD) * k % MOD;   return ret;  }  public void solve(int testNumber, InputReader in, OutputWriter out) {   long n = in.readLong();   long m = in.readLong();   long k = in.readLong();   long wrong = n - m;   long wow = n / k;   long ans;   if (wrong >= wow)    ans = m;   else    ans = (func(n - wrong * k, k) + (k - 1L) * wrong % MOD) % MOD;   out.printLine(ans);  } } class InputReader {  private InputStream stream;  private byte[] buf = new byte[1024];  private int curChar;  private int numChars;  public InputReader(InputStream stream) {   this.stream = stream;  }  public int read() {   if (numChars == -1)    throw new InputMismatchException();   if (curChar >= numChars) {    curChar = 0;    try {     numChars = stream.read(buf);    }    catch (IOException e) {     throw new InputMismatchException();    }    if (numChars <= 0)     return -1;   }   return buf[curChar++];  }  public long readLong() {   int c = read();   while (isSpaceChar(c))    c = read();   int sgn = 1;   if (c == '-') {    sgn = -1;    c = read();   }   long res = 0L;   do {    if (c < '0' || c > '9')     throw new InputMismatchException();    res *= 10;    res += c - '0';    c = read();   } while (!isSpaceChar(c));   return res * sgn;  }  public static boolean isSpaceChar(int c) {   return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;  }  } class OutputWriter {  private final PrintWriter writer;  public OutputWriter(OutputStream outputStream) {   writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));  }  public OutputWriter(Writer writer) {   this.writer = new PrintWriter(writer);  }  public void print(Object...objects) {   for (int i = 0; i < objects.length; i++) {    if (i != 0)     writer.print(' ');    writer.print(objects[i]);   }  }  public void printLine(Object...objects) {   print(objects);   writer.println();  }  public void close() {   writer.close();  }  }
4,public class x1517D2 {  static final int INF = Integer.MAX_VALUE/3;  public static void main(String hi[]) throws Exception  {   FastScanner infile = new FastScanner();   int N = infile.nextInt();   int M = infile.nextInt();   int K = infile.nextInt();   int[][] weights1 = new int[N][M-1];   for(int r=0; r < N; r++)    weights1[r] = infile.nextInts(M-1);   int[][] weights2 = new int[N-1][M];   for(int r=0; r < N-1; r++)    weights2[r] = infile.nextInts(M);     int[][] res = new int[N][M];   if(K%2 == 1)   {    StringBuilder sb = new StringBuilder();    for(int r=0; r < N; r++)    {     for(int c=0; c < M; c++)      sb.append("-1 ");     sb.append("\n");    }    System.out.print(sb);    return;   }   int[][] dp = new int[N][M];   StringBuilder sb = new StringBuilder();   for(int k=0; k < K/2; k++)   {    int[][] next = new int[N][M];    for(int r=0; r < N; r++)     Arrays.fill(next[r], INF);    for(int r=0; r < N; r++)     for(int c=0; c < M; c++)     {      if(r > 0)       next[r-1][c] = min(next[r-1][c], dp[r][c]+weights2[r-1][c]);      if(r+1 < N)       next[r+1][c] = min(next[r+1][c], dp[r][c]+weights2[r][c]);      if(c > 0)       next[r][c-1] = min(next[r][c-1], dp[r][c]+weights1[r][c-1]);      if(c+1 < M)       next[r][c+1] = min(next[r][c+1], dp[r][c]+weights1[r][c]);     }    dp = next;   }   for(int r=0; r < N; r++)   {    for(int x: dp[r])     sb.append((2*x)+" ");    sb.append("\n");   }   System.out.print(sb);  } } class FastScanner {  private int BS = 1 << 16;  private char NC = (char) 0;  private byte[] buf = new byte[BS];  private int bId = 0, size = 0;  private char c = NC;  private double cnt = 1;  private BufferedInputStream in;  public FastScanner() {   in = new BufferedInputStream(System.in, BS);  }  public FastScanner(String s) {   try {    in = new BufferedInputStream(new FileInputStream(new File(s)), BS);   } catch (Exception e) {    in = new BufferedInputStream(System.in, BS);   }  }  private char getChar() {   while (bId == size) {    try {     size = in.read(buf);    } catch (Exception e) {     return NC;    }    if (size == -1) return NC;    bId = 0;   }   return (char) buf[bId++];  }  public int nextInt() {   return (int) nextLong();  }  public int[] nextInts(int N) {   int[] res = new int[N];   for (int i = 0; i < N; i++) {    res[i] = (int) nextLong();   }   return res;  }  public long[] nextLongs(int N) {   long[] res = new long[N];   for (int i = 0; i < N; i++) {    res[i] = nextLong();   }   return res;  }  public long nextLong() {   cnt = 1;   boolean neg = false;   if (c == NC) c = getChar();   for (; (c < '0' || c > '9'); c = getChar()) {    if (c == '-') neg = true;   }   long res = 0;   for (; c >= '0' && c <= '9'; c = getChar()) {    res = (res << 3) + (res << 1) + c - '0';    cnt *= 10;   }   return neg ? -res : res;  }  public double nextDouble() {   double cur = nextLong();   return c != '.' ? cur : cur + nextLong() / cnt;  }  public double[] nextDoubles(int N) {   double[] res = new double[N];   for (int i = 0; i < N; i++) {    res[i] = nextDouble();   }   return res;  }  public String next() {   StringBuilder res = new StringBuilder();   while (c <= 32) c = getChar();   while (c > 32) {    res.append(c);    c = getChar();   }   return res.toString();  }  public String nextLine() {   StringBuilder res = new StringBuilder();   while (c <= 32) c = getChar();   while (c != '\n') {    res.append(c);    c = getChar();   }   return res.toString();  }  public boolean hasNext() {   if (c > 32) return true;   while (true) {    c = getChar();    if (c == NC) return false;    else if (c > 32) return true;   }  } }
3,public class D { FastScanner in; PrintWriter out; boolean systemIO = true;  public void solve() {  int n = in.nextInt();  int[] a = new int[n];  for (int i = 0; i < a.length; i++) {  a[i] = in.nextInt();  }  int x = 0;  for (int i = 0; i < a.length; i++) {  for (int j = i + 1; j < a.length; j++) {   if (a[i] > a[j]) {   x++;   }  }  }  boolean ans = x % 2 == 0;  int m = in.nextInt();  for (int i = 0; i < m; i++) {  int len = -in.nextInt() + in.nextInt();  len = len * (len + 1) / 2;  if (len % 2 == 1) {   ans = !ans;  }  if (ans) {   out.println("even");  } else {   out.println("odd");  }  } }  public void run() {  try {  if (systemIO) {   in = new FastScanner(System.in);   out = new PrintWriter(System.out);  } else {   in = new FastScanner(new File("segments.in"));   out = new PrintWriter(new File("segments.out"));  }  solve();   out.close();  } catch (IOException e) {  e.printStackTrace();  } }  class FastScanner {  BufferedReader br;  StringTokenizer st;  FastScanner(File f) {  try {   br = new BufferedReader(new FileReader(f));  } catch (FileNotFoundException e) {   e.printStackTrace();  }  }  FastScanner(InputStream f) {  br = new BufferedReader(new InputStreamReader(f));  }  String nextLine() {  try {   return br.readLine();  } catch (IOException e) {   return null;  }  }  String next() {  while (st == null || !st.hasMoreTokens()) {   try {   st = new StringTokenizer(br.readLine());   } catch (IOException e) {   e.printStackTrace();   }  }  return st.nextToken();  }  int nextInt() {  return Integer.parseInt(next());  }  long nextLong() {  return Long.parseLong(next());  }  double nextDouble() {  return Double.parseDouble(next());  }  }   public static void main(String[] arg) {  new D().run(); } }
5,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  Scanner in = new Scanner(inputStream);  PrintWriter out = new PrintWriter(outputStream);  TaskA solver = new TaskA();  solver.solve(1, in, out);  out.close(); } } class TaskA { public void solve(int testNumber, Scanner in, PrintWriter out) {   int n = in.nextInt();   int a = in.nextInt();   int b = in.nextInt();   int[] chores = new int[n];   for (int i=0; i<n; i++) chores[i] = in.nextInt();   Arrays.sort(chores);   out.println(chores[b]-chores[b-1]);  } }
3,public class PythonIndentation { public static void main(String args[]) {  Scanner in = new Scanner(System.in) ;  int n = in.nextInt() ;  boolean[] lst = new boolean[n] ;  for(int i=0;i<n;i++)  {  lst[i] = (in.next().equals("s"))?false:true ;  }  System.out.println(dp(lst)) ; }  static int dp(boolean[] lst) {  int[][] dp = new int[2][lst.length] ;  dp[0][0] = 1 ;  for(int i=1;i<lst.length;i++)  {    for(int j=0;j<lst.length;j++)  {   if(lst[i-1])   {   if(j==0)    dp[i%2][j] = 0 ;   else    dp[i%2][j] = dp[(i-1)%2][j-1] ;   }     else   {   if(j==0)   {    int temp = 0 ;    for(int k=0;k<lst.length;k++)    temp = (temp+dp[(i-1)%2][k])%1000000007 ;    dp[i%2][j] = temp ;   }   else    dp[i%2][j] = (dp[i%2][j-1]-dp[(i-1)%2][j-1])%1000000007 ;   }  }  }  int ans = 0 ;  for(int i=0;i<lst.length;i++)  {  ans = (ans + dp[(lst.length-1)%2][i])%1000000007 ;  }  if(ans<0)  ans = ans + 1000000007 ;   return ans ; } }
2,public class ReallyBigNumbers { public static void main(String[] args) {  @SuppressWarnings("resource")  Scanner sc = new Scanner(System.in);  long n = sc.nextLong();  long s = sc.nextLong();  long bigNums = 0;  long inARow = 0;  for (long i = s; i <= n; i++) {  if (inARow == 9) {   bigNums += (n - i+1);   break;  } else {   if (i >= s + digitSum(i)) {   bigNums++;   inARow++;   } else {   inARow = 0;   }  }  }  System.out.println(bigNums); }  public static long digitSum(long a) {  long sum = a % 10;  if (9 < a) {  a /= 10;  sum += digitSum(a);  }  return sum; } }
4,public class Solution {   final InputReader in = new InputReader(System.in);   final PrintWriter out = new PrintWriter(System.out);  int n,m;  void solve() {   n = in.nextInt();   m = in.nextInt();   int k = in.nextInt();   int[][] hor = new int[n][m-1];   int[][] ver = new int[n-1][m];   for(int i=0; i<n; i++) {    for(int j=0; j<m-1; j++) {     hor[i][j] = in.nextInt();    }   }   for(int i=0; i<n-1; i++) {    for(int j=0; j<m; j++) {     ver[i][j] = in.nextInt();    }   }   int[][] ans = new int[n][m];   if(k%2==1) {    for(int i=0; i<n; i++)     Arrays.fill(ans[i], -1);   } else {    for(int dummy=0; dummy<k>>1; dummy++) {     int[][] newAns = new int[n][m];     for(int i=0; i<n; i++) {      Arrays.fill(newAns[i], Integer.MAX_VALUE);      for(int j=0; j<m; j++) {       if(isGood(i+1, j)) {        newAns[i][j] = Math.min(newAns[i][j], 2*ver[i][j] + ans[i+1][j]);       }       if(isGood(i, j+1)) {        newAns[i][j] = Math.min(newAns[i][j], 2*hor[i][j] + ans[i][j+1]);       }       if(isGood(i, j-1)) {        newAns[i][j] = Math.min(newAns[i][j], 2*hor[i][j-1] + ans[i][j-1]);       }       if(isGood(i-1, j)) {        newAns[i][j] = Math.min(newAns[i][j], 2*ver[i-1][j] + ans[i-1][j]);       }      }     }     ans = newAns;    }   }   for(int i=0; i<n; i++) {    for(int j=0; j<m; j++) {     out.print(ans[i][j] + " ");    }    out.println();   }  }  boolean isGood(int i, int j) {   return i>=0 && i<n && j>=0 && j<m;  }  private void shuffle(int[] a) {   int n = a.length;   Random random = new Random();   random.nextInt();   for (int i = 0; i < n; i++) {    int change = i + random.nextInt(n - i);    swap(a, i, change);   }  }  private static void swap(int[] a, int i, int change) {   int helper = a[i];   a[i] = a[change];   a[change] = helper;  }  public static void main(final String[] args) throws FileNotFoundException {   final Solution s = new Solution();   final Long t1 = System.currentTimeMillis();   s.solve();   System.err.println(System.currentTimeMillis() - t1 + " ms");   s.out.close();  }  public Solution() throws FileNotFoundException {  }  private static class InputReader {   private final InputStream stream;   private final byte[] buf = new byte[1024];   private int curChar;   private int numChars;   Random r = new Random();   InputReader(final InputStream stream) {    this.stream = stream;   }   InputReader(final String fileName) {    InputStream stream = null;    try {     stream = new FileInputStream(fileName);    } catch (final FileNotFoundException e) {     e.printStackTrace();    }    this.stream = stream;   }   int[] nextArray(final int n) {    final int[] arr = new int[n];    for (int i = 0; i < n; i++)     arr[i] = nextInt();    return arr;   }   int[][] nextMatrix(final int n, final int m) {    final int[][] matrix = new int[n][m];    for (int i = 0; i < n; i++)     for (int j = 0; j < m; j++)      matrix[i][j] = nextInt();    return matrix;   }   String nextLine() {    int c = read();    while (isSpaceChar(c))     c = read();    final StringBuilder res = new StringBuilder();    do {     res.appendCodePoint(c);     c = read();    } while (!isEndOfLine(c));    return res.toString();   }   String nextString() {    int c = read();    while (isSpaceChar(c))     c = read();    final StringBuilder res = new StringBuilder();    do {     res.appendCodePoint(c);     c = read();    } while (!isSpaceChar(c));    return res.toString();   }   long nextLong() {    int c = read();    while (isSpaceChar(c))     c = read();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    long res = 0;    do {     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   int nextInt() {    int c = read();    while (isSpaceChar(c))     c = read();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   double nextDouble() {    return Double.parseDouble(nextString());   }   private int read() {    if (numChars == -1)     throw new InputMismatchException();    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (final IOException e) {      throw new InputMismatchException();     }     if (numChars <= 0)      return -1;    }    return buf[curChar++];   }   private boolean isSpaceChar(final int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   private boolean isEndOfLine(final int c) {    return c == '\n' || c == '\r' || c == -1;   }  }  }
1,public class Main {  static BufferedReader in=new BufferedReader(new InputStreamReader(System.in));  static StringTokenizer tok;  static boolean hasNext()  {   while(tok==null||!tok.hasMoreTokens())    try{     tok=new StringTokenizer(in.readLine());    }    catch(Exception e){     return false;    }   return true;  }  static String next()  {   hasNext();   return tok.nextToken();  }  static long nextLong()  {   return Long.parseLong(next());  }  static int nextInt()  {   return Integer.parseInt(next());  }  static PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));  public static void main(String[] args) {   int n = nextInt();   int a[] = new int[9];   int b[] = new int[9];   for(int i=0;i<n;i++){    String s = next();    if(s.equals("M")){     a[0]++;    }else if (s.equals("L")){     a[1]++;    }    else if (s.equals("XL")){     a[2]++;    }    else if (s.equals("XXL")){     a[3]++;    }    else if (s.equals("XXXL")){     a[4]++;    }    else if (s.equals("S")){     a[5]++;    }    else if (s.equals("XS")){     a[6]++;    }    else if (s.equals("XXS")){     a[7]++;    }    else if (s.equals("XXXS")){     a[8]++;    }   }   for(int i=0;i<n;i++){    String s = next();    if(s.equals("M")){     b[0]++;    }else if (s.equals("L")){     b[1]++;    }    else if (s.equals("XL")){     b[2]++;    }    else if (s.equals("XXL")){     b[3]++;    }    else if (s.equals("XXXL")){     b[4]++;    }    else if (s.equals("S")){     b[5]++;    }    else if (s.equals("XS")){     b[6]++;    }    else if (s.equals("XXS")){     b[7]++;    }    else if (s.equals("XXXS")){     b[8]++;    }   }   int ans = 0;   ans+=Math.abs(a[2]-b[2]);   ans+=Math.abs(a[3]-b[3]);   ans+=Math.abs(a[4]-b[4]);   int max = Math.abs(a[0]-b[0]);   max = max(max,Math.abs(a[1]-b[1]));   max = max(max,Math.abs(a[5]-b[5]));   ans+=max;   out.print(ans);   out.flush();  }  public static int max(int a,int b){   return a>b?a:b;  } }
2,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   Scanner in = new Scanner(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskB solver = new TaskB();   solver.solve(1, in, out);   out.close();  } } class TaskB {  public void solve(int testNumber, Scanner in, PrintWriter out) {   long n = in.nextLong();   long k = in.nextLong();   if (n == 1) {    out.println(0);    return;   }   if (k * (k - 1) < 2 * (n - 1)) {    out.println(-1);    return;   }   long sq2 = 4 * k * k - 4 * k + 1 - 4 * (2 * n - 2);   double sqrt = Math.sqrt(sq2);   long sq = (long) sqrt;   if ((sq + 1) * (sq + 1) == sq2) {    sq = sq + 1;   } else if ((sq - 1) * (sq - 1) == sq2) {    sq = sq - 1;   }   if (sq*sq == sq2) {    long kmin = (sq + 3) / 2;    out.println(k - kmin + 1);   } else {    long km = Math.max(2, (long) ((sqrt + 3) / 2.0) - 2);    while (((km + k - 2)*(k - km + 1) >= 2*(n-1))) {     ++km;    }    out.println(k - km + 2);   }  } }
5,public class ProblemA {  public static void main(String[] args) throws IOException {  BufferedReader s = new BufferedReader(new InputStreamReader(System.in));  PrintWriter out = new PrintWriter(System.out);  String[] line = s.readLine().split(" ");  int n = Integer.valueOf(line[0]);  int ht = Integer.valueOf(line[1]);   int[][] house = new int[n][2];  Set<Integer> candidates = new HashSet<Integer>();  for (int i = 0 ; i < n ; i++) {  String[] data = s.readLine().split(" ");  house[i][0] = Integer.valueOf(data[0]) * 2;  house[i][1] = Integer.valueOf(data[1]);  candidates.add(house[i][0] - house[i][1] - ht);  candidates.add(house[i][0] + house[i][1] + ht);  }   int ans = 0;  for (int p : candidates) {  int f = p - ht;  int t = p + ht;  boolean isok = true;  for (int i = 0 ; i < n ; i++) {   if (house[i][0] + house[i][1] <= f) {   } else if (house[i][0] - house[i][1] >= t) {   } else {   isok = false;   break;   }  }  if (isok) {   ans++;  }  }     out.println(ans);  out.flush(); }  public static void debug(Object... os){  System.err.println(Arrays.deepToString(os)); } }
5,public class C {  public static void main(String... args) {   Scanner sc = new Scanner(System.in);     int n = sc.nextInt();   sc.nextLine();   int[] x = new int[n];     int max=0, pos=-1;   for(int i=0; i<n; i++) {    x[i]=sc.nextInt();    if (max<x[i]) {     max=x[i];     pos=i;    }   }   x[pos] = (max==1) ? 2 : 1;     Arrays.sort(x);   for(int i=0; i<n; i++)    System.out.print(x[i]+" ");  }  }
0,public class A { static String file = ""; static BufferedReader br; static PrintWriter pw; static StringTokenizer st;  public static void main(String[] args) throws NumberFormatException,  IOException {  Locale.setDefault(Locale.US);  br = new BufferedReader(new InputStreamReader(System.in));  pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(   System.out)));  long a = nextLong();  long b = nextLong();  if (a % 2 == 1 && b - a == 2 || b - a == 1 || a == b) {  pw.print(-1);  } else {  if (a % 2 == 1)   a++;  pw.print(a + " " + (a + 1) + " " + (a + 2));  }  pw.close(); }  private static double yuza(double x1, double y1, double x2, double y2,  double x3, double y3) {  return (x1 * (y3 - y2) + x2 * (y1 - y3) + x3 * (y2 - y1)); }  private static void ffile() throws IOException {  br = new BufferedReader(new FileReader(file + "in"));  pw = new PrintWriter(new BufferedWriter(new FileWriter(file + "out"))); }  private static int nextInt() throws NumberFormatException, IOException {  return Integer.parseInt(next()); }  private static long nextLong() throws NumberFormatException, IOException {  return Long.parseLong(next()); }  private static double nextDouble() throws NumberFormatException,  IOException {  return Double.parseDouble(next()); }  private static String next() throws IOException {  while (st == null || !st.hasMoreTokens())  st = new StringTokenizer(br.readLine());  return st.nextToken(); } }
0,public class CF { public static void main(String[] args) throws IOException {  Scanner sc=new Scanner(System.in);  PrintWriter pw = new PrintWriter(System.out);   int n=sc.nextInt();   pw.print(n+n/2); pw.close(); sc.close(); } }
6,public class Main {   public static void main(String[] args) throws java.lang.Exception {  BufferedReader kek = new BufferedReader(new InputStreamReader(System.in));   PrintWriter outkek = new PrintWriter(System.out);  String[] input = kek.readLine().split(" ");  int X0 = Integer.parseInt(input[0]), Y0 = Integer.parseInt(input[1]), N = Integer.parseInt(kek.readLine());   int[] xCoords = new int[N + 1];  int[] yCoords = new int[N + 1];  int[][] distances = new int[N + 1][N + 1];  xCoords[N] = X0;  yCoords[N] = Y0;   for(int i = 0; i < N; i++){  input = kek.readLine().split(" ");  xCoords[i] = Integer.parseInt(input[0]);  yCoords[i] = Integer.parseInt(input[1]);  }   for(int i = 0; i <= N; i++){  for(int j = i + 1; j <= N; j++){   int temp = xCoords[i] - xCoords[j];   int temp2 = yCoords[i] - yCoords[j];   distances[i][j] = (temp * temp) + (temp2 * temp2);  }  }   int[] aa = new int[1 << N];  int[] bb = new int[1 << N];   for(int i = 1; i < 1 << N; i++){  int a = -1;  for(int j = 0; j < N; j++){   if((i & 1 << j) > 0){   a = j;   break;   }  }    int l = i ^ 1 << a;  int dist = distances[a][N] + distances[a][N];  aa[i] = aa[l] + dist;  bb[i] = l;    for(int k = a + 1; k < N; k++){   if((i & 1 << k) > 0) {   l = i ^ 1 << a ^ 1 << k;   dist = distances[a][N] + distances[k][N] + distances[a][k];   if(aa[l] + dist < aa[i]){    aa[i] = aa[l] + dist;    bb[i] = l;   }   }  }  }   int fin = (1 << N) - 1;  outkek.println(aa[fin]);  outkek.print('0');  while (fin != 0){  int temp1 = bb[fin];  int temp2 = fin ^ temp1;  for(int i = 0; i < N; i++){   if((temp2 & 1 << i) > 0){   outkek.print(" " + (i + 1));   }  }  outkek.print(" 0");  fin = temp1;  }  kek.close();  outkek.close(); }  }
5,public class A implements Runnable{     public void run() {   int n = nextInt();   int[] arr = new int[n];   boolean allOne = true;   for (int i = 0; i < n; ++i) {    arr[i] = nextInt();    if (arr[i] != 1) {     allOne = false;    }   }   Arrays.sort(arr);   if (!allOne) {    out.print("1 ");   }   for (int i = 0; i < n-1; ++i) {    out.print(arr[i] + " ");   }   if (allOne) {    out.print("2");   }   out.println();   out.flush();  }   private static BufferedReader br = null;  private static PrintWriter out = null;  private static StringTokenizer stk = null;   public static void main(String[] args) {   br = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);   (new Thread(new A())).start();  }   private void loadLine() {   try {    stk = new StringTokenizer(br.readLine());   }   catch (IOException e) {    e.printStackTrace();   }  }   private String nextLine() {   try {    return br.readLine();   }   catch (IOException e) {    e.printStackTrace();   }   return null;  }   private Integer nextInt() {   while (stk==null||!stk.hasMoreTokens()) loadLine();   return Integer.parseInt(stk.nextToken());  }   private Long nextLong() {   while (stk==null||!stk.hasMoreTokens()) loadLine();   return Long.parseLong(stk.nextToken());  }   private String nextWord() {   while (stk==null||!stk.hasMoreTokens()) loadLine();   return (stk.nextToken());  }   private Double nextDouble() {   while (stk==null||!stk.hasMoreTokens()) loadLine();   return Double.parseDouble(stk.nextToken());  }    }
4,public class Main { public static void main(String args[]) throws IOException {  File f = new File("input.txt");  Scanner sc = new Scanner(f);  BufferedWriter bw = new BufferedWriter(new FileWriter(new File("output.txt")));  int n = sc.nextInt();  int m = sc.nextInt();  boolean[][] grid = new boolean[n][m];  for (int i = 0; i < n; i++) for (int j = 0; j < m; j++)   grid[i][j] = false;  Queue<Pair> q = new LinkedList<>();  int cnt = sc.nextInt();  for (int i = 0; i < cnt; i++) {  int x = sc.nextInt();  int y = sc.nextInt();  x--;  y--;  grid[x][y] = true;  q.add(new Pair(x, y));  }  Pair last = new Pair(-1, -1);  while (!q.isEmpty()) {  Pair current = q.poll();  last = current;  for (int i = -1; i <= 1; i++) {   for (int j = -1; j <= 1; j++) {   if (i != 0 && j != 0) continue;   if (inside(current.x + i, current.y + j, n, m) &&    !grid[current.x + i][current.y + j]) {    grid[current.x + i][current.y + j] = true;    q.add(new Pair(current.x + i, current.y + j));       }   }  }  }   bw.append((last.x + 1) + " " + (last.y + 1) + "\n");  bw.flush();  bw.close();   sc.close(); } static class Pair {  int x;  int y;  Pair(int x, int y) {  this.x = x;  this.y = y;  } } private static boolean inside(int a, int b, int n, int m) {  return (a >= 0 && a < n && b >= 0 && b < m); } }
3,public class PythonIndentation { public static void main(String args[]) {  Scanner in = new Scanner(System.in) ;  int n = in.nextInt() ;  boolean[] lst = new boolean[n] ;  for(int i=0;i<n;i++)  {  lst[i] = (in.next().equals("s"))?false:true ;  }  System.out.println(dp(lst)) ; }                     static long dp(boolean[] lst) {  long[][] dp = new long[lst.length][lst.length] ;  dp[0][0] = 1 ;  for(int i=1;i<lst.length;i++)  {           for(int j=0;j<lst.length;j++)  {   if(lst[i-1])   {   if(j==0)    dp[i][j] = 0 ;   else    dp[i][j] = dp[i-1][j-1] ;   }     else   {   if(j==0)   {    for(int k=0;k<lst.length;k++)    dp[i][j] = (dp[i][j]+dp[i-1][k])%1000000007 ;   }   else    dp[i][j] = (dp[i][j-1]-dp[i-1][j-1])%1000000007 ;                }  }  }       long ans = 0 ;  for(int i=0;i<lst.length;i++)  {  ans = (ans + dp[lst.length-1][i])%1000000007 ;  }  if(ans<0)  ans = ans + 1000000007 ;  return ans ; } }
1,public class Beta17PA {  boolean[] isPrime = new boolean[1001]; int[] prime = new int[200];  public static void main(String[] args) {   new Beta17PA().solve(); }  public void solve() {  Scanner scan = new Scanner(System.in);  int n, k;  n = scan.nextInt();  k = scan.nextInt();  init();  int m = 0;  for(int i=2; i<=n; i++) {  if(check(i)) m ++;  }  if(m>=k) System.out.println("YES");  else System.out.println("NO"); }  private boolean check(int n) {  if(n<6||!isPrime[n]) return false;  int d = n-1;  for(int i=0; i<199&&prime[i]+prime[i+1]<=d; i++) {  if(prime[i]+prime[i+1]==d) return true;  }  return false; }  private void init() {  Arrays.fill(isPrime, true);  isPrime[0] = isPrime[1] = false;  for(int i=2; i<1001; i++) {  if(!isPrime[i]) continue;  for(int j=i+i; j<1001; j+=i) {   isPrime[j] = false;  }  }  int count = 0;  for(int i=2; i<1001; i++) {  if(isPrime[i]) prime[count++] = i;  } } }
3,public class D {  public static void solve(FastScanner fs) {  int n=fs.nextInt();  int[] a=fs.readArray(n);  boolean even=((countInversions(a)&1)==0);  int q=fs.nextInt();  for (int i=0; i<q; i++) {  int start=fs.nextInt();  int end=fs.nextInt();  int diff=end-start;  boolean evenChange=(diff+1)/2%2==0;  even^=!evenChange;  System.out.println(even?"even":"odd");  } }  private static int countInversions(int[] a) {  int c=0;  for (int i=0; i<a.length; i++) {  for (int j=i+1; j<a.length; j++)   if (a[j]<a[i])   c++;  }  return c; }      public static void main(String[] args) throws NumberFormatException, IOException {  FastScanner scanner = new FastScanner(System.in);  solve(scanner); }   private static class FastScanner {  BufferedReader br;  StringTokenizer st;  public FastScanner(InputStream in) {  br = new BufferedReader(new InputStreamReader(in));  }  String next() {  while (st == null || !st.hasMoreElements()) {   try {   st = new StringTokenizer(br.readLine());   } catch (IOException e) {   e.printStackTrace();   }  }  return st.nextToken();  }  int nextInt() {  return Integer.parseInt(next());  }  long nextLong() {  return Long.parseLong(next());  }  double nextDouble() {  return Double.parseDouble(next());  }  String nextLine() {  String str = "";  try {   str = br.readLine();  } catch (IOException e) {   e.printStackTrace();  }  return str;  }  int[] readArray(int n) {  int[] a=new int[n];  for (int i=0; i<n; i++)   a[i]=nextInt();  return a;  } } }
3,public class C {  public static void main(String[] args) throws IOException {   Scanner sc = new Scanner();   PrintWriter out = new PrintWriter(System.out);   int n = sc.nextInt(), r = sc.nextInt();   int[] x = new int[n];   for(int i = 0; i < n; i++)    x[i] = sc.nextInt();   double[] ans = new double[n];   for(int i = 0; i < n; i++) {    ans[i] = r;    for(int j = 0; j < i; j++) {     int d = Math.abs(x[i] - x[j]);     if(d > 2 * r)      continue;     int h = 2 * r;     double yd = Math.sqrt(h * h - d * d);     ans[i] = Math.max(ans[i], ans[j] + yd);    }    out.print(ans[i]);    if(i == n - 1)     out.println();    else     out.print(" ");   }   out.flush();   out.close();  }  static class Scanner {   BufferedReader br; StringTokenizer st;   Scanner() {    br = new BufferedReader(new InputStreamReader(System.in));   }   String next() throws IOException {    while(st == null || !st.hasMoreTokens())     st = new StringTokenizer(br.readLine());    return st.nextToken();   }   int nextInt() throws IOException {    return Integer.parseInt(next());   }  } }
6,public class Main {   static int N, M; static long[] C; static int[][] g; static long[][] DP; public static void main(String[] args) {  InputReader r = new InputReader(System.in);   N = r.nextInt();  M = r.nextInt();   g = new int[N][N];   C = new long[N + 1];   DP = new long[1 << N][N];   for(int k = 0; k < M; k++){  int i = r.nextInt() - 1;  int j = r.nextInt() - 1;    g[i][j] = g[j][i] = 1;  }   for(long[] i : DP)  Arrays.fill(i, -1);   long ret = 0;  for(int s = 0; s < N; s++){  ret += go(s, 1 << s, s);  }   System.out.println(ret / 2); }  private static long go(int s, int m, int e) {  if(DP[m][e] != -1)return DP[m][e];   long cnt = 0;  for(int j = s; j < N; j++)if(g[e][j] == 1){  if((m & (1 << j)) != 0){   if(s == j && Integer.bitCount(m) >= 3){   cnt++;   }  }else{   cnt += go(s, m | 1 << j, j);  }  }  return DP[m][e] = cnt; }  static class InputReader {  private BufferedReader reader;  private StringTokenizer tokenizer;  public InputReader(InputStream stream) {  reader = new BufferedReader(new InputStreamReader(stream));  tokenizer = null;  }  public String nextLine() {  try {   return reader.readLine();  } catch (IOException e) {     e.printStackTrace();   return null;  }  }  public String next() {  while (tokenizer == null || !tokenizer.hasMoreTokens()) {   try {   tokenizer = new StringTokenizer(reader.readLine());   } catch (IOException e) {   throw new RuntimeException(e);   }  }  return tokenizer.nextToken();  }  public int nextInt() {  return Integer.parseInt(next());  }  public long nextLong() {  return Long.parseLong(next());  }   public double nextDouble(){  return Double.parseDouble(next());  } } }
4,public class C_1523 {  static Scanner input = new Scanner(System.in); static int n;  public static void main(String[] args) {  int t = input.nextInt();  for(int test = 0; test < t; test++){  n = input.nextInt();  int num = input.nextInt();  if(num == 1){   n--;   recur("");  }else{   System.out.println("ERROR");  }  } }  public static int recur(String before){  int num = 1;  System.out.println(before + num);  while(n > 0){  int val = input.nextInt();  n--;  if(val == 1){   val = recur(before + num + ".");  }  if(val == num + 1){   num++;   System.out.println(before + num);  }else{   return val;  }  }  return -1; } }
6,public class D implements Runnable { public static void main(String[] args) {  new D().run(); }  class FastScanner {  BufferedReader br;  StringTokenizer st;  boolean eof;  String buf;  public FastScanner(String fileName) throws FileNotFoundException {  br = new BufferedReader(new FileReader(fileName));  nextToken();  }  public FastScanner(InputStream stream) {  br = new BufferedReader(new InputStreamReader(stream));  nextToken();  }  String nextToken() {  while (st == null || !st.hasMoreTokens()) {   try {   st = new StringTokenizer(br.readLine());   } catch (Exception e) {   eof = true;   break;   }  }  String ret = buf;  buf = eof ? "-1" : st.nextToken();  return ret;  }  int nextInt() {  return Integer.parseInt(nextToken());  }  long nextLong() {  return Long.parseLong(nextToken());  }  double nextDouble() {  return Double.parseDouble(nextToken());  }  void close() {  try {   br.close();  } catch (Exception e) {   }  }  boolean isEOF() {  return eof;  } }  FastScanner sc; PrintWriter out;  public void run() {  Locale.setDefault(Locale.US);  try {  sc = new FastScanner(System.in);  out = new PrintWriter(System.out);  solve();  sc.close();  out.close();  } catch (Throwable e) {  e.printStackTrace();  System.exit(1);  } }  int nextInt() {  return sc.nextInt(); }  String nextToken() {  return sc.nextToken(); }  long nextLong() {  return sc.nextLong(); }  double nextDouble() {  return sc.nextDouble(); }  void solve() {   int n = nextInt();  int m = nextInt();  boolean[][] edges = new boolean[n][n];  boolean[] edge = new boolean[(n << 5) | n];  for (int i = 0; i < m; i++) {  int x = nextInt() - 1;  int y = nextInt() - 1;  edges[x][y] = edges[y][x] = true;  edge[(x << 5) | y] = edge[(y << 5) | x] = true;  }  long[][] dp = new long[n][1 << n];  long ans = 0;  for (int i = 0; i < n; i++) {  for (int mask2 = 1; mask2 < 1 << (n - i - 1); ++mask2) {   for (int j = i + 1; j < n; j++) {   dp[j][mask2 << i << 1] = 0;   }  }  for (int j = i + 1; j < n; j++) {   if (edges[i][j]) {   dp[j][1 << j] = 1;   }  }  for (int mask2 = 1; mask2 < 1 << (n - i - 1); ++mask2) {   int mask = (mask2 << i << 1);   if ((mask & (mask - 1)) == 0) {   continue;   }   for (int j = i + 1; j < n; j++) {   if (((mask >> j) & 1) == 0) {    continue;   }   dp[j][mask] = 0;   for (int k = i + 1; k < n; k++) {    if (((mask >> k) & 1) == 0 || !edge[(j << 5) | k]) {    continue;    }    dp[j][mask] += dp[k][mask & ~(1 << j)];   }   if (edge[(i << 5) | j]) {    ans += dp[j][mask];   }   }  }  }     out.println(ans / 2);            } }
6,public class cf2{ static int x0; static int y0; static int x1; static int y1; static HashMap<Integer,HashSet<Integer>>allowed; static HashMap<Integer,HashMap<Integer,Integer>>cost; static int []dx= {-1,-1,-1,0,0,0,1,1,1}; static int []dy= {-1,0,1,-1,0,1,-1,0,1}; static int highbound=(int)1e9; static boolean valid(int i,int j) {  if(i>=1 && i<=highbound && j>=1 && j<=highbound && allowed.containsKey(i) && allowed.get(i).contains(j))return true;  return false; } static long ans; static class Triple implements Comparable<Triple> {  int i,j,cost;  Triple(int x, int y, int z){i = x; j = y; cost = z;}   public int compareTo(Triple t) {  return this.cost - t.cost;  }  public String toString() {  return i+" "+j+" "+cost;  }   } public static int dijkstra() {  PriorityQueue<Triple> q = new PriorityQueue<Triple>();  q.add(new Triple(x0,y0,0));  HashMap<Integer,Integer>z=new HashMap<Integer,Integer>();z.put(y0,0);  cost.put(x0,z);  while(!q.isEmpty())  {   Triple cur = q.remove();    if(cur.cost > cost.getOrDefault(cur.i,new HashMap<Integer,Integer>()).getOrDefault(cur.j,1000000000))   continue;  for(int k = 0; k < 9; k++)  {   int x = cur.i + dx[k];   int y = cur.j + dy[k];   int c=cost.getOrDefault(x,new HashMap<Integer,Integer>()).getOrDefault(y,1000000000);   if(valid(x,y) && cur.cost +1 < c)   {   HashMap<Integer,Integer>zz=new HashMap<Integer,Integer>();zz.put(y,cur.cost+1);   cost.put(x,zz);   q.add(new Triple(x,y,cur.cost+1));   }  }  }     return cost.getOrDefault(x1,new HashMap<Integer,Integer>()).getOrDefault(y1,-1); } static int t;static int n; static int []ds; static int []gs; static int [][]memo; static int dp(int lastg,int msk,int sum) {  if(sum==t)return 1;  if(msk==(1<<n)-1) {  return 0;  }  if(memo[lastg][msk]!=-1)return memo[lastg][msk];  int tot=0;  for(int i=0;i<n;i++) {  if(((1<<i)&msk)==0 && gs[i]!=lastg) {   tot=(tot+dp(gs[i],msk|(1<<i),sum+ds[i]))%(1000000007);  }  }  return memo[lastg][msk]=tot; }  public static void main(String[] args) throws IOException{   MScanner sc = new MScanner(System.in);   PrintWriter pw=new PrintWriter(System.out);   n=sc.nextInt();   t=sc.nextInt();   ds=new int[n];gs=new int[n];   for(int i=0;i<n;i++) {   ds[i]=sc.nextInt();gs[i]=sc.nextInt();   }   memo=new int[4][1<<n];   for(int []i:memo)Arrays.fill(i,-1);   pw.println(dp(0, 0,0));   pw.flush();  }  static long gcd(long a, long b) {   if (b == 0)  return a;  return gcd(b, a % b); }  static int[]primes;  static int sizeofp=0; static int[] isComposite;  static void sieve(int N)  {  isComposite = new int[N+1];    isComposite[0] = isComposite[1] = 1;   primes = new int[N];   for (int i = 2; i <= N; ++i)     if (isComposite[i] == 0)     {   primes[sizeofp++]=i;;   if(1l * i * i <= N)   for (int j = i * i; j <= N; j += i)    isComposite[j] = 1;  }  }  static class pair implements Comparable<pair>{  int num;int idx;  pair(int x,int y){   num=x;idx=y;  }  @Override  public int compareTo(pair o) {  if(num!=o.num) {   return num-o.num;  }  return idx-o.idx;  }  @Override   public int hashCode()   {    return Objects.hash(num,idx) ;   }  public boolean equals(pair o) {  if(this.compareTo(o)==0)return true;  return false;  }  public String toString() {  return "("+0+" "+0+")";  }  } static class MScanner  {  StringTokenizer st;  BufferedReader br;   public MScanner(InputStream s){ br = new BufferedReader(new InputStreamReader(s));}   public String next() throws IOException   {   while (st == null || !st.hasMoreTokens())     st = new StringTokenizer(br.readLine());   return st.nextToken();  }   public int nextInt() throws IOException {return Integer.parseInt(next());}    public long nextLong() throws IOException {return Long.parseLong(next());}   public String nextLine() throws IOException {return br.readLine();}    public double nextDouble() throws IOException  {   String x = next();   StringBuilder sb = new StringBuilder("0");   double res = 0, f = 1;   boolean dec = false, neg = false;   int start = 0;   if(x.charAt(0) == '-')   {    neg = true;    start++;   }   for(int i = start; i < x.length(); i++)    if(x.charAt(i) == '.')    {     res = Long.parseLong(sb.toString());     sb = new StringBuilder("0");     dec = true;    }    else    {     sb.append(x.charAt(i));     if(dec)      f *= 10;    }   res += Long.parseLong(sb.toString()) / f;   return res * (neg?-1:1);  }    public boolean ready() throws IOException {return br.ready();}   } }
2,public class code { public static void main(String[] args) throws Exception {  Scanner sc = new Scanner(System.in);  int q = sc.nextInt();  long[] d = new long[30];  d[0] = 1;  for(int i=1;i<30;i++) d[i] = d[i-1]*4;  for(int z=0;z<q;z++){   long r = 0;   long n = sc.nextLong();   long k = sc.nextLong();   long c = 1;   while(k>0&&n>=1){    if(k<=r) {     k=0;     break;    }    n--;    k-=c;    if(k<=0) break;           if(n>30) {     k=0;     break;    }    for(int i=0;i<(int)n;i++){     r += d[i]*(c*2-1);     if(k<=r) {      k=0;      break;     }    }    if(k<=r) {     k=0;     break;    }    c*=2;    c++;   }   if(k==0) System.out.println("YES "+n);   else System.out.println("NO");  } } }
0,public class A {  BufferedReader in; StringTokenizer st; PrintWriter out;  String next() throws IOException {  while (st == null || !st.hasMoreTokens())  st = new StringTokenizer(in.readLine());  return st.nextToken(); }  int nextInt() throws Exception {  return Integer.parseInt(next()); }  long nextLong() throws Exception {  return Long.parseLong(next()); }  double nextDouble() throws Exception {  return Double.parseDouble(next()); }  void solve() throws Exception {  int n = nextInt();  if(n%2==0)  out.println("4 "+(n-4));  else  out.println("9 "+(n-9)); }  void run() {  try {  Locale.setDefault(Locale.US);  in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(new OutputStreamWriter(System.out));  solve();  out.close();  } catch (Exception e) {  e.printStackTrace();  System.exit(1);  } }  public static void main(String[] args) {  new A().run(); } }
0,public class AgainTwentyfive { public static void main(String[] args) {  System.out.println("25"); } }
1,public class Main {  private static String encode(long rowNum) {  if(rowNum<=26) {   return String.valueOf((char)('A'+rowNum-1));  }  else {     if(rowNum%26==0){   return encode((long)Math.floor((double)rowNum/26)-1)    + String.valueOf((char)('A'+26-1));     }   else {   return encode((long)Math.floor((double)rowNum/26))    + String.valueOf((char)('A'+rowNum%26-1));   }  } }  private static long decode(String rowNum){  long result = 0;  char rowChars[] = rowNum.toCharArray();  for(int i=rowChars.length-1;i>=0;i--){  result+= (rowChars[i]-'A'+1) * (long)Math.pow(26,rowChars.length-i-1);  }  return result; }  public static void main(String arg[])throws IOException {  BufferedReader in = new BufferedReader(new InputStreamReader(System.in));  int t = Integer.parseInt(in.readLine());  Pattern p1 = Pattern.compile("R\\d+C\\d+");  Pattern p2 = Pattern.compile("\\d+");  for(int i=0;i<t;i++){  String input = in.readLine();  Matcher m1 = p1.matcher(input);  Matcher m2 = p2.matcher(input);  if(m1.matches()){   String result = "";   if(m2.find()){   result = m2.group();   }   if(m2.find()){   result = encode(Long.parseLong(m2.group()))+result;   }   System.out.println(result);  }  else {   String result = "R";   if(m2.find()){   result += m2.group();   }     result += "C";   System.out.println(result+decode(input.replaceAll(m2.group(),"")));  }  } } }
1,public class Main {    public static void main(String[] args) {     Scanner entrada = new Scanner (System.in);   int Primos []= {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,     71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,     151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,     233,239,     241,     251,     257,     263,     269,     271,     277,     281,     283,     293,     307,     311,     313,     317,     331,     337,     347,     349,     353,     359,     367,     373,     379,     383,     389,     397,     401,     409,     419,     421,     431,     433,     439,     443,     449,     457,     461,     463,     467,     479,     487,     491,     499,     503,     509,     521,     523,     541,     547,     557,     563,     569,     571,     577,     587,     593,     599,     601,     607,     613,     617,     619,     631,     641,     643,     647,     653,     659,     661,     673,     677,     683,     691,     701,     709,     719,     727,     733,     739,     743,     751,     757,     761,     769,     773,     787,     797,     809,     811,     821,     823,     827,     829,     839,     853,     857,     859,     863,     877,     881,     883,     887,     907,     911,     919,     929,     937,     941,     947,     953,     967,     971,     977,     983,     991,     997     };   boolean sw=true;   int Indices [] = new int [Primos.length];   int cantidad = 0;   for(int i=0;i<Primos.length-1 && sw;i++)   {    int suma=Primos[i]+Primos[i+1]+1;    int posicion = Arrays.binarySearch(Primos,suma);    if(posicion>-1)     Indices[posicion]=1;   }   while(entrada.hasNextInt())   {    int N = entrada.nextInt();    int K = entrada.nextInt();    int contador=0;    for(int i=0;Primos[i]<=N && i<Primos.length-1;i++)     contador+=Indices[i];    if(contador>=K)     System.out.println("YES");    else     System.out.println("NO");   }  } }
1,public class B {    public static void main(String[] args) throws Exception {   Parserdoubt2333 s = new Parserdoubt2333(System.in);     int n = s.nextInt();   int k = s.nextInt();   int a[] = new int[n];   for (int i = 0; i < a.length; i++) {    a[i] = s.nextInt();      }     TreeMap<Integer, Integer> tree = new TreeMap<Integer,Integer>();     int left = 0;   int right = 0;     for (right = 0; right < a.length; right++) {    if(tree.containsKey(a[right]))     tree.put(a[right], tree.get(a[right]) + 1);    else     tree.put(a[right],1);    if(tree.size() == k)     break;   }     if(tree.size() < k){    System.out.println("-1 -1");    return ;   }   for (left = 0; left < a.length; left++) {    int val = tree.get(a[left]);    val--;    if(val > 0)     tree.put(a[left],val);    if(val == 0)     break;      }   left++;   right++;   System.out.println(left + " "+right);  } }  class Parserdoubt2333 {  final private int BUFFER_SIZE = 1 << 18;   private DataInputStream din;  private byte[] buffer;  private int bufferPointer, bytesRead;   public Parserdoubt2333(InputStream in)  {  din = new DataInputStream(in);  buffer = new byte[BUFFER_SIZE];  bufferPointer = bytesRead = 0;  }  public String nextString() throws Exception  {   StringBuffer sb=new StringBuffer("");   byte c = read();   while (c <= ' ') c = read();   do   {    sb.append((char)c);    c=read();   }while(c>' ');   return sb.toString();  }  public char nextChar() throws Exception  {   byte c=read();   while(c<=' ') c= read();   return (char)c;  }  public int nextInt() throws Exception  {  int ret = 0;  byte c = read();  while (c <= ' ') c = read();  boolean neg = c == '-';  if (neg) c = read();  do  {   ret = ret * 10 + c - '0';   c = read();  } while (c > ' ');  if (neg) return -ret;  return ret;  }  public long nextLong() throws Exception  {  long ret = 0;  byte c = read();  while (c <= ' ') c = read();  boolean neg = c == '-';  if (neg) c = read();  do  {   ret = ret * 10 + c - '0';   c = read();  } while (c > ' ');  if (neg) return -ret;  return ret;  }  private void fillBuffer() throws Exception  {  bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);  if (bytesRead == -1) buffer[0] = -1;  }   private byte read() throws Exception  {  if (bufferPointer == bytesRead) fillBuffer();  return buffer[bufferPointer++];  } }
1,public class Spreadsheet {  public static void main(String[] args) {   Scanner in = new Scanner(System.in);   int N = in.nextInt();   in.nextLine();   for (int i = 0; i < N; i++) {    String str = in.nextLine();    if (str.indexOf("R") == 0 && str.indexOf("R") + 1 < str.indexOf("C") && isNum(str.charAt(1))) {     int row = Integer.parseInt(str.substring(str.indexOf("R") + 1, str.indexOf("C")));     int col = Integer.parseInt(str.substring(str.indexOf("C") + 1));     System.out.println(convertRC(row, col));    } else {     String row = "";     int j = 0;     while (str.charAt(j) >= 'A' && str.charAt(j) <= 'Z') {      row += str.charAt(j);      j++;     }     int num = Integer.parseInt(str.substring(j));     System.out.println(convertAB(row, num));    }   }  }  static String convertAB(String str, int num) {   String result = "";   int col = 0;   for (int i = 0; i < str.length(); i++) {    col += (int)Math.pow(26, (str.length()) - (i + 1)) * (str.charAt(i) - 'A' + 1);   }   result += "R" + num;   result += "C" + col;   return result;  }  static String convertRC(int row, int column) {   String result = "";   while (column > 0) {    int index = column % 26;    char c;    if (index == 0) {     c = 'Z';     column = column - 26;    } else {     c = (char) ('A' + index - 1);     column = column - index;    }    result += c;    column = column / 26;   }   String res = "";   for (int i = 0; i < result.length(); i++) {    res += result.charAt(result.length() - (i + 1));   }   res += row;   return res;  }  static boolean isNum(char x){   return x>'0'&&x<='9';  } }
2,public class Main{ final int mod = 1000000007; final int maxn = -1; final double eps = 1e-9;  long digits(long n){  if(n == 0) return 0;  int p = (int)Math.log10(n);  return (p + 1) * (n - (long)Math.pow(10, p) + 1) + digits((long)Math.pow(10, p) - 1); }  void solve(){   String s = "";  long k = nextLong();  long i = 1;  long j = k;  while(i < j){  long m = (i + j) / 2;  if(digits(m) < k){   i = m + 1;  }  else{   j = m;  }  }  if(digits(i) >= k) --i;  printf("%c\n", String.valueOf(i + 1).charAt((int)(k - digits(i) - 1))); }  final double pi = Math.acos(-1.0); final long infl = 0x3f3f3f3f3f3f3f3fl; final int inf = 0x3f3f3f3f; final boolean ONLINE_JUDGE = System.getProperty("ONLINE_JUDGE") != null;  boolean zero(double x){ return x < eps; }   PrintWriter out; BufferedReader reader; StringTokenizer tokens;  Main(){  long s = System.currentTimeMillis();  tokens = new StringTokenizer("");  reader = new BufferedReader(new InputStreamReader(System.in), 1 << 15);  out = new PrintWriter(System.out);  Locale.setDefault(Locale.US);   solve();  out.close();  debug("Time elapsed: %dms", System.currentTimeMillis() - s); }  void freopen(String s){  try{ reader = new BufferedReader(new InputStreamReader(new FileInputStream(s)), 1 << 15); }  catch(FileNotFoundException e){ throw new RuntimeException(e); } }   int nextInt(){ return Integer.parseInt(next()); } long nextLong(){ return Long.parseLong(next()); } double nextDouble(){ return Double.parseDouble(next()); }  String next(){ readTokens(); return tokens.nextToken(); } String nextLine(){ readTokens(); return tokens.nextToken("\n"); }  boolean readTokens(){  while(!tokens.hasMoreTokens()){      try{   String line = reader.readLine();   if(line == null) return false;     tokens = new StringTokenizer(line);  }  catch(IOException e){ throw new RuntimeException(e); }  }  return true; }   void printf(String s, Object... o){ out.printf(s, o); } void debug(String s, Object... o){ if(!ONLINE_JUDGE) System.err.printf((char)27 + "[91m" + s + (char)27 + "[0m", o); }  public static void main(String[] args){ new Main(); } }
1,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskA solver = new TaskA();   solver.solve(1, in, out);   out.close();  }  static class TaskA {   public void solve(int testNumber, InputReader in, PrintWriter out) {    int n = in.nextInt();    long k = in.nextLong();    HashMap<Long, Integer> hm = new HashMap<>();    long ar[] = in.nextLongArray(n);    for (int i = 0; i < n; i++) {     long dist = ar[i] + k;     long min = k;     for (int j = 0; j < n; j++) {      min = Math.min(min, Math.abs(ar[j] - dist));     }     if (min == k) {      hm.put(dist, 1);     }     dist = ar[i] - k;     min = k;     for (int j = 0; j < n; j++) {      min = Math.min(min, Math.abs(ar[j] - dist));     }     if (min == k) {      hm.put(dist, 1);     }    }    out.print(hm.size());   }  }  static class InputReader {   private final InputStream stream;   private final byte[] buf = new byte[8192];   private int curChar;   private int snumChars;   public InputReader(InputStream st) {    this.stream = st;   }   public int read() {             if (snumChars == -1)     throw new InputMismatchException();    if (curChar >= snumChars) {     curChar = 0;     try {      snumChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (snumChars <= 0)      return -1;    }    return buf[curChar++];   }   public int nextInt() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   public long nextLong() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    long res = 0;    do {     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   public long[] nextLongArray(int n) {    long a[] = new long[n];    for (int i = 0; i < n; i++) {     a[i] = nextLong();    }    return a;   }   public boolean isSpaceChar(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }  } }
2,public class SolutionD {  BufferedReader in;  StringTokenizer str;  PrintWriter out;  String SK;  String next() throws IOException {  while ((str == null) || (!str.hasMoreTokens())) {  SK = in.readLine();  if (SK == null)  return null;  str = new StringTokenizer(SK);  }  return str.nextToken();  }  int nextInt() throws IOException {  return Integer.parseInt(next());  }  double nextDouble() throws IOException {  return Double.parseDouble(next());  }  long nextLong() throws IOException {  return Long.parseLong(next());  }  void run() throws IOException {   in = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);        solve();   out.close();  }  public static void main(String[] args) throws IOException {  new SolutionD().run();  }  void solve() throws IOException {   long l=Long.parseLong(next());   long r=Long.parseLong(next());   String low=Long.toBinaryString(l);   String up=Long.toBinaryString(r);     int n=low.length();   int m=up.length();   for(int i=0;i<m-n;i++){    low="0"+low;   }   String ret="";   boolean fu=false;   boolean fd=false;   boolean su=false;   boolean sd=false;   if(m>n){    su=true;    fd=true;   }   for(int i=0;i<m;i++){    if(low.charAt(i)==up.charAt(i)){     if(low.charAt(i)=='1'){      if(fd){       ret+="1";       fu=true;      }      else if(sd){       ret+="1";       su=true;      }      else ret+="0";     }     else{      if(fu){       ret+="1";       fd=true;      }      else if(su){       ret+="1";       sd=true;      }      else ret+="0";     }    }else{     if(up.charAt(i)=='1'){      su=true;      fd=true;     }         ret+="1";    }   }     out.println(Long.parseLong(ret, 2));            }  }
6,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskC solver = new TaskC();   solver.solve(1, in, out);   out.close();  }  static class TaskC {   public void solve(int testNumber, InputReader in, PrintWriter out) {    Point bag = new Point(in.ni(), in.ni());    int n = in.ni();    Point[] arr = new Point[n];    for (int i = 0; i < n; ++i)     arr[i] = new Point(in.ni(), in.ni());    int[] dist = new int[n];    for (int i = 0; i < n; ++i) {     int dx = arr[i].x - bag.x;     int dy = arr[i].y - bag.y;     dist[i] = dx * dx + dy * dy;    }    int[][] d = new int[n][n];    for (int i = 0; i < n; ++i) {     for (int j = 0; j < n; ++j) {      int dx = arr[i].x - arr[j].x;      int dy = arr[i].y - arr[j].y;      d[i][j] = dx * dx + dy * dy + dist[i] + dist[j];     }    }    int lim = (1 << n);    int[] dp = new int[lim];    Arrays.fill(dp, Integer.MAX_VALUE);    dp[0] = 0;    int[] p = new int[lim];    Arrays.fill(p, -1);    for (int mask = 0; mask < lim; ++mask) {     if (dp[mask] == Integer.MAX_VALUE)      continue;     int minBit = -1;     for (int bit = 0; bit < n; ++bit) {      if (checkBit(mask, bit))       continue;      if (minBit == -1 || (dist[minBit] > dist[bit]))       minBit = bit;     }     if (minBit == -1)      continue;     for (int bit = 0; bit < n; ++bit) {      if (checkBit(mask, bit))       continue;      int newMask = (mask | (1 << minBit) | (1 << bit));      if (dp[newMask] > dp[mask] + d[minBit][bit]) {       dp[newMask] = dp[mask] + d[minBit][bit];       p[newMask] = minBit * n + bit;      }     }    }    out.println(dp[lim - 1]);    int curMask = lim - 1;    while (p[curMask] != -1) {     out.print("0 ");     int first = p[curMask] / n;     int second = p[curMask] % n;     out.print(first + 1 + " ");     curMask ^= (1 << first);     if (first != second) {      out.print(second + 1 + " ");      curMask ^= (1 << second);     }    }    out.println(0);   }   boolean checkBit(int mask, int bitNumber) {    return (mask & (1 << bitNumber)) != 0;   }  }  static class InputReader {   BufferedReader br;   StringTokenizer st;   public InputReader(InputStream inputStream) {    br = new BufferedReader(new InputStreamReader(inputStream));   }   public String n() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      throw new RuntimeException();     }    }    return st.nextToken();   }   public int ni() {    return Integer.parseInt(n());   }  } }
6,public class E_fast {  static int g[][];  static int n, m;  static char[] s;  static int dp[], inf = (int) 2e9;  static int cost[][];  public static void main(String[] args) throws Exception {   Scanner in = new Scanner(System.in);   PrintWriter pw = new PrintWriter(System.out);   n = in.nextInt();   m = in.nextInt();   s = in.next().toCharArray();   g = new int[m][m];   for (int i = 1; i < n; i++) {    int x = s[i - 1] - 'a', y = s[i] - 'a';    if (x != y) {     g[x][y]++;     g[y][x]++;    }   }   cost = new int[m][1 << m];   for (int i = 0; i < m; i++) {    int w = 0;    for (int j = 0; j < m; j++) w += g[i][j];    pre(i, 0, 0, -w);   }   dp = new int[1 << m];   Arrays.fill(dp, -1);   pw.println(solve(0, 0));   pw.close();  }  static void pre(int x, int pos, int mask, int w) {   if (pos >= m) {    cost[x][mask] = w;    return;   }   pre(x, pos + 1, mask, w);   pre(x, pos + 1, set(mask, pos), w + 2 * g[x][pos]);  }  static int solve(int pos, int mask) {   if (pos >= m) return 0;   if (dp[mask] != -1) return dp[mask];   int min = inf;   for (int i = 0; i < m; i++) {    if (!check(mask, i)) {     int res = cost[i][mask] * pos + solve(pos + 1, set(mask, i));     min = min(min, res);    }   }   return dp[mask] = min;  }  static boolean check(int N, int pos) {   return (N & (1 << pos)) != 0;  }  static int set(int N, int pos) {   return N = N | (1 << pos);  }  static int reset(int N, int pos) {   return N = N & ~(1 << pos);  }  static void debug(Object... obj) {   System.err.println(Arrays.deepToString(obj));  } }
1,public class Problem17A implements Runnable {  void solve() throws NumberFormatException, IOException {          int n = nextInt();   int k = nextInt();   ArrayList<Integer> primes = new ArrayList<Integer>(n + 1);   boolean[] simplePrime = new boolean[n + 1];   Arrays.fill(simplePrime, 0, simplePrime.length, true);   simplePrime[0] = simplePrime[1] = false;     for (int i = 2; i <= n; i++) {    if (simplePrime[i]) {     for (int j = i + i; j <= n; j += i) {      simplePrime[j] = false;     }         primes.add(i);    }   }        int actualK = 0;   for (int i = 1; i < primes.size(); i++) {    int val = primes.get(i - 1) + primes.get(i) + 1;    if (val <= n) {     if (simplePrime[val]) {           actualK++;     }    } else {     break;    }   }     System.out.println((k <= actualK ? "YES" : "NO"));  }    StringTokenizer st;  BufferedReader in;  PrintWriter out;   public static void main(String[] args) {   new Problem17A().run();  }  public void run() {   try {    in = new BufferedReader(new InputStreamReader(System.in));    out = new PrintWriter(System.out);    solve();   } catch (Exception e) {    e.printStackTrace();   } finally {    out.flush();    out.close();   }  }  String nextToken() throws IOException {   while (st == null || !st.hasMoreTokens()) {    st = new StringTokenizer(in.readLine());   }   return st.nextToken();  }  int nextInt() throws NumberFormatException, IOException {   return Integer.parseInt(nextToken());  }  long nextLong() throws NumberFormatException, IOException {   return Long.parseLong(nextToken());  }  double nextDouble() throws NumberFormatException, IOException {   return Double.parseDouble(nextToken());  } }
6,public class Main{ public static void main(String[] args) throws Exception {  new Main().doWork(); } void doWork() throws Exception{  BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));  BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));   int ncase = Integer.valueOf(reader.readLine());  double[][] p = new double[ncase][];  for(int icase=0;icase<ncase;icase++){  p[icase] = toDoubleArray(reader.readLine());  }  double[] prob = new double[1<<ncase];  prob[0] = 1;  for(int x=0;x<(1<<ncase);x++){  double cp = prob[x];  int count = 0;  for(int i=0;i<ncase;i++){   if((x&(1<<i))!=0) continue;   count ++;  }  if(count == 1) continue;  double np = cp*2.0/(count)/(count-1);  for(int i=0;i<ncase;i++){   if((x&(1<<i))!=0) continue;   for(int j=i+1;j<ncase;j++){   if((x&(1<<j))!=0) continue;   prob[x^(1<<j)] += np*p[i][j];   prob[x^(1<<i)] += np*p[j][i];   }  }  }  String out = "";  for(int i=0;i<ncase;i++){  if(i>0) out += " ";  int index = ((1<<ncase)-1)^(1<<i);  out += String.format("%.6f",prob[index]);  }  out += "\r\n";  writer.write(out,0,out.length());  writer.flush();  writer.close();  reader.close(); } String process(){  return "1"; } double[] toDoubleArray(String line){  String[] p = line.split("[ ]+");  double[] out = new double[p.length];  for(int i=0;i<p.length;i++) out[i] = Double.valueOf(p[i]);  return out; } }
4,public class A implements Runnable {  BufferedReader br; StringTokenizer in; PrintWriter out;  public static void main(String[] args) {  new Thread(new A()).start(); }  public String nextToken() throws IOException {  while (in == null || !in.hasMoreTokens()) {  in = new StringTokenizer(br.readLine());  }  return in.nextToken(); }  public int nextInt() throws IOException {  return Integer.parseInt(nextToken()); }  public long nextLong() throws IOException {  return Long.parseLong(nextToken()); }  public double nextDouble() throws IOException {  return Double.parseDouble(nextToken()); }  public void solve() throws IOException {  String s = nextToken();  int max = 0;  for(int i = 0 ; i < s.length(); i++)  for(int j = i+1 ; j < s.length(); j ++){   String sub = s.substring(i, j);   int kv = 0;   for(int k = 0 ; k<= s.length() - sub.length(); k ++){   boolean ok = true;   for(int g = 0 ; g < sub.length(); g ++)   if (sub.charAt(g) != s.charAt(g+k)){    ok = false;    break;   }   if (ok) kv ++;   }   if (kv > 1)   max = Math.max(max, sub.length());  }    out.println(max); }  public void run() {  try {   br = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);        solve();  out.close();  } catch (IOException e) {  e.printStackTrace();  System.exit(1);  }  } }
2,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  OutputWriter out = new OutputWriter(outputStream);  TaskB solver = new TaskB();  solver.solve(1, in, out);  out.close(); } } class TaskB {  long n,x,y,c;   public void solve(int testNumber, InputReader in, OutputWriter out) {   n = in.readInt();   x = in.readInt();   y = in.readInt();   c = in.readInt();   int lo = -1;   int hi = (int)c;   while(lo+1<hi) {    int mi = (lo+hi)/2;    if(P(mi)) hi = mi; else lo = mi;   }   out.printLine(hi); }  private boolean P(int t) {   if(t == -1) return false;   int ans = 0;   for(long i = Math.max(1,y-t); i <= Math.min(y+t,n); ++i) {    long a = Math.abs(y - i);    ans += D(Math.max(1,x-t+a), Math.min(n,x+t-a));    if(ans >= c) return true;   }   return false;  }  private long D(long a, long b) {   return b - a + 1;  } } class InputReader {  private InputStream stream;  private byte[] buf = new byte[1024];  private int curChar;  private int numChars;  private SpaceCharFilter filter;  public InputReader(InputStream stream) {   this.stream = stream;  }  public int read() {   if (numChars == -1)    throw new InputMismatchException();   if (curChar >= numChars) {    curChar = 0;    try {     numChars = stream.read(buf);    } catch (IOException e) {     throw new InputMismatchException();    }    if (numChars <= 0)     return -1;   }   return buf[curChar++];  }  public int readInt() {   int c = read();   while (isSpaceChar(c))    c = read();   int sgn = 1;   if (c == '-') {    sgn = -1;    c = read();   }   int res = 0;   do {    if (c < '0' || c > '9')     throw new InputMismatchException();    res *= 10;    res += c - '0';    c = read();   } while (!isSpaceChar(c));   return res * sgn;  }  public boolean isSpaceChar(int c) {   if (filter != null)    return filter.isSpaceChar(c);   return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;  }  public interface SpaceCharFilter {   public boolean isSpaceChar(int ch);  } } class OutputWriter {  private final PrintWriter writer;  public OutputWriter(OutputStream outputStream) {   writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));  }  public OutputWriter(Writer writer) {   this.writer = new PrintWriter(writer);  }  public void print(Object...objects) {   for (int i = 0; i < objects.length; i++) {    if (i != 0)     writer.print(' ');    writer.print(objects[i]);   }  }  public void printLine(Object...objects) {   print(objects);   writer.println();  }  public void close() {   writer.close();  } }
4,public class EdA { static long[] mods = {1000000007, 998244353, 1000000009}; static long mod = mods[0]; public static MyScanner sc;  public static PrintWriter out; public static void main(String[] havish) throws Exception{    sc = new MyScanner();  out = new PrintWriter(System.out);  int n = sc.nextInt();  mod = sc.nextLong();  long[] fact = new long[401];  long[] twopowers = new long[401];  fact[0] = 1;  twopowers[0] = 1;  for(int j = 1;j<=400;j++){  twopowers[j] = twopowers[j-1] * 2L;  twopowers[j] %= mod;  fact[j] = fact[j-1] * j;  fact[j] %= mod;  }  long[][] choose = new long[401][401];  for(int j = 0;j<=400;j++){  for(int k = 0;k<=j;k++){   choose[j][k] = fact[j];   choose[j][k] *= inv(fact[k]);   choose[j][k] %= mod;   choose[j][k] *= inv(fact[j-k]);   choose[j][k] %= mod;  }  }  long[][] dp = new long[n+1][n+1];  for(int j = 1;j<=n;j++){  dp[j][0] = twopowers[j-1];  }  for(int k = 0;k<n;k++){   for(int j = 1;j<=n;j++){   if (k > j)   continue;   for(int add = 2; j+add <= n; add++){   long prod = dp[j][k] * choose[j-k+add-1][add-1];   prod %= mod;   prod *= twopowers[add-2];      dp[j+add][k+1] += prod;   dp[j+add][k+1] %= mod;   }  }  }  long ans = 0;  for(int s = 0;s<=n;s++){  ans+=dp[n][s];  ans %= mod;  }  out.println(ans);  out.close();    } public static long inv(long n){  return power(n, mod-2); } public static void sort(int[] array){  ArrayList<Integer> copy = new ArrayList<>();  for (int i : array)  copy.add(i);  Collections.sort(copy);  for(int i = 0;i<array.length;i++)  array[i] = copy.get(i); } static String[] readArrayString(int n){  String[] array = new String[n];  for(int j =0 ;j<n;j++)  array[j] = sc.next();  return array; } static int[] readArrayInt(int n){  int[] array = new int[n];  for(int j = 0;j<n;j++)   array[j] = sc.nextInt();  return array;  } static int[] readArrayInt1(int n){  int[] array = new int[n+1];  for(int j = 1;j<=n;j++){  array[j] = sc.nextInt();  }  return array; } static long[] readArrayLong(int n){  long[] array = new long[n];  for(int j =0 ;j<n;j++)  array[j] = sc.nextLong();  return array; } static double[] readArrayDouble(int n){  double[] array = new double[n];  for(int j =0 ;j<n;j++)  array[j] = sc.nextDouble();  return array; } static int minIndex(int[] array){  int minValue = Integer.MAX_VALUE;  int minIndex = -1;  for(int j = 0;j<array.length;j++){  if (array[j] < minValue){   minValue = array[j];   minIndex = j;  }  }  return minIndex; } static int minIndex(long[] array){  long minValue = Long.MAX_VALUE;  int minIndex = -1;  for(int j = 0;j<array.length;j++){  if (array[j] < minValue){   minValue = array[j];   minIndex = j;  }  }  return minIndex; } static int minIndex(double[] array){  double minValue = Double.MAX_VALUE;  int minIndex = -1;  for(int j = 0;j<array.length;j++){  if (array[j] < minValue){   minValue = array[j];   minIndex = j;  }  }  return minIndex; } static long power(long x, long y){  if (y == 0)  return 1;  if (y%2 == 1)  return (x*power(x, y-1))%mod;  return power((x*x)%mod, y/2)%mod; } static void verdict(boolean a){   out.println(a ? "YES" : "NO");  }  public static class MyScanner {   BufferedReader br;   StringTokenizer st;   public MyScanner() {    br = new BufferedReader(new InputStreamReader(System.in));   }   String next() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     }     catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }   int nextInt() {    return Integer.parseInt(next());   }   long nextLong() {    return Long.parseLong(next());   }   double nextDouble() {    return Double.parseDouble(next());   }   String nextLine() {    String str = "";    try{     str = br.readLine();    }    catch (IOException e) {     e.printStackTrace();    }    return str;   }    } }
3,public final class py_indent {  static BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); static FastScanner sc=new FastScanner(br);  static PrintWriter out=new PrintWriter(System.out); static Random rnd=new Random(); static int maxn=(int)(5e3+5); static long mod=(long)(1e9+7);  static int add(long a,long b) {  long ret=(a+b);   if(ret>=mod)  {  ret%=mod;  }   return (int)ret; }   public static void main(String args[]) throws Exception  {  int n=sc.nextInt();char[] a=new char[n+1];a[0]='s';   for(int i=1;i<=n;i++)  {  a[i]=sc.next().charAt(0);  }   int[][] dp=new int[n+1][maxn],sum=new int[n+1][maxn];dp[0][0]=1;   sum[0][0]=1;   for(int i=1;i<maxn;i++)  {  sum[0][i]=add(sum[0][i],sum[0][i-1]);  }   for(int i=1;i<=n;i++)  {  if(a[i]=='f')  {   continue;  }    int curr=0,idx=0;    for(int j=i-1;j>=0;j--)  {   if(a[j]=='s')   {   idx=j;break;   }     else   {   curr++;   }  }    for(int j=0;j<maxn;j++)  {   int up=Math.max(0,j-curr);      long now=(sum[idx][maxn-1]-(up==0?0:sum[idx][up-1]));       now=add(now,mod);      dp[i][j]=add(dp[i][j],now);  }    sum[i][0]=dp[i][0];    for(int j=1;j<maxn;j++)  {   sum[i][j]=add(dp[i][j],sum[i][j-1]);  }  }      out.println(dp[n][0]);out.close();  } } class FastScanner {  BufferedReader in;  StringTokenizer st;  public FastScanner(BufferedReader in) {   this.in = in;  }   public String nextToken() throws Exception {   while (st == null || !st.hasMoreTokens()) {    st = new StringTokenizer(in.readLine());   }   return st.nextToken();  }  public String next() throws Exception {  return nextToken().toString(); }   public int nextInt() throws Exception {   return Integer.parseInt(nextToken());  }  public long nextLong() throws Exception {   return Long.parseLong(nextToken());  }  public double nextDouble() throws Exception {   return Double.parseDouble(nextToken());  } }
2,public class Cf2 {  static boolean ok(long n, long k, long eatten) {   long moves = n-eatten;   long ans = moves*(moves+1)/2;   ans -= eatten;   return ans <= k;  }  public static void main(String[] args) {   FastReader in = new FastReader();   long n = in.nextInt();   long k = in.nextInt();   long left = 0, right = n;   while (left <= right) {    long middle = (left+right)/2;    if (ok(n, k, middle)) right = middle-1;    else left=middle+1;   }   System.out.println(left);  }  static class FastReader  {   BufferedReader br;   StringTokenizer st;   public FastReader() {    br = new BufferedReader(new      InputStreamReader(System.in));   }   String next()   {    while (st == null || !st.hasMoreElements())    {     try     {      st = new StringTokenizer(br.readLine());     }     catch (IOException e)     {      e.printStackTrace();     }    }    return st.nextToken();   }   int nextInt()   {    return Integer.parseInt(next());   }   long nextLong()   {    return Long.parseLong(next());   }   double nextDouble()   {    return Double.parseDouble(next());   }   String nextLine()   {    String str = "";    try    {     str = br.readLine();    }    catch (IOException e)    {     e.printStackTrace();    }    return str;   }  } }
1,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  OutputWriter out = new OutputWriter(outputStream);  TaskB solver = new TaskB();  solver.solve(1, in, out);  out.close(); } } class TaskB { public void solve(int testNumber, InputReader in, OutputWriter out) {   int n = in.nextInt();   int k = in.nextInt();   int[] a = in.nextIntArray(n);   if (k == 1) {    out.println("1 1");    return;   }   int left = -1, right = -1;   Counter<Integer> counter = new Counter<Integer>();   while (true) {    right++;    if (right == n) {     out.println("-1 -1");     return;    }    counter.add(a[right]);    if (counter.size() >= k)     break;   }   while (true) {    left++;    if (counter.get(a[left]) == 1)     break;    counter.add(a[left], -1);   }   out.printLine(left + 1, right + 1);  } } class InputReader {  private InputStream stream;  private byte[] buf = new byte[1 << 16];  private int curChar;  private int numChars;  public InputReader(InputStream stream) {   this.stream = stream;  }  public int read() {   if (numChars == -1)    throw new InputMismatchException();   if (curChar >= numChars) {    curChar = 0;    try {     numChars = stream.read(buf);    } catch (IOException e) {     throw new InputMismatchException();    }    if (numChars <= 0)     return -1;   }   return buf[curChar++];  }  public int nextInt() {   int c = read();   while (isSpaceChar(c))    c = read();   int sgn = 1;   if (c == '-') {    sgn = -1;    c = read();   }   int res = 0;   do {    if (c < '0' || c > '9')     throw new InputMismatchException();    res *= 10;    res += c & 15;    c = read();   } while (!isSpaceChar(c));   return res * sgn;  }  public static boolean isSpaceChar(int c) {   return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;  }  public int[] nextIntArray(int count) {   int[] result = new int[count];   for (int i = 0; i < count; i++) {    result[i] = nextInt();   }   return result;  }  } class OutputWriter {  private PrintWriter writer;  public OutputWriter(OutputStream stream) {   writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(stream)));  }  public OutputWriter(Writer writer) {   this.writer = new PrintWriter(writer);  }  public void print(Object obj) {   writer.print(obj);  }  public void println() {   writer.println();  }  public void println(String x) {   writer.println(x);  }  public void print(char c) {   writer.print(c);  }  public void close() {   writer.close();  }  public void printItems(Object... items) {   for (int i = 0; i < items.length; i++) {    if (i != 0) {     print(' ');    }    print(items[i]);   }  }  public void printLine(Object... items) {   printItems(items);   println();  } } class Counter<T> extends HashMap<T, Long> {  public void add(T obj, long count) {   put(obj, get(obj) + count);  }  public void add(T obj) {   put(obj, get(obj) + 1L);  }  public Long get(Object key) {   return containsKey(key) ? super.get(key) : 0L;  } }
5,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  Scanner in = new Scanner(inputStream);  PrintWriter out = new PrintWriter(outputStream);  TaskA solver = new TaskA();  solver.solve(1, in, out);  out.close(); } } class TaskA {  public void solve(int testNumber, Scanner in, PrintWriter out) {   int n = in.nextInt();   int k = in.nextInt();   Integer[] a = new Integer[n];   for (int i = 0; i < n; i++) {    a[i] = in.nextInt();   }   Set <Integer> vis = new TreeSet<Integer>();   Arrays.sort(a);   int ans = 0;   for (int i = 0; i < n; i++) {    if (!(a[i] % k == 0 && vis.contains(a[i] / k))) {     ++ans;     vis.add(a[i]);    }   }   out.println(ans);  } } class Scanner {  BufferedReader in;  StringTokenizer tok;  public Scanner(InputStream in) {   this.in = new BufferedReader(new InputStreamReader(in));   tok = new StringTokenizer("");  }  public String nextToken() {   if (!tok.hasMoreTokens()) {    try {     String newLine = in.readLine();     if (newLine == null)      throw new InputMismatchException();     tok = new StringTokenizer(newLine);    } catch (IOException e) {     throw new InputMismatchException();    }    return nextToken();   }   return tok.nextToken();  }  public int nextInt() {   return Integer.parseInt(nextToken());  }  }
3,public class Main {   public void solve() throws IOException {   int n = nextInt(), r = nextInt();   int x[] = new int[n];   for (int i = 0; i < n; i++) {    x[i] = nextInt();   }   double res[] = new double[n];   res[0] = r;   for (int i = 1; i < n; i++) {    double max = r;    for (int j = 0; j < i; j++) {     int d = Math.abs(x[i] - x[j]);     if(d <= 2 * r){      double yy = Math.sqrt(4 * r * r - d * d);      max = Math.max(max, yy + res[j]);     }    }    res[i] = max;   }   for (int i = 0; i < n; i++) {    out.print(res[i] + " ");   }  }  BufferedReader br;  StringTokenizer sc;  PrintWriter out;  public static void main(String[] args) throws IOException {   Locale.setDefault(Locale.US);   new Main().run();  }  void run() throws IOException {   try {    br = new BufferedReader(new InputStreamReader(System.in));    out = new PrintWriter(System.out);     solve();    out.close();   } catch (Exception e) {    e.printStackTrace();    System.exit(1);   }  }  String nextToken() throws IOException {   while (sc == null || !sc.hasMoreTokens()) {    try {     sc = new StringTokenizer(br.readLine());    } catch (Exception e) {     return null;    }   }   return sc.nextToken();  }  int nextInt() throws IOException {   return Integer.parseInt(nextToken());  }  long nextLong() throws IOException {   return Long.parseLong(nextToken());  }  double nextDouble() throws IOException {   return Double.parseDouble(nextToken());  } }
0,public class LearnMath {  public static void main(String[] args) {  Scanner scan = new Scanner(System.in);  int N = scan.nextInt();  scan.close();   if ((N%2) == 0) {  System.out.println(4 + " " + (N-4));  }  else {  if (N > 18) {   System.out.println(9 + " " + (N-9));  }  else {   System.out.println((N-9) + " " + 9);  }  }  } }
2,public class C { FastScanner in; PrintWriter out; boolean systemIO = true;  public static class Pair implements Comparable<Pair> {  int x;  int y;  public Pair(int x, int y) {  super();  this.x = x;  this.y = y;  }  @Override  public int compareTo(Pair o) {  return x - o.x;  }   }  public static void quickSort(long[] a, int from, int to) {  if (to - from <= 1) {  return;  }  int i = from;  int j = to - 1;  long x = a[from + (new Random()).nextInt(to - from)];  while (i <= j) {  while (a[i] < x) {   i++;  }  while (a[j] > x) {   j--;  }  if (i <= j) {   long t = a[i];   a[i] = a[j];   a[j] = t;   i++;   j--;  }  }  quickSort(a, from, j + 1);  quickSort(a, j + 1, to); }  public static long check(long x) {  long sum = 0;  long k = x;  while (x > 0) {  sum += x % 10;  x /= 10;  }  return k - sum; }  public void solve() throws IOException {  long n = in.nextLong();  long s = in.nextLong();  long ans = 0;  for (long i = s; i <= Math.min(n, s + 10000L); i++) {  if (check(i) >= s) {   ans++;  }  }  ans += (n - Math.min(n, s + 10000L));  System.out.println(ans); }  public void run() throws IOException {  if (systemIO) {  in = new FastScanner(System.in);  out = new PrintWriter(System.out);  } else {  in = new FastScanner(new File("input.txt"));  out = new PrintWriter(new File("output.txt"));  }  solve();  out.close(); }  class FastScanner {  BufferedReader br;  StringTokenizer st;  FastScanner(File f) {  try {   br = new BufferedReader(new FileReader(f));  } catch (FileNotFoundException e) {   e.printStackTrace();  }  }  FastScanner(InputStream f) {  br = new BufferedReader(new InputStreamReader(f));  }  String nextLine() {  try {   return br.readLine();  } catch (IOException e) {   return null;  }  }  String next() {  while (st == null || !st.hasMoreTokens()) {   try {   st = new StringTokenizer(br.readLine());   } catch (IOException e) {   e.printStackTrace();   }  }  return st.nextToken();  }  int nextInt() {  return Integer.parseInt(next());  }  long nextLong() {  return Long.parseLong(next());  }  double nextDouble() {  return Double.parseDouble(next());  }  }   public static void main(String[] arg) throws IOException {  new C().run(); } }
0,public class BetaRound72_Div2_A implements Runnable {  final boolean ONLINE_JUDGE = System.getProperty("ONLINE_JUDGE") != null; BufferedReader in; PrintWriter out; StringTokenizer tok = new StringTokenizer("");  void init() throws IOException {  if (ONLINE_JUDGE) {  in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);  } else {  in = new BufferedReader(new FileReader("input.txt"));  out = new PrintWriter("output.txt");  } }  String readString() throws IOException {  while (!tok.hasMoreTokens()) {  tok = new StringTokenizer(in.readLine());  }  return tok.nextToken(); }  int readInt() throws IOException {  return Integer.parseInt(readString()); }  @Override public void run() {  try {  long t1 = System.currentTimeMillis();  init();  Locale.setDefault(Locale.US);  solve();  out.close();  long t2 = System.currentTimeMillis();  System.err.println("Time = " + (t2 - t1));  } catch (Exception e) {  e.printStackTrace(System.err);  System.exit(-1);  } }  public static void main(String[] args) {  new Thread(new BetaRound72_Div2_A()).start(); }  void solve() throws IOException {  int n = readInt();  int ans = n * 3 / 2;  out.print(ans); }  }
6,public class Cycles { public static FastInputStream fis;  public static void main(String[] args) throws IOException {  fis = new FastInputStream(System.in);   System.out.println(solve(fis.nextInt(), fis.nextInt()));   fis.close(); }  public static long solve(int n, int m) throws IOException {  boolean[][] graph = new boolean[n][];  long[][] state = new long[1 << n][n];   for (int i = 0; i < n; i++)  graph[i] = new boolean[n - i];   for (int i = 0; i < m; i++)  {  int a = fis.nextInt() - 1;  int b = fis.nextInt() - 1;  setConnected(graph, a, b);  state[(1 << a) | (1 << b)][a > b ? a : b] = 1;  }   long res = 0;   for (int i = 2; i < n; i++)  {  int baseCombination = (2 << i) - 1;    while (baseCombination < (1 << n))  {   int min = getFirstOne(baseCombination);   int bits = baseCombination;   while (bits != 0)   {   int firstBit = bits & (-bits);   int firstBitPos = getFirstOne(firstBit);      bits &= bits - 1;      if (firstBitPos == min)    continue;      int leftOverBits = baseCombination - firstBit;   int nextBits = leftOverBits;      while (nextBits != 0)   {    int nextBit = nextBits & (-nextBits);    int nextBitPos = getFirstOne(nextBit);       nextBits &= nextBits - 1;       if (nextBitPos == min)    continue;       if (!isConnected(graph, firstBitPos, nextBitPos))    continue;              state[baseCombination][firstBitPos] += state[leftOverBits][nextBitPos];   }      if (isConnected(graph, firstBitPos, min))    res += state[baseCombination][firstBitPos];   }     baseCombination = nextCombination(baseCombination);  }  }      return res >> 1; }  public static boolean isConnected(boolean[][] graph, int a, int b) {  if (b < a || graph[a].length <= (b - a))  return graph[b][a - b];  return graph[a][b - a]; }  public static void setConnected(boolean[][] graph, int a, int b) {  if (b < a || graph[a].length <= (b - a))  graph[b][a - b] = true;  else  graph[a][b - a] = true; }  public static int nextCombination(int x) {  int smallest = x & -x;  int ripple = x + smallest;  int ones = ((x ^ ripple) >> 2) / smallest;  return ripple | ones; }  public static boolean on(int bitmask, int pos) {  return ((bitmask >> pos) & 1) == 1; }  public static int setOn(int bitmask, int pos) {  return bitmask | (1 << pos); }  public static int setOff(int bitmask, int pos) {  return bitmask & ~(1 << pos); }  public static int getOns(int bitmask) {  int amt = 0;  while (bitmask != 0)  {  bitmask &= bitmask - 1;  amt++;  }   return amt; }  public static int getFirstOne(int bitmask) {  if (bitmask == 0)  return -1;   int first = 0;  while ((bitmask & 1) != 1)  {  first++;  bitmask = bitmask >> 1;  }   return first; }  public static class FastInputStream extends InputStream {  private InputStream in;   private byte[] buffer = new byte[512];  private int loaded = 0;  private int pointer = 0;   public FastInputStream(InputStream in)  {  this.in = in;  }  @Override  public int read() throws IOException  {  if (hasNext())   return buffer[pointer++];  else   return -1;  }  public void skipWhitespace() throws IOException  {  while (hasNext())  {   char c = (char) buffer[pointer];   if (c == ' ' || c == '\t' || c == '\n' || c == '\r') pointer++;   else return;  }  }  public Integer nextInt() throws IOException  {  skipWhitespace();   if (!hasNext()) return null;   byte multiplier = 1;  int number = 0;   if (buffer[pointer] == '-')  {   multiplier = -1;   pointer++;  }   while (hasNext())  {   char c = (char) buffer[pointer];   if (c >= '0' && c <= '9')   {   number = (number << 3) + (number << 1) + c - '0';   pointer++;   } else break;  }   return number * multiplier;  }   public void close() throws IOException  {  in.close();  }   public boolean hasNext() throws IOException  {  while (pointer == loaded)  {   loaded = in.read(buffer);   pointer = 0;     if (loaded == -1) return false;  }  return loaded != -1;  } } }
0,public class MainY {    static double eps=(double)1e-6;  static long mod=(int)1e9+7;  static boolean f=true;  public static void main(String args[]){   InputReader in = new InputReader(System.in);   OutputStream outputStream = System.out;   PrintWriter out = new PrintWriter(outputStream);     long n=in.nextLong();   if(n==1){   System.out.println("5");   }   else{   System.out.println("25");   }   out.close();     }    static class Pair implements Comparable<Pair>{   int r1=-1;   int r2=-1;   int extra=0;  @Override  public int compareTo(Pair arg0) {     return 0;  }  }    static class InputReader {   public BufferedReader reader;   public StringTokenizer tokenizer;     public InputReader(InputStream inputstream) {    reader = new BufferedReader(new InputStreamReader(inputstream));    tokenizer = null;   }      public String nextLine(){    String fullLine=null;    while (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      fullLine=reader.readLine();     } catch (IOException e) {      throw new RuntimeException(e);     }     return fullLine;     }     return fullLine;   }   public String next() {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {    try {     tokenizer = new StringTokenizer(reader.readLine());    } catch (IOException e) {     throw new RuntimeException(e);    }    }    return tokenizer.nextToken();   }   public long nextLong() {    return Long.parseLong(next());    }   public int nextInt() {    return Integer.parseInt(next());   }   }  }
0,public class Main {  public static void main(String[]args)  {   Scanner input=new Scanner (System.in);   while(input.hasNext())   {    long n=input.nextLong();    if(n==1||n==2)     System.out.println(n);    else if(n%2==1)     System.out.println(n*(n-1)*(n-2));    else     if(n%3!=0)      System.out.println(Math.max(n*(n-1)*(n-3),n*(n-1)*(n-2)/2));     else      System.out.println(Math.max( Math.max(n*(n-1)*(n-3)/3,n*(n-1)*(n-2)/2) , Math.max((n-2)*(n-1)*(n-3),n*(n-2)*(n-3)/6) ));   }  } }
2,public class b {  public static void main(String[] args) {   Scanner sc = new Scanner(System.in);   long n = sc.nextLong() - 1, k = sc.nextLong() - 1;   int a = 0;   if ((k + 1) * k / 2 < n) {    System.out.println(-1);    return;   }   while (n > 0 && k > 0) {    long min = go(n, k);    a += (k - min + 1);    n -= (k + min) * (k - min + 1) / 2;    k = Math.min(min - 1, n);   }   if (n == 0)    System.out.println(a);   else    System.out.println(-1);  }  static long go(long n, long k) {   long low = 1, high = k;   while (low + 1 < high) {    long mid = (low + high) / 2;    if ((k + mid) * (k - mid + 1) / 2 <= n) {     high = mid;    } else     low = mid;   }   return high;  } }
3,public class wef { public static class FastReader { BufferedReader br; StringTokenizer st;    public FastReader() {  br = new BufferedReader(new InputStreamReader(System.in)); }  String next() {  while (st == null || !st.hasMoreTokens()) {  try {   st = new StringTokenizer(br.readLine());  } catch (Exception r) {   r.printStackTrace();  }  }  return st.nextToken(); }  int nextInt() {  return Integer.parseInt(next()); }  double nextDouble() {  return Double.parseDouble(next()); }  long nextLong() {  return Long.parseLong(next()); }  String nextLine() {  String str = "";  try {  str = br.readLine();  } catch (Exception r) {  r.printStackTrace();  }  return str; } } static ArrayList<String>list1=new ArrayList<String>(); static void combine(String instr, StringBuffer outstr, int index,int k) { if(outstr.length()==k) {  list1.add(outstr.toString());return; } if(outstr.toString().length()==0) outstr.append(instr.charAt(index));  for (int i = 0; i < instr.length(); i++)  {   outstr.append(instr.charAt(i));     combine(instr, outstr, i + 1,k);   outstr.deleteCharAt(outstr.length() - 1);  }  index++; } static ArrayList<ArrayList<Integer>>l=new ArrayList<>(); static void comb(int n,int k,int ind,ArrayList<Integer>list) { if(k==0) {  l.add(new ArrayList<>(list));  return; }   for(int i=ind;i<=n;i++) {  list.add(i);  comb(n,k-1,ind+1,list);   list.remove(list.size()-1);   }      } static long sum(long n) { long sum=0; while(n!=0) {  sum+=n%10;  n/=10; } return sum; }  static boolean check(HashMap<Integer,Integer>map) { for(int h:map.values())  if(h>1)  return false; return true; } static class Pair implements Comparable<Pair>{  int x;int y;  Pair(int x,int y){   this.x=x;   this.y=y;    } @Override public int compareTo(Pair o) {   return x-o.x;   } } static boolean isPrime(int n) {    if (n <= 1)   return false;  if (n <= 3)   return true;         if (n % 2 == 0 ||   n % 3 == 0)   return false;   for (int i = 5;     i * i <= n; i = i + 6)   if (n % i == 0 ||    n % (i + 2) == 0)    return false;   return true; }   static long gcd(long a, long b) {  if (b == 0)  return a;  return gcd(b, a % b); }  public static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));  public static void main(String[] args) {   FastReader in=new FastReader(); HashMap<Integer,Integer>map=new HashMap<Integer,Integer>(); ArrayList<Integer>list=new ArrayList<Integer>(); TreeSet<Integer>set=new TreeSet<Integer>();  int n=in.nextInt(); for(int i=0;i<n;i++)  set.add(in.nextInt());  int ans=0;  while(!set.isEmpty()) {  int f=set.first();  int s=f;  while(!set.isEmpty()&&s<=set.last())  {  if(set.contains(s))  set.remove(new Integer(s));  s+=f;  }  ans++;   } out.println(ans);  out.close();     } }
3,public class Paint {  public static void main (String srgs[] ){     Scanner sc=new Scanner(System.in);   int n=sc.nextInt();   TreeSet<Integer> ts=new TreeSet<>();   for(int i=0;i<n;++i){    ts.add(sc.nextInt());   }   int x=0;   int a[]=new int[ts.size()];   for(int y:ts){    a[x++]=y;   }   for(int i=0;i<ts.size()-1;++i){    for(int j=i+1;j<ts.size();++j){     if((a[i]!=-1)&&(a[j]!=-1)&&(a[j]%a[i]==0)){      a[j]=-1;     }    }   }   int c=0;   for(int z:a){    if(z!=-1)++c;   }   System.out.print(c);  } }
5,public class A {  private void solve() throws IOException {   int n = nextInt();   int k = nextInt();   Point[] p = new Point[n];   for (int i = 0; i < n; i++)    p[i] = new Point(nextInt(), nextInt());   Arrays.sort(p, new Comparator<Point>() {    @Override    public int compare(Point o1, Point o2) {     if (o1.x == o2.x) return o1.y - o2.y;     return o2.x - o1.x;    }   });     Point cur = p[k - 1];   int res = 0;   for (int i = 0; i < p.length; i++) {    if (p[i].x == cur.x && p[i].y == cur.y) res++;   }   pl(res);  }  public static void main(String[] args) {   new A().run();  }  BufferedReader reader;  StringTokenizer tokenizer;  PrintWriter writer;  public void run() {   try {    reader = new BufferedReader(new InputStreamReader(System.in));    tokenizer = null;    writer = new PrintWriter(System.out);    solve();    reader.close();    writer.close();   } catch (Exception e) {    e.printStackTrace();    System.exit(1);   }  }  int nextInt() throws IOException {   return Integer.parseInt(nextToken());  }  long nextLong() throws IOException {   return Long.parseLong(nextToken());  }  double nextDouble() throws IOException {   return Double.parseDouble(nextToken());  }  BigInteger nextBigInteger() throws IOException {   return new BigInteger(nextToken());  }  String nextToken() throws IOException {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    tokenizer = new StringTokenizer(reader.readLine());   }   return tokenizer.nextToken();  }  void p(Object... objects) {   for (int i = 0; i < objects.length; i++) {    if (i != 0)     writer.print(' ');    writer.flush();    writer.print(objects[i]);    writer.flush();   }  }  void pl(Object... objects) {   p(objects);   writer.flush();   writer.println();   writer.flush();  }  int cc;  void pf() {   writer.printf("Case #%d: ", ++cc);   writer.flush();  } }
3,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputScanner in = new InputScanner(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskC solver = new TaskC();   solver.solve(1, in, out);   out.close();  }  static class TaskC {   public void solve(int testNumber, InputScanner in, PrintWriter out) {    int[] arr = in.readIntArr();    int n = arr[0];    int r = arr[1];    int[] x = in.readIntArr();    for (int i = 0; i < n; i++) {     x[i] += 999;    }    double[] h = new double[n];    int dsk[] = new int[3000];    Arrays.fill(dsk, -1);    for (int i = 0; i < r; i++) {     dsk[x[0] + i] = 0;     dsk[x[0] - i - 1] = 0;    }    int rs = 4 * r * r;    h[0] = r;     for (int i = 1; i < n; i++) {     double ch = r;     for (int j = 0; j < r; j++) {      if (dsk[x[i] + j] != -1) {       int ind = dsk[x[i] + j];       int diff = x[ind] - x[i];       int diffs = diff * diff;       int hs = rs - diffs;       ch = Math.max(ch, h[ind] + Math.sqrt(hs));      }      if (dsk[x[i] - j - 1] != -1) {       int ind = dsk[x[i] - j - 1];       int diff = x[ind] - x[i];       int diffs = diff * diff;       int hs = rs - diffs;       ch = Math.max(ch, h[ind] + Math.sqrt(hs));      }      }     if (x[i] + r < 3000) {      if (dsk[x[i] + r] != -1) {       ch = Math.max(ch, h[dsk[x[i] + r]]);      }     }     if (x[i] - r - 1 > 0) {      if (dsk[x[i] - r - 1] != -1) {       ch = Math.max(ch, h[dsk[x[i] - r - 1]]);      }     }     for (int j = 0; j < r; j++) {      dsk[x[i] + j] = i;      dsk[x[i] - j - 1] = i;     }     h[i] = ch;    }    for (int i = 0; i < n; i++) {     out.print(h[i] + " ");    }    out.println();   }  }  static class InputScanner {   BufferedReader br;   public InputScanner(InputStream is) {    br = new BufferedReader(new InputStreamReader(is));   }   String readLine() {    String line = null;    try {     line = br.readLine();    } catch (IOException e) {     e.printStackTrace();    }    return line;   }   public String[] readStringArr() {    return readLine().split(" ");   }   public int[] readIntArr() {    String[] str = readStringArr();    int arr[] = new int[str.length];    for (int i = 0; i < arr.length; i++)     arr[i] = Integer.parseInt(str[i]);    return arr;   }  } }
4,public class EdE { static long[] mods = {1000000007, 998244353, 1000000009}; static long mod = mods[0]; public static MyScanner sc;  public static PrintWriter out;  static long[][][] paths;  static long[] powers501; public static void main(String[] havish) throws Exception{    sc = new MyScanner();  out = new PrintWriter(System.out);  int n = sc.nextInt();  int m = sc.nextInt();  int k = sc.nextInt();  paths = new long[n+1][m+1][4];   powers501 = new long[5];  powers501[0] = 1;  for(int j = 1;j<5;j++){   powers501[j] = 501L*powers501[j-1];  }  long[][][]dp = new long[n+1][m+1][k/2+2];  for(int i = 1;i<=n;i++){   for(int j = 1;j<=m-1;j++){   int val = sc.nextInt();   paths[i][j][3] = val;   paths[i][j+1][2] = val;    }  }  for(int i = 1;i<=n-1;i++){   for(int j = 1;j<=m;j++){   int val = sc.nextInt();    paths[i][j][1] = val;   paths[i+1][j][0] = val;      }  }  for(int j = 1;j<=n;j++){   for(int i = 1;i<=m;i++){   Arrays.fill(dp[j][i], Integer.MAX_VALUE);   dp[j][i][0] = 0;   }  }  for(int steps = 1;steps<k/2+2;steps++){   for(int i = 1;i<=n;i++){   for(int j = 1;j<=m;j++){    if (i-1 > 0) {    dp[i][j][steps] = Math.min(dp[i-1][j][steps-1] + getVal(i, j, i-1, j), dp[i][j][steps]);    }    if (j-1 > 0) {    dp[i][j][steps] = Math.min(dp[i][j-1][steps-1] + getVal(i, j, i, j-1), dp[i][j][steps]);    }       if (i+1 <= n) {    dp[i][j][steps] = Math.min(dp[i+1][j][steps-1] + getVal(i, j, i+1, j), dp[i][j][steps]);    }    if (j+1 <= m) {    dp[i][j][steps] = Math.min(dp[i][j+1][steps-1] + getVal(i, j, i, j+1), dp[i][j][steps]);    }   }   }  }  if (k%2 == 1){   for(int j = 1;j<=n;j++){   for(int s = 1;s<=m;s++){    out.print(-1 + " ");   }   out.println();   }  }  else{   for(int j = 1;j<=n;j++){   for(int s = 1;s<=m;s++){    out.print(dp[j][s][k/2]*2L + " ");   }   out.println();   }  }         out.close();  } public static long getVal(int x1, int y1, int x2, int y2) {  if (x2 == x1+1)  return paths[x1][y1][1];  else if (x1 == x2+1)  return paths[x1][y1][0];  else if (y2 == y1 + 1)  return paths[x1][y1][3];  else  return paths[x1][y1][2]; } public static void sort(int[] array){  ArrayList<Integer> copy = new ArrayList<>();  for (int i : array)  copy.add(i);  Collections.sort(copy);  for(int i = 0;i<array.length;i++)  array[i] = copy.get(i); } static String[] readArrayString(int n){  String[] array = new String[n];  for(int j =0 ;j<n;j++)  array[j] = sc.next();  return array; } static int[] readArrayInt(int n){  int[] array = new int[n];  for(int j = 0;j<n;j++)   array[j] = sc.nextInt();  return array;  } static int[] readArrayInt1(int n){  int[] array = new int[n+1];  for(int j = 1;j<=n;j++){  array[j] = sc.nextInt();  }  return array; } static long[] readArrayLong(int n){  long[] array = new long[n];  for(int j =0 ;j<n;j++)  array[j] = sc.nextLong();  return array; } static double[] readArrayDouble(int n){  double[] array = new double[n];  for(int j =0 ;j<n;j++)  array[j] = sc.nextDouble();  return array; } static int minIndex(int[] array){  int minValue = Integer.MAX_VALUE;  int minIndex = -1;  for(int j = 0;j<array.length;j++){  if (array[j] < minValue){   minValue = array[j];   minIndex = j;  }  }  return minIndex; } static int minIndex(long[] array){  long minValue = Long.MAX_VALUE;  int minIndex = -1;  for(int j = 0;j<array.length;j++){  if (array[j] < minValue){   minValue = array[j];   minIndex = j;  }  }  return minIndex; } static int minIndex(double[] array){  double minValue = Double.MAX_VALUE;  int minIndex = -1;  for(int j = 0;j<array.length;j++){  if (array[j] < minValue){   minValue = array[j];   minIndex = j;  }  }  return minIndex; } static long power(long x, long y){  if (y == 0)  return 1;  if (y%2 == 1)  return (x*power(x, y-1))%mod;  return power((x*x)%mod, y/2)%mod; } static void verdict(boolean a){   out.println(a ? "YES" : "NO");  }  public static class MyScanner {   BufferedReader br;   StringTokenizer st;   public MyScanner() {    br = new BufferedReader(new InputStreamReader(System.in));   }   String next() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     }     catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }   int nextInt() {    return Integer.parseInt(next());   }   long nextLong() {    return Long.parseLong(next());   }   double nextDouble() {    return Double.parseDouble(next());   }   String nextLine() {    String str = "";    try{     str = br.readLine();    }    catch (IOException e) {     e.printStackTrace();    }    return str;   }    } }
0,public class A { public static void main (String[] args){  Scanner in = new Scanner(System.in);  PrintWriter out = new PrintWriter(System.out);   int n = in.nextInt();   out.printf(Locale.US, "%d", n/2*3);   out.close(); } }
1,public class Solution implements Runnable{  private static BufferedReader br = null;  private static PrintWriter out = null;  private static StringTokenizer stk = null;   public static void main(String[] args) {   br = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);   (new Thread(new Solution())).start();  }   private void loadLine() {   try {    stk = new StringTokenizer(br.readLine());   }   catch (IOException e) {    e.printStackTrace();   }  }   private String nextLine() {   try {    return br.readLine();   }   catch (IOException e) {    e.printStackTrace();   }   return null;  }   private Integer nextInt() {   while (stk==null||!stk.hasMoreTokens()) loadLine();   return Integer.parseInt(stk.nextToken());  }   private Long nextLong() {   while (stk==null||!stk.hasMoreTokens()) loadLine();   return Long.parseLong(stk.nextToken());  }   private String nextWord() {   while (stk==null||!stk.hasMoreTokens()) loadLine();   return (stk.nextToken());  }   private Double nextDouble() {   while (stk==null||!stk.hasMoreTokens()) loadLine();   return Double.parseDouble(stk.nextToken());  }   public void run() {   int n = nextInt();   int k = nextInt();     boolean[] isP = new boolean[2*n];   Arrays.fill(isP, true);   isP[0] = isP[1] = false;     for (int i = 0; i <= n; ++i) {    if (isP[i]) {     for (int j = i+i; j <= n; j+=i) {      isP[j] = false;     }    }   }     ArrayList<Integer> p = new ArrayList<Integer>();   for (int i = 0; i <= n; ++i) {    if (isP[i]) {     p.add(i);    }   }     int cnt = 0;   for (int i = 0; i < p.size(); ++i) {    int num = p.get(i) - 1;       for (int j = 0; j < p.size() - 1; ++j) {     if (p.get(j) + p.get(j+1) == num) {      ++cnt;      break;     }    }   }     if (cnt >= k) {    out.println("YES");   }   else {    out.println("NO");   }   out.flush();  } }
0,public class Main {  public static void main(String[] args) throws IOException {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);    try (PrintWriter out = new PrintWriter(outputStream)) {     TaskB solver = new TaskB();     solver.solve(1, in, out);    }  } } class TaskB {  public void solve(int testNumber, InputReader in, PrintWriter out) throws IOException{   String n = in.next();   out.println(25);  } }     class InputReader {  private final BufferedReader reader;  private StringTokenizer tokenizer;  public InputReader(InputStream stream) {   reader = new BufferedReader(new InputStreamReader(stream));   tokenizer = null;  }    public String nextLine() {   try {    return reader.readLine();   } catch (IOException e) {    throw new RuntimeException(e);   }  }    public String next() {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    tokenizer = new StringTokenizer(nextLine());   }   return tokenizer.nextToken();  }    public int nextInt() {   return Integer.parseInt(next());  }  public BigInteger nextBigInteger(){   return new BigInteger(next());  }  public long nextLong() {   return Long.parseLong(next());  }  public double nextDouble() {   return Double.parseDouble(next());  } }
1,public class Main {  public static void main(String[] args) throws NumberFormatException, IOException {    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));  int n = Integer.parseInt(in.readLine());  String in1 = in.readLine();  String store = "";  HashSet<Character> contain = new HashSet<Character>();  for(int i = 0; i < n;i++){  if(!contain.contains(in1.charAt(i))){   store += in1.charAt(i);   contain.add(in1.charAt(i));  }  }  int[] index = new int[store.length()];  for(int i = 0; i < store.length(); i++){  index [i] = -1;  }  HashSet<Integer> index2 = new HashSet<Integer>();  ArrayList<Integer> index3 = new ArrayList<Integer>();  int min = Integer.MAX_VALUE;  for(int i = 0; i < n; i++){  int index4 = store.indexOf(in1.charAt(i));  if(index[index4] == -1){   index[index4] = i;   index2.add(i);   index3.add(i);  }  else{   index2.remove(index[index4]);   index2.add(i);   index3.add(i);   index[index4] = i;  }  if(index2.size() == index.length){   while(!index2.contains(index3.get(0))){   index3.remove(0);   }   min = Math.min(min, i - index3.get(0)+ 1);  }    }  System.out.println(min); } }
6,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskF solver = new TaskF();   solver.solve(1, in, out);   out.close();  }  static class TaskF {   final int INF = (int) 1e9 + 5;   int n;   int m;   int[][][] dp;   int[][] diff;   int[][] diffStartLast;   int two(int x) {    return 1 << x;   }   boolean contain(int mask, int x) {    return (mask & two(x)) > 0;   }   int rec(int start, int pre, int mask) {    if (mask == two(n) - 1)     return INF;    int res = dp[start][pre][mask];    if (res != -1)     return res;    res = 0;    for (int i = 0; i < n; i++)     if (contain(mask, i) == false) {      int diffPre = mask == 0 ? INF : diff[pre][i];      int diffLast = (mask | two(i)) == two(n) - 1 ? diffStartLast[start][i] : INF;      res = Math.max(res, Math.min(rec(start, i, mask | two(i)), Math.min(diffLast, diffPre)));     }    dp[start][pre][mask] = res;    return res;   }   public void solve(int testNumber, InputReader in, PrintWriter out) {    n = in.nextInt();    m = in.nextInt();    int[][] grid = new int[n][m];    for (int i = 0; i < n; i++)     for (int j = 0; j < m; j++)      grid[i][j] = in.nextInt();    if (n == 1) {     int res = INF;     for (int i = 0; i + 1 < m; i++) {      res = Math.min(res, Math.abs(grid[0][i] - grid[0][i + 1]));     }     out.println(res);     return;    }    diff = new int[n][n];    diffStartLast = new int[n][n];    for (int i = 0; i < n; i++) {     for (int j = 0; j < n; j++) {      diff[i][j] = INF;      diffStartLast[i][j] = INF;      for (int k = 0; k < m; k++) {       diff[i][j] = Math.min(diff[i][j], Math.abs(grid[i][k] - grid[j][k]));       if (k + 1 < m) {        diffStartLast[i][j] = Math.min(diffStartLast[i][j], Math.abs(grid[i][k + 1] - grid[j][k]));       }      }     }    }    dp = new int[n][n][two(n)];    for (int[][] aux : dp)     for (int[] aux2 : aux)      Arrays.fill(aux2, -1);    int ans = 0;    for (int start = 0; start < n; start++) {     ans = Math.max(ans, rec(start, start, two(start)));    }    out.println(ans);   }  }  static class InputReader {   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   private InputStream stream;   public InputReader(InputStream stream) {    this.stream = stream;   }   private boolean isWhitespace(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   private int read() {    if (numChars == -1)     throw new InputMismatchException();    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (numChars <= 0)      return -1;    }    return buf[curChar++];   }   public int nextInt() {    int c = read();    while (isWhitespace(c))     c = read();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    } while (!isWhitespace(c));    return res * sgn;   }  } }
5,public class SolA {  static Scanner in; static PrintWriter out;  public static void main(String[] args) {  in = new Scanner(System.in);  out = new PrintWriter(System.out);  new SolA().run();  in.close();  out.close();  }  private void run() {  int n = in.nextInt();  int[] a = new int[n];  int sum = 0;  for(int i = 0; i < n; i++) {  a[i] = in.nextInt();  sum+=a[i];  }  Arrays.sort(a);  int cs = 0;  int kol = 0;  for(int i = n - 1; i>=0; i--) {  cs+=a[i];  kol++;  if (cs > sum - cs) {   break;  }  }  out.print(kol); } }
2,public class D {  final int MOD = (int)1e9 + 7; final double eps = 1e-12; final int INF = (int)1e9;  public D () {  long L = sc.nextLong();  long R = sc.nextLong();   int Z = 64 - Long.numberOfLeadingZeros(L ^ R);  long res = (1L << Z) - 1;  exit(res); }     static MyScanner sc = new MyScanner();  static class MyScanner {  public String next() {  newLine();  return line[index++];  }   public char nextChar() {  return next().charAt(0);  }    public int nextInt() {  return Integer.parseInt(next());  }   public long nextLong() {  return Long.parseLong(next());  }   public double nextDouble() {  return Double.parseDouble(next());  }   public String nextLine() {  line = null;  return readLine();  }   public String [] nextStrings() {  line = null;  return readLine().split(" ");  }   public char [] nextChars() {  return next().toCharArray();  }  public Integer [] nextInts() {  String [] L = nextStrings();  Integer [] res = new Integer [L.length];  for (int i = 0; i < L.length; ++i)   res[i] = Integer.parseInt(L[i]);  return res;  }    public Long [] nextLongs() {  String [] L = nextStrings();  Long [] res = new Long [L.length];  for (int i = 0; i < L.length; ++i)   res[i] = Long.parseLong(L[i]);  return res;  }  public Double [] nextDoubles() {  String [] L = nextStrings();  Double [] res = new Double [L.length];  for (int i = 0; i < L.length; ++i)   res[i] = Double.parseDouble(L[i]);  return res;  }  public String [] next (int N) {  String [] res = new String [N];  for (int i = 0; i < N; ++i)   res[i] = sc.next();  return res;  }   public Integer [] nextInt (int N) {  Integer [] res = new Integer [N];  for (int i = 0; i < N; ++i)   res[i] = sc.nextInt();  return res;  }    public Long [] nextLong (int N) {  Long [] res = new Long [N];  for (int i = 0; i < N; ++i)   res[i] = sc.nextLong();  return res;  }    public Double [] nextDouble (int N) {  Double [] res = new Double [N];  for (int i = 0; i < N; ++i)   res[i] = sc.nextDouble();  return res;  }    public String [][] nextStrings (int N) {  String [][] res = new String [N][];  for (int i = 0; i < N; ++i)   res[i] = sc.nextStrings();  return res;  }   public Integer [][] nextInts (int N) {  Integer [][] res = new Integer [N][];  for (int i = 0; i < N; ++i)   res[i] = sc.nextInts();  return res;  }   public Long [][] nextLongs (int N) {  Long [][] res = new Long [N][];  for (int i = 0; i < N; ++i)   res[i] = sc.nextLongs();  return res;  }   public Double [][] nextDoubles (int N) {  Double [][] res = new Double [N][];  for (int i = 0; i < N; ++i)   res[i] = sc.nextDoubles();  return res;  }      private boolean eol() {  return index == line.length;  }  private String readLine() {  try {   return r.readLine();  } catch (Exception e) {   throw new Error(e);  }  }  private final BufferedReader r;  MyScanner () {  this(new BufferedReader(new InputStreamReader(System.in)));  }   MyScanner(BufferedReader r) {  try {   this.r = r;   while (!r.ready())   Thread.sleep(1);   start();  } catch (Exception e) {   throw new Error(e);  }  }   private String [] line;  private int index;  private void newLine() {  if (line == null || eol()) {   line = readLine().split(" ");   index = 0;  }  }  }  static void print(Object o, Object... a) {  printDelim(" ", o, a); }  static void cprint(Object o, Object... a) {  printDelim("", o, a); }  static void printDelim (String delim, Object o, Object... a) {  pw.println(build(delim, o, a)); }  static void exit (Object o, Object... a) {  print(o, a);  exit(); }  static void exit () {  pw.close();  System.out.flush();  System.err.println("------------------");  System.err.println("Time: " + ((millis() - t) / 1000.0));  System.exit(0); }  void NO() {  throw new Error("NO!"); }    static String build(String delim, Object o, Object... a) {  StringBuilder b = new StringBuilder();  append(b, o, delim);  for (Object p : a)  append(b, p, delim);  return b.toString().trim();  }  static void append(StringBuilder b, Object o, String delim) {  if (o.getClass().isArray()) {  int L = Array.getLength(o);  for (int i = 0; i < L; ++i)   append(b, Array.get(o, i), delim);  } else if (o instanceof Iterable<?>) {  for (Object p : (Iterable<?>)o)   append(b, p, delim);  } else  b.append(delim).append(o);  }    public static void main(String[] args) {  new D();  exit(); }  static void start() {  t = millis(); }  static PrintWriter pw = new PrintWriter(System.out);  static long t;  static long millis() {  return System.currentTimeMillis(); } }
1,public class C364 { static HashMap<Character, Integer> freq; static int unique = 0; public static void main(String[] args) throws Exception {  FastScanner in = new FastScanner();  PrintWriter pw = new PrintWriter(System.out);   int n = in.nextInt();  char[] s = in.next().toCharArray();  freq = new HashMap<Character, Integer>();  for(int i = 0; i < n; i++) {  char c = s[i];  if(!freq.containsKey(c))   freq.put(c, 0);  }   int k = freq.size();  int l = 0, r = 0, best = n;  inc(s[0]);   while(r < n) {  if(unique == k) {   best = Math.min(best, r+1-l);   dec(s[l++]);  }  else {   if(++r == n)   break;   inc(s[r]);  }  }   pw.println(best);   pw.flush();  pw.close(); }  static void inc(char c) {  int cur = freq.get(c);  if(cur == 0)  unique++;  freq.put(c, cur+1); }  static void dec(char c) {  int cur = freq.get(c);  if(cur == 1)  unique--;  freq.put(c, cur-1); }  static class FastScanner {  BufferedReader br;  StringTokenizer st;  public FastScanner() {  br = new BufferedReader(new InputStreamReader(System.in));  st = new StringTokenizer("");  }   String next() throws Exception {  while(!st.hasMoreTokens())   st = new StringTokenizer(br.readLine());  return st.nextToken();  }   int nextInt() throws Exception {  return Integer.parseInt(next());  } } }
1,public class Main { static int MAX = 1000;  static BitSet P = new BitSet(MAX + 1);   public static boolean Noldbach(int n) {  n--;   int j;   for(int i=2; i<=n; i++)  {  if(!P.get(i))  {   j = i + 1;     while(P.get(j))   j++;     if(i+j == n)   {   if(!P.get(i+j+1))   {          return true;   }   }  }  }   return false; }  public static void main(String[] args) {  Scanner lee = new Scanner(System.in);   for(int i=2; i*i<=MAX; i++)  {   if(!P.get(i))   {   for(int j=i+i; j<=MAX; j+=i)    P.set(j);   }  }   int n, k, c;   n = lee.nextInt();  k = lee.nextInt();   c = 0;   for(int i=2; i<=n; i++)  {  if(Noldbach(i))   c++;    if(c == k)   break;  }   if(c == k)  System.out.println("YES");  else  System.out.println("NO"); } }
4,public class P23A {  public P23A() {   Scanner sc = new Scanner(System.in);   String str = sc.next();   sc.close();     String maxStr = "";   for (int i = 0; i < str.length() - 1; i++){    for (int j = i + 1; j < str.length(); j++){     String pattern = str.substring(i, j);     if (str.substring(i+1).contains(pattern) && pattern.length() > maxStr.length()){      maxStr = pattern;     }    }   }   System.out.println(maxStr.length());  }   public static void main (String []args){   new P23A();  } }
6,public class ProblemB { public static int _gnum; public static int _cnum; public static int _needs; public static int _level;  public static double _maxans = 0;  public static double votedfs(int[][] grl, int g, int votes) {  if (votes >= _needs) {  return 1.0d;  }  if (g >= _gnum) {  return 0.0d;  }  double agrees = (double)grl[g][1] / 100;  return agrees * votedfs(grl, g+1, votes+1) + (1.0d - agrees) * votedfs(grl, g+1, votes); }  public static double battledfs(int[][] grl, int g, int votes, int levels) {  if (votes >= _needs) {  return 0.0d;  }  if (g >= _gnum) {  return (double)_level / (_level + levels);  }  double agrees = (double)grl[g][1] / 100;  return agrees * battledfs(grl, g+1, votes+1, levels) + (1.0d - agrees) * battledfs(grl, g+1, votes, levels + grl[g][0]); }  public static void candydfs(int[][] grl, int g, int n) {  if (g >= _gnum) {  double na = votedfs(grl, 0, 0) + battledfs(grl, 0, 0, 0);  _maxans = Math.max(_maxans, na);  return;  }   int rem = grl[g][1];  candydfs(grl, g+1, n);  for (int i = 1 ; i <= n ; i++) {  if (grl[g][1] < 100) {   grl[g][1] += 10;   candydfs(grl, g+1, n-i);  }  }  grl[g][1] = rem; }  public static void main(String[] args) throws IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));   String line = br.readLine();   String[] d = line.split(" ");   int gnum = Integer.valueOf(d[0]);   int cnum = Integer.valueOf(d[1]);   int level = Integer.valueOf(d[2]);   _gnum = gnum;   _cnum = cnum;   _needs = (gnum + 1) / 2;   if (gnum % 2 == 0) {   _needs += 1;   }   _level = level;     int[][] grl = new int[gnum][2];   for (int g = 0 ; g < gnum ; g++) {   line = br.readLine();   String[] gg = line.split(" ");   grl[g][0] = Integer.valueOf(gg[0]);   grl[g][1] = Integer.valueOf(gg[1]);   }     for (int a = 0 ; a < gnum ; a++) {    for (int b = 0 ; b < gnum - 1 ; b++) {    if (grl[b][1] < grl[b+1][1]) {     int tmp = grl[b][0];     grl[b][0] = grl[b+1][0];     grl[b+1][0] = tmp;     tmp = grl[b][1];     grl[b][1] = grl[b+1][1];     grl[b+1][1] = tmp;    }    }    }     int ag = 0;   int xnum = cnum;   for (int g = 0 ; g < gnum ; g++) {   int needs = (100 - grl[g][1]) / 10;   int roy = 0;   if (needs <= xnum) {    xnum -= needs;    roy = 100;   } else {    roy = grl[g][1] + xnum * 10;    xnum = 0;   }   if (roy >= 100) {    ag++;   }   }   if (ag >= _needs) {   System.out.println(1.0);   return;   }     candydfs(grl, 0, _cnum);     System.out.println(_maxans);   br.close(); } }
2,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskB solver = new TaskB();   solver.solve(1, in, out);   out.close();  }  static class TaskB {   int[][] dr = new int[][]{{0, 0, 0, -1}, {0, 0, -1, 0}, {0, 1, 0, 0}, {1, 0, 0, 0}};   int[][] dd = new int[][]{{1, 3}, {0, 2}, {1, 3}, {0, 2}};   PrintWriter out;   InputReader in;   int[] re1;   int[] re2;   int N;   public void solve(int testNumber, InputReader in, PrintWriter out) {    N = in.nextInt();    int r[] = new int[]{1, 1, N, N};    this.out = out;    this.in = in;    re1 = new int[]{1, 1, 1, 1};    re2 = new int[]{2, 1, 2, 1};        int fr[] = moveSide(r, dr[2], dd[2]);    int sr[] = subtract(r, fr);    if (!validSeparation(sr)) {     fr = moveSide(r, dr[1], dd[1]);     sr = subtract(r, fr);    }    fr = boundary(fr);    sr = boundary(sr);    out.println(String.format("! %d %d %d %d %d %d %d %d", fr[0], fr[1], fr[2], fr[3], sr[0], sr[1], sr[2], sr[3]));   }   private boolean validSeparation(int[] sr) {    if (!validRectangle(sr)) return false;    out.println(String.format("? %d %d %d %d", sr[0], sr[1], sr[2], sr[3]));    out.flush();    return in.nextInt() == 1;   }   private boolean validRectangle(int[] sr) {    for (int i = 0; i < 4; i++) {     if (sr[i] < 1 || sr[i] > N) return false;    }    return true;   }   private int[] boundary(int[] r) {    for (int d = 0; d < 4; d++) {     r = moveSide(r, dr[d], dd[d]);    }    return r;   }   private int[] subtract(final int[] r, final int[] fr) {    if (r[1] == fr[1]) {         return new int[]{fr[2] + 1, r[1], r[2], r[3]};    }       return new int[]{r[0], r[1], r[2], fr[1] - 1};   }   private int[] moveSide(final int[] rect, final int[] factors, final int[] widths) {    int width = Math.abs(rect[widths[0]] - rect[widths[1]]);    int lo = -1, hi = width + 1;    while (lo + 1 < hi) {     int m = lo + (hi - lo) / 2;     int qr[] = new int[4];     for (int d = 0; d < 4; d++) qr[d] = rect[d] + factors[d] * m;     int ans = query(qr);     if (ans != 0) {      lo = m;     } else {      hi = m;     }    }    int ans_rect[] = new int[4];    for (int d = 0; d < 4; d++) ans_rect[d] = rect[d] + factors[d] * lo;    return ans_rect;   }   private int query(final int[] qr) {    int ans = 0;    out.println(String.format("? %d %d %d %d", qr[0], qr[1], qr[2], qr[3]));    out.flush();    ans = in.nextInt();     return ans;   }  }  static class InputReader {   public BufferedReader reader;   public StringTokenizer tokenizer;   public InputReader(InputStream stream) {    reader = new BufferedReader(new InputStreamReader(stream), 32768);    tokenizer = null;   }   public String next() {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      tokenizer = new StringTokenizer(reader.readLine());     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return tokenizer.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }  } }
3,public class Main {  public static void main(String args[])  {   FastReader input=new FastReader();   PrintWriter out=new PrintWriter(System.out);   int T=1;   while(T-->0)   {    int n=input.nextInt();    int a[]=new int[n];    for(int i=0;i<n;i++)    {     a[i]=input.nextInt();    }    HashMap<Integer,ArrayList<Pair>> map=new HashMap<>();    for(int i=0;i<n;i++)    {     int sum=0;     for(int j=i;j<n;j++)     {      sum+=a[j];      if(map.containsKey(sum))      {       map.get(sum).add(new Pair(i,j));      }      else      {       map.put(sum,new ArrayList<>());       map.get(sum).add(new Pair(i,j));      }     }    }    int max=Integer.MIN_VALUE;    Iterator it=map.entrySet().iterator();    ArrayList<Pair> setBlocks=new ArrayList<>();    while(it.hasNext())    {     Map.Entry e=(Map.Entry)it.next();     ArrayList<Pair> list=(ArrayList)e.getValue();     Collections.sort(list, new Comparator<Pair>() {      @Override      public int compare(Pair o1, Pair o2) {       if(o1.l==o2.l)       {        return o1.r-o2.r;       }       else       {        return o1.l-o2.l;       }      }     });     Pair1 sufMin[]=new Pair1[list.size()];     TreeSet<Pair> set=new TreeSet<>(new Comparator<Pair>() {      @Override      public int compare(Pair o1, Pair o2) {       if(o1.l==o2.l)       {        return o1.r-o2.r;       }       else       {        return o1.l-o2.l;       }      }     });     int min=Integer.MAX_VALUE;     int index=-1;     for(int j=list.size()-1;j>=0;j--)     {      if(min>=list.get(j).r)      {       min=list.get(j).r;       index=j;      }      sufMin[j]=new Pair1(min,index);      set.add(new Pair(list.get(j).l,j));     }     int count=0;     int j=0;     ArrayList<Pair> blocks=new ArrayList<>();     while(j<list.size())     {      int m=sufMin[j].min;      int ind=sufMin[j].index;      blocks.add(list.get(ind));      count++;      Pair p=new Pair(m+1,0);      if(set.ceiling(p)==null)      {       break;      }      else      {       Pair p1=set.ceiling(p);       j=p1.r;      }     }     if(max<count)     {      max=count;      setBlocks=blocks;     }    }    out.println(max);    for(int i=0;i<setBlocks.size();i++)    {     out.println((setBlocks.get(i).l+1)+" "+(setBlocks.get(i).r+1));    }   }   out.close();  }  public static class Pair1  {   int min,index;   Pair1(int min,int index)   {    this.min=min;    this.index=index;   }  }  public static class Pair  {   int l,r;   Pair(int l,int r)   {    this.l=l;    this.r=r;   }  }  static class FastReader  {   BufferedReader br;   StringTokenizer st;   public FastReader()   {    br = new BufferedReader(new InputStreamReader(System.in));   }   String next()   {    while (st == null || !st.hasMoreElements())    {     try     {      st = new StringTokenizer(br.readLine());     }     catch (IOException e)     {      e.printStackTrace();     }    }    return st.nextToken();   }   int nextInt()   {    return Integer.parseInt(next());   }   long nextLong()   {    return Long.parseLong(next());   }   double nextDouble()   {    return Double.parseDouble(next());   }   String nextLine()   {    String str="";    try    {     str=br.readLine();    }    catch (IOException e)    {     e.printStackTrace();    }    return str;   }  } }
5,public class Solution {  public static void main(String [] args) {   Scanner scan = new Scanner(System.in);   int n = scan.nextInt();   int [] a = new int [n];   int i;   int s = 0;   for (i = 0; i < n; i++) {    a[i] = scan.nextInt();    s += a[i];   }   Arrays.sort(a);   int sum = 0;   for (i = n - 1; i > -1; i--) {    sum += a[i];    if (s - sum < sum) {     System.out.println(n - i);     return;    }   }  } }
2,public class Solution implements Runnable {   boolean hasBit(long n, int pos) {   return (n & (1L << pos)) != 0;  }   public void solve() throws Exception {   long l = sc.nextLong(), r = sc.nextLong();   int bit = 62;   while (bit >= 0 && (hasBit(l, bit) == hasBit(r, bit))) {    bit--;   }   out.println((1L << (bit + 1)) - 1);  }   static Throwable uncaught;   BufferedReader in;  FastScanner sc;  PrintWriter out;   @Override  public void run() {   try {    in = new BufferedReader(new InputStreamReader(System.in));    out = new PrintWriter(System.out);    sc = new FastScanner(in);    solve();   } catch (Throwable uncaught) {    Solution.uncaught = uncaught;   } finally {    out.close();   }  }   public static void main(String[] args) throws Throwable {   Thread thread = new Thread (null, new Solution(), "", (1 << 26));   thread.start();   thread.join();   if (Solution.uncaught != null) {    throw Solution.uncaught;   }  } } class FastScanner {   BufferedReader in;  StringTokenizer st;   public FastScanner(BufferedReader in) {   this.in = in;  }   public String nextToken() throws Exception {   while (st == null || !st.hasMoreTokens()) {    st = new StringTokenizer(in.readLine());   }   return st.nextToken();  }   public int nextInt() throws Exception {   return Integer.parseInt(nextToken());  }   public long nextLong() throws Exception {   return Long.parseLong(nextToken());  }   public double nextDouble() throws Exception {   return Double.parseDouble(nextToken());  }  }
3,public class Main6{ static class Pair {  int x;  int y;  int z;  public Pair(int x,int y,int z)  {   this.x= x;   this.y= y;  this.z=z;  }    @Override  public int hashCode()   {   final int temp = 14;   int ans = 1;   ans =x*31+y*13;   return ans;   }        @Override  public boolean equals(Object o)  {   if (this == o) {   return true;   }   if (o == null) {   return false;   }   if (this.getClass() != o.getClass()) {   return false;   }   Pair other = (Pair)o;   if (this.x != other.x || this.y!=other.y) {   return false;   }   return true;  }    }  static class Pair1 {  String x;  int y;  int z;   } static class Compare {  static void compare(Pair arr[], int n)  {      }   }   public static long pow(long a, long b) {  long result=1;  while(b>0)  {  if (b % 2 != 0)  {   result=(result*a)%998244353;   b--;  }   a=(a*a)%998244353;  b /= 2;  }   return result; } public static long fact(long num) {   long value=1;   int i=0;   for(i=2;i<num;i++)   {   value=((value%mod)*i%mod)%mod;   }   return value;  }  public static int gcd(int a, int b)  {   if (a == 0)   return b;   return gcd(b%a, a);  }    public static long sum(int h)  {   return (h*(h+1)/2);  }  public static void dfs(int parent,boolean[] visited,int[] dp)  {   ArrayList<Integer> arr=new ArrayList<Integer>();   arr=graph.get(parent);   visited[parent]=true;   for(int i=0;i<arr.size();i++)   {   int num=(int)arr.get(i);   if(visited[num]==false)   {    dfs(num,visited,dp);   }   dp[parent]=Math.max(dp[num]+1,dp[parent]);   }  }    static int[] dis;  static int mod=1000000007;  static ArrayList<ArrayList<Integer>> graph;    public static void bfs(int num,int size)  {   boolean[] visited=new boolean[size+1];   Queue<Integer> q=new LinkedList<>();   q.add(num);   ans[num]=1;   visited[num]=true;   while(!q.isEmpty())   {   int x=q.poll();   ArrayList<Integer> al=graph.get(x);   for(int i=0;i<al.size();i++)   {    int y=al.get(i);    if(visited[y]==false)    {    q.add(y);    ans[y]=ans[x]+1;    visited[y]=true;    }   }   }  }  static int[] ans;                      public static int[] sort(int[] a)  {   int n=a.length;   ArrayList<Integer> ar=new ArrayList<>();   for(int i=0;i<a.length;i++)   {   ar.add(a[i]);   }   Collections.sort(ar);   for(int i=0;i<n;i++)   {   a[i]=ar.get(i);   }   return a;  }  static public void main(String args[])throws IOException  {   int n=i();   int[] a=new int[n];   for(int i=0;i<n;i++)   {   a[i]=i();   }   Arrays.sort(a);   boolean[] flag=new boolean[n];   int ans=0;   for(int i=0;i<n;i++)   {   if(flag[i]==false)   {    ans++;    for(int j=0;j<n;j++)    {    if(a[j]%a[i]==0 && flag[j]==false)    {     flag[j]=true;    }    }   }   }   pln(ans+"");  }          static InputReader in=new InputReader(System.in);   static OutputWriter out=new OutputWriter(System.out);   public static long l()   {   String s=in.String();   return Long.parseLong(s);   }   public static void pln(String value)   {   System.out.println(value);   }   public static int i()   {   return in.Int();   }   public static String s()   {   return in.String();   } }                                              class InputReader {     private InputStream stream;  private byte[] buf = new byte[1024];  private int curChar;  private int numChars;  private SpaceCharFilter filter;    public InputReader(InputStream stream) {   this.stream = stream;  }    public int read() {   if (numChars== -1)   throw new InputMismatchException();   if (curChar >= numChars) {   curChar = 0;   try {    numChars = stream.read(buf);   } catch (IOException e) {    throw new InputMismatchException();   }   if (numChars <= 0)    return -1;   }   return buf[curChar++];  }    public int Int() {   int c = read();   while (isSpaceChar(c))   c = read();   int sgn = 1;   if (c == '-') {   sgn = -1;   c = read();   }   int res = 0;   do {   if (c < '0' || c > '9')    throw new InputMismatchException();   res *= 10;   res += c - '0';   c = read();   } while (!isSpaceChar(c));   return res * sgn;  }    public String String() {   int c = read();   while (isSpaceChar(c))   c = read();   StringBuilder res = new StringBuilder();   do {   res.appendCodePoint(c);   c = read();   } while (!isSpaceChar(c));   return res.toString();  }    public boolean isSpaceChar(int c) {   if (filter != null)   return filter.isSpaceChar(c);   return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;  }    public String next() {   return String();  }    public interface SpaceCharFilter {   public boolean isSpaceChar(int ch);  }  }    class OutputWriter {  private final PrintWriter writer;    public OutputWriter(OutputStream outputStream) {   writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));  }    public OutputWriter(Writer writer) {   this.writer = new PrintWriter(writer);  }    public void print(Object...objects) {   for (int i = 0; i < objects.length; i++) {   if (i != 0)    writer.print(' ');   writer.print(objects[i]);   }  }    public void printLine(Object...objects) {   print(objects);   writer.println();  }    public void close() {   writer.close();  }    public void flush() {   writer.flush();  }    }    class IOUtils {    public static int[] readIntArray(InputReader in, int size) {   int[] array = new int[size];   for (int i = 0; i < size; i++)   array[i] = in.Int();   return array;  }    }
1,public class Task25a {   public static void main(String[] args) {  Scanner sc = new Scanner(System.in);  int n = sc.nextInt();  int a1 = 0, a2 = 0;  int n1 = 0, n2 = 0;  for (int i = 1; i <= n; i++) {  int c = sc.nextInt();  if (c % 2 == 1) {   a1 = i;   n1++;  } else {   a2 = i;   n2++;  }  }  if (n1 == 1) {  System.out.println(a1);  } else {  System.out.println(a2);  } } }
6,public class Main {  public static void main(String[] args) {     Scanner in = new Scanner(System.in);   int n = in.nextInt();   int m = in.nextInt();     boolean[][] graph = new boolean[n][n];     for(int i = 0; i < m; i++) {    int from = in.nextInt() - 1;    int to = in.nextInt() - 1;    graph[from][to] = true;    graph[to][from] = true;   }   int max = 1 << n;   long[][] dp = new long[max][n];   for(int mask = 1; mask < max; mask++) {    for(int i = 0; i < n; i++) {     int countMask = Integer.bitCount(mask);     boolean existSubSeti = (mask & (1 << i)) > 0;     if(countMask == 1 && existSubSeti) {      dp[mask][i] = 1;     }     else if(countMask > 1 && existSubSeti) {      int mask1 = mask ^ (1 << i);      for(int j = 0; j < n; j++) {       if(((mask1 & (1 << j)) > 0) && graph[j][i] && i != firstMask(mask, n)) {        dp[mask][i] += dp[mask1][j];       }      }     }    }   }     long counter = 0;   for(int mask = 1; mask < max; mask++) {    for(int i = 0; i < n; i++) {     if(Integer.bitCount(mask) >= 3 && graph[firstMask(mask, n)][i]) {      counter += dp[mask][i];     }    }      }   System.out.println(counter / 2);   in.close();  }   public static int firstMask(int mask, int n) {   for(int i = 0; i < n; i++) {    if((mask & (1 << i)) > 0) return i;   }   return -1;    } }
4,public class Cbeta35 { public static void main(String[] args) { new Cbeta35(); } Scanner in; PrintWriter out;  int t; int n, m, k, oo; int[][] grid;  boolean debug = !true, multi = !true;  Cbeta35() {  if (multi) t = in.nextInt();  do {  if (multi) if (z(t--)) break;   try {   in = new Scanner(new File("input.txt"));   out = new PrintWriter(new File("output.txt"));  }  catch (Exception e) {   in = new Scanner(System.in);   out = new PrintWriter(System.out);  }   n = in.nextInt();  m = in.nextInt();  k = in.nextInt();   oo = n + m + 1;  grid = new int[n][m];  for (int i = 0; i < n; i++)   Arrays.fill(grid[i], oo);  for (int i = 0; i < k; i++) {   int x = in.nextInt() - 1;   int y = in.nextInt() - 1;   for (int j = 0; j < n; j++)   for (int kk = 0; kk < m; kk++) {    int dx = j - x < 0 ? x - j : j - x;    int dy = kk - y < 0 ? y - kk : kk - y;    grid[j][kk] = min(grid[j][kk], dx + dy);   }  }   int x = 0, y = 0;  int max = 0;  for (int i = 0; i < n; i++)   for (int j = 0; j < m; j++)   if (max < grid[i][j]) {    max = grid[i][j];    x = i; y = j;   }  out.printf("%d %d%n", x + 1, y + 1);  } while (debug || multi);  out.close(); }   int min(int a, int b) { if (a < b) return a; return b; }  int max(int a, int b) { if (a > b) return a; return b; }  long min(long a, long b) { if (a < b) return a; return b; }  long max(long a, long b) { if (a > b) return a; return b; }  boolean z(int x) { if (x == 0) return true; return false; }  boolean z(long x) { if (x == 0) return true; return false; }  void sort(int[] arr) {  int szArr = arr.length;  Random r = new Random();  for (int i = 0; i < szArr; i++) {  int j = r.nextInt(szArr);  arr[i] = arr[j]^(arr[i]^(arr[j] = arr[i]));  }  Arrays.sort(arr); }  class FS {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer("");  String next() {  while (!st.hasMoreTokens()) {   try { st = new StringTokenizer(br.readLine()); }   catch (Exception e) {}  } return st.nextToken();  }  int nextInt() { return Integer.parseInt(next()); }  long nextLong() { return Long.parseLong(next()); }  double nextDouble() { return Double.parseDouble(next()); } } }
0,public class CFA {  private void work() throws IOException {  Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(   System.in)));  while (sc.hasNextInt()) {  int n = sc.nextInt();  int a = n;  int b = n / 10;  int c;  if (n < 0) {   n = -n;   c = -((n / 100) * 10 + n % 10);  } else {   c = (n / 100) * 10 + n % 10;  }  System.out.println(Math.max(a, Math.max(b, c)));  }  System.out.close(); }  private int gcd(int a, int b) {  return b == 0 ? a : gcd(b, a % b); }  public static void main(String[] args) throws IOException {  new CFA().work(); } }
2,public class Main {  boolean[] b;  int[] r;  ArrayList<ArrayList<Integer>> q;  public void dfs(int u, int p) {   for (int i = 0; i < q.get(u).size(); i++) {    int v = q.get(u).get(i);    if (v != p) {     r[v] = r[u] + 1;     if (b[u]) {      b[v] = b[u];     }     dfs(v, u);    }   }  }  public void solve() throws IOException {   long n = nextLong();   long s = nextLong();   long t = 0;   if(s + 200 < n){    t = n - s - 200;   }   for(long i = s; i <= Math.min(s + 200,n); i++){    long p = 0;    long u = i;    while (u > 0){     p += u % 10;     u /= 10;    }    if(i - p >= s){     t++;    }   }   out.print(t);  }  BufferedReader br;  StringTokenizer sc;  PrintWriter out;  public String nextToken() throws IOException {   while (sc == null || !sc.hasMoreTokens()) {    try {     sc = new StringTokenizer(br.readLine());    } catch (Exception e) {     return null;    }   }   return sc.nextToken();  }  public Integer nextInt() throws IOException {   return Integer.parseInt(nextToken());  }  public Long nextLong() throws IOException {   return Long.parseLong(nextToken());  }  public static void main(String[] args) throws IOException {   try {    Locale.setDefault(Locale.US);   } catch (Exception e) {   }   new Main().run();  }  public void run() {   try {    br = new BufferedReader(new InputStreamReader(System.in));    out = new PrintWriter(System.out);     solve();    out.close();   } catch (Exception e) {    e.printStackTrace();    System.exit(1);   }  } }
1,public class C {  public static void main(String[] args)  {   Scanner in = new Scanner(System.in);   int n = in.nextInt();   char[] s = new char[n];   String line = in.next();   int ct=0,ht=0;   for(int i=0;i<n;i++)    if(line.charAt(i)=='T')     ct++;    else     ht++;     int cnt = 1000000000;   int[] c = new int[2];   char[] cc = new char[2];   if(ct<ht)   {    c[0] = ct;    c[1] = ht;    cc[0] = 'T';    cc[1] = 'H';   }else{    c[0] = ht;    c[1] = ct;    cc[0] = 'H';    cc[1] = 'T';   }     for(int i=0;i<n;i++)   {    int ptr = i;    for(int j=0;j<c[0];j++)    {     s[ptr] = cc[0];     ptr = (ptr+1)%n;    }    for(int j=0;j<c[1];j++)    {     s[ptr] = cc[1];     ptr = (ptr+1)%n;    }       int ch = 0;    for(int j=0;j<n;j++)     if(s[j]!=line.charAt(j)&&s[j]==cc[0])      ch++;    cnt = Math.min(cnt,ch);   }     System.out.print(cnt);  } }
1,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   Scanner in = new Scanner(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskC solver = new TaskC();   solver.solve(1, in, out);   out.close();  }  static class TaskC {   public void solve(int testNumber, Scanner in, PrintWriter out) {    int n = in.nextInt();    String s = in.next();    int[] cnt = new int[26];    int[] cnt2 = new int[26];    int j = 0;    int res = n;    HashSet<Character> set = new HashSet<Character>();    for (char c : s.toCharArray()) {     set.add(c);    }    int m = set.size();    for (int i = 0; i < n; ++i) {     if (Character.isLowerCase(s.charAt(i))) {      cnt[s.charAt(i) - 'a']++;     } else {      cnt2[s.charAt(i) - 'A']++;     }     while (isOK(cnt, cnt2, m)) {      res = Math.min(res, i - j + 1);      if (Character.isLowerCase(s.charAt(j))) {       cnt[s.charAt(j) - 'a']--;      } else {       cnt2[s.charAt(j) - 'A']--;      }      ++j;     }    }    out.println(res);   }   boolean isOK(int[] cnt, int[] cnt2, int m) {    int c = 0;    for (int i = 0; i < 26; ++i) {     if (cnt[i] > 0) {      ++c;     }    }    for (int i = 0; i < 26; ++i) {     if (cnt2[i] > 0) {      ++c;     }    }    return c >= m;   }  } }
4,public class Main {  static PrintWriter out;  static Reader in;  public static void main(String[] args) throws IOException {   input_output();   Main solver = new Main();   solver.solve();   out.close();   out.flush();  }  static long INF = (long)1e18;  static int MAXN = (int)1e7+5;  static int mod = 998_244_353;  static int n, m, q, t;  static double pi = Math.PI;  void solve() throws IOException{  t = in.nextInt();   int[] div = new int[MAXN];  Arrays.fill(div, 1);  for (int i = 2; i < MAXN; i++) {   if (div[i] == 1) {   for (int j = i; j < MAXN; j+=i) {    div[j] = i;   }   }  }   while (t --> 0) {   n = in.nextInt();  int k = in.nextInt();   int[] arr = new int[n+1];  for (int i = 1; i <= n; i++) {   arr[i] = in.nextInt();   int tmp = arr[i], newn = 1;   while (div[arr[i]] != 1) {   int elm = div[arr[i]],    cnt = 0;   while (div[arr[i]] == elm) {    cnt++;    arr[i] /= elm;   }   if (cnt%2 == 1) newn *= elm;   }   newn *= arr[i];   arr[i] = newn;  }   int[] close = new int[n+1];  List<Node> list = new ArrayList<>();  for (int i = 1; i <= n; i++) list.add(new Node(arr[i], i));  Collections.sort(list);   for (int i = 0; i < n; i++) {   if (i == n-1 || list.get(i+1).val != list.get(i).val) {   close[list.get(i).idx] = -1;   } else {   close[list.get(i).idx] = list.get(i+1).idx;   }  }   int[][] next = new int[n+1][k+1];  List<Integer> upd = new ArrayList<>();  List<Integer> nupd = new ArrayList<>();  for (int i = 0; i <= k; i++) next[n][i] = n;  for (int i = n-1; i >= 1; i--) {   nupd.clear();   if (close[i] == -1) {   for (int j = 0; j <= k; j++) next[i][j] = next[i+1][j];   } else {   int tmp = close[i]-1, cnt = 0;   if (upd.size() == 0 || tmp < upd.get(0)) {    nupd.add(tmp);    tmp = -1;   }   for (int j = 0; j < upd.size(); j++) {    if (nupd.size() < k+1 && tmp != -1 && tmp < upd.get(j)) {    nupd.add(tmp);    tmp = -1;    }    if (nupd.size() < k+1) nupd.add(upd.get(j));   }   if (tmp != -1 && nupd.size() < k+1) nupd.add(tmp);    for (int j = 0; j < nupd.size(); j++)    next[i][j] = nupd.get(j);   for (int j = nupd.size(); j <= k; j++)    next[i][j] = n;    upd.clear();   for (int j = 0; j < nupd.size(); j++) upd.add(nupd.get(j));   }   }    int[][] dp = new int[n+1][k+1];   for (int i = 1; i <= n; i++)   for (int j = 0; j <= k; j++)    dp[i][j] = n;   for (int i = 0; i < n; i++) {   for (int cur = 0; cur <= k; cur++) {    for (int ncur = cur; ncur <= k; ncur++) {    dp[next[i+1][ncur-cur]][ncur] = Math.min(dp[next[i+1][ncur-cur]][ncur],          dp[i][cur]+1);    }   }   }   int ans = n;   for (int i = 0; i <= k; i++) ans = Math.min(ans, dp[n][i]);   out.println(ans);  }  }    static class Node implements Comparable<Node> {  int val, idx;   Node (int val, int idx) {   this.val = val;   this.idx = idx;  }   public int compareTo(Node o) {   if (this.val != o.val) return this.val - o.val;   return this.idx - o.idx;  }  }  static class Reader {    private InputStream mIs;   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;    public Reader() {    this(System.in);   }    public Reader(InputStream is) {    mIs = is;   }    public int read() {    if (numChars == -1) {     throw new InputMismatchException();    }    if (curChar >= numChars) {     curChar = 0;     try {      numChars = mIs.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (numChars <= 0) {      return -1;     }    }    return buf[curChar++];   }    public String nextLine() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    StringBuilder res = new StringBuilder();    do {     res.appendCodePoint(c);     c = read();    } while (!isEndOfLine(c));    return res.toString();   }    public String next() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    StringBuilder res = new StringBuilder();    do {     res.appendCodePoint(c);     c = read();    } while (!isSpaceChar(c));    return res.toString();   }    double nextDouble()   {    return Double.parseDouble(next());   }    public long nextLong() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    long res = 0;    do {     if (c < '0' || c > '9') {      throw new InputMismatchException();     }     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }    public int nextInt() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if (c < '0' || c > '9') {      throw new InputMismatchException();     }     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }    public boolean isSpaceChar(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }    public boolean isEndOfLine(int c) {    return c == '\n' || c == '\r' || c == -1;   }   }  static void input_output() throws IOException {   File f = new File("in.txt");   if(f.exists() && !f.isDirectory()) {    in = new Reader(new FileInputStream("in.txt"));   } else in = new Reader();   f = new File("out.txt");   if(f.exists() && !f.isDirectory()) {    out = new PrintWriter(new File("out.txt"));   } else out = new PrintWriter(System.out);  } }
0,public class A122 {  public static void main(String aa[])  {   Scanner ob=new Scanner(System.in);   int n;     n=ob.nextInt();   if(n%4==0||n%7==0||n%44==0||n%47==0||n%444==0||n%447==0||n%474==0||n%477==0||n%744==0||n%747==0||n%774==0||n%777==0)   System.out.println("YES");   else   System.out.println("NO");  } }
1,public class Array implements Runnable {  void solve() throws IOException {   int n = readInt();   int k = readInt();   int a[] = new int[n];   int startIdx = 0;   int endIdx = -1;   Map<Integer,Integer> map = new HashMap<Integer,Integer>();   for(int i = 0; i < n; i ++) {    a[i] = readInt();    if(map.containsKey(a[i]))     map.put(a[i], map.get(a[i]) + 1);    else     map.put(a[i], 1);    if(map.size() == k && endIdx == -1) {     endIdx = i;     break;    }   }   if(endIdx != -1) {    while(startIdx < n && map.get(a[startIdx])>1) {     map.put(a[startIdx], map.get(a[startIdx]) - 1);     startIdx ++;    }    startIdx ++;    endIdx ++;   } else    startIdx = -1;   out.println((startIdx)+" "+(endIdx));   }   BufferedReader in;  PrintWriter out;  StringTokenizer tok = new StringTokenizer("");  public static void main(String[] args) {   new Array().run();  }  public void run() {   try {    long t1 = System.currentTimeMillis();    if (System.getProperty("ONLINE_JUDGE") != null) {     in = new BufferedReader(new InputStreamReader(System.in));     out = new PrintWriter(System.out);    } else {     in = new BufferedReader(new FileReader("/Users/shenchen/input.txt"));     out = new PrintWriter("/Users/shenchen/output.txt");    }    Locale.setDefault(Locale.US);    solve();    in.close();    out.close();    long t2 = System.currentTimeMillis();    System.err.println("Time = " + (t2 - t1));   } catch (Throwable t) {    t.printStackTrace(System.err);    System.exit(-1);   }  }  String readString() throws IOException {   while (!tok.hasMoreTokens()) {    tok = new StringTokenizer(in.readLine());   }   return tok.nextToken();  }  int readInt() throws IOException {   return Integer.parseInt(readString());  }  long readLong() throws IOException {   return Long.parseLong(readString());  }  double readDouble() throws IOException {   return Double.parseDouble(readString());  }  }
1,public class Task1b {  static int[] fromRC (String data) {  int pos = data.indexOf('C');  int res[] = new int[2];  res[0] = Integer.parseInt(data.substring(1, pos));  res[1] = Integer.parseInt(data.substring(pos + 1));  return res; }  static int[] fromXC (String data) {  int pos = 0;  int res[] = new int[2];  res[0] = res[1] = 0;  while (data.charAt(pos) >= 'A' && data.charAt(pos) <= 'Z') {  res[1] *= 26;  res[1]++;  res[1] += data.charAt(pos) - 'A';  pos++;  }  res[0] = Integer.parseInt(data.substring(pos));  return res; }  static String toRC (int[] data) {  return String.format("R%dC%d", data[0], data[1]); }  static String toXC (int[] data) {  StringBuilder sb = new StringBuilder();  while (data[1] > 0) {  data[1]--;  sb.append((char)('A' + data[1] % 26));  data[1] /= 26;  }  sb = sb.reverse();  sb.append(data[0]);  return sb.toString(); }   public static void main(String[] args) throws Exception {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  int n = Integer.parseInt(br.readLine());  for (int i = 0; i < n; i++) {  String s = br.readLine();  if ((s.charAt(0) == 'R') &&   (s.charAt(1) >= '0' && s.charAt(1) <= '9') &&   (s.indexOf('C') != -1)) {     System.out.println(toXC(fromRC(s)));  } else {   System.out.println(toRC(fromXC(s)));  }  } } }
5,public class Village{ static class House implements Comparable<House>{  public double center, length;  public House(double center, double length){  this.center = center;  this.length = length;  }  public double getRight(){  return center + length/2;  }  public double getLeft(){  return center - length/2;  }  public int compareTo(House h){  return this.center < h.center ? -1 : this.center == h.center ? 0 : 1;  }  } public static void main(String[] args){  Scanner in = new Scanner(System.in);  String[] fline = in.nextLine().split("\\s+");  int N = Integer.parseInt(fline[0]);  int T = Integer.parseInt(fline[1]);  House[] houses = new House[N];  for (int i = 0; i < N; i++){  String[] house = in.nextLine().split("\\s+");  houses[i] = new House(Double.parseDouble(house[0]), Double.parseDouble(house[1]));  }  Arrays.sort(houses);  int count = 2;  for (int i = 0; i < houses.length - 1; i++){    double diff = houses[i+1].getLeft() - houses[i].getRight();  if (diff < T) continue;  if (Math.abs(diff - T) < 1E-12) count++;  else count+=2;  }  System.out.println(count); } }
1,public class Test11 {  public static void main(String[] Args) {   Scanner sc = new Scanner(System.in);   int n = sc.nextInt();   String s0 = sc.nextLine();   int s = 0;   int m = 0;   int l = 0;   int s1 = 0;   int l1 = 0;   int s2 = 0;   int l2 = 0;   int s3 = 0;   int l3 = 0;   for (int i = 0; i < n; i++) {    s0 = sc.nextLine();    if (s0.charAt(0) == 'S') s++;    if (s0.charAt(0) == 'M') m++;    if (s0.charAt(0) == 'L') l++;    if (s0.charAt(0) == 'X' && s0.length() == 2 && s0.charAt(s0.length() - 1) == 'S') s1++;    if (s0.charAt(0) == 'X' && s0.length() == 3 && s0.charAt(s0.length() - 1) == 'S') s2++;    if (s0.charAt(0) == 'X' && s0.length() == 4 && s0.charAt(s0.length() - 1) == 'S') s3++;    if (s0.charAt(0) == 'X' && s0.length() == 2 && s0.charAt(s0.length() - 1) == 'L') l1++;    if (s0.charAt(0) == 'X' && s0.length() == 3 && s0.charAt(s0.length() - 1) == 'L') l2++;    if (s0.charAt(0) == 'X' && s0.length() == 4 && s0.charAt(s0.length() - 1) == 'L') l3++;   }    int rs = 0;   int rm = 0;   int rl = 0;   int rs1 = 0;   int rl1 = 0;   int rs2 = 0;   int rl2 = 0;   int rs3 = 0;   int rl3 = 0;   for (int i = 0; i < n; i++) {    s0 = sc.nextLine();    if (s0.charAt(0) == 'S') rs++;    if (s0.charAt(0) == 'M') rm++;    if (s0.charAt(0) == 'L') rl++;    if (s0.charAt(0) == 'X' && s0.length() == 2 && s0.charAt(s0.length() - 1) == 'S') rs1++;    if (s0.charAt(0) == 'X' && s0.length() == 3 && s0.charAt(s0.length() - 1) == 'S') rs2++;    if (s0.charAt(0) == 'X' && s0.length() == 4 && s0.charAt(s0.length() - 1) == 'S') rs3++;    if (s0.charAt(0) == 'X' && s0.length() == 2 && s0.charAt(s0.length() - 1) == 'L') rl1++;    if (s0.charAt(0) == 'X' && s0.length() == 3 && s0.charAt(s0.length() - 1) == 'L') rl2++;    if (s0.charAt(0) == 'X' && s0.length() == 4 && s0.charAt(s0.length() - 1) == 'L') rl3++;   }    int ans = Math.abs(s1 - rs1) + Math.abs(s2 - rs2) + Math.abs(s3 - rs3) + (Math.abs(s - rs) + Math.abs(l - rl) + Math.abs(m - rm))/2;   System.out.println(ans);     } }
4,public class Main {  static class Fast {  StringTokenizer st;  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  public String next() throws IOException {  while (st == null || !st.hasMoreTokens())   st = new StringTokenizer(br.readLine());  return st.nextToken();  }   public int nextInt() throws IOException {  return Integer.parseInt(next());  }   public long nextLong() throws IOException {  return Long.parseLong(next());  } }  static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  static Fast scn = new Fast();  public static void main(String args[]) throws Exception {   int t = 1;   while(t-- > 0){    func();   }   bw.close();  }  private static void func() throws Exception{   int n = scn.nextInt();   int m = scn.nextInt();   int k = scn.nextInt();   int[][] hori = new int[n][m - 1];   int[][] vert = new int[n - 1][m];   for(int i = 0; i < n; i++){    for(int j = 0; j < m - 1; j++){     hori[i][j] = scn.nextInt();    }   }   for(int i = 0; i < n - 1; i++){    for(int j = 0; j < m; j++){     vert[i][j] = scn.nextInt();    }   }   if(k % 2 != 0){    for(int i = 0; i < n; i++){     for(int j = 0; j < m; j++){      bw.append(-1 + " ");     }     bw.append("\n");    }    return;   }   int[][][] strg = new int[n][m][k + 1];               int[][] answer = new int[n][m];   for(int i = 0; i < n; i++){    for(int j = 0; j < m; j++){     answer[i][j] = steps(i, j, hori, vert, k, strg);    }   }  for(int i = 0; i < n; i++){   for(int j = 0; j < m; j++){    bw.append(answer[i][j] + " ");   }   bw.append("\n");  }    }  static int steps(int x, int y, int[][] hori, int[][] vert, int k, int[][][] strg){   if(k == 0)    return 0;   if(strg[x][y][k] != 0)    return strg[x][y][k];   int xmove = x;   int ymove = y;   int ans = 0;   int val = Integer.MAX_VALUE;   if(y < hori[0].length){    xmove = x;    ymove = y + 1;    val = Math.min(val, steps(xmove, ymove, hori, vert, k - 2, strg) + (2 * hori[x][y]));   }   if(y - 1 >= 0){    xmove = x;    ymove = y - 1;    val = Math.min(val, steps(xmove, ymove, hori, vert, k - 2, strg) + (2 * hori[x][y - 1]));      }   if(x - 1 >= 0){    xmove = x - 1;    ymove = y;    val = Math.min(val, steps(xmove, ymove, hori, vert, k - 2, strg) + (2 * vert[x - 1][y]));      }   if(x < vert.length){    xmove = x + 1;    ymove = y;    val = Math.min(val, steps(xmove, ymove, hori, vert, k - 2, strg) + (2 * vert[x][y]));      }     ans += val;   return strg[x][y][k] = ans;  } }
5,public class Main {  public static void main(String[] args) {   Scanner input = new Scanner(System.in);   int n = input.nextInt();   int k = input.nextInt() - 1 ;   int a[][] = new int[n][2];   for (int i = 0;i <n; i++) {    a[i][0]=input.nextInt();    a[i][1]=input.nextInt();   }   for (int i = 0; i<n; i++) {    for (int j=i+1; j<n; j++) {     if (a[i][0]<a[j][0]) {      int x=a[i][0];      int y=a[i][1];      a[i][0]=a[j][0];      a[i][1]=a[j][1];      a[j][0]=x;      a[j][1]=y;          }    }   }   for (int i = 0; i<n; i++) {    for (int j=i+1; j<n; j++) {     if ((a[i][1]>a[j][1])&&(a[i][0]==a[j][0])) {      int x=a[i][0];      int y=a[i][1];      a[i][0]=a[j][0];      a[i][1]=a[j][1];      a[j][0]=x;      a[j][1]=y;          }    }   }   int x = a[k][0];   int y = a[k][1];   int s = 0;   for (int i = 0; i<n; i++) {    if ((a[i][0]==x)&&(a[i][1]==y)) {     s++;    }   }   System.out.println(s);  } }
4,public class C35C_BFS_Fire {  public static boolean[][] burning;  public static LinkedList<int[]> LitTrees;  public static int N, M;  public static int[] lastTree;  public static void main(String[] args) throws IOException {        BufferedReader input = new BufferedReader(new FileReader("input.txt"));  PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("output.txt")));   StringTokenizer dataR = new StringTokenizer(input.readLine());   N = Integer.parseInt(dataR.nextToken());   M = Integer.parseInt(dataR.nextToken());   burning = new boolean[N+1][M+1];   StringTokenizer dataR1 = new StringTokenizer(input.readLine());   int K = Integer.parseInt(dataR1.nextToken());   StringTokenizer dataR2 = new StringTokenizer(input.readLine());   LitTrees = new LinkedList<int[]>();   for (int j = 0; j < K; j++){    int x = Integer.parseInt(dataR2.nextToken());    int y = Integer.parseInt(dataR2.nextToken());    int[] coord = {x, y};    LitTrees.add(coord);    burning[x][y] = true;   }   spread();   out.println(lastTree[0] + " " + lastTree[1]);   out.close();  }  public static void spread(){   while(!LitTrees.isEmpty()){    int[] studying = LitTrees.remove();    LinkedList<int[]> ll = new LinkedList<int[]>();    if(studying[0]-1 >= 1) ll.add(new int[]{studying[0]-1, studying[1]});    if(studying[1]-1 >= 1) ll.add(new int[]{studying[0], studying[1]-1});    if(studying[1]+1 < M+1) ll.add(new int[]{studying[0], studying[1]+1});    if(studying[0]+1 < N+1) ll.add(new int[]{studying[0]+1, studying[1]});    while(!ll.isEmpty()) {     int[] focus = ll.remove();     if(!burning[focus[0]][focus[1]]) {      LitTrees.add(focus);      burning[focus[0]][focus[1]] = true;     }    }    lastTree = studying;   }    }  }
0,public class FollowTrafficRules { public Scanner in = new Scanner(System.in); public PrintStream out = System.out;  public double len, d, w, vmax, a;  DecimalFormat fmt = new DecimalFormat("0.0000000000000000");  public void main() {  a = in.nextDouble();  vmax = in.nextDouble();  len = in.nextDouble();  d = in.nextDouble();  w = in.nextDouble();   out.println(fmt.format(T())); }  public double T() {  double t, s;   double t1, s1;  t1 = vmax / a;  s1 = vmax*vmax/(2.0*a);   double t3, s3;  t3 = w/a;  s3 = w*w/(2.0*a);    if(w >= vmax)  {  if(s1 < len)  {   return t1 + (len - s1)/vmax;  }  else  {   return Math.sqrt(2.0*len/a);  }   }  else  {      double t2, s2, v2;  t2 = Math.sqrt(2.0*d/a);  v2 = a*t2;    double tx, vx;  vx = Math.sqrt((2.0*a*d + w*w)/2.0);  tx = vx / a;           if(v2 < w)  {   if(v2 > vmax)   {      if(vmax > vx)   {    return tx + (vx - w)/a + T2(w);   }   else   {    double ty, sy;    ty = (vmax - w)/a;    sy = ty * (vmax + w)/2.0;    return t1 + ty + (d - s1 - sy)/vmax + T2(w);   }   }   else   {      return t2 + T2(v2);     }  }  else if(v2 > vmax)   {     if(vmax > vx)   {   return tx + (vx - w)/a + T2(w);   }   else   {   double ty, sy;   ty = (vmax - w)/a;   sy = ty * (vmax + w)/2.0;   return t1 + ty + (d - s1 - sy)/vmax + T2(w);   }  }  else   {             return tx + (vx - w)/a + T2(w);  }  } }  public double binary() {  double low, high, t, s;  low = 0.0; high = vmax/a;   for(int c=0;c<50;++c)  {  t = (low+high)/2;  s = (a*t*t)/2 + ((a*t - w)/a)*(a*t + w)/2.0;    if(s > d) high = t;  else low = t;  }  t = (low+high)/2;  return t + (a*t - w)/a; }   public double T2(double v0) {     double t1, s1;  t1 = (vmax - v0)/a;  s1 = ((vmax + v0)/2.0)*t1;   if(s1 < len-d)  {    return t1 + (len-d-s1)/vmax;  }  else  {    return (-v0 + Math.sqrt(v0*v0 + 2*a*(len-d)))/a;  } }  public static void main(String[] args) {  (new FollowTrafficRules()).main(); } }
0,public class Solution {  private static int n;  private static PrintWriter writer;  private static int maxstep;   private static void g(int src, int step) {   if (step != 0 && n % src == 0) {    writer.print("YES");    writer.close();    System.exit(0);   }     if (step == maxstep) return;     int p = (int)Math.pow(10, step);     g(src + 4 * p, step + 1);   g(src + 7 * p, step + 1);  }   public static void main(String[] args) throws Exception {          Scanner reader = new Scanner(System.in);   writer = new PrintWriter(System.out);     n = reader.nextInt();   maxstep = String.valueOf(n).length() + 1;     g(0, 0);     writer.print("NO");   writer.close();  } }
1,public class B {  BufferedReader reader;  StringTokenizer tokenizer;  PrintWriter out;   public void solve() throws IOException {    int N = nextInt();   int A = nextInt();   int B = nextInt();   int[] nsA = new int[N];   int[] nsB = new int[N];   char[] ans = new char[N];   Arrays.fill(nsA, -1);   Arrays.fill(nsB, -1);   Arrays.fill(ans, 'C');   HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();   int[] P = new int[N];  for (int i = 0; i < N; i++) {    P[i] = nextInt();    map.put(P[i], i);   }      if (A == B) {    for (int i = 0; i < N; i++) {     if (!map.containsKey(A - P[i])) {      out.println("NO"); return;     }    }    out.println("YES");    for (int i = 0; i < N; i++) {     out.print(0 + " ");    }    out.println();    return;   }    for (int i = 0; i < N; i++) {    int oppA = A - P[i];    int oppB = B - P[i];    if (map.containsKey(oppA)) {     nsA[i] = map.get(oppA);    }    if (map.containsKey(oppB)) {     nsB[i] = map.get(oppB);    }   }   for (int i = 0; i < N; i++) {    if (nsA[i] == -1 && nsB[i] == -1) {     out.println("NO");     return;    }   }   for (int i = 0; i < N; i++) {    if (ans[i] != 'C') continue;    if (nsA[i] == -1) {     if (!go(i, 'B', ans, nsA, nsB) ){      out.println("NO"); return;     }    } else if (nsB[i] == -1) {     if (!go(i, 'A', ans, nsA, nsB) ){      out.println("NO"); return;     }    }   }   for (int i = 0; i < N; i++) {    if (ans[i] != 'C') continue;    if (nsA[i] == i || nsB[i] == i) {     if (nsA[i] == i) {      if (!go(i, 'B', ans, nsA, nsB) ){       out.println("NO"); return;      }     } else {      if (!go(i, 'A', ans, nsA, nsB) ){       out.println("NO"); return;      }     }    }   }   for (int i = 0; i < N; i++) {    if (ans[i] != 'C') continue;    if (!go(i, 'A', ans, nsA, nsB) ){     out.println("NO"); return;    }   }   for (int i = 0; i < N; i++) {    if (ans[i] == 'C') {     out.println("NO");     return;    }   }   out.println("YES");   for (int i = 0; i < N; i++) {    out.print(ans[i] == 'A'? 0: 1);    out.print(" ");   }   out.println(); }  public boolean go(int cur, char link, char[] ans, int[] nsA, int[] nsB) {   while (ans[cur] == 'C') {    int next = link == 'A'? nsA[cur]: nsB[cur];    if (next == -1) return false;    if (ans[next] != 'C') return false;    ans[cur] = link;    ans[next] = link;     int nextNext = link == 'A'? nsB[next]: nsA[next];    cur = nextNext;    if (cur == -1) return true;   }   return true;  }   public static void main(String[] args) {  new B().run(); }  public void run() {   try {    reader = new BufferedReader(new InputStreamReader(System.in));    tokenizer = null;    out = new PrintWriter(System.out);    solve();    reader.close();    out.close();   } catch (Exception e) {    e.printStackTrace();    System.exit(1);   }  }  int nextInt() throws IOException {   return Integer.parseInt(nextToken());  }  long nextLong() throws IOException {   return Long.parseLong(nextToken());  }  double nextDouble() throws IOException {   return Double.parseDouble(nextToken());  }  String nextToken() throws IOException {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    tokenizer = new StringTokenizer(reader.readLine());   }   return tokenizer.nextToken();  } }
1,public class Main { public static void main(String[] args) {  InputReader in = new StreamInputReader(System.in);  PrintWriter out = new PrintWriter(System.out);  run(in, out); }  public static void run(InputReader in, PrintWriter out) {  Solver solver = new Task();  solver.solve(1, in, out);  Exit.exit(in, out); } } abstract class InputReader { private boolean finished = false;  public abstract int read();  public long readLong() {  return new BigInteger(readString()).longValue(); }  public int readInt() {  int c = read();  while (isSpaceChar(c))  c = read();  int sgn = 1;  if (c == '-') {  sgn = -1;  c = read();  }  int res = 0;  do {  if (c < '0' || c > '9')   throw new InputMismatchException();  res *= 10;  res += c - '0';  c = read();  } while (!isSpaceChar(c));  return res * sgn; }  public String readString() {  int c = read();  while (isSpaceChar(c))  c = read();  StringBuffer res = new StringBuffer();  do {  res.appendCodePoint(c);  c = read();  } while (!isSpaceChar(c));  return res.toString(); }  private boolean isSpaceChar(int c) {  return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; }  public void setFinished(boolean finished) {  this.finished = finished; }  public abstract void close(); } class StreamInputReader extends InputReader { private InputStream stream; private byte[] buf = new byte[1024]; private int curChar, numChars;  public StreamInputReader(InputStream stream) {  this.stream = stream; }  public int read() {  if (numChars == -1)  throw new InputMismatchException();  if (curChar >= numChars) {  curChar = 0;  try {   numChars = stream.read(buf);  } catch (IOException e) {   throw new InputMismatchException();  }  if (numChars <= 0)   return -1;  }  return buf[curChar++]; }  public void close() {  try {  stream.close();  } catch (IOException ignored) {  } } } class Exit { private Exit() { }  public static void exit(InputReader in, PrintWriter out) {  in.setFinished(true);  in.close();  out.close(); } } interface Solver { public void solve(int testNumber, InputReader in, PrintWriter out); } class Task implements Solver { public void solve(int testNumber, InputReader in, PrintWriter out) {  int n = in.readInt();  int a = in.readInt();  int b = in.readInt();   if (a==b) {  b = 0;  }   boolean[] where = new boolean[n];   HashSet<Integer> set = new HashSet<Integer>();  HashMap<Integer,Integer> indexmap = new HashMap<Integer,Integer>();   for (int i = 0; i<n; i++) {  int x = in.readInt();  indexmap.put(x, i);  set.add(x);  }   while (set.size() > 0) {  int size = set.size();  HashSet<Integer> todo = new HashSet<Integer>();  HashSet<Integer> used = new HashSet<Integer>();  for (int x : set) {   if (used.contains(x))   continue;   int ax = a-x;   int bx = b-x;     if ((set.contains(ax) && !used.contains(ax)) && (set.contains(bx) && !used.contains(bx))) {   todo.add(x);   } else if (set.contains(ax) && !used.contains(ax)) {   used.add(x);   used.add(ax);   todo.remove(ax);         bx = b-ax;   while (set.contains(bx) && !used.contains(bx)) {    x = bx;    ax = a-x;    if (!set.contains(ax) || used.contains(ax)) {    System.out.println("NO");    return;    }    todo.remove(x);    todo.remove(ax);    used.add(x);    used.add(ax);    bx = b-ax;   }      } else if (set.contains(bx) && !used.contains(bx)) {   used.add(x);   used.add(bx);   todo.remove(bx);   where[indexmap.get(bx)] = true;   where[indexmap.get(x)] = true;         ax = a-bx;   while (set.contains(ax) && !used.contains(ax)) {    x = ax;    bx = b-x;    if (!set.contains(bx) || used.contains(bx)) {    System.out.println("NO");    return;    }    todo.remove(x);    todo.remove(bx);    used.add(x);    used.add(bx);    where[indexmap.get(bx)] = true;    where[indexmap.get(x)] = true;    ax = a-bx;   }      } else {   System.out.println("NO");   return;   }  }  set = todo;  if (set.size() == size) {   System.out.println("Set size constant!!");   break;  }  }   System.out.println("YES");  for (int i = 0; i<n; i++)  if (where[i])   System.out.print("1 ");  else   System.out.print("0 "); } } class num {   }
5,public class A {  static class House {  int x, a; }   public static void main(final String[] args) {  final Scanner in = new Scanner(System.in);  final PrintWriter out = new PrintWriter(System.out);  try {  final int n = in.nextInt();  final int t = in.nextInt();   final House[] h = new House[n];  for (int i = 0; i < h.length; ++i) {   h[i] = new House();   h[i].x = in.nextInt();   h[i].a = in.nextInt();  }   Arrays.sort(h, new Comparator<House>() {   @Override   public int compare(final House o1, final House o2) {   return Integer.valueOf(o1.x).compareTo(o2.x);   }  });   int ans = 2;  for (int i = 1; i < n; ++i) {   final int dspace = 2 * h[i].x - h[i].a    - (2 * h[i - 1].x + h[i - 1].a);   if (dspace == 2 * t) {   ++ans;   } else if (dspace > 2 * t) {   ans += 2;   }  }   out.println(ans);  } finally {  in.close();  out.close();  } } }
3,public class D {   String INPUT = "4\n" +     "1 2 4 3\n" +     "4\n" +     "1 1\n" +     "1 4\n" +     "1 4\n" +     "2 3";   void solve()   {     int n = i();     int[] a = ia(n);     int count = 0 ;     for(int i = 0 ; i<n-1 ; i++)     {       for(int j = i+1; j<n ; j++)       {         if(a[j]<a[i])         {           count++;         }       }     }     int q = i();     for(int i = 0 ; i<q ; i++)     {       int l = i(), r=i();       int mid = (r-l+1)/2;       if(mid%2==0)       {         out.println(count%2==0?"even":"odd");       }       else       {         count++;         out.println(count%2==0?"even":"odd");       }     }    }     void run() throws Exception{     is = oj ? System.in: new ByteArrayInputStream(INPUT.getBytes());         out = new PrintWriter(System.out);     int t = 1;     while(t-->0) solve();     out.flush();   }   public static void main(String[] args)throws Exception {     new D().run();   }   InputStream is;   PrintWriter out;   private byte[] inbuf = new byte[1024];   public int lenbuf = 0, ptrbuf = 0;   private int readByte()   {     if(lenbuf == -1)throw new InputMismatchException();     if(ptrbuf >= lenbuf){       ptrbuf = 0;       try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }       if(lenbuf <= 0)return -1;     }     return inbuf[ptrbuf++];   }   private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }   private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }   private double d() { return Double.parseDouble(s()); }   private char c() { return (char)skip(); }   private String s()   {     int b = skip();     StringBuilder sb = new StringBuilder();     while(!(isSpaceChar(b))){       sb.appendCodePoint(b);       b = readByte();     }     return sb.toString();   }   private char[] sa(int n)   {     char[] buf = new char[n];     int b = skip(), p = 0;     while(p < n && !(isSpaceChar(b))){       buf[p++] = (char)b;       b = readByte();     }     return n == p ? buf : Arrays.copyOf(buf, p);   }   private char[][] nm(int n, int m)   {     char[][] map = new char[n][];     for(int i = 0;i < n;i++)map[i] = sa(m);     return map;   }   private int[] ia(int n)   {     int[] a = new int[n];     for(int i = 0;i < n;i++)a[i] = i();     return a;   }   private int i()   {     int num = 0, b;     boolean minus = false;     while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));     if(b == '-'){       minus = true;       b = readByte();     }     while(true){       if(b >= '0' && b <= '9'){         num = num * 10 + (b - '0');       }else{         return minus ? -num : num;       }       b = readByte();     }   }   private long l()   {     long num = 0;     int b;     boolean minus = false;     while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));     if(b == '-'){       minus = true;       b = readByte();     }     while(true){       if(b >= '0' && b <= '9'){         num = num * 10 + (b - '0');       }else{         return minus ? -num : num;       }       b = readByte();     }   }   private boolean oj = System.getProperty("ONLINE_JUDGE") != null;   private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); } }
5,public class Main {   public static void main(String[] args) {   FastScanner sc = new FastScanner(System.in);   PrintWriter out = new PrintWriter(System.out);   int N = sc.nextInt();   long dest = sc.nextLong();   long max = (long)N * ((long)N + 1L) / 2L;   if (dest < 2 * N - 1 || dest > max) {    out.println("No");    out.close();    return;   }   int[] d = new int[N + 1];   int[] f = new int[N + 1];   int K = 1;   for (; K <= N; K++) {    long dep = 1L, cnt = 1L, c = 1L;    long t = 1L;    while (cnt < N) {     c = c * K;     dep++;     t += (dep * Math.min(c, N - cnt));     cnt += c;    }    if (t <= dest) break;   }   out.println("Yes");   int dep = 1; long cnt = 1L, c = 1L;   long t = 1L;   d[1] = 1;   while (cnt < N) {    dep++; c = c * K;    long x = (long)N - cnt;    int min;    if (c >= x) min = (int)x;    else min = (int)c;    d[dep] = min;    t += (dep * Math.min(c, (long)N - cnt)); cnt += c;   }   dest -= t;   int curDep = dep; int nextDep = dep + 1;   while (dest > 0) {    if (d[curDep] <= 1) curDep--;    d[curDep]--;    long next = Math.min(nextDep++, dest + curDep);    dest -= ((int)next - curDep);    d[(int)next]++;   }   int first = 1;   for (int i = 2; i < nextDep; i++) {    int p = 0, fn = first - d[i - 1] + 1;    for (int j = first + 1; j <= first + d[i]; j++) {     if (p == K) {      fn++; p = 0;     }     p++; f[j] = fn;    }    first += d[i];   }   for (int i = 2; i <= N; i++)    out.format("%d ", f[i]);   out.close();  }        static class FastScanner {   private BufferedReader reader = null;   private StringTokenizer tokenizer = null;     public FastScanner(InputStream in) {    reader = new BufferedReader(new InputStreamReader(in));    tokenizer = null;   }     public String next() {    if (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      tokenizer = new StringTokenizer(reader.readLine());     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return tokenizer.nextToken();   }     public String nextLine() {    if (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      return reader.readLine();     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return tokenizer.nextToken("\n");   }     public long nextLong() {    return Long.parseLong(next());   }     public int nextInt() {    return Integer.parseInt(next());   }       } }
1,public class Main {  static MyScanner scan;  static PrintWriter pw;  public static void main(String[] args) {   new Thread(null,null,"_",1<<25)   {    public void run()    {     try     {      solve();     }     catch(Exception e)     {      e.printStackTrace();      System.exit(1);     }    }   }.start();  }  static void solve() throws IOException {   scan = new MyScanner();   pw = new PrintWriter(System.out, true);   StringBuilder sb = new StringBuilder();   Map<String,Integer> map = new HashMap<>();   map.put("M",0);   map.put("L",1);   map.put("S",2);   map.put("XL",3);   map.put("XS",4);   map.put("XXL",5);   map.put("XXS",6);   map.put("XXXL",7);   map.put("XXXS",8);   int freqa[] = new int[9];   int freqb[] = new int[9];   int n = ni();   for(int i=0;i<n;++i)    ++freqa[map.get(ne())];   for(int i=0;i<n;++i)    ++freqb[map.get(ne())];   for(int i=0;i<9;++i)   {    int xx = min(freqa[i],freqb[i]);    freqa[i]-=xx;    freqb[i]-=xx;   }   long res = 0;   for(int i=0;i<9;++i)    res+=freqa[i]+freqb[i];   pl(res/2);   pw.flush();   pw.close();  }  static long MMI(long A,long MOD)  {   return modpow(A,MOD-2,MOD);  }  static long modpow(long x,long y,long MOD)  {   if(y==0)    return 1;   if((y&1)==0)    return modpow((x*x)%MOD,y>>1,MOD);   else return (x*modpow(x,y-1,MOD))%MOD;  }  static class Pair implements Comparable<Pair>  {   int x,y;   Pair(int x,int y)   {    this.x=x;    this.y=y;   }   public int compareTo(Pair other)   {    if(this.x!=other.x)     return this.x-other.x;    return this.y-other.y;   }   public String toString()   {    return "{"+x+","+y+"}";   }  }  static int ni() throws IOException  {   return scan.nextInt();  }  static long nl() throws IOException  {   return scan.nextLong();  }  static double nd() throws IOException  {   return scan.nextDouble();  }  static String ne() throws IOException  {   return scan.next();  }  static String nel() throws IOException  {   return scan.nextLine();  }  static void pl()  {   pw.println();  }  static void p(Object o)  {   pw.print(o+" ");  }  static void pl(Object o)  {   pw.println(o);  }  static void psb(StringBuilder sb)  {   pw.print(sb);  }  static class MyScanner  {   BufferedReader br;   StringTokenizer st;   MyScanner()   {    br = new BufferedReader(new InputStreamReader(System.in));   }   String nextLine()throws IOException   {    return br.readLine();   }   String next() throws IOException   {    if(st==null || !st.hasMoreTokens())     st = new StringTokenizer(br.readLine());    return st.nextToken();   }   int nextInt() throws IOException   {    return Integer.parseInt(next());   }   long nextLong() throws IOException   {    return Long.parseLong(next());   }   double nextDouble() throws IOException   {    return Double.parseDouble(next());   }  } }
2,public class cf5722{ public static void main(String[] args) throws IOException{  BufferedReader br=new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st=new StringTokenizer(br.readLine());  long n=Long.parseLong(st.nextToken());  long k=Long.parseLong(st.nextToken());   long ans=((-3-(long)Math.sqrt(9+4*(1*2*(n+k))))/2);  long ans1=((-3+(long)Math.sqrt(9+4*(1*2*(n+k))))/2);  if(ans>0)  System.out.println(n-ans);  else{  System.out.println(n-ans1);  }  } }
5,public class AAA { public static void main(String[] args) throws IOException {  Scanner sc = new Scanner(System.in);  int n = sc.nextInt();  int[] array = new int[n];  int sum = 0;  for (int i = 0; i < n; i++) {  array[i] = sc.nextInt();  sum += array[i];  }  int counter = 0;  Arrays.sort(array);  int first = 0;  for (int j = n - 1; j >= 0; j--) {  first += array[j];  sum -= array[j];  counter++;  if (first > sum) {   break;  }  }  System.out.println(counter); } }
6,public class Main implements Runnable {  final String filename = "";  public void solve() throws Exception {  int n = iread(), k = iread(), A = iread();  int[] b = new int[n], l = new int[n];  for (int i = 0; i < n; i++) {  l[i] = iread();  b[i] = iread();  }  int[] c = new int[n];  double ans = 0.0;  for (int mask = 0; mask < 1 << (k + n - 1); mask++) {  int t = 0;  for (int i = 0; i < n + k - 1; i++) {   if ((mask & (1 << i)) != 0)   t++;  }  if (t != k)   continue;   int x = mask;  for (int i = 0; i < n; i++) {   c[i] = b[i];   while (x % 2 == 1) {   c[i] += 10;   x /= 2;   }   if (c[i] > 100)   c[i] = 100;   x /= 2;  }  double res = 0.0;  for (int mask2 = 0; mask2 < 1 << n; mask2++) {   int m = 0;   double p = 1.0;   t = 0;   for (int i = 0; i < n; i++) {   if ((mask2 & (1 << i)) == 0) {    t += l[i];    p *= (100.0 - c[i]) / 100.0;   } else {    p *= c[i] / 100.0;    m++;   }   }   if (m * 2 > n)   res += p;   else   res += p * A * 1.0 / (A + t);  }  ans = Math.max(ans, res);  }  DecimalFormat df = new DecimalFormat("0.0000000");  out.write(df.format(ans) + "\n"); }  public void run() {  try {  in = new BufferedReader(new InputStreamReader(System.in));  out = new BufferedWriter(new OutputStreamWriter(System.out));      solve();  out.flush();  } catch (Exception e) {  e.printStackTrace();  System.exit(1);  } }  public int iread() throws Exception {  return Integer.parseInt(readword()); }  public double dread() throws Exception {  return Double.parseDouble(readword()); }  public long lread() throws Exception {  return Long.parseLong(readword()); }  BufferedReader in;  BufferedWriter out;  public String readword() throws IOException {  StringBuilder b = new StringBuilder();  int c;  c = in.read();  while (c >= 0 && c <= ' ')  c = in.read();  if (c < 0)  return "";  while (c > ' ') {  b.append((char) c);  c = in.read();  }  return b.toString(); }  public static void main(String[] args) {  try {  Locale.setDefault(Locale.US);  } catch (Exception e) {  }   new Thread(null, new Main(), "1", 1 << 25).start(); } }
0,public class Challenge {  public static void main(String[] args) throws java.lang.Exception {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  PrintWriter out = new PrintWriter(outputStream);  TaskA solver = new TaskA();  solver.solve(in, out);  out.close(); } } class TaskA {  public void solve(InputReader in, PrintWriter out) {  int n = in.nextInt();   if (n == 1) {  out.println("1");  } else if (n == 2) {  out.println("2");  } else if (n == 3) {  out.println("6");  } else if (n%2 > 0) {  out.println(1L * n * (n-1) * (n-2));  } else if (n%3 == 0) {  out.println(1L * (n-1) * (n-2) * (n-3));  } else {  out.println(1L * n * (n-1) * (n-3));  } } } class InputReader { public BufferedReader reader; public StringTokenizer tokenizer;  public InputReader(InputStream stream) {  reader = new BufferedReader(new InputStreamReader(stream), 32768);  tokenizer = null; }  public String next() {  while (tokenizer==null || !tokenizer.hasMoreTokens()) {  try {   tokenizer = new StringTokenizer(reader.readLine());  } catch (IOException e) {   throw new RuntimeException(e);  }  }  return tokenizer.nextToken(); }  public int nextInt() {  return Integer.parseInt(next()); }  public long nextLong() {  return Long.parseLong(next()); } }
3,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   FastScanner in = new FastScanner(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskC solver = new TaskC();   solver.solve(1, in, out);   out.close();  }  static class TaskC {   private final int MOD = (int) (1e9 + 7);   public void solve(int testNumber, FastScanner in, PrintWriter out) {    int n = in.nextInt();    String[] arr = new String[n];    for (int i = 0; i < n; i++) {     arr[i] = in.nextString();    }    int[] dp = new int[n];    Arrays.parallelSetAll(dp, i -> 0);    dp[0] = 1;    int cnt = 0;    for (int i = 0; i < n; i++) {     if (arr[i].equals("f")) {      cnt++;      continue;     }     calc(dp, n, cnt);     cnt = 0;    }    int sum = 0;    for (int i = 0; i < n; i++) {     sum += dp[i];     sum %= MOD;    }    out.println(sum);   }   private void calc(int[] dp, int n, int cnt) {    for (int i = n - 1; i >= 0; i--) {     if (i != n - 1) dp[i] += dp[i + 1];     dp[i] %= MOD;    }    int[] tmp = new int[n];    for (int i = 0; i < n; i++) {     tmp[(i + cnt) % n] = dp[i];    }    Arrays.parallelSetAll(dp, i -> tmp[i]);   }  }  static class FastScanner {   private BufferedReader br;   private StringTokenizer st;   public FastScanner(File f) {    try {     br = new BufferedReader(new FileReader(f));    } catch (FileNotFoundException e) {     e.printStackTrace();    }   }   public FastScanner(InputStream f) {    br = new BufferedReader(new InputStreamReader(f));   }   public String nextString() {    while (st == null || !st.hasMoreTokens()) {     String s = null;     try {      s = br.readLine();     } catch (IOException e) {      e.printStackTrace();     }     if (s == null)      return null;     st = new StringTokenizer(s);    }    return st.nextToken();   }   public int nextInt() {    return Integer.parseInt(nextString());   }  } }
1,public class B {  void solve() throws IOException {   in = new InputReader("__std");   out = new OutputWriter("__std");   int n = in.readInt();   int a = in.readInt();   int b = in.readInt();   int ma = 0;   int mb = 1;   if (a < b) {    int t = a; a = b; b = t;    t = ma; ma = mb; mb = t;   }   final int[] p = new int[n];   Integer id[] = new Integer[n];   Map<Integer, Integer> pos = new HashMap<Integer, Integer>();   for (int i = 0; i < n; ++i) {    p[i] = in.readInt();    id[i] = i;    pos.put(p[i], i);   }   Arrays.sort(id, new Comparator<Integer>() {    public int compare(Integer i, Integer j) {     return p[i] - p[j];    }   });   int[] mask = new int[n];   Arrays.fill(mask, -1);   boolean flag = true;   for (int i = 0; i < n && flag; ++i) {    if (mask[id[i]] == -1) {     if (p[id[i]] < a) {      if (pos.containsKey(a - p[id[i]])) {       int j = pos.get(a - p[id[i]]);       if (mask[j] != mb) {        mask[id[i]] = mask[j] = ma;        continue;       }      }      if (p[id[i]] < b && pos.containsKey(b - p[id[i]])) {       int j = pos.get(b - p[id[i]]);       if (mask[j] != ma) {        mask[id[i]] = mask[j] = mb;        continue;       }      }     }     flag = false;    }   }   if (flag) {    out.println("YES");    for (int m : mask) {     out.print(m + " ");    }   } else {    out.println("NO");   }   exit();  }  void exit() {     out.close();   System.exit(0);  }  InputReader in;  OutputWriter out;    public static void main(String[] args) throws IOException {   new B().solve();  }  class InputReader {   private InputStream stream;   private byte[] buffer = new byte[1024];   private int pos, len;   private int cur;   private StringBuilder sb = new StringBuilder(32);   InputReader(String name) throws IOException {    if (name.equals("__std")) {     stream = System.in;    } else {     stream = new FileInputStream(name);    }    cur = read();   }   private int read() throws IOException {    if (len == -1) {     throw new EOFException();    }    if (pos >= len) {     pos = 0;     len = stream.read(buffer);     if (len == -1) return -1;    }    return buffer[pos++];   }   char readChar() throws IOException {    if (cur == -1) {     throw new EOFException();    }    char res = (char) cur;    cur = read();    return res;   }   int readInt() throws IOException {    if (cur == -1) {     throw new EOFException();    }    while (whitespace()) {     cur = read();    }    if (cur == -1) {     throw new EOFException();    }    int sign = 1;    if (cur == '-') {     sign = -1;     cur = read();    }    int res = 0;    while (!whitespace()) {     if (cur < '0' || cur > '9') {      throw new NumberFormatException();     }     res *= 10;     res += cur - '0';     cur = read();    }    return res * sign;   }   long readLong() throws IOException {    if (cur == -1) {     throw new EOFException();    }    return Long.parseLong(readToken());   }   double readDouble() throws IOException {    if (cur == -1) {     throw new EOFException();    }    return Double.parseDouble(readToken());   }   String readLine() throws IOException {    if (cur == -1) {     throw new EOFException();    }    sb.setLength(0);    while (cur != -1 && cur != '\r' && cur != '\n') {     sb.append((char) cur);     cur = read();    }    if (cur == '\r') {     cur = read();    }    if (cur == '\n') {     cur = read();    }    return sb.toString();   }   String readToken() throws IOException {    if (cur == -1) {     throw new EOFException();    }    while (whitespace()) {     cur = read();    }    if (cur == -1) {     throw new EOFException();    }    sb.setLength(0);    while (!whitespace()) {     sb.append((char) cur);     cur = read();    }    return sb.toString();   }   boolean whitespace() {    return cur == ' ' || cur == '\t' || cur == '\r' || cur == '\n' || cur == -1;   }   boolean eof() {    return cur == -1;   }  }  class OutputWriter {   private PrintWriter writer;   OutputWriter(String name) throws IOException {    if (name.equals("__std")) {     writer = new PrintWriter(System.out);    } else {     writer = new PrintWriter(name);    }   }   void print(String format, Object ... args) {    writer.print(new Formatter(Locale.US).format(format, args));   }   void println(String format, Object ... args) {    writer.println(new Formatter(Locale.US).format(format, args));   }   void print(Object value) {    writer.print(value);   }   void println(Object value) {    writer.println(value);   }   void println() {    writer.println();   }   void close() {    writer.close();   }  } }
4,public class Solution {  public static void main(String[] args)  {   new Solution().calc();  }  void calc()  {   Scanner cin = new Scanner(System.in);   String s = cin.next();   int ret = 0;   for (int i = 0; i < s.length(); i++)   {    for (int j = i + 1; j < s.length(); j++)    {     for (int k = 0; j + k < s.length(); k++)     {      if (s.charAt(i + k) != s.charAt(j + k)) break;      ret = Math.max(k + 1, ret);     }    }   }   System.out.println(ret);  } }
1,public class Solution implements Runnable {  public static void main(String[] args) {  (new Thread(new Solution())).start(); }  BufferedReader in; PrintWriter out; StringTokenizer st;  String nextToken() throws IOException {  while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(in.readLine());  return st.nextToken(); }  int nextInt() throws IOException {  return Integer.parseInt(nextToken()); }  double nextDouble() throws IOException {  return Double.parseDouble(nextToken()); }  String sti(String s) {  int res = 0;  int q = 1;  int qq = 0;  for (int i = 0; i < s.length(); i++) {  if (i > 0) qq += q;  res = res * 26 + s.charAt(i) - 'A';  q *= 26;  }  return Integer.toString(qq + res + 1); }  String its(String s) {  int q = Integer.parseInt(s);  String res = "";  int w = 26;  int l = 1;  while (q > w) {  q -= w;  l++;  w *= 26;  }  q--;  if (q == 0) return "A";  while (q > 0) {  res = "" + (char)('A' + q % 26) + res;  l--;  q /= 26;  }  for (; l > 0; l--) res = "A" + res;  return res; }    void solve() throws IOException {  int n = nextInt();  for (int i = 0; i < n; i++) {  String s = nextToken();  int j = 0;  while (!Character.isDigit(s.charAt(j))) j++;  int q = j + 1;  while (q < s.length() && Character.isDigit(s.charAt(q))) q++;  if (q == s.length()) {   out.println("R" + s.substring(j) + "C" + sti(s.substring(0, j)));  } else {   String w = s.substring(j, q);   while (!Character.isDigit(s.charAt(q))) q++;   out.println(its(s.substring(q)) + w);  }  } }  public void run() {  try {   in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);  solve();  } catch (IOException e) {  e.printStackTrace();  }  out.flush(); } }
0,public class Main {  public static void main(String[] args) throws IOException {   BufferedReader in = new BufferedReader(new InputStreamReader(System.in));   int n = Integer.parseInt(in.readLine());   System.out.println((n/2) *3);  } }
4,public class Main {  static class FastReader {   BufferedReader br;   StringTokenizer st;   public FastReader()   {    br = new BufferedReader(      new InputStreamReader(System.in));   }   String next()   {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     }     catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }   int nextInt() { return Integer.parseInt(next()); }   long nextLong() { return Long.parseLong(next()); }   double nextDouble()   {    return Double.parseDouble(next());   }   String nextLine()   {    String str = "";    try {     str = br.readLine();    }    catch (IOException e) {     e.printStackTrace();    }    return str;   }  }  static final int N=205;  static final int mod=1000000007;  static final int INF=1000000009;  static final int numBit=17;  static FastReader r=new FastReader();  static PrintWriter pw = new PrintWriter(System.out);  public static void main(String[] args) throws IOException {   int n=r.nextInt();   int m=r.nextInt();   int k=r.nextInt();   int [][]hor=new int[n][m-1];   int [][]ver=new int[n-1][m];   for(int i=0;i<n;++i){    for(int j=0;j<m-1;++j) hor[i][j]=r.nextInt();   }   for(int i=0;i<n-1;++i){    for(int j=0;j<m;++j) ver[i][j]=r.nextInt();   }   int [][]dp=new int[n][m];   if(k%2!=0){    for(int i=0;i<n;++i){     for(int j=0;j<m;++j) dp[i][j]=-1;    }   }   else{    int [][]new_dp=new int[n][m];    for(int step=0;step<k/2;++step){     for(int i=0;i<n;++i){      for(int j=0;j<m;++j){       new_dp[i][j]=INF;       if(i>0){        new_dp[i][j]=Math.min(new_dp[i][j],dp[i-1][j]+ver[i-1][j]*2);       }       if(i<n-1){        new_dp[i][j]=Math.min(new_dp[i][j],dp[i+1][j]+ver[i][j]*2);       }       if(j>0){        new_dp[i][j]=Math.min(new_dp[i][j],dp[i][j-1]+hor[i][j-1]*2);       }       if(j<m-1){        new_dp[i][j]=Math.min(new_dp[i][j],dp[i][j+1]+hor[i][j]*2);       }      }     }     for(int i=0;i<n;++i){      for(int j=0;j<m;++j){       dp[i][j]=new_dp[i][j];      }     }    }   }   for(int i=0;i<n;++i){    for(int j=0;j<m;++j){     pw.print(dp[i][j]+" ");    }    pw.println();   }   pw.close();  } }
3,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   OutputWriter out = new OutputWriter(outputStream);   TaskC solver = new TaskC();   solver.solve(1, in, out);   out.close();  }  static class TaskC {   public void solve(int testNumber, InputReader in, OutputWriter out) {    int n = in.nextInt();    int r = in.nextInt();    ArrayList<PointDouble> centers = new ArrayList<>();    ArrayList<Integer> xs = new ArrayList<>();    for (int i = 0; i < n; ++i) {     int x = in.nextInt();     double y = r;     for (int j = 0; j < centers.size(); j++) {      int ox = xs.get(j);      if (Math.abs(ox - x) > 2 * r) continue;      PointDouble c = centers.get(j);      double t = Math.abs(ox - x);      double h = Math.sqrt(Math.abs(4.0 * r * r - t * t));      double val = c.y + h;      if (y < val) y = val;     }     out.print(String.format("%.20f ", y));     centers.add(new PointDouble(x, y));     xs.add(x);    }    out.printLine();   }  }  static class OutputWriter {   private final PrintWriter writer;   public OutputWriter(OutputStream outputStream) {    writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));   }   public OutputWriter(Writer writer) {    this.writer = new PrintWriter(writer);   }   public void print(Object... objects) {    for (int i = 0; i < objects.length; i++) {     if (i != 0) {      writer.print(' ');     }     writer.print(objects[i]);    }   }   public void printLine(Object... objects) {    print(objects);    writer.println();   }   public void close() {    writer.close();   }  }  static class InputReader {   private InputStream stream;   private byte[] buffer = new byte[10000];   private int cur;   private int count;   public InputReader(InputStream stream) {    this.stream = stream;   }   public static boolean isSpace(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   public int read() {    if (count == -1) {     throw new InputMismatchException();    }    try {     if (cur >= count) {      cur = 0;      count = stream.read(buffer);      if (count <= 0)       return -1;     }    } catch (IOException e) {     throw new InputMismatchException();    }    return buffer[cur++];   }   public int readSkipSpace() {    int c;    do {     c = read();    } while (isSpace(c));    return c;   }   public int nextInt() {    int sgn = 1;    int c = readSkipSpace();    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if (c < '0' || c > '9') {      throw new InputMismatchException();     }     res = res * 10 + c - '0';     c = read();    } while (!isSpace(c));    res *= sgn;    return res;   }  }  static class PointDouble {   public double x;   public double y;   public PointDouble(double x, double y) {    this.x = x;    this.y = y;   }   public PointDouble() {    x = 0;    y = 0;   }  } }
0,public final class b1 {  public static void main(String[] args) {  Scanner datain = new Scanner(System.in);  long l=datain.nextLong();  long r=datain.nextLong();  if(r-l<2){System.out.print(-1);}else{  if(((r-l)==2)&&(l%2==1)){System.out.print(-1);}else{   if((l%2)==0){System.out.print(""+l+" "+(l+1)+" "+(l+2));}else{   System.out.print(""+(l+1)+" "+(l+2)+" "+(l+3));   }  }  } } }
0,public class Main {   public static void main(String[] args)  {   Scanner sc = new Scanner(System.in);   int n = sc.nextInt();     int one, two;   if(n%2 == 0)   {    one = two = n/2;    if(one%2 != 0 && two%2 != 0)    {     one--;     two++;    }   }   else   {    one = n - 9;    two = 9;   }     System.out.println(one+" "+two);    } }
5,public class a { public static void main(String[] args) throws IOException {  input.init(System.in);  int n = input.nextInt(), k = input.nextInt();  TreeSet<Integer> ts = new TreeSet<Integer>();  int[] data = new int[n];  for(int i = 0; i<n; i++)  {   data[i] = input.nextInt();  }  Arrays.sort(data);  if(n>1 && k==1.*data[n-1]/data[0])   System.out.println(n-1);  else  {  for(int i = 0; i<n; i++)  {   if(data[i]%k != 0)    ts.add(data[i]);   else   {    if(!ts.contains(data[i]/k))     ts.add(data[i]);   }  }  System.out.println(ts.size());  } } public static class input {  static BufferedReader reader;  static StringTokenizer tokenizer;    static void init(InputStream input) {   reader = new BufferedReader(      new InputStreamReader(input) );   tokenizer = new StringTokenizer("");  }    static String next() throws IOException {   while ( ! tokenizer.hasMoreTokens() ) {       tokenizer = new StringTokenizer(      reader.readLine() );   }   return tokenizer.nextToken();  }  static int nextInt() throws IOException {   return Integer.parseInt( next() );  }   static double nextDouble() throws IOException {   return Double.parseDouble( next() );  }  static long nextLong() throws IOException {   return Long.parseLong( next() );  } } }
6,public class Round8_C {    int n ; int[] X, Y ;  public Round8_C() {  info_in() ;  process() ; }  void info_in() {  Scanner input = new Scanner(System.in) ;  int dx = input.nextInt() ;  int dy = input.nextInt() ;   n = input.nextInt() ;  X = new int[n] ;  Y = new int[n] ;   for( int i=0;i<n;i++) {  X[i] = input.nextInt() - dx ;  Y[i] = input.nextInt() - dy ;  } }  int[] d ; int[] trace ;  public static int distance( int x1, int y1, int x2, int y2 ) {  return (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) ; }  void process() {  int gh = 1<<n ;  d = new int[gh] ;  trace = new int[gh] ;   d[0] = 0 ;  for( int i=1;i<gh;i++) {  d[i] = Integer.MAX_VALUE ;  for( int j=0;j<n;j++)   if ( (i & (1<<j)) > 0 ) {   int val = d[i^(1<<j)] + ( distance( X[j], Y[j], 0, 0 ) << 1 ) ;   if ( val < d[i] ) {    d[i] = val ;    trace[i] = j+1 ;   }      int state = i ^ (1<<j) ;   for( int p=j+1;p<n;p++)    if ( (i & (1<<p)) > 0) {    val = d[state^(1<<p)] + distance( X[j], Y[j], 0, 0 ) + distance( X[j], Y[j], X[p], Y[p] ) + distance( X[p], Y[p], 0, 0 ) ;    if ( val < d[i] ) {     d[i] = val ;     trace[i] = (j+1) * 100 + (p+1) ;     }    }   break ;   }  }   System.out.println( d[gh-1] ) ;  gh-- ;  while ( gh > 0 ) {  int v1 = trace[gh] / 100 - 1 ;  int v2 = trace[gh] % 100 - 1 ;  System.out.print(0 + " ") ;  if ( v1 != -1 ) {   System.out.print((v1+1) + " " ) ;   gh -= 1 << v1 ;  }  System.out.print( (v2+1) + " " ) ;  gh -= 1 << v2 ;  }  System.out.println(0) ; }  public static void main(String[] args) {   new Round8_C() ; } }
0,public class E {  static Scanner in; static int next() throws Exception {return in.nextInt();};   static PrintWriter out;  public static void main(String[] args) throws Exception {   in = new Scanner(System.in);    out = new PrintWriter(System.out);   int n = next();   if (n%4 == 0||n%7 == 0||n%44 == 0||n%47 == 0||n%74 == 0||n%77 == 0||n%444 == 0||n%447 == 0||n%474 == 0||n%744 == 0||n%774 == 0||n%747 == 0||n%477 == 0||n%777==0) out.println("YES");   else out.println("NO");   out.println();   out.close();  } }
0,public class Main {  FastScanner in;  PrintWriter out;  static final String FILE = "";  public void solve() {   out.print(25);  }  public void run() {   if (FILE.equals("")) {    in = new FastScanner(System.in);    out = new PrintWriter(System.out);   } else {    try {     in = new FastScanner(new FileInputStream(FILE +       ".in"));     out = new PrintWriter(new FileOutputStream(FILE +       ".out"));    } catch (FileNotFoundException e) {     e.printStackTrace();    }   }   solve();   out.close();  }  public static void main(String[] args) {   (new Main()).run();  }  class FastScanner {   BufferedReader br;   StringTokenizer st;   public FastScanner(InputStream is) {    br = new BufferedReader(new InputStreamReader(is));   }   public String next() {    while (st == null || !st.hasMoreTokens()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }   public String nextLine() {    st = null;    try {     return br.readLine();    } catch (IOException e) {     e.printStackTrace();     return "";    }   }   public int nextInt() {    return Integer.parseInt(next());   }   public long nextLong() {    return Long.parseLong(next());   }   public double nextDouble() {    return Double.parseDouble(next());   }   public float nextFloat() {    return Float.parseFloat(next());   }  }  class Pair<A extends Comparable<A>, B extends Comparable<B>>    implements Comparable<Pair<A, B>> {   public A a;   public B b;   public Pair(A a, B b) {    this.a = a;    this.b = b;   }   @Override   public int compareTo(Pair<A, B> o) {    if (o == null || o.getClass() != getClass())     return 1;    int cmp = a.compareTo(o.a);    if (cmp == 0)     return b.compareTo(o.b);    return cmp;   }   @Override   public boolean equals(Object o) {    if (this == o) return true;    if (o == null || getClass() != o.getClass()) return false;    Pair<?, ?> pair = (Pair<?, ?>) o;    if (a != null ? !a.equals(pair.a) : pair.a != null) return      false;    return !(b != null ? !b.equals(pair.b) : pair.b != null);   }  }  class PairInt extends Pair<Integer, Integer> {   public PairInt(Integer u, Integer v) {    super(u, v);   }  }  class PairLong extends Pair<Long, Long> {   public PairLong(Long u, Long v) {    super(u, v);   }  } }
4,public class Main { public static void main(String[] args) throws IOException {  InputStreamReader in = new InputStreamReader(System.in);  BufferedReader br = new BufferedReader(in);  int t = Integer.parseInt(br.readLine());     int A = 10000000;  int[] convert = new int[A+1];  for (int a = 1; a <= A; a++) {  convert[a] = a;  }  for (int a = 2; a <= A/a; a++) {  int sq = a*a;  for (int b = sq; b <= A; b += sq) {   while (convert[b] % sq == 0) {   convert[b] /= sq;   }  }  }  int[] prevIndex = new int[A+1];  for (int i = 0; i <= A; i++) {  prevIndex[i] = -1;  }  for (int c = 0; c < t; c++) {  StringTokenizer st = new StringTokenizer(br.readLine());   int n = Integer.parseInt(st.nextToken());  int k = Integer.parseInt(st.nextToken());   int[] a = new int[n];  int maxA = 0;   st = new StringTokenizer(br.readLine());   for (int i = 0; i < n; i++) {      a[i] = convert[Integer.parseInt(st.nextToken())];   maxA = Math.max(maxA, a[i]);  }       int[] partitions = new int[k+1];  int[] partIndex = new int[k+1];   for (int i = 0; i < n; i++) {   int cur = a[i];   for (int j = k; j >= 0; j--) {   if (prevIndex[cur] >= partIndex[j]) {    partitions[j]++;    partIndex[j] = i;   }   if (j > 0 && (partitions[j-1] < partitions[j] || partitions[j-1] == partitions[j] && partIndex[j-1] > partIndex[j])) {    partitions[j] = partitions[j-1];    partIndex[j] = partIndex[j-1];   }   }   prevIndex[cur] = i;  }   System.out.println(partitions[k]+1);   for (int i = 0; i < n; i++) {   int cur = a[i];   prevIndex[cur] = -1;  }         }  } }
5,public class A {  static BufferedReader bf = new BufferedReader(new InputStreamReader(  System.in)); static StringTokenizer st; static PrintWriter out = new PrintWriter(System.out);  static String nextToken() throws IOException {  while (st == null || !st.hasMoreTokens()) {  String s = bf.readLine();  if (s == null)   return null;  st = new StringTokenizer(s);  }  return st.nextToken(); }  static int nextInt() throws IOException {  return Integer.parseInt(nextToken()); }  static long nextLong() throws IOException {  return Long.parseLong(nextToken()); }  static String nextStr() throws IOException {  return nextToken(); }  static double nextDouble() throws IOException {  return Double.parseDouble(nextToken()); }  public static void main(String[] args) throws IOException {  int n = nextInt();  int a[] = new int[n];  for (int i = 0; i < n; i++) {  a[i] = nextInt();  }  Arrays.sort(a);   for (int q = 0; q < n; q++) {  if (a[q] != 1) {   out.print("1");   for (int i = 1; i < n; i++) {   out.print(" " + a[i - 1]);   }   out.flush();   return;  }  }   for (int i = 0; i < n - 1; i++) {  out.print("1 ");  }  out.println("2");  out.flush();    } }
6,public class Main { static int n, exp; static double arr[][],dp[], dies[][]; public static void main(String[] args) throws NumberFormatException, IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  n = new Integer(br.readLine());  arr = new double[n][n];  StringTokenizer st;  for (int i = 0; i < n; i++) {  st = new StringTokenizer(br.readLine());  for (int j = 0; j < n; j++) {   arr[i][j] = Double.parseDouble(st.nextToken());  }  }  exp = 1<<n;  dp = new double[exp];  dies = new double[n][exp];  for (int all = 0; all < exp; all++) {  dp[all] = -1;  int countAlive = 0;  for (int i = 0; i < n; i++) {   if((all&(1<<i))!=0)   countAlive++;  }  if(countAlive <2)continue;  double x=1.0/(countAlive*(countAlive-1)/2.0);  for(int i=0; i<n; i++){   dies[i][all]=0;   int mask=1<<i;   if((mask&all)>0){   for(int j=0; j<n; j++)   {    int mask2=1<<j;    if((mask2&all)>0)    dies[i][all]+=arr[j][i];   }   dies[i][all]*=x;   }  }  }  for(int myFish=0; myFish<n; myFish++){  if(myFish>0)System.out.printf(" ");  System.out.printf("%.6f",ff(1<<myFish));  }  System.out.println();   } static double ff(int state){  if(state==exp-1)return 1;  if(dp[state]!=-1)return dp[state];  double ans=0;  for(int i=0; i<n; i++)  {  int mask=1<<i;  if((mask &state)==0)  {   ans+=dies[i][state+mask]*ff(state+mask);  }  }  return dp[state]=ans; }  }
3,public class Main {  public static void main(String[] args) {  Scanner s=new Scanner(System.in);   int n=s.nextInt();   int[] arr=new int[n];   for(int i=0;i<n;i++)  {  arr[i]=s.nextInt();  }   Arrays.sort(arr);   int[] visited=new int[n];   int ans=0;   for(int i=0;i<n;i++)  {  if(visited[i]==0)  {   ans++;     for(int j=i+1;j<n;j++)   {   if(arr[j]%arr[i]==0&&visited[j]==0)   {    visited[j]=1;   }   }  }  }   System.out.println(ans);   }  }
6,public class B { static int ourLevel; public static void main(String[] args) throws IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer(br.readLine());  int n = Integer.parseInt(st.nextToken());  int k = Integer.parseInt(st.nextToken());  ourLevel = Integer.parseInt(st.nextToken());  State[] list = new State[n];  for(int i = 0; i < n; i++) {  st = new StringTokenizer(br.readLine());  list[i] = new State(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken())/10);  }  System.out.println(solve(list, 0, k)); } public static double solve(State[] s, int index, int left) {  if(index == s.length)  return prob(s);  double ret = 0;  for(int c = 0; c <= left && s[index].prob + c <= 10; c++) {  s[index].prob += c;  ret = Math.max(ret, solve(s, index+1, left-c));  s[index].prob -= c;  }  return ret; } public static double prob(State[] s) {  double win = 1;  for(int i = 0; i < (1<<s.length); i++) {  int numLose = s.length - Integer.bitCount(i);  if(2*numLose >= s.length) {   int level = 0;   double p = 1;   for(int j = 0; j < s.length; j++) {   if((i&(1<<j)) == 0) {    p *= (10-s[j].prob)/10.;    level += s[j].level;   }   else {    p *= s[j].prob/10.;   }   }   double lose = level * 1.0 / (ourLevel + level);   win -= p * lose;  }  }  return win; } static class State {  public int level,prob;  public State(int a, int b) {  level = a;  prob = b;  } } }
2,public class Main{ public static void main(String[] args)throws IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer(br.readLine());  long n = Long.parseLong(st.nextToken());  long s = Long.parseLong(st.nextToken());  long posible = binarySearch(n,s);  long dig, answer;  long i, cmed;  for (i = posible; i >= 0; i--) {  dig = 0;  cmed = i;  while (cmed > 0) {   dig = dig+cmed%10;   cmed/=10;  }  if (i-dig < s) {   break;  }  }  answer = n-i;  System.out.println(answer); } private static long binarySearch(long n, long s){  long med=n, l = 0, r = n, cmed, dig;  while(l<=r){  med = (l+r)/2;  cmed = med;  dig = 0;  while (cmed > 0) {   dig = dig+cmed%10;   cmed/=10;  }  if (med-dig == s) {   break;  }else {   if (med-dig > s) {   r = med-1;   }else {   l = med+1;   }  }    }  return med; } }
3,public class Solution {  public static void main(String[] args) throws Exception {   MyReader reader = new MyReader(System.in);   MyWriter writer = new MyWriter(System.out);   new Solution().run(reader, writer);   writer.close();  }  private void run(MyReader reader, MyWriter writer) throws Exception {   char[] c = reader.nextCharArray();   int n = c.length;   int[] x = new int[n];   for (int i = 0; i < n; i++) {    x[i] = c[i] - '0';   }   long mod = 1_000_000_007;   long[] p = new long[n + 1];   long[] s = new long[n + 1];   p[0] = 1;   for (int i = 1; i <= n; i++) {    p[i] = p[i - 1] * 10 % mod;   }   s[n] = 1;   for (int i = n - 1; i >= 0; i--) {    s[i] = (p[n - i - 1] * x[i] + s[i + 1]) % mod;   }   long[][][] d = new long[n + 1][n + 1][2];   long ans = 0;   for (int i = 1; i < 10; i++) {    for (long[][] q : d) {     for (long[] w : q) {      Arrays.fill(w, 0);     }    }    for (int j = 0; j <= n; j++) {     d[j][0][0] = s[j];     d[j][0][1] = p[n - j];    }    for (int j = n - 1; j >= 0; j--) {     for (int k = 1; k <= n; k++) {      for (int l = 1; l >= 0; l--) {       int lim = l == 1 ? 10 : x[j] + 1;       for (int m = 0; m < lim; m++) {        d[j][k][l] += d[j + 1][k - (m >= i ? 1 : 0)][l == 1 || m < x[j] ? 1 : 0];        d[j][k][l] %= mod;       }      }      if (j == 0) {       ans = (ans + p[k - 1] * d[0][k][0]) % mod;      }     }    }   }   System.out.println(ans);  }  static class MyReader {   final BufferedInputStream in;   final int bufSize = 1 << 16;   final byte buf[] = new byte[bufSize];   int i = bufSize;   int k = bufSize;   boolean end = false;   final StringBuilder str = new StringBuilder();   MyReader(InputStream in) {    this.in = new BufferedInputStream(in, bufSize);   }   int nextInt() throws IOException {    return (int) nextLong();   }   int[] nextIntArray(int n) throws IOException {    int[] m = new int[n];    for (int i = 0; i < n; i++) {     m[i] = nextInt();    }    return m;   }   int[][] nextIntMatrix(int n, int m) throws IOException {    int[][] a = new int[n][0];    for (int j = 0; j < n; j++) {     a[j] = nextIntArray(m);    }    return a;   }   long nextLong() throws IOException {    int c;    long x = 0;    boolean sign = true;    while ((c = nextChar()) <= 32) ;    if (c == '-') {     sign = false;     c = nextChar();    }    if (c == '+') {     c = nextChar();    }    while (c >= '0') {     x = x * 10 + (c - '0');     c = nextChar();    }    return sign ? x : -x;   }   long[] nextLongArray(int n) throws IOException {    long[] m = new long[n];    for (int i = 0; i < n; i++) {     m[i] = nextLong();    }    return m;   }   int nextChar() throws IOException {    if (i == k) {     k = in.read(buf, 0, bufSize);     i = 0;    }    return i >= k ? -1 : buf[i++];   }   String nextString() throws IOException {    if (end) {     return null;    }    str.setLength(0);    int c;    while ((c = nextChar()) <= 32 && c != -1) ;    if (c == -1) {     end = true;     return null;    }    while (c > 32) {     str.append((char) c);     c = nextChar();    }    return str.toString();   }   String nextLine() throws IOException {    if (end) {     return null;    }    str.setLength(0);    int c = nextChar();    while (c != '\n' && c != '\r' && c != -1) {     str.append((char) c);     c = nextChar();    }    if (c == -1) {     end = true;     if (str.length() == 0) {      return null;     }    }    if (c == '\r') {     nextChar();    }    return str.toString();   }   char[] nextCharArray() throws IOException {    return nextString().toCharArray();   }   char[][] nextCharMatrix(int n) throws IOException {    char[][] a = new char[n][0];    for (int i = 0; i < n; i++) {     a[i] = nextCharArray();    }    return a;   }  }  static class MyWriter {   final BufferedOutputStream out;   final int bufSize = 1 << 16;   final byte buf[] = new byte[bufSize];   int i = 0;   final byte c[] = new byte[30];   static final String newLine = System.getProperty("line.separator");   MyWriter(OutputStream out) {    this.out = new BufferedOutputStream(out, bufSize);   }   void print(long x) throws IOException {    int j = 0;    if (i + 30 >= bufSize) {     flush();    }    if (x < 0) {     buf[i++] = (byte) ('-');     x = -x;    }    while (j == 0 || x != 0) {     c[j++] = (byte) (x % 10 + '0');     x /= 10;    }    while (j-- > 0)     buf[i++] = c[j];   }   void print(int[] m) throws IOException {    for (int a : m) {     print(a);     print(' ');    }   }   void print(long[] m) throws IOException {    for (long a : m) {     print(a);     print(' ');    }   }   void print(String s) throws IOException {    for (int i = 0; i < s.length(); i++) {     print(s.charAt(i));    }   }   void print(char x) throws IOException {    if (i == bufSize) {     flush();    }    buf[i++] = (byte) x;   }   void print(char[] m) throws IOException {    for (char c : m) {     print(c);    }   }   void println(String s) throws IOException {    print(s);    println();   }   void println() throws IOException {    print(newLine);   }   void flush() throws IOException {    out.write(buf, 0, i);    out.flush();    i = 0;   }   void close() throws IOException {    flush();    out.close();   }  } }
5,public class A {  public static void main(String[] args) {   Scanner in = new Scanner(System.in);   int n = in.nextInt();   int[] A = new int[n];   int sum = 0;   for (int i = 0; i < n; i++) {    A[i] = in.nextInt();    sum += A[i];   }   Arrays.sort(A);   int cnt = 0;   int temp = 0;   for (int i = n - 1; i >= 0; i--) {    temp += A[i];    sum -= A[i];    cnt++;    if (temp > sum)     break;   }   System.out.println(cnt);  } }
6,public class E implements Runnable { public static void main (String[] args) {new Thread(null, new E(), "_cf", 1 << 28).start();}  int n, m; char[] str; int[][] occs, cost; int[] dp;  public void run() {  FastScanner fs = new FastScanner();  PrintWriter out = new PrintWriter(System.out);  System.err.println("");    long tot = 0;  for(int i = 0; i < 20000; i++) tot += i;  System.err.println(tot);   n = fs.nextInt(); m = fs.nextInt();  byte[] str = fs.next().getBytes();  int[] occs = new int[1<<m];  for(int i = 0; i < n-1; i++) {  int l1 = str[i] - 'a';  int l2 = str[i+1] - 'a';  occs[(1<<l1) | (1<<l2)]++;  occs[(1<<l2) | (1<<l1)]++;  }   int all = (1<<m)-1;  cost = new int[m][1<<m];  for(int i = 0; i < m; i++) {  for(int mask = 1; mask < all; mask++) {   if(((1<<i)&mask) > 0) continue;   int lb = mask & (-mask);   int trail = Integer.numberOfTrailingZeros(lb);   int nmask = mask ^ lb;   cost[i][mask] = cost[i][nmask]+occs[1<<i | 1<<trail];  }  }   dp = new int[1<<m];  for(int mask = dp.length-2; mask >= 0; mask--) {  int addOn = 0;  for(int nxt = 0; nxt < m; nxt++) {   if(((1<<nxt)&mask) > 0) continue;   addOn += cost[nxt][mask];  }  int res = oo;  for(int nxt = 0; nxt < m; nxt++) {   if(((1<<nxt)&mask) > 0) continue;   int ret = addOn+dp[mask | (1<<nxt)];   res = min(res, ret);  }  dp[mask] = res;  }   System.out.println(dp[0]>>1);   out.close(); }  int oo = (int)1e9; int min(int a, int b) {  if(a < b) return a;  return b; }  class FastScanner {  public int BS = 1<<16;  public char NC = (char)0;  byte[] buf = new byte[BS];  int bId = 0, size = 0;  char c = NC;  double num = 1;  BufferedInputStream in;  public FastScanner() {  in = new BufferedInputStream(System.in, BS);  }  public FastScanner(String s) {  try {   in = new BufferedInputStream(new FileInputStream(new File(s)), BS);  }  catch (Exception e) {   in = new BufferedInputStream(System.in, BS);  }  }  public char nextChar(){  while(bId==size) {   try {   size = in.read(buf);   }catch(Exception e) {   return NC;   }       if(size==-1)return NC;   bId=0;  }  return (char)buf[bId++];  }  public int nextInt() {  return (int)nextLong();  }  public long nextLong() {  num=1;  boolean neg = false;  if(c==NC)c=nextChar();  for(;(c<'0' || c>'9'); c = nextChar()) {   if(c=='-')neg=true;  }  long res = 0;  for(; c>='0' && c <='9'; c=nextChar()) {   res = (res<<3)+(res<<1)+c-'0';   num*=10;  }  return neg?-res:res;  }  public double nextDouble() {  double cur = nextLong();  return c!='.' ? cur:cur+nextLong()/num;  }  public String next() {  StringBuilder res = new StringBuilder();  while(c<=32)c=nextChar();  while(c>32) {   res.append(c);   c=nextChar();  }  return res.toString();  }  public String nextLine() {  StringBuilder res = new StringBuilder();  while(c<=32)c=nextChar();  while(c!='\n') {   res.append(c);   c=nextChar();  }  return res.toString();  }  public boolean hasNext() {  if(c>32)return true;  while(true) {   c=nextChar();   if(c==NC)return false;   else if(c>32)return true;  }  }   public int[] nextIntArray(int n) {  int[] res = new int[n];  for(int i = 0; i < n; i++) res[i] = nextInt();  return res;  }   } }
1,public class Main {  static Scanner sc;  static PrintWriter out;  public static void main(String[] args) {   sc = new Scanner(System.in);   out = new PrintWriter(System.out);   int t = 1;   if (true) {    t = sc.nextInt();   }   for(int i=0; i<t; i++) {    new Main().solve();   }   out.flush();  }  public void solve() {   long n = sc.nextInt();   if(n % 2 == 1) {    out.println("NO");    return;   }   for(long i=1; i*i*2 <= n; i++) {    if(i * i * 2 == n || i * i * 4 == n) {     out.println("YES");     return;    }   }   out.println("NO");  } }
6,public class Bag implements Runnable {  private void solve() throws IOException {   int xs = nextInt();   int ys = nextInt();   int n = nextInt();   int[] x = new int[n];   int[] y = new int[n];   for (int i = 0; i < n; ++i) {    x[i] = nextInt();    y[i] = nextInt();   }   final int[][] pair = new int[n][n];   for (int i = 0; i < n; ++i)    for (int j = i + 1; j < n; ++j)     pair[i][j] = (x[i] - xs) * (x[i] - xs) + (y[i] - ys) * (y[i] - ys) + (x[j] - xs) * (x[j] - xs) + (y[j] - ys) * (y[j] - ys) + (x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]);   final int[] single = new int[n];   for (int i = 0; i < n; ++i) {    single[i] = 2 * ((x[i] - xs) * (x[i] - xs) + (y[i] - ys) * (y[i] - ys));   }   final int[] best = new int[1 << n];   final int[] prev = new int[1 << n];   for (int set = 1; set < (1 << n); ++set) {    int i;    for (i = 0; i < n; ++i)     if ((set & (1 << i)) != 0)      break;    int bestC = best[set ^ (1 << i)] + single[i];    int prevC = 1 << i;    int nextSet = set ^ (1 << i);    int unoI = 1 << i;    int msc = set >> (i + 1);    for (int j = i + 1, unoJ = 1 << (i + 1); msc != 0 && j < n; ++j, unoJ <<= 1, msc >>= 1)     if ((msc & 1) != 0) {      int cur = best[nextSet ^ unoJ] + pair[i][j];      if (cur < bestC) {       bestC = cur;       prevC = unoI | unoJ;      }     }    best[set] = bestC;    prev[set] = prevC;   }   writer.println(best[(1 << n) - 1]);   int now = (1 << n) - 1;   writer.print("0");   while (now > 0) {   int differents = prev[now];   for(int i = 0; i < n; i++)   if((differents & (1 << i)) != 0)   {    writer.print(" ");     writer.print(i + 1);     now ^= 1 << i;   }    writer.print(" ");    writer.print("0");   }   writer.println();  }   public static void main(String[] args) {   new Bag().run();  }  BufferedReader reader;  StringTokenizer tokenizer;  PrintWriter writer;  public void run() {   try {    reader = new BufferedReader(new InputStreamReader(System.in));    tokenizer = null;    writer = new PrintWriter(System.out);    solve();    reader.close();    writer.close();   } catch (Exception e) {    e.printStackTrace();    System.exit(1);   }  }  int nextInt() throws IOException {   return Integer.parseInt(nextToken());  }  long nextLong() throws IOException {   return Long.parseLong(nextToken());  }  double nextDouble() throws IOException {   return Double.parseDouble(nextToken());  }  String nextToken() throws IOException {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    tokenizer = new StringTokenizer(reader.readLine());   }   return tokenizer.nextToken();  } }
2,public class Code { public Code(){} public static void main(String args[]){  Scanner QQQ=new Scanner(System.in);  long l=QQQ.nextLong();  long r=QQQ.nextLong();  long ans=l^r;  int a[]=new int [70];  int b[]=new int [70];  int n=0,m=0;  while (l!=0){  a[m]=(int)(l%2);  l/=2;  m++;  }  while (r!=0){  b[n]=(int)(r%2);  r/=2;  n++;  }  m--;n--;  long deg[]=new long [70];  deg[0]=1;  for (int i=1;i<=62;i++) deg[i]=deg[i-1]*2;  for (int i=n;i>=0;i--)   if (b[i]==1&&a[i]==0){   System.out.println(deg[i+1]-1);   return;  }  System.out.println(ans); } }
6,public class D11 { static HashMap<State, Integer> map; static long[][] ans; static boolean[][] connect; public static void main(String[] args) throws IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer(br.readLine());  int n = Integer.parseInt(st.nextToken());  map = new HashMap<State, Integer>();  connect = new boolean[n][n];  ans = new long[n][1<<n];  for(int i = 0; i < n; i++)  Arrays.fill(ans[i], -1);  int m = Integer.parseInt(st.nextToken());  while(m-- > 0) {  st = new StringTokenizer(br.readLine());  int a = Integer.parseInt(st.nextToken());  int b = Integer.parseInt(st.nextToken());  a--;  b--;  connect[a][b] = connect[b][a] = true;  }  long ret = 0;  int mask = 1 << n;  mask--;  for(int i = 0; i < n; i++) {  for(int out = i+1; out < n; out++) {   if(connect[i][out]) {   ret += solve(mask - (1<<out), out, true);   }  }  mask -= (1<<i);  }  System.out.println(ret/2); } public static long solve(int mask, int start, boolean a) {  if(ans[start][mask] != -1)  return ans[start][mask];  int end = 0;  while((mask & (1<<end)) == 0)  end++;  long ret = 0;  for(int out = 0; out < connect.length; out++) {  if(connect[start][out] && (mask & (1 << out)) != 0) {   if(out == end) {   if(!a)    ret++;   }   else   ret += solve(mask - (1<<out), out, false);  }  }  ans[start][mask] = ret;  return ret; } static class State {  public byte start, go;  public int mask;  public State(byte a, byte b, int c) {  start = a;  go = b;  mask = c;  }  public int hashCode() {  return 10007*mask + 43 * start + go;  }  public boolean equals(Object o) {  State s = (State)o;  return start == s.start && go == s.go && mask == s.mask;  } } }
6,public class Main implements Runnable {       private int n;  private int nn;  private double[][] a;  private double[] dp;  private void solve() throws Throwable {   n = nextInt();   nn = 1 << n;   a = new double[n][n];   for (int i = 0; i < n; i++) {    for (int j = 0; j < n; j++) {     a[i][j] = nextDouble();    }   }   dp = new double[nn];   Arrays.fill(dp, -1.0);   dp[nn - 1] = 1.0;   for (int j = 0; j < n; j++) {    pw.format(Locale.US, "%.7f ", Dp(1 << j));   }  }  private double Dp(int i) {   if (dp[i] >= 0.0)    return dp[i];     double ans = 0;   int count = Integer.bitCount(i);   for (int j = 0; j < n; j++) {    int jj = 1 << j;    if ((jj & i) == 0) {     double p = Dp(jj | i);     double pPair = 2.0 / (double)((count + 1) * count);     double s = 0;     for (int l = 0; l < n; l++) {      int ll = 1 << l;      if ((ll & i) != 0) {       s += a[l][j];      }     }     ans += p * pPair * s;        }   }   dp[i] = ans;   return dp[i];  }      PrintWriter pw;  BufferedReader in;  StringTokenizer st;  void initStreams() throws FileNotFoundException {     in = new BufferedReader(new InputStreamReader(System.in));   pw = new PrintWriter(System.out);  }  String nextString() throws IOException {   while (st == null || !st.hasMoreTokens()) {    st = new StringTokenizer(in.readLine());   }   return st.nextToken();  }  int nextInt() throws NumberFormatException, IOException {   return Integer.parseInt(nextString());  }  long nextLong() throws NumberFormatException, IOException {   return Long.parseLong(nextString());  }  double nextDouble() throws NumberFormatException, IOException {   return Double.parseDouble(nextString());  }  static Throwable sError;  public static void main(String[] args) throws Throwable {   Thread t = new Thread(new Main());   t.start();   t.join();   if (sError != null) {    throw sError;   }  }  public void run() {   try {    initStreams();    solve();   } catch (Throwable e) {    sError = e;   } finally {    if (pw != null)     pw.close();   }  } }
3,public class Main {  static int dx[] = {-1,1,0,0};  static int dy[] = {0,0,1,-1};  static long MOD = 1000000007;  static int INF = Integer.MAX_VALUE/10;  static PrintWriter pw;  static Reader scan;     static int ni() throws IOException{return scan.nextInt();}  static long nl() throws IOException{return scan.nextLong();}  static double nd() throws IOException{return scan.nextDouble();}  static void pl() throws IOException{pw.println();}  static void pl(Object o) throws IOException{pw.println(o);}  static void p(Object o) throws IOException {pw.print(o+" ");}  static void psb(StringBuilder sb) throws IOException {pw.print(sb);}  public static void main(String[] args){   new Thread(null,null,"BaZ",99999999)   {    public void run()    {     try     {      solve();     }     catch(Exception e)     {      e.printStackTrace();      System.exit(1);     }    }   }.start();  }  static void solve() throws IOException  {   Calendar CAL1 = Calendar.getInstance();   CAL1.setTime(new Date());   scan = new Reader();        pw = new PrintWriter(System.out,true);     StringBuilder sb = new StringBuilder();   int n = ni();   int inv = 0;   int arr[] = new int[n];   for(int i=0;i<n;++i)   {    arr[i] = ni();    for(int j=0;j<i;++j)     if(arr[j]>arr[i])      inv = 1-inv;   }   int q = ni();   while(q-->0)   {    int l = ni();    int r = ni();    int par = c2(r-l+1);    par&=1;    if(par!=0)     inv = 1-inv;    if(inv==0)     sb.append("even\n");    else sb.append("odd\n");   }   psb(sb);   Calendar CAL2 = Calendar.getInstance();   CAL2.setTime(new Date());   double Execution_Time = (double)(CAL2.getTimeInMillis()-CAL1.getTimeInMillis())/1000.000;     pw.flush();   pw.close();  }  static int c2(int n)  {   return (n*(n-1))>>1;  }  static class Reader {  final private int BUFFER_SIZE = 1 << 16;  private DataInputStream din;  private byte[] buffer;  private int bufferPointer, bytesRead;  public Reader() {   din = new DataInputStream(System.in);   buffer = new byte[BUFFER_SIZE];   bufferPointer = bytesRead = 0;  }  public Reader(String file_name) throws IOException {   din = new DataInputStream(new FileInputStream(file_name));   buffer = new byte[BUFFER_SIZE];   bufferPointer = bytesRead = 0;  }  public String readLine() throws IOException {   byte[] buf = new byte[64];   int cnt = 0, c;   while ((c = read()) != -1) {    if (c == '\n') break;    buf[cnt++] = (byte) c;   }   return new String(buf, 0, cnt);  }  public int nextInt() throws IOException {   int ret = 0;   byte c = read();   while (c <= ' ') c = read();   boolean neg = (c == '-');   if (neg) c = read();   do {    ret = ret * 10 + c - '0';   } while ((c = read()) >= '0' && c <= '9');   if (neg) return -ret;   return ret;  }  public long nextLong() throws IOException {   long ret = 0;   byte c = read();   while (c <= ' ') c = read();   boolean neg = (c == '-');   if (neg) c = read();   do {    ret = ret * 10 + c - '0';   } while ((c = read()) >= '0' && c <= '9');   if (neg) return -ret;   return ret;  }  public double nextDouble() throws IOException {   double ret = 0, div = 1;   byte c = read();   while (c <= ' ') c = read();   boolean neg = (c == '-');   if (neg) c = read();   do {    ret = ret * 10 + c - '0';   } while ((c = read()) >= '0' && c <= '9');   if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') / (div *= 10);   if (neg) return -ret;   return ret;  }  private void fillBuffer() throws IOException {   bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);   if (bytesRead == -1) buffer[0] = -1;  }  private byte read() throws IOException {   if (bufferPointer == bytesRead) fillBuffer();   return buffer[bufferPointer++];  }  public void close() throws IOException {   if (din == null) return;   din.close();  } }  static class MyFileReader            {   StringTokenizer st;   BufferedReader br;   MyFileReader() throws IOException   {    br = new BufferedReader(new FileReader("C://Users/Aman deep/Desktop/input.txt"));   }   String nextLine() throws IOException   {    return br.readLine();   }   String next() throws IOException   {    if(st==null || !st.hasMoreTokens())     st = new StringTokenizer(nextLine());    return st.nextToken();   }   int nextInt() throws IOException   {    return Integer.parseInt(next());   }   long nextLong() throws IOException   {    return Long.parseLong(next());   }   double nextDouble() throws IOException   {    return Double.parseDouble(next());   }  }  static class MyFileReader1            {   StringTokenizer st;   BufferedReader br;   MyFileReader1() throws IOException   {    br = new BufferedReader(new FileReader("C://Users/Aman deep/Desktop/output.txt"));   }   String nextLine() throws IOException   {    return br.readLine();   }   String next() throws IOException   {    if(st==null || !st.hasMoreTokens())     st = new StringTokenizer(nextLine());    return st.nextToken();   }   int nextInt() throws IOException   {    return Integer.parseInt(next());   }   long nextLong() throws IOException   {    return Long.parseLong(next());   }   double nextDouble() throws IOException   {    return Double.parseDouble(next());   }  } }
1,public class Main{  final long mod = (int)1e9+7, IINF = (long)1e19;  final int MAX = (int)5e5+1, MX = (int)1e7+1, INF = (int)1e9, root = 3;  DecimalFormat df = new DecimalFormat("0.0000000000000");  double eps = 1e-9, PI = 3.141592653589793238462643383279502884197169399375105820974944;  static boolean multipleTC = false, memory = false;  FastReader in;PrintWriter out;  public static void main(String[] args) throws Exception{   if(memory)new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();}}}, "1", 1 << 28).start();   else new Main().run();  }  void run() throws Exception{   in = new FastReader();   out = new PrintWriter(System.out);   for(int i = 1, T= (multipleTC)?ni():1; i<= T; i++)solve(i);   out.flush();   out.close();  }   void solve(int TC) throws Exception{   int n = ni();   long d = nl();   long ans = 2;   long[] p = new long[n];   for(int i = 0; i< n; i++)p[i] = nl();   for(int i = 1; i< n; i++){    if(p[i]-p[i-1] == 2*d)ans++;    else if(p[i]-p[i-1]>2*d)ans+=2;   }   pn(ans);  }    int[] reverse(int[] a){   int[] o = new int[a.length];   for(int i = 0; i< a.length; i++)o[i] = a[a.length-i-1];   return o;   }  int[] sort(int[] a){   if(a.length==1)return a;   int mid = a.length/2;   int[] b = sort(Arrays.copyOfRange(a,0,mid)), c = sort(Arrays.copyOfRange(a,mid,a.length));   for(int i = 0, j = 0, k = 0; i< a.length; i++){    if(j<b.length && k<c.length){     if(b[j]<c[k])a[i] = b[j++];     else a[i] = c[k++];    }else if(j<b.length)a[i] = b[j++];    else a[i] = c[k++];   }   return a;  }  long[] sort(long[] a){   if(a.length==1)return a;   int mid = a.length/2;   long[] b = sort(Arrays.copyOfRange(a,0,mid)), c = sort(Arrays.copyOfRange(a,mid,a.length));   for(int i = 0, j = 0, k = 0; i< a.length; i++){    if(j<b.length && k<c.length){     if(b[j]<c[k])a[i] = b[j++];     else a[i] = c[k++];    }else if(j<b.length)a[i] = b[j++];    else a[i] = c[k++];   }   return a;  }  long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}  int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}  int bitcount(long n){return (n==0)?0:(1+bitcount(n&(n-1)));}  void p(Object o){out.print(o);}  void pn(Object o){out.println(o);}  void pni(Object o){out.println(o);out.flush();}  String n(){return in.next();}  String nln(){return in.nextLine();}  int ni(){return Integer.parseInt(in.next());}  long nl(){return Long.parseLong(in.next());}  double nd(){return Double.parseDouble(in.next());}  class FastReader{   BufferedReader br;   StringTokenizer st;   public FastReader(){    br = new BufferedReader(new InputStreamReader(System.in));   }   public FastReader(String s) throws Exception{    br = new BufferedReader(new FileReader(s));   }   String next(){    while (st == null || !st.hasMoreElements()){     try{      st = new StringTokenizer(br.readLine());     }catch (IOException e){      e.printStackTrace();     }    }    return st.nextToken();   }   String nextLine(){    String str = "";    try{     str = br.readLine();    }catch (IOException e){     e.printStackTrace();    }     return str;   }  } }
5,public class Main2 {  public static void main(String[] args) throws Exception {   new Main2().run();  }  public void solve() throws Exception {   n = nextInt();   int a[]= new int[n], pos = 1;   for(int i=0; i<n; i++)    a[i] = nextInt();   Arrays.sort(a);   if(n == 1){    out.println("NO"); return;   }   boolean has = false;   for(; pos<n; pos++){    if(a[pos] != a[0]){     has = true;     break;    }   }   if(!has){    out.println("NO");   }   else{    out.println(a[pos]);   }  }  public int n, m;  public void run() throws Exception {   inter = new StreamTokenizer(new BufferedReader(new InputStreamReader(     System.in)));   in = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(new OutputStreamWriter(System.out));   solve();   out.flush();  }  public BufferedReader in;  public StreamTokenizer inter;  public PrintWriter out;  public int nextInt() throws Exception {   inter.nextToken();   return (int) inter.nval;  }  public String nextLine() throws Exception{   return in.readLine();  } }
6,public class cf112e {  static int n,m,s;  static int[][][] memo;  public static void main(String[] args) {   Scanner in = new Scanner(System.in);   n = in.nextInt();   m = in.nextInt();   if(n > m) {    int tmp = n;    n = m;    m = tmp;   }   s = (1<<n);   memo = new int[s][s][m];   for(int i=0; i<s; i++)    for(int j=0; j<s; j++)     Arrays.fill(memo[i][j], -1);   int ret = go(0,0,0);   System.out.println(n*m - ret);  }  static int go(int last, int trans, int r) {   if(r==m) {    if(trans == 0) return 0;    return 100;   }   if(memo[last][trans][r] != -1) return memo[last][trans][r];   int best = 100;   for(int crnt = 0; crnt < s; crnt++) {    if((trans & ~crnt) != 0) continue;    for(int pass = 0; pass < s; pass++) {     int tmp = ((1<<n)-1) & ~last;      if((pass & ~tmp) != 0) continue;     tmp = tmp & ~pass;     boolean fail = false;     for(int k=0; k<n; k++)      if(isSet(tmp,k) && !(isSet(crnt,k-1) || isSet(crnt,k) || isSet(crnt,k+1)))       fail = true;     if(fail) continue;     best = Math.min(best, Integer.bitCount(crnt) + go(crnt,pass,r+1));    }   }   return memo[last][trans][r] = best;  }  static boolean isSet(int x, int p) {   if(p < 0 || p >= n) return false;   return (x & (1<<p)) != 0;  } }
4,public class Main { private static BufferedReader br; private static StringTokenizer st; private static PrintWriter pw;  public static void main(String[] args) throws Exception {  br = new BufferedReader(new FileReader("input.txt"));  pw = new PrintWriter(new BufferedWriter(new FileWriter("output.txt")));   int qq = Integer.MAX_VALUE;   for(int casenum = 1; casenum <= qq; casenum++) {  int r = readInt();  int c = readInt();  int n = readInt();  int[][] dist = new int[r][c];  for(int i = 0; i < r; i++) {   Arrays.fill(dist[i], 1 << 25);  }  LinkedList<State> q = new LinkedList<State>();  while(n-- > 0) {   q.add(new State(readInt()-1, readInt()-1));   dist[q.peekLast().x][q.peekLast().y] = 0;  }  int[] dx = new int[]{-1,1,0,0};  int[] dy = new int[]{0,0,-1,1};  State ret = q.peekLast();  while(!q.isEmpty()) {   State curr = q.removeFirst();   ret = curr;   for(int k = 0; k < dx.length; k++) {   int nx = curr.x + dx[k];   int ny = curr.y + dy[k];   if(nx >= 0 && nx < r && ny >= 0 && ny < c && dist[nx][ny] > 1 + dist[curr.x][curr.y]) {    dist[nx][ny] = 1 + dist[curr.x][curr.y];    q.add(new State(nx, ny));   }   }  }  pw.println(ret.x+1 + " " + (ret.y+1));  }  exitImmediately(); }  static class State {  public int x,y;  public State(int x, int y) {  super();  this.x = x;  this.y = y;  }   }  private static void exitImmediately() {  pw.close();  System.exit(0); }  private static long readLong() throws IOException {  return Long.parseLong(nextToken()); }  private static double readDouble() throws IOException {  return Double.parseDouble(nextToken()); }  private static int readInt() throws IOException {  return Integer.parseInt(nextToken()); }  private static String nextLine() throws IOException {  if(!br.ready()) {  exitImmediately();  }  st = null;  return br.readLine(); }  private static String nextToken() throws IOException {  while(st == null || !st.hasMoreTokens()) {  if(!br.ready()) {   exitImmediately();  }  st = new StringTokenizer(br.readLine().trim());  }  return st.nextToken(); } }
2,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   OutputWriter out = new OutputWriter(outputStream);   DOlyaIMagicheskiiKvadrat solver = new DOlyaIMagicheskiiKvadrat();   solver.solve(1, in, out);   out.close();  }  static class DOlyaIMagicheskiiKvadrat {   long inf = (long) 1e18 + 1;   long[] maxLen;   public void solve(int testNumber, InputReader in, OutputWriter out) {    maxLen = new long[100];    maxLen[1] = 0;    for (int i = 1; i < maxLen.length; i++) {     maxLen[i] = Math.min(inf, maxLen[i - 1] * 4 + 1);    }    if (false) {     for (int n = 1; n <= 3; n++) {      for (int k = 1; k <= maxSplitCount(n) + 20; k++) {       out.print(n + " " + k + " ");       int res = solve(n, k);       if (res == -1) {        out.printLine("NO");       } else {        out.printLine("YES " + res);       }      }     }     return;    }    int q = in.readInt();    while (q-- > 0) {     int n = in.readInt();     long k = in.readLong();     int res = solve(n, k);     if (res == -1) {      out.printLine("NO");      continue;     }     out.printLine("YES " + res);    }   }   long maxSplitCount(int n) {    if (n >= maxLen.length) {     return inf;    }    return maxLen[n];   }   int solve(int n, long k) {    if (maxSplitCount(n) < k) {     return -1;    }    int at = 0;    while (maxSplitCount(at + 1) <= k) {     at++;    }    int curSideLog = n - at;    k -= maxSplitCount(at);    double sideLen = Math.pow(2, n - curSideLog);    double pathLen = sideLen * 2 - 1;    if (curSideLog > 0 && pathLen <= k) {     return curSideLog - 1;    }    double area = sideLen * sideLen;    double otherArea = area - pathLen;    if (otherArea * (double) maxSplitCount(curSideLog) >= k) {     return curSideLog;    }    return -1;   }  }  static class InputReader {   private InputStream stream;   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   private InputReader.SpaceCharFilter filter;   public InputReader(InputStream stream) {    this.stream = stream;   }   public int read() {    if (numChars == -1) {     throw new InputMismatchException();    }    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (numChars <= 0) {      return -1;     }    }    return buf[curChar++];   }   public int readInt() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if (c < '0' || c > '9') {      throw new InputMismatchException();     }     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   public long readLong() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    long res = 0;    do {     if (c < '0' || c > '9') {      throw new InputMismatchException();     }     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   public boolean isSpaceChar(int c) {    if (filter != null) {     return filter.isSpaceChar(c);    }    return isWhitespace(c);   }   public static boolean isWhitespace(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   public interface SpaceCharFilter {    public boolean isSpaceChar(int ch);   }  }  static class OutputWriter {   private final PrintWriter writer;   public OutputWriter(OutputStream outputStream) {    writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));   }   public OutputWriter(Writer writer) {    this.writer = new PrintWriter(writer);   }   public void print(Object... objects) {    for (int i = 0; i < objects.length; i++) {     if (i != 0) {      writer.print(' ');     }     writer.print(objects[i]);    }   }   public void printLine(Object... objects) {    print(objects);    writer.println();   }   public void close() {    writer.close();   }  } }
2,public class Main { public static void main(String[] args) {  FastReader reader = new FastReader();  PrintWriter writer = new PrintWriter(System.out);  long n = reader.nextLong();  long k = reader.nextLong();  long s=0;  long e=n;  long ans = -1;  while (s<=e) {  long m = (s+e)/2;  long temp = ((n-m)*(n-m+1))/2 - m;   if (temp < k)   e = m-1;  else if (temp > k)   s = m+1;  else {   ans = m;   break;  }  }  writer.println(ans);  writer.close(); }  static class FastReader {  BufferedReader br;  StringTokenizer st;  public FastReader()  {  br = new BufferedReader(new InputStreamReader(System.in));  }  String next()  {  while (st == null || !st.hasMoreElements())  {   try   {   st = new StringTokenizer(br.readLine());   }   catch (IOException e)   {   e.printStackTrace();   }  }  return st.nextToken();  }  int nextInt()  {  return Integer.parseInt(next());  }  long nextLong()  {  return Long.parseLong(next());  }  double nextDouble()  {  return Double.parseDouble(next());  }  String nextLine()  {  String str = "";  try  {   str = br.readLine();  }  catch (IOException e)  {   e.printStackTrace();  }  return str;  } } }
6,public class Main implements Runnable {   public static void main(String[] args) {  new Thread(new Main()).start(); }  public void run() {  Locale.setDefault(Locale.US);  try {  run1();  } catch (IOException e) {  throw new RuntimeException();  } }  int nextInt(StreamTokenizer st) throws IOException {  st.nextToken();  return (int) st.nval; }  private List<Integer> kmp(String x, String a) {  String s = a + "$" + x;  int[] oppa = new int[s.length()];  oppa[0] = 0;  int tmp = 0;  List<Integer> res = new ArrayList<Integer>();  for (int i = 1; i < s.length(); i++) {  while (tmp != 0 && s.charAt(tmp) != s.charAt(i)) {     tmp = oppa[tmp - 1];  }  if (s.charAt(tmp) == s.charAt(i))   tmp++;  oppa[i] = tmp;  if (tmp == a.length()) {   res.add(i - a.length() - a.length());  }  }  return res; }  double nextDouble(StreamTokenizer st) throws IOException {  st.nextToken();  return st.nval; }  String nextLine(StreamTokenizer st) throws IOException {  st.nextToken();  return st.sval; }  public void run1() throws IOException {  Scanner sc = new Scanner(new InputStreamReader(System.in));   int n = sc.nextInt();  int m = sc.nextInt();  boolean[][] arr = new boolean[n][n];  for (int i = 0; i < m; i++) {  int a = sc.nextInt();  int b = sc.nextInt();  arr[a - 1][b - 1] = true;  arr[b - 1][a - 1] = true;  }  long[][] res = new long[n][1 << n];  for (int mask = 1; mask < (1 << n); mask++) {  int min = -1;  for (int i = 0; i < n; i++) {   if ((mask & (1 << i)) != 0) {   if (min == -1) {    min = i;    if (mask == (1 << min))    res[min][mask] = 1;   }   for (int j = min + 1; j < n; j++)    if ((mask & (1 << j)) == 0 && arr[i][j]) {    res[j][mask | (1 << j)] += res[i][mask];    }   }  }  }  long r = 0;  for (int mask = 1; mask < (1 << n); mask++)  if (Integer.bitCount(mask) != 2)   for (int j = 0; j < n; j++) {   int i = 0;   while ((mask & (1 << i)) == 0)    i++;   if (arr[i][j])    r += res[j][mask];   }  System.out.println(r / 2); } }
6,public class B { Scanner in; PrintWriter out; String INPUT = "";  void solve() {  int n = ni();  int k = ni();  int a = ni();  int[] lv = new int[n];  int[] lo = new int[n];  for(int i = 0;i < n;i++){  lv[i] = ni();  lo[i] = ni();  }   out.printf("%.9f", rec(lv, lo, n, 0, k, a)); }  double rec(int[] lv, int[] lo, int n, int pos, int k, int a) {  if(pos == n){  int h = n/2+1;  double gp = 0;  for(int i = 0;i < 1<<n;i++){   if(Integer.bitCount(i) >= h){   double p = 1.0;   for(int j = 0;j < n;j++){    if(i<<31-j<0){    p *= (double)lo[j] / 100;    }else{    p *= (double)(100-lo[j]) / 100;    }   }   gp += p;   }else{   double p = 1.0;   int sl = 0;   for(int j = 0;j < n;j++){    if(i<<31-j<0){    p *= (double)lo[j] / 100;    }else{    p *= (double)(100-lo[j]) / 100;    sl += lv[j];    }   }   gp += p * a/(a+sl);   }  }  return gp;  }else{  int o = lo[pos];  double max = 0;  for(int i = 0;i <= k && lo[pos] <= 100;i++){   max = Math.max(max, rec(lv, lo, n, pos+1, k-i, a));   lo[pos]+=10;  }  lo[pos] = o;  return max;  } }    void run() throws Exception {  in = oj ? new Scanner(System.in) : new Scanner(INPUT);  out = new PrintWriter(System.out);  long s = System.currentTimeMillis();  solve();  out.flush();  tr(System.currentTimeMillis()-s+"ms"); }  public static void main(String[] args) throws Exception {  new B().run(); }  int ni() { return Integer.parseInt(in.next()); } long nl() { return Long.parseLong(in.next()); } double nd() { return Double.parseDouble(in.next()); } boolean oj = System.getProperty("ONLINE_JUDGE") != null; void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); } }
6,public class E16 {  static StreamTokenizer in;  static PrintWriter out;   static int nextInt() throws IOException {   in.nextToken();   return (int)in.nval;  }   static double nextDouble() throws IOException {   in.nextToken();   return in.nval;  }   static String nextString() throws IOException {   in.nextToken();   return in.sval;  }  public static void main(String[] args) throws IOException {   in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));   out = new PrintWriter(System.out);     n = nextInt();   t = 1 << n;   m = new double[n][n];   for (int i = 0; i < n; i++)    for (int j = 0; j < n; j++)     m[i][j] = nextDouble();     memo = new double[t];   Arrays.fill(memo, Double.POSITIVE_INFINITY);   for (int i = 0; i < n; i++) out.print(String.format(Locale.US, "%.6f", solve(1 << i)) + " ");   out.println();     out.flush();  }   static int n, t;  static double[][] m;  static double[] memo;   static double solve(int mask) {   if (memo[mask] != Double.POSITIVE_INFINITY) return memo[mask];   if (mask == t-1) return memo[mask] = 1;     int k = Integer.bitCount(mask);   k = (k+1)*k/2;   double res = 0;   for (int i = 0; i < n; i++) if ((mask&(1 << i)) != 0)    for (int j = 0; j < n; j++) if ((mask&(1 << j)) == 0)     res += m[i][j]*solve(mask|(1 << j));     return memo[mask] = res/k;  } }
0,public class Recovery {  public static void main(String [] args) {   Scanner scan = new Scanner(System.in);   int N = scan.nextInt();   if( N%2 == 0) {    System.out.println( (4)+" "+(N-4));   }   else System.out.println( (9)+" "+(N-9));   scan .close();  } }
6,public class SimpleTask {  public static void main(String[] args) {  Scanner scan = new Scanner(System.in);  int n = scan.nextInt();  int m = scan.nextInt();  boolean[][] graph = new boolean[n][n];  for (int i = 0; i < m; i++) {  int u = scan.nextInt() - 1;  int v = scan.nextInt() - 1;  graph[u][v] = true;  graph[v][u] = true;  }  long[][] dp = new long[1 << n][n];  long sum = 0;  for (int i = 0; i < n; i++)  dp[1 << i][i] = 1;  for (int mask = 1; mask < (1 << n); mask++) {   int first = Integer.numberOfTrailingZeros(mask);   for (int i = 0; i < n; i++) {   if ((mask & (1 << i)) == 0 || first == i)   continue;   for (int j = 0; j < n; j++) {   if (graph[i][j] && (mask & (1 << j)) != 0)    dp[mask][i] += dp[mask ^ 1 << i][j];   }   if (Integer.bitCount(mask) >= 3 && graph[i][first])   sum += dp[mask][i];  }  }  System.out.println(sum / 2);  scan.close(); } }
0,public class Ideone { public static void main (String[] args) throws java.lang.Exception {    long n,s,p;  Scanner in=new Scanner(System.in);  n=in.nextLong();  s=in.nextLong();  if(n==1 && s<=1)  {   System.out.print(n-1);  }   else if(s<n)   {    if(s%2!=0)    {System.out.print(s/2);}    else    {System.out.print(s/2-1);}   }   else if(s==n) {  if(s%2==0)  {System.out.println((n/2)-1);}  else  {System.out.println(n/2);} } else if(s<=(2*n-1))  {  System.out.print((2*n+1-s)/2); } else {  System.out.print(0); } } }
0,public class Solution { private BufferedReader cin; private PrintWriter cout; private StringTokenizer strtok;  public static void main(String[] args) throws IOException {   Solution sol = new Solution();  final boolean CONTEST = true;  if (CONTEST) {  sol.cin = new BufferedReader(new InputStreamReader(System.in));  sol.cout = new PrintWriter(System.out);  } else {  sol.cin = new BufferedReader(new FileReader("input.txt"));  sol.cout = new PrintWriter("output.txt");  }  sol.solve();  sol.cin.close();  sol.cout.close(); }  private int nextInt() throws NumberFormatException, IOException {  return Integer.parseInt(nextToken()); }  private String nextToken() throws IOException {  while (strtok == null || !strtok.hasMoreTokens()) {  strtok = new StringTokenizer(cin.readLine());  }  return strtok.nextToken(); }  private void solve() throws IOException {  int n = nextInt();  if (n % 2 == 0) {  cout.println(n - 4 + " " + 4);  } else {  cout.println(n - 9 + " " + 9);  } } }
3,public class C {  public static void main(String[] args) {  Scanner qwe = new Scanner(System.in);  int n = qwe.nextInt();  double r = qwe.nextDouble();   double[] fy = new double[n];  Arrays.fill(fy, r);   double[] xs = new double[n];  for (int i = 0; i < xs.length; i++) {  xs[i] = qwe.nextDouble();  }   for(int i =0; i < n; i++){    for(int j = i+1; j < n; j++){   double dx = xs[j]-xs[i];   if(Math.abs(dx) > 2*r) continue;   fy[j] = Math.max(fy[j], Math.sqrt(4*r*r-dx*dx)+fy[i]);  }    }   StringBuilder stb = new StringBuilder();  for (int i = 0; i < xs.length; i++) {  stb.append(fy[i]+" ");  }  System.out.println(stb); } }
5,public class Main {  void A(){  Scanner sc = new Scanner(System.in);  int n = sc.nextInt();  int a = sc.nextInt();  int b = sc.nextInt();  int[] h = new int[n];  for(int i=0; i<n; i++){  h[i] = sc.nextInt();  }  Arrays.sort(h);  System.out.println(h[b]-h[b-1]); }  public static void main(String[] args) {  new Main().A(); } }
6,public class Task16e {   public static void main(String[] args) {  Scanner sc = new Scanner(System.in);  int n = sc.nextInt();  double[][] prob = new double[n][n];  for (int i = 0; i < n; i++) {  for (int j = 0; j < n; j++) {   prob[i][j] = sc.nextDouble();  }  }  double[] var = new double[1 << n];  boolean[] was = new boolean[1 << n];  Arrays.fill(var, 0.0);  Arrays.fill(was, false);  was[0] = true;  var[(1 << n) - 1] = 1.0;  Set<Integer> cr = new HashSet<Integer>();  Set<Integer> nx = new HashSet<Integer>();  nx.add((1 << n) - 1);  boolean[] fish = new boolean[n];  for (int cnt = 0; cnt < n -1; cnt++) {  cr.clear();  cr.addAll(nx);  nx.clear();  for (Iterator<Integer> iterator = cr.iterator(); iterator.hasNext();) {   int curr = iterator.next();   for (int i = 0; i < n; i++) {   fish[i] = ((1 << i) & curr) != 0;   }   int fishn = 0;   for (int i = 0; i < n; i++) {   if (fish[i]) fishn++;   }   if (fishn == 1) continue;     for (int i = 0; i < n; i++) {   if (!fish[i]) continue;   for (int j = i + 1; j < n; j++) {    if (!fish[j]) continue;    int woi = curr & ~(1 << i);    int woj = curr & ~(1 << j);    var[woi] += var[curr] * prob[j][i];    var[woj] += var[curr] * prob[i][j];    nx.add(woi);    nx.add(woj);   }   }  }  }  double sum = 0.0;  for (int i = 0; i < n; i++) {  sum += var[1 << i];  }  for (int i = 0; i < n; i++) {  System.out.printf("%.6f ", var[1 << i] / sum);  } } }
5,public class Main {  public static void main(String [] args){   Scanner in= new Scanner(System.in);   int n=in.nextInt();   int a=in.nextInt();   int b=in.nextInt();   int []deals=new int[n];   for(int i=0; i<n; i++){    deals[i]=in.nextInt();   }   Arrays.sort(deals);   System.out.println(deals[b]-deals[b-1]);  } }
2,public class Main {  private void solve() throws IOException {  int n = nextInt();  int x = nextInt();  int y = nextInt();  int c = nextInt();   int lux = x;  int luy = y + 1;   int rux = x + 1;  int ruy = y;   int ldx = x - 1;  int ldy = y;   int rdx = x;  int rdy = y - 1;   int k = 1;  int res = 0;  while (k < c) {  lux--;  luy--;  rux--;  ruy++;  rdx++;  rdy++;  ldx++;  ldy--;  int p = 0;  p += lu(x - 1, luy, lux, y, n);  p += ru(x, ruy, rux, y + 1, n);  p += ld(x, ldy, ldx, y - 1, n);  p += rd(x + 1, rdy, rdx, y, n);  k += p;  res++;  }   println(res); }  private int lu(int x1, int y1, int x2, int y2, int n) {  if (y1 > 0 && x2 > 0) {  return x1 - x2 + 1;  } else if (y1 > 0 && x2 < 1) {  return x1;  } else if (y1 < 1 && x2 > 0) {  return y2;  } else if (x1 - (1 - y1) > 0) {  return lu(x1 - (1 - y1), 1, x2, y2, n);  } else {  return 0;  } }  private int ru(int x1, int y1, int x2, int y2, int n) {  if (y1 <= n && x2 > 0) {  return x1 - x2 + 1;  } else if (y1 <= n && x2 < 1) {  return x1;  } else if (y1 > n && x2 > 0) {  return n - y2 + 1;  } else if (x1 - (y1 - n) > 0) {  return ru(x1 - (y1 - n), n, x2, y2, n);  } else {  return 0;  } }  private int ld(int x1, int y1, int x2, int y2, int n) {  if (y1 > 0 && x2 <= n) {  return x2 - x1 + 1;  } else if (y1 > 0 && x2 > n) {  return n - x1 + 1;  } else if (y1 < 1 && x2 <= n) {  return y2;  } else if (x1 + (1 - y1) <= n) {  return ld(x1 + (1 - y1), 1, x2, y2, n);  } else {  return 0;  } }  private int rd(int x1, int y1, int x2, int y2, int n) {  if (y1 <= n && x2 <= n) {  return x2 - x1 + 1;  } else if (y1 <= n && x2 > n) {  return n - x1 + 1;  } else if (y1 > n && x2 <= n) {  return n - y2 + 1;  } else if (x1 + (y1 - n) <= n) {  return rd(x1 + (y1 - n), n, x2, y2, n);  } else {  return 0;  } }  private String next() throws IOException {  while (st == null || !st.hasMoreTokens()) {  st = new StringTokenizer(reader.readLine());  }  return st.nextToken(); }  @SuppressWarnings("unused") private int nextInt() throws IOException {  return Integer.parseInt(next()); }  @SuppressWarnings("unused") private double nextDouble() throws IOException {  return Double.parseDouble(next()); }  @SuppressWarnings("unused") private long nextLong() throws IOException {  return Long.parseLong(next()); }  @SuppressWarnings("unused") private void println(Object o) {  writer.println(o); }  @SuppressWarnings("unused") private void print(Object o) {  writer.print(o); }  private BufferedReader reader; private PrintWriter writer; private StringTokenizer st;  private void run() throws IOException {  long time = System.currentTimeMillis();  Locale.setDefault(Locale.US);  reader = new BufferedReader(new InputStreamReader(System.in));  writer = new PrintWriter(System.out);  solve();  writer.close();  System.err.println(System.currentTimeMillis() - time); }  public static void main(String[] args) throws IOException {  new Main().run(); } }
2,public class Main {  public static void main (String[] argv)  {  new Main(); }       boolean test = false;  int n;  long mod = 1000000007; public Main() {  FastReader in = new FastReader(new BufferedReader(new InputStreamReader(System.in)));    long x = in.nextLong();  long k = in.nextLong();    if (x == 0) {   System.out.println(0);   return;  }    if (k == 0) {   x %= mod;   System.out.println((2*x%mod));   return;  }    x %= mod;    long f = pow(2, k);  long ans = ((2 * f * x % mod - f + 1) % mod + mod) % mod;    System.out.println(ans);   }  private long pow(long x, long y) {  long ans = 1;  while (y > 0) {   if (y % 2 == 1)     ans = ans * x % mod;   x = x * x % mod;   y /= 2;  }  return ans; }  private long gcd(long x, long y) {  if (y == 0) return x;  return gcd(y, x % y); } private int max(int a, int b) {  return a > b ? a : b; }  private int min(int a, int b) {  return a > b ? b : a; }   static class FastReader  {   BufferedReader br;   StringTokenizer st;    public FastReader(BufferedReader in)   {       br = in;   }    String next()   {    while (st == null || !st.hasMoreElements())    {     try     {      String line = br.readLine();      if (line == null || line.length() == 0) return "";      st = new StringTokenizer(line);     }     catch (IOException e)     {      return "";          }    }    return st.nextToken();   }    int nextInt()   {    return Integer.parseInt(next());   }    long nextLong()   {    return Long.parseLong(next());   }    double nextDouble()   {    return Double.parseDouble(next());   }    String nextLine()   {    String str = "";    try    {     str = br.readLine();    }    catch (IOException e)    {     return "";        }    return str;   }  } }
2,public class D {  public static void main(String[] args) throws IOException {   try (Input input = new StandardInput(); PrintWriter writer = new PrintWriter(System.out)) {    long[] s = new long[40];    for (int i = 1; i < s.length; i++) {     s[i] = 1 + 4 * s[i - 1];     if (i >= 32) {      s[i] = Long.MAX_VALUE;     }    }    Function<Integer, Long> getS = (i) -> (i < s.length) ? s[i] : Long.MAX_VALUE;    int t = input.nextInt();    testCase:    for (int tt = 0; tt < t; tt++) {     int n = input.nextInt();     long k = input.nextLong();     long kk = 1;     BigInteger maxDivisions = BigInteger.ZERO;     for (int division = 1; division <= n; division++) {      long needToDivide = (1L << division) - 1;      if (needToDivide > k) {       writer.println("NO");       continue testCase;      }      k -= needToDivide;      maxDivisions = maxDivisions.add(BigInteger.valueOf(kk).multiply(BigInteger.valueOf(getS.apply(n - division))));      if (maxDivisions.compareTo(BigInteger.valueOf(k)) >= 0) {       writer.println("YES " + (n - division));       continue testCase;      }      kk += (1L << division + 1);     }     writer.println("NO");    }   }  }  interface Input extends Closeable {   String next() throws IOException;   default int nextInt() throws IOException {    return Integer.parseInt(next());   }   default long nextLong() throws IOException {    return Long.parseLong(next());   }  }  private static class StandardInput implements Input {   private final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));   private StringTokenizer stringTokenizer;   @Override   public void close() throws IOException {    reader.close();   }   @Override   public String next() throws IOException {    if (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {     stringTokenizer = new StringTokenizer(reader.readLine());    }    return stringTokenizer.nextToken();   }  } }
3,public class G { InputStream is; PrintWriter out; String INPUT = "";  void solve() {  char[] s = ns().toCharArray();  int mod = 1000000007;  int m = 702;   long[] bases = new long[m+1];  bases[0] = 1;  for(int i = 1;i <= m;i++)bases[i] = bases[i-1] * 10 % mod;     long ans = 0;  for(int d = 9;d >= 1;d--){  int n = s.length;  long[] sum = new long[m];   long[] num = new long[m];   long esum = 0;  int ebase = 0;  for(int i = 0;i < n;i++){   long[] nsum = new long[m];   long[] nnum = new long[m];   for(int j = 0;j < m;j++){   for(int k = 0;k <= 9;k++){    if(k > d && j+1 < m){    nsum[j+1] += sum[j] * 10;    nsum[j+1] %= mod;    nnum[j+1] += num[j];    if(nnum[j+1] >= mod)nnum[j+1] -= mod;    }    if(k == d){    nsum[j] += sum[j] * 10 + num[j] * bases[j];    nsum[j] %= mod;    nnum[j] += num[j];    if(nnum[j] >= mod)nnum[j] -= mod;    }    if(k < d){    nsum[j] += sum[j];    if(nsum[j] >= mod)nsum[j] -= mod;    nnum[j] += num[j];    if(nnum[j] >= mod)nnum[j] -= mod;    }   }   }     for(int k = 0;k < s[i]-'0';k++){   if(k > d){    nsum[ebase+1] += esum * 10;    nsum[ebase+1] %= mod;    nnum[ebase+1] += 1;    if(nnum[ebase+1] >= mod)nnum[ebase+1] -= mod;   }   if(k == d){    nsum[ebase] += esum * 10 + bases[ebase];    nsum[ebase] %= mod;    nnum[ebase] += 1;    if(nnum[ebase] >= mod)nnum[ebase] -= mod;   }   if(k < d){    nsum[ebase] += esum;    if(nsum[ebase] >= mod)nsum[ebase] -= mod;    nnum[ebase] += 1;    if(nnum[ebase] >= mod)nnum[ebase] -= mod;   }   }     if(s[i]-'0' > d){   esum = esum * 10;   esum %= mod;   ebase++;   }else if(s[i]-'0' == d){   esum = esum * 10 + bases[ebase];   esum %= mod;   }     sum = nsum;   num = nnum;  }  long all = esum;  for(int j = 0;j < m;j++){   all += sum[j];  }  ans += all % mod * d;  }  out.println(ans%mod); }  void run() throws Exception {  is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());  out = new PrintWriter(System.out);   long s = System.currentTimeMillis();  solve();  out.flush();  tr(System.currentTimeMillis()-s+"ms"); }  public static void main(String[] args) throws Exception { new G().run(); }  private byte[] inbuf = new byte[1024]; public int lenbuf = 0, ptrbuf = 0;  private int readByte() {  if(lenbuf == -1)throw new InputMismatchException();  if(ptrbuf >= lenbuf){  ptrbuf = 0;  try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }  if(lenbuf <= 0)return -1;  }  return inbuf[ptrbuf++]; }  private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }  private double nd() { return Double.parseDouble(ns()); } private char nc() { return (char)skip(); }  private String ns() {  int b = skip();  StringBuilder sb = new StringBuilder();  while(!(isSpaceChar(b))){   sb.appendCodePoint(b);  b = readByte();  }  return sb.toString(); }  private char[] ns(int n) {  char[] buf = new char[n];  int b = skip(), p = 0;  while(p < n && !(isSpaceChar(b))){  buf[p++] = (char)b;  b = readByte();  }  return n == p ? buf : Arrays.copyOf(buf, p); }  private char[][] nm(int n, int m) {  char[][] map = new char[n][];  for(int i = 0;i < n;i++)map[i] = ns(m);  return map; }  private int[] na(int n) {  int[] a = new int[n];  for(int i = 0;i < n;i++)a[i] = ni();  return a; }  private int ni() {  int num = 0, b;  boolean minus = false;  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));  if(b == '-'){  minus = true;  b = readByte();  }   while(true){  if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');  }else{   return minus ? -num : num;  }  b = readByte();  } }  private long nl() {  long num = 0;  int b;  boolean minus = false;  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));  if(b == '-'){  minus = true;  b = readByte();  }   while(true){  if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');  }else{   return minus ? -num : num;  }  b = readByte();  } }  private boolean oj = System.getProperty("ONLINE_JUDGE") != null; private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); } }
4,public class CF035C {  public static void main(String[] args) throws IOException {   Scanner s = new Scanner(new File("input.txt"));   int n = s.nextInt();   int m = s.nextInt();   int k = s.nextInt();   Queue<pair> q = new LinkedList<>();   PrintWriter out = new PrintWriter(new FileWriter("output.txt"));   boolean[][] visited = new boolean[n][m];   for (int i = 0; i < k; i++) {    int x = s.nextInt() - 1;    int y = s.nextInt() - 1;    visited[x][y] = true;    pair p = new pair(x,y);    q.add(p);   }   q.add(null);   int[] dx = {0,0,1,-1};   int[] dy = {1,-1,0,0};   int ansX = q.peek().x;   int ansY = q.peek().y;   while(true){    if(q.peek() == null){     q.poll();     q.add(null);    }    pair p = q.poll();    if(p == null){     break;    }    for (int i = 0; i < 4; i++) {     if(isValid(p.x + dx[i],p.y+dy[i],n,m) && !visited[p.x + dx[i]][p.y+dy[i]]){      q.add(new pair(p.x + dx[i],p.y+dy[i]));      ansX = p.x + dx[i];      ansY = p.y + dy[i];      visited[ansX][ansY] = true;     }    }   }   out.println((ansX+1) + " " + (ansY+1));   out.close();  }  public static boolean isValid(int x, int y,int n, int m){   return x >= 0 && x < n && y >= 0 && y < m;  }  private static class pair{   int x;   int y;   public pair(int x, int y) {    this.x = x;    this.y = y;   }  } }
3,public class A {  InputStream in; PrintWriter out;  void solve()  {  int n=ni();  int a[]=na(n);  int INV=0;  for (int i=0;i<n;i++)  for (int j=i+1;j<n;j++)   if (a[i]>a[j])   INV++;  boolean even=INV%2==0;  int q=ni();  while (q-->0)  {  int l=ni();  int r=ni();  int len=r-l+1;  len=(len-1)*(len)/2;  if (len%2==1)   even=!even;  if (even)   out.println("even");  else   out.println("odd");  } }  int MAX = (int)1e5; long factorial[]; void findfactorial()  {  factorial = new long[MAX + 1];  factorial[0] = 1;  for (int i = 1; i < MAX + 1; i++)  {  factorial[i] = mul(i,factorial[i - 1]);  } }  long mod=(long)1e9+7; long add(long a,long b) {  long x=(a+b);  while(x>=mod) x-=mod;  return x;   }   long sub(long a,long b) {  long x=(a-b);  while(x<0) x+=mod;  return x;   }   long mul(long a,long b) {  a%=mod;  b%=mod;  long x=(a*b);  return x%mod;   }  int max(int a,int b) {  if(a>b)  return a;  else  return b; }  int min(int a,int b) {  if(a>b)  return b;  else   return a; }  long max(long a,long b) {  if(a>b)  return a;  else  return b;   }   long min(long a,long b) {  if(a>b)  return b;  else   return a;   }   void run() throws Exception  {  String INPUT = "C:/Users/ayubs/Desktop/input.txt";  in = oj ? System.in : new FileInputStream(INPUT);  out = new PrintWriter(System.out);   long s = System.currentTimeMillis();  solve();  out.flush();  tr(System.currentTimeMillis() - s + "ms");   } public static void main(String[] args) throws Exception  {  new A().run(); }  private byte[] inbuf = new byte[1024]; public int lenbuf = 0, ptrbuf = 0;  private int readByte()  {  if (lenbuf == -1)  throw new InputMismatchException();  if (ptrbuf >= lenbuf)  {  ptrbuf = 0;  try   {   lenbuf = in.read(inbuf);  }  catch (IOException e)   {   throw new InputMismatchException();  }  if (lenbuf <= 0)   return -1;  }  return inbuf[ptrbuf++]; }  private boolean inSpaceChar(int c)  {  return !(c >= 33 && c <= 126); }  private int skip()  {  int b;  while ((b = readByte()) != -1 && inSpaceChar(b))  ;  return b; }  private double nd()  {  return Double.parseDouble(ns()); }  private char nc()  {  return (char) skip(); }  private String ns()  {  int b = skip();  StringBuilder sb = new StringBuilder();  while (!(inSpaceChar(b)))  {   sb.appendCodePoint(b);  b = readByte();  }  return sb.toString(); }  private char[] ns(int n)  {  char[] buf = new char[n];  int b = skip(), p = 0;  while (p < n && !(inSpaceChar(b)))  {  buf[p++] = (char) b;  b = readByte();  }  return n == p ? buf : Arrays.copyOf(buf, p); }  private char[][] nm(int n, int m)  {  char[][] map = new char[n][];  for (int i = 0; i < n; i++)  map[i] = ns(m);  return map; }  private int[] na(int n)  {  int[] a = new int[n];  for (int i = 0; i < n; i++)  a[i] = ni();  return a; }  private int ni()  {  int num = 0, b;  boolean minus = false;  while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))  ;  if (b == '-')  {  minus = true;  b = readByte();  }   while (true)  {  if (b >= '0' && b <= '9')   {   num = num * 10 + (b - '0');  }   else   {   return minus ? -num : num;  }  b = readByte();  } }  private long nl()  {  long num = 0;  int b;  boolean minus = false;  while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))  ;  if (b == '-')  {  minus = true;  b = readByte();  }   while (true)  {  if (b >= '0' && b <= '9')   {   num = num * 10 + (b - '0');  }  else   {   return minus ? -num : num;  }  b = readByte();  } }  private boolean oj = System.getProperty("ONLINE_JUDGE") != null;  private void tr(Object... o)  {  if (!oj)  System.out.println(Arrays.deepToString(o)); }  }
6,public class Main {  Reader in = new Reader(System.in);  PrintWriter out = new PrintWriter(System.out);  public static void main(String[] args) throws IOException {   new Main().run();  }  int n;  int[] x, y;  int[][] time;  int status;  int[] dp;  int[] pre;   void run() throws IOException {   int xs = in.nextInt(), ys = in.nextInt();   n = in.nextInt();   x = new int[n+1];   y = new int[n+1];   for (int i = 0; i < n; i++) {    x[i] = in.nextInt();    y[i] = in.nextInt();   }   x[n] = xs;   y[n] = ys;   computeTime();   status = (1<<n);   dp = new int[1<<n];   pre = new int[1<<n];   Arrays.fill(dp, -1);   dp[0] = 0;   for (int i = 0; i < status; i++) {    if (dp[i] == -1)     continue;    for (int j = 0; j < n; j++) {     if (((1<<j) & i) == 0) {      int t1 = ((1<<j) | i), temp1 = dp[i] + 2 * time[n][j];      if (dp[t1] == -1 || dp[t1] > temp1) {       dp[t1] = temp1;       pre[t1] = i;      }      for (int k = 0; k < n; k++) {       if (((1<<k) & t1) == 0) {        int t2 = ((1<<k) | t1),          temp2 = dp[i] + time[n][j] + time[j][k] + time[k][n];        if (dp[t2] == -1 || dp[t2] > temp2) {         dp[t2] = temp2;         pre[t2] = i;        }       }      }      break;     }    }   }   int cur = (1 << n) - 1;   out.println(dp[cur]);   out.print(0);   while (cur > 0) {    int last = pre[cur], diff = cur ^ last;    int obj1 = -1, obj2 = -1;    for (int i = 0; i < n; i++) {     if (((1<<i) & diff) > 0) {      obj2 = obj1;      obj1 = i;     }    }    if (obj2 >= 0)     out.printf(" %d %d %d", obj1+1, obj2+1, 0);    else     out.printf(" %d %d", obj1+1, 0);    cur = last;   }   out.flush();  }  void computeTime() {   time = new int[n+1][n+1];   for (int i = 0; i <= n; i++) {    for (int j = i+1; j <= n; j++)     time[i][j] = time[j][i] = (x[i]- x[j])*(x[i]- x[j]) +       (y[i]- y[j])*(y[i]- y[j]);   }  }  static class Reader {   BufferedReader reader;   StringTokenizer tokenizer;   public Reader(InputStream input) {    reader = new BufferedReader(new InputStreamReader(input));    tokenizer = new StringTokenizer("");   }      String nextToken() throws IOException {    while ( ! tokenizer.hasMoreTokens() ) {         tokenizer = new StringTokenizer( reader.readLine() );    }    return tokenizer.nextToken();   }   String readLine() throws IOException {    return reader.readLine();   }   int nextInt() throws IOException {    return Integer.parseInt( nextToken() );   }   long nextLong() throws IOException {    return Long.parseLong( nextToken() );   }   double nextDouble() throws IOException {    return Double.parseDouble( nextToken() );   }  } }
2,public class B { public static void main(String [] args) throws IOException {  Scanner in = new Scanner(System.in);  long n = in.nextLong();  long k = in.nextLong();  if(n == 1)  {  System.out.println(0);  return;  }  if(n <= k)  {  System.out.println(1);  return;  }  long lb = 2, ub = k;  long sum = ((k)*(k-1))/2;  if(sum+1 < n)  {  System.out.println(-1);  return;  }  while(ub - lb > 1)  {  long mid = (lb+ub)/2;  long s = ((mid-1)*(mid-2))/2;  if(n - (sum-s+1) < 0)   lb = mid;  else   ub = mid;  }  long rem = n - (sum - ((ub-1)*(ub-2))/2 + 1);  long res = k - ub + 1;  if(rem == 0)  {  System.out.println(res);  return;  }  rem++;  if(!(rem >= 2 && rem < ub))  {  System.out.println(-1);  return;  }  System.out.println(res+1);  } }
2,public class algo_1802 {  public static void main(String args[])  {   Scanner ex=new Scanner(System.in);   int n=ex.nextInt();   int k=ex.nextInt();   int x=(int)((Math.sqrt(9.0+8.0*((double)n+(double)k))-3.0)/2.0);   System.out.println(n-x);  } }
3,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskD solver = new TaskD();   solver.solve(1, in, out);   out.close();  }  static class TaskD {   public void solve(int testNumber, InputReader in, PrintWriter out) {    int n = in.nextInt();    int[] ar = new int[n];    for (int i = 0; i < n; i++) {     ar[i] = in.nextInt();    }    long ninv = 0;    for (int i = 0; i < n - 1; i++) {     for (int j = i + 1; j < n; j++) {      if (ar[i] > ar[j])       ninv++;     }    }    int m = in.nextInt();    for (int i = 0; i < m; i++) {     int l = in.nextInt();     int r = in.nextInt();     int s = (r - l) * (r - l + 1) / 2;     ninv += s;     if (ninv % 2 == 0)      out.println("even");     else      out.println("odd");    }   }  }  static class InputReader {   StringTokenizer st;   BufferedReader br;   public InputReader(InputStream is) {    BufferedReader br = new BufferedReader(new InputStreamReader(is));    this.br = br;   }   public String next() {    if (st == null || !st.hasMoreTokens()) {     String nextLine = null;     try {      nextLine = br.readLine();     } catch (IOException e) {      throw new RuntimeException(e);     }     if (nextLine == null)      return null;     st = new StringTokenizer(nextLine);    }    return st.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }  } }
2,public class Main {  static BufferedReader f;  static StringTokenizer st;  public static void main (String [] args) throws Exception {        f = new BufferedReader(new java.io.InputStreamReader(System.in));     long unixTime = System.currentTimeMillis();     long l=nextLong();   long r=nextLong();     String ll=Long.toBinaryString(l);   String rr=Long.toBinaryString(r);     System.err.println(ll);   System.err.println(rr);     System.err.println(Long.parseLong(rr,2));     int len=0;   if(ll.length()!=rr.length()){    len=Math.max(ll.length(),rr.length());   }else{       for(int i=0;i<ll.length();i++){     if(ll.charAt(i)!=rr.charAt(i)){      len=ll.length()-i;      break;     }    }   }   System.err.println(len);     StringBuffer s=new StringBuffer();   for(int i=0;i<len;i++){       s.append(1);   }     if(len==0){    System.out.println(0);   }else{    System.out.println(Long.parseLong(s.toString(),2));   }        System.exit(0);          }     static long nextLong() throws Exception{   return Long.parseLong(next());  }  static int nextInt() throws Exception {   return Integer.parseInt(next());  }   static String next() throws Exception {    while (st == null || !st.hasMoreTokens()) {      st = new StringTokenizer(f.readLine());    }    return st.nextToken();  }  } class ii{  int a;  int b;  public ii(int a, int b){   this.a=a;   this.b=b;  } }
4,public class C {  int removeSq(int x) {  for (int i = 2; i * i <= x; i++) {  while (x % (i * i) == 0) {   x /= i * i;  }  }  return x; }  void submit() {  int n = nextInt();  HashMap<Integer, Integer> map = new HashMap<>();  for (int i = 0; i < n; i++) {  int x = removeSq(nextInt());  map.merge(x, 1, Integer::sum);  }   int[] a = new int[map.size()];  int ptr = 0;  for (Integer x : map.values()) {  a[ptr++] = x;  }  int ret = go(a);  for (int x : a) {  ret = (int)((long)ret * fact[x] % P);  }   out.println(ret); }  int go(int[] a) {  int[] dp = new int[a[0]];  dp[a[0] - 1] = 1;  int places = a[0] + 1;   int toInsert = 0;  for (int x : a) {  toInsert += x;  }  toInsert -= a[0];  for (int i =1; i < a.length; i++) {   int here = a[i];  if (here == 0) {   continue;  }   int[] nxt = new int[dp.length + here];   for (int wasSame = 0; wasSame < dp.length; wasSame++) {   if (wasSame > toInsert) {   continue;   }   if (dp[wasSame] == 0) {   continue;   }   int wasDiff = places - wasSame;   for (int runsSame = 0; runsSame <= wasSame && runsSame <= here; runsSame++) {   for (int runsDiff = 0; runsDiff <= wasDiff && runsSame + runsDiff <= here; runsDiff++) {    if (runsSame + runsDiff == 0) {    continue;    }    int delta = (int) ((long) dp[wasSame]     * ways[wasSame][runsSame] % P * ways[wasDiff][runsDiff]     % P * ways[here - 1][runsSame + runsDiff - 1] % P);    if (delta == 0) {    continue;    }    int nxtIdx = (wasSame - runsSame) + (here - runsSame - runsDiff);    nxt[nxtIdx] += delta;    if (nxt[nxtIdx] >= P) {    nxt[nxtIdx] -= P;    }   }   }   }   dp = nxt;  places += here;  toInsert -= here;  }    return dp[0]; }  int[][] ways; int[] fact; static final int N = 350; static final int P = 1_000_000_007;  void preCalc() {  ways = new int[N][];  for (int i = 0; i < N; i++) {  ways[i] = new int[i + 1];  ways[i][0] = ways[i][i] = 1;  for (int j = 1; j < i; j++) {   ways[i][j] = ways[i - 1][j] + ways[i - 1][j - 1];   if (ways[i][j] >= P) {   ways[i][j] -= P;   }  }  }  fact = new int[N];  fact[0] = 1;  for (int i = 1; i < N; i++) {  fact[i] = (int)((long)fact[i - 1] * i % P);  } }  void stress() {  }  void test() {  }  C() throws IOException {  br = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);  preCalc();  submit();     out.close(); }  static final Random rng = new Random();  static int rand(int l, int r) {  return l + rng.nextInt(r - l + 1); }  public static void main(String[] args) throws IOException {  new C(); }  BufferedReader br; PrintWriter out; StringTokenizer st;  String nextToken() {  while (st == null || !st.hasMoreTokens()) {  try {   st = new StringTokenizer(br.readLine());  } catch (IOException e) {   throw new RuntimeException(e);  }  }  return st.nextToken(); }  String nextString() {  try {  return br.readLine();  } catch (IOException e) {  throw new RuntimeException(e);  } }  int nextInt() {  return Integer.parseInt(nextToken()); }  long nextLong() {  return Long.parseLong(nextToken()); }  double nextDouble() {  return Double.parseDouble(nextToken()); } }
4,public class P035C {  private class Pair {   private int x;   private int y;     private Pair(int x, int y) {    this.x = x;    this.y = y;   }     public int hashCode() {    return 37 * x + y;   }     public boolean equals(Object other) {    if (other instanceof Pair) {     Pair otherPair = (Pair)other;     return x == otherPair.x && y == otherPair.y;    }       return false;   }  }   private boolean[][] visited;  private final int N;  private final int M;  private final int k;  private ArrayList<Pair> fires = new ArrayList<Pair>();  private ArrayList<Pair> neighbors = new ArrayList<Pair>();   public P035C() throws IOException {   Scanner sc = new Scanner(new File("input.txt"));   N = sc.nextInt();   M = sc.nextInt();   visited = new boolean[N][M];   k = sc.nextInt();   for (int i = 0; i < k; i++) {    int x = sc.nextInt() - 1;    int y = sc.nextInt() - 1;    fires.add(new Pair(x, y));   }   bfs();  }   private void bfs() throws IOException{   java.util.Queue<Pair> queue = new ArrayDeque<Pair>();   for (Pair p : fires) {    queue.add(p);    visited[p.x][p.y] = true;   }     Pair last = fires.get(0);   while (!queue.isEmpty()) {    Pair p = last = queue.poll();       for (Pair pn : getNeighbors(p)) {     if (!visited[pn.x][pn.y]) {      queue.add(pn);      visited[pn.x][pn.y] = true;     }    }   }     PrintWriter output = new PrintWriter(new FileWriter(new File("output.txt")));   output.printf("%d %d\n", last.x + 1, last.y + 1);   output.close();  }   private Collection<Pair> getNeighbors(Pair p) {   neighbors.clear();   if (p.x > 0) neighbors.add(new Pair(p.x-1, p.y));   if (p.x < N-1) neighbors.add(new Pair(p.x+1, p.y));   if (p.y > 0) neighbors.add(new Pair(p.x, p.y-1));   if (p.y < M-1) neighbors.add(new Pair(p.x, p.y+1));     return neighbors;  }   public static void main(String[] args) throws IOException {   P035C solution = new P035C();  } }
5,public class Main {    public static void main(String[] args) throws NumberFormatException, IOException {   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));   StringTokenizer st = new StringTokenizer(br.readLine(), " ");   int num = Integer.parseInt(st.nextToken());   int k = Integer.parseInt(st.nextToken());   st = new StringTokenizer(br.readLine(), " ");   if (k == 1) System.out.println(num);   else {    Set<Integer> set = new TreeSet<Integer>();    Set<Integer> bad = new TreeSet<Integer>();    int sel;       int[] arr = new int[num];    for (int i = 0; i < num; i++) {     arr[i] = Integer.parseInt((st.nextToken()));    }    shuffle(arr);    Arrays.sort(arr);    for (int i = 0; i < num; i++) {     sel = arr[i];     if (sel % k != 0) {      set.add(sel);      bad.add(sel * k);     }     if (!bad.contains(sel) && !set.contains(sel / k)) {      bad.add(sel * k);      set.add(sel);     }    }    System.out.println(set.size());   }  }  public static void shuffle(int[] arr) {   Random rand = new Random();   for (int i = arr.length - 1; i >= 0; --i) {    int pos = rand.nextInt(i + 1);    int aux = arr[i];    arr[i] = arr[pos];    arr[pos] = aux;   }  } }
1,public class Main { public static void main(String[] args) {  Scanner in = new Scanner(System.in);  PrintWriter out = new PrintWriter(System.out);      int n = in.nextInt();  String line = in.next();  int h = 0;  for (int i = 0; i < line.length(); i++) {  if(line.charAt(i)=='H') h++;  }  line = line + line;   int min = Integer.MAX_VALUE;  for (int i = 0; i < n; i++) {  int ans = 0;  for (int j = i; j < i+h; j++) {   if(line.charAt(j)!='H') ans++;  }  if(min>ans) min = ans;  }   out.print(min);        in.close();  out.close(); } }
1,public class Main {  static BufferedReader reader;  static StringTokenizer tokenizer;  static PrintWriter writer;  static int nextInt() throws NumberFormatException, IOException {   return Integer.parseInt(nextToken());  }  static long nextLong() throws NumberFormatException, IOException {   return Long.parseLong(nextToken());  }  static double nextDouble() throws NumberFormatException, IOException {   return Double.parseDouble(nextToken());  }  static String nextToken() throws IOException {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    tokenizer = new StringTokenizer(reader.readLine());   }   return tokenizer.nextToken();  }  public static void main(String[] args) throws IOException {   reader = new BufferedReader(new InputStreamReader(System.in));   writer = new PrintWriter(System.out);   pineapple();   reader.close();   writer.close();  }  static void pineapple() throws NumberFormatException, IOException {   int n = nextInt();   int a = nextInt();   int b = nextInt();   HashSet<Integer> al = new HashSet<Integer>();   HashMap<Integer, Integer> mp = new HashMap<Integer, Integer>();   int[] ans = new int[n];   Arrays.fill(ans, -1);   HashSet<Integer> used = new HashSet<Integer>();   int[] mas = new int[n];   for (int i = 0; i < n; i++) {    int t = nextInt();    al.add(t);    mas[i] = t;    mp.put(t, i);   }   for (int st : al) {    if (used.contains(st))     continue;    {     int pr = st;     int cc = -1;     HashSet<Integer> u2 = new HashSet<Integer>();     u2.add(pr);     if (!u2.contains(a - pr) && al.contains(a - pr))      cc = a - pr;     if (!u2.contains(a - pr) && al.contains(b - pr))      cc = b - pr;     if (cc != -1) {      u2.add(cc);      boolean bGo = true;      while (bGo) {       bGo = false;       int nxt = -1;       if (!u2.contains(a - cc) && al.contains(a - cc))        nxt = a - cc;       if (!u2.contains(b - cc) && al.contains(b - cc))        nxt = b - cc;       if (nxt != -1) {        bGo = true;        u2.add(nxt);        cc = nxt;        pr = cc;       }      }      st = cc;     }    }    LinkedList<Integer> ll = new LinkedList<Integer>();    ll.add(st);    while (!ll.isEmpty()) {     int curr = ll.pollFirst();     used.add(curr);     int next1 = a - curr;     if (al.contains(next1)) {      if (!used.contains(next1)) {       ll.addLast(next1);       if (ans[mp.get(curr)] == -1 && ans[mp.get(next1)] == -1) {        ans[mp.get(next1)] = 0;        ans[mp.get(curr)] = 0;       }      }     }     int next2 = b - curr;     if (al.contains(next2)) {      if (!used.contains(next2)) {       ll.addLast(next2);       if (ans[mp.get(curr)] == -1 && ans[mp.get(next2)] == -1) {        ans[mp.get(next2)] = 1;        ans[mp.get(curr)] = 1;       }      }     }    }   }   for (int i = 0; i < n; i++) {    if (ans[i] == -1) {     if (2 * mas[i] == a) {      ans[i] = 0;      continue;     }     if (2 * mas[i] == b) {      ans[i] = 1;      continue;     }     writer.println("NO");     return;    }   }   writer.println("YES");   for (int i = 0; i < n; i++) {    writer.print(ans[i] + " ");   }  }  }
5,public class CF113_Div2_A implements Runnable {  BufferedReader in; PrintWriter out; StringTokenizer tok;  final boolean ONLINE_JUDGE = (System.getProperty("ONLINE_JUDGE") != null);  public static void main(String[] args) {  new Thread(null, new CF113_Div2_A(), "", 256 * (1L << 20)).start(); }  @Override public void run() {  try {  long startTime = System.currentTimeMillis();  if (ONLINE_JUDGE) {   in = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);  } else {   in = new BufferedReader(new FileReader("input.txt"));   out = new PrintWriter("output.txt");  }  Locale.setDefault(Locale.US);  tok = new StringTokenizer("");  solve();  in.close();  out.close();  long endTime = System.currentTimeMillis();  System.err.println("Time = " + (endTime - startTime));  long freeMemory = Runtime.getRuntime().freeMemory();  long totalMemory = Runtime.getRuntime().totalMemory();  System.err.println("Memory = " + ((totalMemory - freeMemory) >> 10));  } catch (Throwable t) {  t.printStackTrace(System.err);  System.exit(-1);  } }  String readString() throws IOException {  while (!tok.hasMoreTokens()) {  tok = new StringTokenizer(in.readLine());  }  return tok.nextToken(); }  int readInt() throws IOException {  return Integer.parseInt(readString()); }  long readLong() throws IOException {  return Long.parseLong(readString()); }  double readDouble() throws IOException {  return Double.parseDouble(readString()); }   static class Utils {  private Utils() {}  public static void mergeSort(int[] a) {  mergeSort(a, 0, a.length - 1);  }  private static final int MAGIC_VALUE = 50;  private static void mergeSort(int[] a, int leftIndex, int rightIndex) {  if (leftIndex < rightIndex) {   if (rightIndex - leftIndex <= MAGIC_VALUE) {   insertionSort(a, leftIndex, rightIndex);   } else {   int middleIndex = (leftIndex + rightIndex) / 2;   mergeSort(a, leftIndex, middleIndex);   mergeSort(a, middleIndex + 1, rightIndex);   merge(a, leftIndex, middleIndex, rightIndex);   }  }  }  private static void merge(int[] a, int leftIndex, int middleIndex, int rightIndex) {  int length1 = middleIndex - leftIndex + 1;  int length2 = rightIndex - middleIndex;  int[] leftArray = new int[length1];  int[] rightArray = new int[length2];  System.arraycopy(a, leftIndex, leftArray, 0, length1);  System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);  for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {   if (i == length1) {   a[k] = rightArray[j++];   } else if (j == length2) {   a[k] = leftArray[i++];   } else {   a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];   }  }  }  private static void insertionSort(int[] a, int leftIndex, int rightIndex) {  for (int i = leftIndex + 1; i <= rightIndex; i++) {   int current = a[i];   int j = i - 1;   while (j >= leftIndex && a[j] > current) {   a[j + 1] = a[j];   j--;   }   a[j + 1] = current;  }  }  }  void debug(Object... o) {  if (!ONLINE_JUDGE) {  System.err.println(Arrays.deepToString(o));  } }   class Team implements Comparable<Team>{  int cnt, time;  public Team(int cnt, int time) {  this.cnt = cnt;  this.time = time;  }  @Override  public int compareTo(Team x) {  if (cnt == x.cnt) return time - x.time;  return x.cnt - cnt;  }  @Override  public int hashCode() {  final int prime = 31;  int result = 1;  result = prime * result + getOuterType().hashCode();  result = prime * result + cnt;  result = prime * result + time;  return result;  }  @Override  public boolean equals(Object obj) {  if (this == obj)   return true;  if (obj == null)   return false;  if (getClass() != obj.getClass())   return false;  Team other = (Team) obj;  if (!getOuterType().equals(other.getOuterType()))   return false;  if (cnt != other.cnt)   return false;  if (time != other.time)   return false;  return true;  }  private CF113_Div2_A getOuterType() {  return CF113_Div2_A.this;  }      }  void solve() throws IOException {  int n = readInt();  int k = readInt();  k--;  Team[] a = new Team[n];  for (int i =0 ; i < n; i++) {  a[i] = new Team(readInt(), readInt());  }  Arrays.sort(a);  int res = 1;  for (int i = k-1; i >= 0; i--) {  if (a[k].equals(a[i])) res++;  }  for (int i = k+1; i < n; i++) {  if (a[k].equals(a[i])) res++;  }  out.print(res);   } }
6,public class Bag implements Runnable {  private void solve() throws IOException {   int xs = nextInt();   int ys = nextInt();   int n = nextInt();   int[] x = new int[n];   int[] y = new int[n];   for (int i = 0; i < n; ++i) {    x[i] = nextInt();    y[i] = nextInt();   }   final int[][] pair = new int[n][n];   for (int i = 0; i < n; ++i)    for (int j = i + 1; j < n; ++j)     pair[i][j] = (x[i] - xs) * (x[i] - xs) + (y[i] - ys) * (y[i] - ys) + (x[j] - xs) * (x[j] - xs) + (y[j] - ys) * (y[j] - ys) + (x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]);   final int[] single = new int[n];   for (int i = 0; i < n; ++i) {    single[i] = 2 * ((x[i] - xs) * (x[i] - xs) + (y[i] - ys) * (y[i] - ys));   }   final int[] best = new int[1 << n];   final int[] prev = new int[1 << n];   for (int set = 1; set < (1 << n); ++set) {    int i;    for (i = 0; i < n; ++i)     if ((set & (1 << i)) != 0)      break;    best[set] = best[set ^ (1 << i)] + single[i];    prev[set] = 1 << i;    int nextSet = set ^ (1 << i);    int unoI = 1 << i;    for (int j = i + 1, unoJ = 1 << (i + 1); j < n; ++j, unoJ <<= 1)     if ((set & unoJ) != 0) {      int cur = best[nextSet ^ unoJ] + pair[i][j];      if (cur < best[set]) {       best[set] = cur;       prev[set] = unoI | unoJ;      }     }   }   writer.println(best[(1 << n) - 1]);   int now = (1 << n) - 1;   writer.print("0");   while (now > 0) {   int differents = prev[now];   for(int i = 0; i < n; i++)   if((differents & (1 << i)) != 0)   {    writer.print(" ");     writer.print(i + 1);     now ^= 1 << i;   }    writer.print(" ");    writer.print("0");   }   writer.println();  }   public static void main(String[] args) {   new Bag().run();  }  BufferedReader reader;  StringTokenizer tokenizer;  PrintWriter writer;  public void run() {   try {    reader = new BufferedReader(new InputStreamReader(System.in));    tokenizer = null;    writer = new PrintWriter(System.out);    solve();    reader.close();    writer.close();   } catch (Exception e) {    e.printStackTrace();    System.exit(1);   }  }  int nextInt() throws IOException {   return Integer.parseInt(nextToken());  }  long nextLong() throws IOException {   return Long.parseLong(nextToken());  }  double nextDouble() throws IOException {   return Double.parseDouble(nextToken());  }  String nextToken() throws IOException {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    tokenizer = new StringTokenizer(reader.readLine());   }   return tokenizer.nextToken();  } }
0,public class Solution {  public static void main(String[] args) throws Exception {  Scanner in = new Scanner(System.in);  int n = in.nextInt();  if (n % 2 == 0)  System.out.println("4 " + (n - 4));  else  System.out.println("9 " + (n - 9)); } }
2,public class A {  public static void main(String ar[]) throws Exception  {    BufferedReader br=new BufferedReader(new InputStreamReader(System.in));    long k=Long.parseLong(br.readLine());    long l=1,h=1000000000000l;    long p[]=new long[13];    for(int i=1;i<=12;i++)    {     long ll=9*i;     p[i]=ll*(long)Math.pow(10,i-1);     p[i]+=p[i-1];    }    while(h-l>1)    {     long mid=(l+h)/2;     long num=(long)(Math.log(mid)/Math.log(10));     long l1=p[(int)num]+(num+1)*(mid-(long)Math.pow(10,num));     long l2=p[(int)num]+(num+1)*(mid-(long)Math.pow(10,num)+1);     if(k<=l1)      h=mid;     else if(k>l2)      l=mid;     else     { l=mid; h=mid; }    }       if(h-l==1)    {     long num=(long)(Math.log(h)/Math.log(10));     long l1=p[(int)num]+(num+1)*(h-(long)Math.pow(10,num));     long l2=p[(int)num]+(num+1)*(h-(long)Math.pow(10,num)+1);     if(k>l1 && k<=l2)     { l=h; }    }       long n=(long)(Math.log(l)/Math.log(10));    long u=p[(int)n]+(n+1)*(l-(long)Math.pow(10,n));    k-=u;    String ss=String.valueOf(l);       System.out.println(ss.charAt((int)(k-1)));  } }
3,public class Main {  static double [] res;  static double r;  static double solve (int xMe, int xHim, int idxHim) {   if (Math.abs(xMe - xHim) > 2 * r) return r;   double hisY = res[idxHim];   double lo = hisY, hi = hisY + 2 * r, best = hi;   for (int cnt = 0; cnt <= 50; cnt++) {    double myY = (lo) + ((hi - lo) / 2);    if (notIntersect(xMe, myY, xHim, hisY)) {     best = Math.min(best, myY);     hi = Math.max(lo, myY);    } else     lo = Math.min(hi, myY);   }   return best;  }  static boolean notIntersect (double x1, double y1, double x2, double y2) {   return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) >= 2 * r * 2 * r;  }  public static void main(String[] args) throws Exception {   Scanner sc = new Scanner(System.in);   PrintWriter out = new PrintWriter(System.out);   int n = sc.nextInt();   res = new double[n];   r = sc.nextInt();   int[] x = new int[n];   for (int i = 0; i < n; i++)    x[i] = sc.nextInt();   for (int i = 0; i < n; i++) {    double max = r;    for (int j = 0; j < i; j++) {     max = Math.max(max, solve(x[i], x[j], j));    }    if (i > 0) out.print(" ");    res[i] = max;    out.printf("%.10f", max);   }   out.println();   out.flush();   out.close();  }  static class Scanner {   StringTokenizer st;   BufferedReader br;   public Scanner(InputStream s){ br = new BufferedReader(new InputStreamReader(s));}   public Scanner(FileReader s) throws FileNotFoundException { br = new BufferedReader(s);}   public String next() throws IOException   {    while (st == null || !st.hasMoreTokens())     st = new StringTokenizer(br.readLine());    return st.nextToken();   }   public int nextInt() throws IOException {return Integer.parseInt(next());}   public long nextLong() throws IOException {return Long.parseLong(next());}   public String nextLine() throws IOException {return br.readLine();}   public double nextDouble() throws IOException { return Double.parseDouble(next()); }   public boolean ready() throws IOException {return br.ready();}  } }
5,public class Main{   public static void main(String[] args) throws Exception {  Parserdoubt3 s = new Parserdoubt3(System.in);  int n = s.nextInt();  long k = s.nextInt();  Long a[] = new Long[n];  TreeSet<Long> tree = new TreeSet<Long>();  for (int i = 0; i < a.length; i++) {  a[i] = s.nextLong();  tree.add(a[i]);  }  Arrays.sort(a);   int ans = 0;   for (int i = 0; i < a.length; i++) {  if(tree.contains(a[i])){   ans++;   long next = a[i] * k;   if(tree.contains(next)) tree.remove(next);  }  }  System.out.println(ans); } } class Parserdoubt3 { final private int BUFFER_SIZE = 1 << 17;  private DataInputStream din; private byte[] buffer; private int bufferPointer, bytesRead;  public Parserdoubt3(InputStream in) {  din = new DataInputStream(in);  buffer = new byte[BUFFER_SIZE];  bufferPointer = bytesRead = 0; }  public String nextString() throws Exception {  StringBuffer sb = new StringBuffer("");  byte c = read();  while (c <= ' ')  c = read();  do {  sb.append((char) c);  c = read();  } while (c > ' ');  return sb.toString(); }  public char nextChar() throws Exception {  byte c = read();  while (c <= ' ')  c = read();  return (char) c; }  public int nextInt() throws Exception {  int ret = 0;  byte c = read();  while (c <= ' ')  c = read();  boolean neg = c == '-';  if (neg)  c = read();  do {  ret = ret * 10 + c - '0';  c = read();  } while (c > ' ');  if (neg)  return -ret;  return ret; }  public long nextLong() throws Exception {  long ret = 0;  byte c = read();  while (c <= ' ')  c = read();  boolean neg = c == '-';  if (neg)  c = read();  do {  ret = ret * 10 + c - '0';  c = read();  } while (c > ' ');  if (neg)  return -ret;  return ret; }  private void fillBuffer() throws Exception {  bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);  if (bytesRead == -1)  buffer[0] = -1; }  private byte read() throws Exception {  if (bufferPointer == bytesRead)  fillBuffer();  return buffer[bufferPointer++]; } }
5,public class Solution implements Runnable{  public static BufferedReader br;  public static PrintWriter out;  public static StringTokenizer stk;  public static boolean isStream = true;  public static void main(String[] args) throws IOException {  if (isStream) {    br = new BufferedReader(new InputStreamReader(System.in));   } else {    br = new BufferedReader(new FileReader("in.txt"));   }   out = new PrintWriter(System.out);   new Thread(new Solution()).start();  }  public void loadLine() {   try {    stk = new StringTokenizer(br.readLine());   } catch (IOException e) {    e.printStackTrace();   }  }  public String nextLine() {   try {    return br.readLine();   } catch (IOException e) {    e.printStackTrace();    return "";   }  }  public String nextWord() {   while (stk==null||!stk.hasMoreTokens()) loadLine();   return stk.nextToken();  }  public Integer nextInt() {   while (stk==null||!stk.hasMoreTokens()) loadLine();   return Integer.valueOf(stk.nextToken());  }  public Long nextLong() {   while (stk==null||!stk.hasMoreTokens()) loadLine();   return Long.valueOf(stk.nextToken());  }  public Double nextDouble() {   while (stk==null||!stk.hasMoreTokens()) loadLine();   return Double.valueOf(stk.nextToken());  }   public Float nextFloat() {   while (stk==null||!stk.hasMoreTokens()) loadLine();   return Float.valueOf(stk.nextToken());  }   public void run() {  int n = nextInt();  int[] arr = new int[n];  for (int i = 0; i < n;i++) {   arr[i] = nextInt();  }  Arrays.sort(arr);  if (arr[n-1] != 1) arr[n-1] = 1;  else arr[n-1] = 2;  Arrays.sort(arr);  for (int i = 0; i < n; i++) {   out.print(arr[i]+" ");  }  out.println();  out.flush();  } }
0,public class lucky {  public static void main(String args[]) throws IOException  {  BufferedReader cin=new BufferedReader(new InputStreamReader(System.in));   String s=cin.readLine();  int l=s.length();  int n=Integer.parseInt(s);  if(s.equals("47") || s.equals("4") || s.equals("7") || s.equals("74") || s.equals("447") || s.equals("477") || s.equals("474") || s.equals("44") || s.equals("77") || s.equals("444") || s.equals("777") || s.equals("747") || s.equals("774") || s.equals("744"))      System.out.println("YES");  else if(n%(47)==0 || n%(4)==0 || n%(7)==0 || n%(74)==0 || n%(447)==0 || n%(477)==0 || n%(474)==0 || n%(44)==0 || n%(77)==0 || n%(444)==0 || n%(777)==0 || n%(747)==0 || n%(774)==0 || n%(744)==0)    System.out.println("YES");  else    System.out.println("NO");    } }
1,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   OutputWriter out = new OutputWriter(outputStream);   TaskA solver = new TaskA();   solver.solve(1, in, out);   out.close();  }  static class TaskA {   public void solve(int testNumber, InputReader in, OutputWriter out) {    int n = in.nextInt();    int[] cnt = new int[10];    Arrays.fill(cnt, 0);    List<String> a = new ArrayList<>();    for (int i = 0; i < n; i++) {     a.add(in.readLine());    }    List<String> b = new ArrayList<>();    for (int i = 0; i < n; i++) {     String temp = in.readLine();     if (a.contains(temp)) {      a.remove(temp);     } else      b.add(temp);    }    int[] cnta = new int[10];    for (int i = 0; i < a.size(); i++) {     cnta[a.get(i).length()]++;    }    int[] cntb = new int[10];    Arrays.fill(cnta, 0);    Arrays.fill(cntb, 0);    for (int i = 0; i < b.size(); i++) {     cntb[a.get(i).length()]++;    }    int ans = 0;    for (int i = 0; i < 10; i++) {     ans += Math.abs(cnta[i] - cntb[i]);    }    out.println(ans);   }  }  static class InputReader {   private InputStream stream;   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   private InputReader.SpaceCharFilter filter;   public InputReader(InputStream stream) {    this.stream = stream;   }   public int read() {    if (numChars == -1) {     throw new InputMismatchException();    }    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (numChars <= 0) {      return -1;     }    }    return buf[curChar++];   }   public int nextInt() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if (c < '0' || c > '9') {      throw new InputMismatchException();     }     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   public boolean isSpaceChar(int c) {    if (filter != null) {     return filter.isSpaceChar(c);    }    return isWhitespace(c);   }   public static boolean isWhitespace(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   private String readLine0() {    StringBuilder buf = new StringBuilder();    int c = read();    while (c != '\n' && c != -1) {     if (c != '\r') {      buf.appendCodePoint(c);     }     c = read();    }    return buf.toString();   }   public String readLine() {    String s = readLine0();    while (s.trim().length() == 0) {     s = readLine0();    }    return s;   }   public interface SpaceCharFilter {    public boolean isSpaceChar(int ch);   }  }  static class OutputWriter {   private final PrintWriter writer;   public OutputWriter(OutputStream outputStream) {    writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));   }   public OutputWriter(Writer writer) {    this.writer = new PrintWriter(writer);   }   public void close() {    writer.close();   }   public void println(int i) {    writer.println(i);   }  } }
5,public class Main {  static PrintWriter out; static StreamTokenizer in; static int next() throws Exception {in.nextToken(); return (int) in.nval;}  public static void main(String[] args) throws Exception {  out = new PrintWriter(System.out);  in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));  int n = next();  int t = 2*next();  int[] x = new int[n];  int[] a = new int[n];  for (int i = 0; i < n; i++) {  x[i] = 2* next() + 2000;  a[i] = next();  }  int[] srt = new int[n];  for (int i = 0; i < n; i++) srt[i] = 10000 * x[i] + a[i];  Arrays.sort(srt);  for (int i = 0; i < n; i++) {  x[i] = srt[i] / 10000;  a[i] = srt[i] % 10000;  }  int answ = 2;  for (int i = 0; i < n - 1; i++) {  if (x[i + 1] - x[i] > a[i] + a[i + 1] + t) answ++;  if (x[i + 1] - x[i] >= a[i] + a[i + 1] + t) answ++;  }  out.println(answ);  out.close(); } }
1,public class Main {  FastScanner in;  PrintWriter out;  private void solve() throws IOException {   solveA();              }  private void solveA() throws IOException {   int n = in.nextInt();   TreeMap<String, Integer> map = new TreeMap<>();   for (int i = 0; i < n; i++) {    String s = in.next();    map.put(s, map.getOrDefault(s, 0) + 1);   }   for (int i = 0; i < n; i++) {    String s = in.next();    map.put(s, map.getOrDefault(s, 0) - 1);   }   long ans = 0;   for (String i : map.keySet())    ans += abs(map.get(i));   out.println(ans / 2);  }  private void solveB() throws IOException {   int n = in.nextInt();   int time = (int) 1e9, ans = -1;   for (int i = 0; i < n; i++) {    int a = in.nextInt() - i;    if ((a + (n - 1)) / n < time) {     time = (a + (n - 1)) / n;     ans = i;    }   }   out.println(ans + 1);  }  class PairC {   int i, j;   PairC(int i, int j) {    this.i = i;    this.j = j;   }   public String toString() {    return "(" + i + ", " + j + ")";   }  }  private void solveC() throws IOException {   int n = in.nextInt(), k = in.nextInt();   int[][] a = new int[4][n];   for (int i = 0; i < 4; i++)    for (int j = 0; j < n; j++)     a[i][j] = in.nextInt() - 1;   int[] empty = new int[4];   PairC[] from = new PairC[k];   for (int i = 1; i < 3; i++)    for (int j = 0; j < n; j++)     if (a[i][j] != -1)      from[a[i][j]] = new PairC(i, j);     else      empty[i]++;   PairC[] to = new PairC[k];   for (int i = 0; i < 4; i += 3)    for (int j = 0; j < n; j++)     if (a[i][j] != -1)      to[a[i][j]] = new PairC(i, j);   out.println(Arrays.toString(from));   out.println(Arrays.toString(to));   ArrayList<int[]> ans = new ArrayList<>();   int cnt = 0;   for (int i = 0; i < k; i++) {    if (abs(from[i].i - to[i].i) == 1) {     if (from[i].j == to[i].j) {      ans.add(new int[]{i, to[i].i, to[i].j});      a[from[i].i][from[i].j] = 0;      empty[from[i].i]++;      cnt++;     }    } else if (from[i].j == to[i].j && a[(from[i].i + to[i].i) / 2][to[i].j] == 0) {     ans.add(new int[]{i, (from[i].i + to[i].i) / 2, to[i].j});     ans.add(new int[]{i, to[i].i, to[i].j});     a[from[i].i][from[i].j] = 0;     empty[from[i].i]++;     cnt++;    }   }   for (int i = 1; i < 3; i++) {    if (empty[i] > 0) {     for (int j = 0; j < k; j++) {      if (from[j].i == i && true) {      }     }    }   }    while (true) {    boolean flag = false;    for (int i = 0; i < k; i++) {     if (abs(from[i].i - to[i].i) == 1 && abs(from[i].j - to[i].j) <= empty[i]) {     }    }    if (!flag)     break;   }   if (cnt == k) {    out.println(ans.size());    for (int[] i : ans) {     for (int j : i)      out.print(j + 1 + " ");     out.println();    }   } else    out.println(-1);  }  private void solveD() throws IOException {   int n = in.nextInt();   int[] a = new int[n * 2];   for (int i = 0; i < n * 2; i++)    a[i] = in.nextInt();   long ans = 0;   for (int i = 0; i < 2 * n; i += 2) {    int j = i + 1;    while (a[i] != a[j])     j++;    ans += j - i - 1;    while (j > i + 1)     a[j] = a[--j];   }   out.println(ans);  }  class PairE implements Comparable<PairE> {   long x, y;   int id;   boolean b;   PairE(long x, long y, int id) {    this.x = x;    this.y = y;    this.id = id;    b = false;   }   @Override   public int compareTo(PairE o) {    return x != o.x ? Long.compare(x, o.x) : Long.compare(y, o.y);   }  }  private void solveE() throws IOException {   int n = in.nextInt();   PairE[] p = new PairE[n];   for (int i = 0; i < n; i++)    p[i] = new PairE(in.nextLong(), in.nextLong(), i);   shuffle(p);   sort(p);   long X = 0, Y = 0;   long max = 225 * (long) 1e10;   for (int i = 0; i < n; i++) {    if ((X + p[i].x) * (X + p[i].x) + (Y + p[i].y) * (Y + p[i].y) < (X - p[i].x) * (X - p[i].x) + (Y - p[i].y) * (Y - p[i].y)) {     p[i].b = true;     X += p[i].x;     Y += p[i].y;    } else {     p[i].b = false;     X -= p[i].x;     Y -= p[i].y;    }   }   sort(p, comparingInt(o -> o.id));   for (int i = 0; i < n; i++) {    out.print(p[i].b ? 1 : -1);    if (i + 1 < n)     out.print(" ");   }   out.println();  }  void shuffle(PairE[] a) {   PairE b;   Random r = new Random();   for (int i = a.length - 1, j; i > 0; i--) {    j = r.nextInt(i + 1);    b = a[j];    a[j] = a[i];    a[i] = b;   }  }  private void solveF() throws IOException {  }  class FastScanner {   StringTokenizer st;   BufferedReader br;   FastScanner(InputStream s) {    br = new BufferedReader(new InputStreamReader(s));   }   String next() throws IOException {    while (st == null || !st.hasMoreTokens())     st = new StringTokenizer(br.readLine());    return st.nextToken();   }   boolean hasNext() throws IOException {    return br.ready() || (st != null && st.hasMoreTokens());   }   int nextInt() throws IOException {    return Integer.parseInt(next());   }   long nextLong() throws IOException {    return Long.parseLong(next());   }   double nextDouble() throws IOException {    return Double.parseDouble(next().replace(',', '.'));   }   String nextLine() throws IOException {    return br.readLine();   }   boolean hasNextLine() throws IOException {    return br.ready();   }  }  private void run() throws IOException {   in = new FastScanner(System.in);   out = new PrintWriter(System.out);    solve();   out.flush();   out.close();  }  public static void main(String[] args) throws IOException {   new Main().run();  } }
6,public class CF85C {  public static void main(String[] args) {   reader = new BufferedReader(new InputStreamReader(System.in));   int height = nextInt(), width = nextInt();   if (width > height) {    int t = width;    width = height;    height = t;   }   final int INF = height * width + 10;   final int ALL_BITS = (1 << width) - 1;   int[][][] dp = new int[height + 1][1 << width][1 << width];   for (int[][] ints : dp) {    for (int[] anInt : ints) {     Arrays.fill(anInt, INF);    }   }   dp[0][0][0] = 0;   for(int r = 0; r < height; ++r) {    for(int uncovered = 0; uncovered < (1 << width); ++uncovered) {     for(int mask = 0; mask < (1 << width); ++mask) {      if (dp[r][uncovered][mask] == INF) {       continue;      }      for(int curMask = uncovered; curMask < (1 << width); curMask = (curMask + 1) | uncovered) {       int curCovered = (mask | curMask);       curCovered |= (curMask >> 1);       curCovered |= (ALL_BITS & (curMask << 1));       int curUncovered = ALL_BITS ^ curCovered;       dp[r+1][curUncovered][curMask] = Math.min(dp[r+1][curUncovered][curMask], dp[r][uncovered][mask] + Integer.bitCount(curMask));      }     }    }   }   int res = INF;   for(int x: dp[height][0]) res = Math.min(res, x);   System.out.println(height * width - res);  }  public static BufferedReader reader;  public static StringTokenizer tokenizer = null;  static String nextToken() {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    try {     tokenizer = new StringTokenizer(reader.readLine());    } catch (IOException e) {     throw new RuntimeException(e);    }   }   return tokenizer.nextToken();  }  static public int nextInt() {   return Integer.parseInt(nextToken());  }  static public long nextLong() {   return Long.parseLong(nextToken());  }  static public String next() {   return nextToken();  }  static public String nextLine() {   try {    return reader.readLine();   } catch (IOException e) {    e.printStackTrace();   }   return null;  } }
0,public class problemA {  public static long GCD(long number1, long number2) {     if(number2 == 0){    return number1;   }   return GCD(number2, number1%number2);  }  public static void main(String[] args) throws NumberFormatException, IOException {  BufferedReader br = new BufferedReader (new InputStreamReader(System.in));   StringTokenizer st = new StringTokenizer(br.readLine());   long b = Long.parseLong(st.nextToken());   long c = Long.parseLong(st.nextToken());   if(c-b<2 ||((c-b==2)&& GCD(c,b)==1) ){    System.out.println("-1");   }else{     if(b%2==0 ){      System.out.println(b+" "+(b+1)+" "+(b+2));    }else     System.out.println((b+1)+" "+(b+2)+" "+(b+3));      }       } }
5,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  Scanner in = new Scanner(inputStream);  PrintWriter out = new PrintWriter(outputStream);  TaskA solver = new TaskA();  solver.solve(1, in, out);  out.close(); } } class TaskA {  class Pair{  public int a;  public int b;  public Pair(int a, int b) {    this.a = a;  this.b = b;  } }  public void solve(int testNumber, Scanner in, PrintWriter out) {   int n = in.nextInt();   int k = in.nextInt(); --k;   ArrayList<Pair> list = new ArrayList<Pair>();  for (int i = 1; i <= n; ++i){    int num = in.nextInt();    int pen = in.nextInt();  Pair t = new Pair(num, pen);   list.add(t);   }   Collections.sort(list, new Comparator<Pair>(){   public int compare(Pair o1, Pair o2){   if (o1.a != o2.a){    return (o2.a - o1.a);   }   return (o1.b - o2.b);   }  });   int res = 1;   Pair compare = list.get(k);   int i = k - 1;   while (i >= 0){    Pair t = list.get(i);    if (t.a == compare.a && t.b == compare.b){     --i;     ++res;     continue;    }else{     break;    }   }   i = k + 1;   while (i < list.size()){    Pair t = list.get(i);    if (t.a == compare.a && t.b == compare.b){     ++res; ++i;     continue;    }else{     break;    }   }   out.println(res);   return;  } }
1,public class C_138B { private static BufferedReader in; private static StringTokenizer st; private static PrintWriter out;   static String nextToken() throws IOException {  while (!st.hasMoreTokens()) {  st = new StringTokenizer(in.readLine());  }  return st.nextToken(); }  static int nextInt() throws NumberFormatException, IOException {  return Integer.parseInt(nextToken()); } public static void main(String[] args) throws NumberFormatException, IOException {  in = new BufferedReader(new InputStreamReader(System.in));  st = new StringTokenizer("");  out = new PrintWriter(new OutputStreamWriter(System.out));  int n = nextInt();  int k = nextInt();  int [] a = new int [n];  for (int i = 0; i < n; i++) {  a[i] = nextInt();  }  Set<Integer> set = new HashSet<Integer>();  for (int i = 0; i < a.length; i++) {  set.add(a[i]);  if(set.size()==k){   Set<Integer> set2 = new HashSet<Integer>();   for (int j = i; j >= 0; j--) {   set2.add(a[j]);   if(set2.size()==k){    out.print((j+1)+" "+(i+1));    out.close();    return;   }   }  }  }  out.print("-1 -1");   out.close(); } }
2,public class ProblemA {  private static long MOD = 1000000009;  public void solve() throws Exception {   long n = nextInt();   long m = nextInt();   long k = nextInt();   long tmp = 1024 * 1024;   long res = 0;   long nTmp = n;   long mTmp = m;   while (tmp > 0) {    while (mTmp >= (k - 1) * tmp && nTmp - k * tmp >= mTmp - (k - 1) * tmp) {     nTmp -= k * tmp;     mTmp -= (k - 1) * tmp;    }    tmp /= 2;   }   long fullC = mTmp / k;    long pow2 = getPow(2, fullC + 1, MOD);   res = (((res + pow2 + MOD - 2) % MOD) * k) % MOD;    mTmp = mTmp % k;   res = (res + mTmp) % MOD;   nTmp = n;   mTmp = m - fullC * k - mTmp;   tmp = 1024 * 1024;   while (tmp > 0) {    while (mTmp >= (k - 1) * tmp && nTmp - k * tmp >= mTmp - (k - 1) * tmp) {     nTmp -= k * tmp;     mTmp -= (k - 1) * tmp;     res = (res + (k - 1) * tmp) % MOD;    }    tmp /= 2;   }   out.println(res);  }  static long[] pows = new long[1000000];  public static long getPow(long base, long pow, long mod) {   if (pow < pows.length && pows[(int) pow] != 0) {    return pows[(int) pow];   }   if (pow == 0) {    pows[0] = 1;    return 1;   }   if (pow == 1) {    pows[1] = base;    return base;   }   long res = getPow(base, pow / 2, mod);   res = (res * res) % mod;   res = (res * getPow(base, pow % 2, mod)) % mod;   if (pow < pows.length) {    pows[(int) pow] = res;   }   return res;  }  public static void main(String[] args) throws Exception {   ProblemA problem = new ProblemA();   problem.solve();   problem.close();  }  BufferedReader in;  PrintWriter out;  String curLine;  StringTokenizer tok;  final String delimeter = " ";  final String endOfFile = "";  public ProblemA(BufferedReader in, PrintWriter out) throws Exception {   this.in = in;   this.out = out;   curLine = in.readLine();   if (curLine == null || curLine == endOfFile) {    tok = null;   } else {    tok = new StringTokenizer(curLine, delimeter);   }  }  public ProblemA() throws Exception {   this(new BufferedReader(new InputStreamReader(System.in)),     new PrintWriter(System.out));  }  public ProblemA(String filename) throws Exception {   this(new BufferedReader(new FileReader(filename + ".in")),     new PrintWriter(filename + ".out"));  }  public boolean hasMore() throws Exception {   if (tok == null || curLine == null) {    return false;   } else {    while (!tok.hasMoreTokens()) {     curLine = in.readLine();     if (curLine == null || curLine.equalsIgnoreCase(endOfFile)) {      tok = null;      return false;     } else {      tok = new StringTokenizer(curLine);     }    }    return true;   }  }  public String nextWord() throws Exception {   if (!hasMore()) {    return null;   } else {    return tok.nextToken();   }  }  public int nextInt() throws Exception {   return Integer.parseInt(nextWord());  }  public long nextLong() throws Exception {   return Long.parseLong(nextWord());  }  public int[] readIntArray(int n) throws Exception {   int[] res = new int[n];   for (int i = 0; i < n; i++) {    res[i] = nextInt();   }   return res;  }  public void close() throws Exception {   in.close();   out.close();  } }
6,public class cf1102f {  public static void main(String[] args) throws IOException {   int n = rni(), m = ni(), a[][] = new int[n][];   for (int i = 0; i < n; ++i) {    a[i] = ria(m);   }   int delta[][] = new int[n][n], end_delta[][] = new int[n][n], dp[][][] = new int[n][1 << n][n];   for (int i = 0; i < n; ++i) {    fill(delta[i], IBIG);    fill(end_delta[i], IBIG);    delta[i][i] = 0;   }   for (int i = 0; i < n - 1; ++i) {    for (int j = i + 1; j < n; ++j) {     for (int k = 0; k < m; ++k) {      delta[i][j] = delta[j][i] = min(delta[i][j], abs(a[i][k] - a[j][k]));     }    }   }   for (int i = 0; i < n; ++i) {    for (int j = 0; j < n; ++j) {     for (int k = 1; k < m; ++k) {      end_delta[i][j] = min(end_delta[i][j], abs(a[j][k] - a[i][k - 1]));     }    }   }   for (int[][] layer : dp) {    for (int[] row : layer) {     fill(row, IBIG);    }   }   for (int i = 1; i < 1 << n; ++i) {    boolean one_bit = Integer.bitCount(i) == 1;    for (int j = 0; j < n; ++j) {     if ((i & (1 << j)) > 0) {      for (int l = 0; l < n; ++l) {       if ((i & (1 << l)) == 0) {        int max = 0;        for (int k = 0; k < n; ++k) {         if ((one_bit || j != k) && (i & (1 << k)) > 0) {          max = max(max, min(dp[j][i][k], delta[k][l]));         }        }                              dp[j][i | (1 << l)][l] = max;       }      }     }    }   }   int ans = 0;   for (int i = 0; i < n; ++i) {    for (int j = 0; j < n; ++j) {     if (i != j) {           ans = max(ans, min(dp[i][(1 << n) - 1][j], end_delta[j][i]));     }    }   }   if (n == 1) {    ans = maxof(end_delta[0]);   }   prln(ans);   close();  }  static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));  static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));  static StringTokenizer input;  static Random __rand = new Random();          static final int IBIG = 1000000007;  static final int IMAX = 2147483647;  static final int IMIN = -2147483648;  static final long LMAX = 9223372036854775807L;  static final long LMIN = -9223372036854775808L;   static int minof(int a, int b, int c) {return min(a, min(b, c));}  static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}  static long minof(long a, long b, long c) {return min(a, min(b, c));}  static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}  static int maxof(int a, int b, int c) {return max(a, max(b, c));}  static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}  static long maxof(long a, long b, long c) {return max(a, max(b, c));}  static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}  static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}  static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}  static int fli(double d) {return (int) d;}  static int cei(double d) {return (int) ceil(d);}  static long fll(double d) {return (long) d;}  static long cel(double d) {return (long) ceil(d);}  static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}  static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}  static int lcm(int a, int b) {return a * b / gcf(a, b);}  static long lcm(long a, long b) {return a * b / gcf(a, b);}  static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}  static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}   static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}  static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}  static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}  static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}  static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}  static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}  static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}  static void rsort(int[] a) {shuffle(a); sort(a);}  static void rsort(long[] a) {shuffle(a); sort(a);}  static void rsort(double[] a) {shuffle(a); sort(a);}  static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}  static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}  static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}  static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}   static void r() throws IOException {input = new StringTokenizer(rline());}  static int ri() throws IOException {return Integer.parseInt(rline());}  static long rl() throws IOException {return Long.parseLong(rline());}  static double rd() throws IOException {return Double.parseDouble(rline());}  static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}  static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}  static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}  static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}  static char[] rcha() throws IOException {return rline().toCharArray();}  static String rline() throws IOException {return __in.readLine();}  static String n() {return input.nextToken();}  static int rni() throws IOException {r(); return ni();}  static int ni() {return Integer.parseInt(n());}  static long rnl() throws IOException {r(); return nl();}  static long nl() {return Long.parseLong(n());}  static double rnd() throws IOException {r(); return nd();}  static double nd() {return Double.parseDouble(n());}   static void pr(int i) {__out.print(i);}  static void prln(int i) {__out.println(i);}  static void pr(long l) {__out.print(l);}  static void prln(long l) {__out.println(l);}  static void pr(double d) {__out.print(d);}  static void prln(double d) {__out.println(d);}  static void pr(char c) {__out.print(c);}  static void prln(char c) {__out.println(c);}  static void pr(char[] s) {__out.print(new String(s));}  static void prln(char[] s) {__out.println(new String(s));}  static void pr(String s) {__out.print(s);}  static void prln(String s) {__out.println(s);}  static void pr(Object o) {__out.print(o);}  static void prln(Object o) {__out.println(o);}  static void prln() {__out.println();}  static void pryes() {prln("yes");}  static void pry() {prln("Yes");}  static void prY() {prln("YES");}  static void prno() {prln("no");}  static void prn() {prln("No");}  static void prN() {prln("NO");}  static boolean pryesno(boolean b) {prln(b ? "yes" : "no"); return b;};  static boolean pryn(boolean b) {prln(b ? "Yes" : "No"); return b;}  static boolean prYN(boolean b) {prln(b ? "YES" : "NO"); return b;}  static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}  static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}  static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}  static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}  static void h() {prln("hlfd"); flush();}  static void flush() {__out.flush();}  static void close() {__out.close();} }
1,public class B {  public static void main (String[] args) throws IOException {   BufferedReader b = new BufferedReader(new InputStreamReader(System.in));   int n = Integer.parseInt(b.readLine());   while (n-- > 0) {    String s = b.readLine();    if (s.matches("^[A-Z]+[0-9]+$")) {     System.out.println(toRC(decodeCR(s)));    } else {     System.out.println(toCR(decodeRC(s)));    }   }  }  private static String toRC(int[] a) {   return "R" + a[0] + "C" + a[1];  }  private static String toCR(int[] a) {   String r = "";   if (a[1] == 1) {    r = "A";   } else {    for (int x = a[1]; x > 0; x /= 26) {     r = (char)('A' + (x - 1) % 26) + r;     if (x % 26 == 0) x -= 26;    }   }   return r + a[0];  }  private static int[] decodeCR(String s) {   int[] a = new int[2];   int i = 0;   while (s.charAt(i) >= 'A') {    a[1] = a[1] * 26 + (s.charAt(i) - 'A' + 1);    i++;   }   a[0] = Integer.parseInt(s.substring(i));     return a;  }  private static int[] decodeRC(String s) {   assert s.charAt(0) == 'R';   int[] a = new int[2];   a[0] = Integer.parseInt(s.substring(1, s.indexOf('C')));   a[1] = Integer.parseInt(s.substring(s.indexOf('C') + 1));     return a;  } }
1,public class CF_468B {  public static void main(String[] args) throws IOException {   new CF_468B().solve();  }   int root(int[] father, int a){   if (father[a]==a) return a;   else return father[a]=root(father, father[a]);  }  void unite(int[] father, int a, int b){   father[root(father, a)]=root(father, b);  }     private void solve() throws IOException{     InputStream in = System.in;   PrintStream out = System.out;         long mod=1_000_000_007;   Scanner sc=new Scanner(in);   int n=sc.nextInt();   long a=sc.nextLong(), b=sc.nextLong();   int[] father=new int[n];   long[] p=new long[n];   HashMap<Long, Integer> pos=new HashMap<Long, Integer>();   for (int i=0;i<n;i++){    father[i]=i;    p[i]=sc.nextLong();    pos.put(p[i],i);   }     for (int i=0;i<n;i++){    if (pos.containsKey(a-p[i])) unite(father,i,pos.get(a-p[i]) );    if (pos.containsKey(b-p[i])) unite(father,i,pos.get(b-p[i]) );   }   boolean[] canA=new boolean[n],     canB=new boolean[n];   Arrays.fill(canA,true);   Arrays.fill(canB,true);   for (int i=0;i<n;i++){    if (!pos.containsKey(a-p[i]) ||      root(father, i)!=root(father, pos.get(a-p[i])))     canA[root(father, i)]=false;    if (!pos.containsKey(b-p[i]) ||      root(father, i)!=root(father, pos.get(b-p[i])))     canB[root(father, i)]=false;    if (!canA[root(father,i)] && !canB[root(father,i)]){     out.println("NO");     return;         }   }   out.println("YES");   for (int i=0;i<n;i++)    if (canA[root(father, i)])     out.print("0 ");    else     out.print("1 ");          } }
4,public class Main {  public static InputStream IN;  public static OutputStream OUT;  public static PrintWriter out;  public static BufferedReader in;   public static StringTokenizer st = null;  public static int ni() throws Exception {   for (;st == null || !st.hasMoreTokens();){    st = new StringTokenizer(in.readLine());   }   return Integer.parseInt(st.nextToken());  }  public static void main(String[] args) throws Exception {   IN = new FileInputStream("input.txt");   OUT = new FileOutputStream("output.txt");   out = new PrintWriter(OUT);   in = new BufferedReader(new InputStreamReader(IN));   int n = ni();   int m = ni();   int k = ni();   int[] x = new int[k];   int[] y = new int[k];   for (int i = 0 ; i < k; i++){    x[i] = ni() - 1;    y[i] = ni() - 1;   }   int w = Integer.MIN_VALUE;   int aa = -1;   int ab = -1;   for (int i = 0 ; i < n ; i++){    for (int j = 0; j < m; j++){     int min = Integer.MAX_VALUE;     for (int q = 0; q < k; q++){      int cur = Math.abs(i - x[q]) + Math.abs(j - y[q]);      min = Math.min(cur, min);     }     if (min > w){      w = min;      aa = i;      ab = j;     }    }   }   out.println((aa + 1) + " " + (ab + 1));     out.flush();  } }
0,public class A { FastScanner in; PrintWriter out;  public void run() {  try {  in = new FastScanner(new InputStreamReader(System.in));  out = new PrintWriter(System.out);  solve();  out.close();  } catch (IOException e) {  e.printStackTrace();  } }  public void solve() throws IOException {  long l = new Long(in.next());  long r = new Long(in.next());  if (r - l < 2 || (r - l == 2 && l % 2 != 0)) {  out.println("-1");  } else {  if (l % 2 != 0) {   l++;  }  out.println(l);  out.println(l+1);  out.println(l+2);  } }  class FastScanner {  BufferedReader br;  StringTokenizer st;  FastScanner(InputStreamReader in) {  br = new BufferedReader(in);  }  String nextLine() {  String str = null;  try {   str = br.readLine();  } catch (IOException e) {   e.printStackTrace();  }   return str;  }  String next() {  while (st == null || !st.hasMoreTokens()) {   try {   st = new StringTokenizer(br.readLine());   } catch (IOException e) {   e.printStackTrace();   }  }  return st.nextToken();  }  int nextInt() {  return Integer.parseInt(next());  } }  public static void main(String[] arg) {  A o = new A();  o.run(); } }
0,public class A{       private BufferedReader in;   private StringTokenizer st;     void solve() throws IOException{       int n = nextInt();    System.out.println(3 * n/2);   }       A() throws IOException {    in = new BufferedReader(new InputStreamReader(System.in));      eat("");    solve();      }   private void eat(String str) {    st = new StringTokenizer(str);   }   String next() throws IOException {    while (!st.hasMoreTokens()) {     String line = in.readLine();     if (line == null) {      return null;     }     eat(line);    }    return st.nextToken();   }   int nextInt() throws IOException {    return Integer.parseInt(next());   }   long nextLong() throws IOException {    return Long.parseLong(next());   }   double nextDouble() throws IOException {    return Double.parseDouble(next());   }   public static void main(String[] args) throws IOException {    new A();   }   int gcd(int a,int b){    if(b>a) return gcd(b,a);    if(b==0) return a;    return gcd(b,a%b);   } }
1,public class Spreadsheets implements Runnable { private Scanner in = new Scanner(System.in); private PrintWriter out = new PrintWriter(System.out); private String s, ans;  public static void main(String[] args) {  new Thread(new Spreadsheets()).start(); }  private void read() {  s = in.next(); }  private void solve() {  if (s.matches("R\\d+C\\d+")) {  s = s.replace('R', ' ').replace('C', ' ');  Scanner ss = new Scanner(s);  int r = ss.nextInt();  int c = ss.nextInt();  c--;  StringBuffer b = new StringBuffer();  int c26 = 26;  int cc = 0;  while (cc + c26 <= c) {   cc += c26;   c26 *= 26;  }  c -= cc;  while (c26 > 1) {   c26 /= 26;   b.append((char) (c / c26 + 'A'));   c %= c26;  }  ans = b.toString() + r;  } else {  int p = 0;  while (!Character.isDigit(s.charAt(p))) {   p++;  }  int c26 = 1;  int cc = 0;  for (int i = 0; i < p; i++) {   cc += c26;   c26 *= 26;  }  for (int i = 0; i < p; i++) {   c26 /= 26;   cc += c26 * (s.charAt(i) - 'A');  }  ans = "R" + s.substring(p) + "C" + cc;  } }  private void write() {  out.println(ans); }  public void run() {  int n = in.nextInt();  for (int i = 0; i < n; i++) {  read();  solve();  write();  }  out.close(); } }
5,public class A {  static int [] solve(int [] a) {  int n = a.length;  Arrays.sort(a);  a[n - 1] = (a[n - 1] > 1 ? 1 : 2);  int [] b = Arrays.copyOf(a, n);  Arrays.sort(b);  return b; }  public static void main(String[] args) throws Exception {  reader = new BufferedReader(new InputStreamReader(System.in));  writer = new PrintWriter(System.out);  setTime();   int n = nextInt();  int [] a = new int[n];  for (int i = 0; i < n; i++) {  a[i] = nextInt();  }  int [] b = solve(a);  for (int v: b) {  writer.print(v + " ");  }   printTime();  printMemory();  writer.close(); }  static BufferedReader reader; static PrintWriter writer; static StringTokenizer tok = new StringTokenizer(""); static long systemTime;  static void debug(Object... o) {  System.err.println(deepToString(o)); }  static void setTime() {  systemTime = System.currentTimeMillis(); }  static void printTime() {  System.err.println("Time consumed: " + (System.currentTimeMillis() - systemTime)); }  static void printMemory() {  System.err.println("Memory consumed: "   + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 1000 + "kb"); }  static String next() {  while (!tok.hasMoreTokens()) {  String w = null;  try {   w = reader.readLine();  } catch (Exception e) {   e.printStackTrace();  }  if (w == null)   return null;  tok = new StringTokenizer(w);  }  return tok.nextToken(); }  static int nextInt() {  return Integer.parseInt(next()); }  static long nextLong() {  return Long.parseLong(next()); }  static double nextDouble() {  return Double.parseDouble(next()); }  static BigInteger nextBigInteger() {  return new BigInteger(next()); } }
0,public class c { public static void main(String[] args) {  Scanner input = new Scanner(System.in);  long a = input.nextLong(), b = input.nextLong();  System.out.println(gcd(a, b)); } static long gcd(long a, long b) {  if(b==1) return a;  if(a==1) return b;  if(a>b) return a/b + gcd(b, a%b);  return b/a + gcd(a, b%a); } }
3,public class curling { public static void main(String[] args) throws IOException {  Scanner input = new Scanner(System.in);  int numD = input.nextInt();  double rad = input.nextInt();  int[] xC = new int[numD];  for (int i = 0; i < numD; i++){  xC[i] = input.nextInt();  }  double[] maxY = new double[1001];  for (int i = 0; i < numD; i++){  double h = rad;  for (int j = Math.max(1, xC[i]-(int)(2*rad)); j <= Math.min(1000, xC[i]+2*rad); j++){   if (maxY[j] > 0){   h = Math.max(h, Math.sqrt(4*rad*rad-(j-xC[i])*(j-xC[i]))+maxY[j]);   }  }  System.out.print(h + " ");  maxY[xC[i]] = h;  } } }
1,public class B {  static class Scan {   private byte[] buf=new byte[1024];   private int index;   private InputStream in;   private int total;   public Scan()   {    in=System.in;   }   public int scan()throws IOException   {    if(total<0)    throw new InputMismatchException();    if(index>=total)    {     index=0;     total=in.read(buf);     if(total<=0)     return -1;    }    return buf[index++];   }   public int scanInt()throws IOException   {    int integer=0;    int n=scan();    while(isWhiteSpace(n))    n=scan();    int neg=1;    if(n=='-')    {     neg=-1;     n=scan();    }    while(!isWhiteSpace(n))    {     if(n>='0'&&n<='9')     {      integer*=10;      integer+=n-'0';      n=scan();     }     else throw new InputMismatchException();    }    return neg*integer;   }   public double scanDouble()throws IOException   {    double doub=0;    int n=scan();    while(isWhiteSpace(n))    n=scan();    int neg=1;    if(n=='-')    {     neg=-1;     n=scan();    }    while(!isWhiteSpace(n)&&n!='.')    {     if(n>='0'&&n<='9')     {      doub*=10;      doub+=n-'0';      n=scan();     }     else throw new InputMismatchException();    }    if(n=='.')    {     n=scan();     double temp=1;     while(!isWhiteSpace(n))     {      if(n>='0'&&n<='9')      {       temp/=10;       doub+=(n-'0')*temp;       n=scan();      }      else throw new InputMismatchException();     }    }    return doub*neg;   }   public String scanString()throws IOException   {    StringBuilder sb=new StringBuilder();    int n=scan();    while(isWhiteSpace(n))    n=scan();    while(!isWhiteSpace(n))    {     sb.append((char)n);     n=scan();    }    return sb.toString();   }   private boolean isWhiteSpace(int n)   {    if(n==' '||n=='\n'||n=='\r'||n=='\t'||n==-1)    return true;    return false;   }  }   public static void sort(int arr[],int l,int r) {    if(l==r) {    return;   }   int mid=(l+r)/2;   sort(arr,l,mid);   sort(arr,mid+1,r);   merge(arr,l,mid,mid+1,r);  }  public static void merge(int arr[],int l1,int r1,int l2,int r2) {   int tmp[]=new int[r2-l1+1];   int indx1=l1,indx2=l2;     for(int i=0;i<tmp.length;i++) {    if(indx1>r1) {     tmp[i]=arr[indx2];     indx2++;     continue;    }    if(indx2>r2) {     tmp[i]=arr[indx1];     indx1++;     continue;    }    if(arr[indx1]<arr[indx2]) {     tmp[i]=arr[indx1];     indx1++;     continue;    }    tmp[i]=arr[indx2];    indx2++;   }     for(int i=0,j=l1;i<tmp.length;i++,j++) {    arr[j]=tmp[i];   }  }   public static void sort(long arr[],int l,int r) {    if(l==r) {    return;   }   int mid=(l+r)/2;   sort(arr,l,mid);   sort(arr,mid+1,r);   merge(arr,l,mid,mid+1,r);  }  public static void merge(long arr[],int l1,int r1,int l2,int r2) {   long tmp[]=new long[r2-l1+1];   int indx1=l1,indx2=l2;     for(int i=0;i<tmp.length;i++) {    if(indx1>r1) {     tmp[i]=arr[indx2];     indx2++;     continue;    }    if(indx2>r2) {     tmp[i]=arr[indx1];     indx1++;     continue;    }    if(arr[indx1]<arr[indx2]) {     tmp[i]=arr[indx1];     indx1++;     continue;    }    tmp[i]=arr[indx2];    indx2++;   }     for(int i=0,j=l1;i<tmp.length;i++,j++) {    arr[j]=tmp[i];   }  }   public static void main(String args[]) throws IOException {   Scan input=new Scan();   StringBuilder ans=new StringBuilder("");   int test=input.scanInt();     for(int tt=1;tt<=test;tt++) {    int n=input.scanInt();    if(n%2==1) {     ans.append("NO\n");     continue;    }    n/=2;    double sq=Math.sqrt(n);    if(Math.floor(sq)==Math.ceil(sq)) {     ans.append("YES\n");     continue;    }    if(n%2==1) {     ans.append("NO\n");     continue;    }    n/=2;    sq=Math.sqrt(n);    if(Math.floor(sq)==Math.ceil(sq)) {     ans.append("YES\n");     continue;    }    ans.append("NO\n");   }   System.out.println(ans);  } }
5,public class Round111A {  public static void main(String[] args) throws IOException {   new Round111A().run();  }  public void run() throws IOException {   BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));   Scanner scanner = new Scanner(reader);   PrintWriter writer = new PrintWriter(System.out);   int n = scanner.nextInt();   int sum = 0;   Integer[] a = new Integer[n];   for (int i = 0; i < n; i++) {    a[i] = scanner.nextInt();    sum += a[i];   }   Arrays.sort(a, Collections.reverseOrder());   int s = 0;   int i = 0;   while (i < n && (s <= sum / 2)) {    s += a[i];    i++;   }   writer.print(i);   scanner.close();   writer.close();  } }
5,public class CF220A {  public static void main(String[] args) throws Exception {   BufferedReader in = new BufferedReader(new InputStreamReader(System.in));   int n = Integer.parseInt(in.readLine());   StringTokenizer st = new StringTokenizer(in.readLine());   int[] A = new int[n];   Integer[] B = new Integer[n];   for(int i=0; i<n; i++) {    A[i] = Integer.parseInt(st.nextToken());    B[i] = A[i];   }   Collections.sort(Arrays.asList(B));   int cnt = 0;   for(int i=0; i<n; i++)    if(A[i] != B[i])     cnt++;   System.out.println(cnt <= 2 ? "YES" : "NO");  } }
6,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   Scanner in = new Scanner(inputStream);   PrintWriter out = new PrintWriter(outputStream);   FElongatedMatrix solver = new FElongatedMatrix();   solver.solve(1, in, out);   out.close();  }  static class FElongatedMatrix {   int n;   int m;   int[][] arr;   int[][] memo;   int[][][] memo2;   int first;   public void readInput(Scanner sc) {    n = sc.nextInt();    m = sc.nextInt();    arr = new int[n][m];    for (int i = 0; i < n; i++)     for (int j = 0; j < m; j++)      arr[i][j] = sc.nextInt();   }   public void solve(int testNumber, Scanner sc, PrintWriter pw) {    int tc = 1;    while (tc-- > 0) {     readInput(sc);     int max = 0;     memo2 = new int[2][n][n];     for (int[][] x : memo2)      for (int[] y : x)       Arrays.fill(y, -1);     for (int i = 0; i < n; i++) {      memo = new int[n][1 << n];      for (int[] y : memo)       Arrays.fill(y, -1);      first = i;      max = Math.max(max, dp(1 << i, i));     }     pw.println(max);    }   }   private int dp(int msk, int prev) {    if (msk == (1 << n) - 1)     return getLast(first, prev);    if (memo[prev][msk] != -1)     return memo[prev][msk];    int max = 0;    for (int i = 0; i < n; i++) {     if ((msk & 1 << i) == 0)      max = Math.max(max, Math.min(getDiff(prev, i), dp(msk | 1 << i, i)));    }    return memo[prev][msk] = max;   }   private int getLast(int i, int j) {    if (memo2[0][i][j] != -1)     return memo2[0][i][j];    int min = Integer.MAX_VALUE;    for (int k = 0; k < m - 1; k++)     min = Math.min(min, Math.abs(arr[i][k] - arr[j][k + 1]));    return memo2[0][i][j] = min;   }   private int getDiff(int i, int j) {    if (memo2[1][i][j] != -1)     return memo2[1][i][j];    int min = Integer.MAX_VALUE;    for (int k = 0; k < m; k++)     min = Math.min(min, Math.abs(arr[i][k] - arr[j][k]));    return memo2[1][i][j] = min;   }  }  static class Scanner {   StringTokenizer st;   BufferedReader br;   public Scanner(InputStream s) {    br = new BufferedReader(new InputStreamReader(s));   }   public String next() {    try {     while (st == null || !st.hasMoreTokens())      st = new StringTokenizer(br.readLine());     return st.nextToken();    } catch (Exception e) {     throw new RuntimeException(e);    }   }   public int nextInt() {    return Integer.parseInt(next());   }  } }
2,public class Main { public static void main(String[] args) {  long x=nl(),k=nl();  if(x==0)  {  pr(0);  exit();  }  x%=mod;  pr((((x*powm(2,k+1,mod))%mod-powm(2,k,mod)+1)%mod+mod)%mod);  System.out.print(output); }    static class pair {  long a, b;  pair(){}  pair(long c,long d){a=c;b=d;} } static interface combiner {  public long combine(long a, long b); } static final int mod=1000000007; static final double eps=1e-9; static final long inf=100000000000000000L; static Reader in=new Reader(); static StringBuilder output=new StringBuilder(); static Random rn=new Random(); static void reverse(int[]a){for(int i=0; i<a.length/2; i++){a[i]^=a[a.length-i-1];a[a.length-i-1]^=a[i];a[i]^=a[a.length-i-1];}} static void sort(int[]a) {  int te;  for(int i=0; i<a.length; i+=2)  {  te=rn.nextInt(a.length);  if(i!=te)  {   a[i]^=a[te];   a[te]^=a[i];   a[i]^=a[te];  }  }  Arrays.sort(a); } static void sort(long[]a) {  int te;  for(int i=0; i<a.length; i+=2)  {  te=rn.nextInt(a.length);  if(i!=te)  {  a[i]^=a[te];  a[te]^=a[i];  a[i]^=a[te];  }  }  Arrays.sort(a); } static void sort(double[]a) {  int te;  double te1;  for(int i=0; i<a.length; i+=2)  {  te=rn.nextInt(a.length);  if(i!=te)  {  te1=a[te];  a[te]=a[i];  a[i]=te1;  }  }  Arrays.sort(a); } static void sort(int[][]a) {  Arrays.sort(a, new Comparator<int[]>()  {  public int compare(int[]a,int[]b)  {   if(a[0]>b[0])   return -1;   if(b[0]>a[0])   return 1;   return 0;  }  }); } static void sort(pair[]a) {  Arrays.sort(a,new Comparator<pair>()   {  @Override  public int compare(pair a,pair b)  {   if(a.a>b.a)   return 1;   if(b.a>a.a)   return -1;   return 0;  }   }); } static int log2n(long a) {  int te=0;  while(a>0)  {  a>>=1;  ++te;  }  return te; } static class vector implements Iterable<Integer> {  int a[],size;  vector(){a=new int[10];size=0;}  vector(int n){a=new int[n];size=0;}  public void add(int b){if(++size==a.length)a=Arrays.copyOf(a, 2*size);a[size-1]=b;}  public void sort(){Arrays.sort(a, 0, size);}  public void sort(int l, int r){Arrays.sort(a, l, r);}  @Override  public Iterator<Integer> iterator() {  Iterator<Integer> hola=new Iterator<Integer>()   {   int cur=0;    @Override    public boolean hasNext() {    return cur<size;    }    @Override    public Integer next() {    return a[cur++];    }     };  return hola;  } }  static void pr(Object a){output.append(a+"\n");} static void pr(){output.append("\n");} static void p(Object a){output.append(a);} static void pra(int[]a){for(int i:a)output.append(i+" ");output.append("\n");} static void pra(long[]a){for(long i:a)output.append(i+" ");output.append("\n");} static void pra(String[]a){for(String i:a)output.append(i+" ");output.append("\n");} static void pra(double[]a){for(double i:a)output.append(i+" ");output.append("\n");} static void sop(Object a){System.out.println(a);} static void flush(){System.out.println(output);output=new StringBuilder();}   static int ni(){return Integer.parseInt(in.next());} static long nl(){return Long.parseLong(in.next());} static String ns(){return in.next();} static double nd(){return Double.parseDouble(in.next());} static int[] nia(int n){int a[]=new int[n];for(int i=0; i<n; i++)a[i]=ni();return a;} static int[] pnia(int n){int a[]=new int[n+1];for(int i=1; i<=n; i++)a[i]=ni();return a;} static long[] nla(int n){long a[]=new long[n];for(int i=0; i<n; i++)a[i]=nl();return a;} static String[] nsa(int n){String a[]=new String[n];for(int i=0; i<n; i++)a[i]=ns();return a;} static double[] nda(int n){double a[]=new double[n];for(int i=0; i<n; i++)a[i]=nd();return a;}   static void exit(){System.out.print(output);System.exit(0);} static int min(int... a){int min=a[0];for(int i:a)min=Math.min(min, i);return min;} static int max(int... a){int max=a[0];for(int i:a)max=Math.max(max, i);return max;}  static int gcd(int... a){int gcd=a[0];for(int i:a)gcd=gcd(gcd, i);return gcd;}  static long min(long... a){long min=a[0];for(long i:a)min=Math.min(min, i);return min;} static long max(long... a){long max=a[0];for(long i:a)max=Math.max(max, i);return max;}  static long gcd(long... a){long gcd=a[0];for(long i:a)gcd=gcd(gcd, i);return gcd;}  static String pr(String a, long b){String c="";while(b>0){if(b%2==1)c=c.concat(a);a=a.concat(a);b>>=1;}return c;} static long powm(long a, long b, long m) {long an=1;long c=a;while(b>0) {if(b%2==1)an=(an*c)%m;c=(c*c)%m;b>>=1;}return an;} static int gcd(int a, int b){if(b==0)return a;return gcd(b, a%b);} static long gcd(long a, long b){if(b==0)return a;return gcd(b, a%b);} static class Reader {   public BufferedReader reader;   public StringTokenizer tokenizer;   public Reader() {    reader = new BufferedReader(new InputStreamReader(System.in), 32768);    tokenizer = null;   }   public String next() {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      tokenizer = new StringTokenizer(reader.readLine());     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return tokenizer.nextToken();   }  } }
3,public class Main{ public static void main(String[] args){  InputReader reader = new InputReader(System.in);  PrintWriter pw = new PrintWriter(System.out);  int n = reader.nextInt();  int r = reader.nextInt();  int[] x = new int[n];  double[] y = new double[n];   for(int i=0;i<n;++i){  int iniX = reader.nextInt();  double bestY = (double)r;  for(int j=0;j<i;++j){   if(Math.abs(iniX - x[j]) < 2*r){    bestY = Math.max(bestY, collisionY((double)x[j], y[j], (double)iniX, r));   }   if(Math.abs(iniX - x[j]) == 2*r){    bestY = Math.max(bestY, y[j]);   }  }  x[i] = iniX;  y[i] = bestY;  }  for(int i=0;i<n;++i){  pw.printf("%.9f ", y[i]);  }   pw.flush();  pw.close(); }  public static double collisionY(double x1, double y1, double x2, double r){  double dhsq = r*r*4-(x1-x2)*(x1-x2);  return y1+Math.sqrt(dhsq); }  public static class InputReader {  BufferedReader reader;  StringTokenizer tokenizer;   public InputReader (InputStream stream){  reader = new BufferedReader(new InputStreamReader(stream));  }    public String next(){  while(tokenizer == null || !tokenizer.hasMoreTokens()){   try{   String line = reader.readLine();   if(line == null){    return "0";   }   tokenizer = new StringTokenizer(line);   } catch(IOException ioe){   throw new RuntimeException(ioe);   }  }  return tokenizer.nextToken();  }   public int nextInt(){  return Integer.parseInt(next());  }   public double nextDouble(){  return Double.parseDouble(next());  }   public Long nextLong(){  return Long.parseLong(next());  }   public BigInteger nextBigInteger(){  return new BigInteger(next());  }   public String nextLine(){  String line = "";  try{   while(line.equals("")){   line = reader.readLine();   }  } catch(IOException ioe){   throw new RuntimeException(ioe);  }  return line;  } }  public static class MultiSet<E> {  HashMap<E, Integer> map = new HashMap<E, Integer>();  int multiSize = 0;  public int add(E key){  multiSize ++;  Integer amount = map.get(key);  if(amount == null){   map.put(key, 1);   return 1;  }  map.put(key, amount+1);  return amount+1;  }   public int remove(E key){  Integer amount = map.get(key);  if(amount == null){   return -1;  }  multiSize --;  if(amount == 1){   map.remove(key);  } else {   map.put(key, amount-1);  }  return amount-1;  }   public ArrayList<E> elems(){  ArrayList<E> ret = new ArrayList<E>(multiSize);  for(Map.Entry<E, Integer> e : map.entrySet()){   E key = e.getKey();   int v = e.getValue();   while(v-->0){   ret.add(key);   }  }  return ret;  }   public int getMultiSize(){  return multiSize;  }  }    public static class MaxBIT{  int n;  int[]t;   public MaxBIT(int n){  this.n = Integer.highestOneBit(n)<<1;  this.t = new int[this.n<<1];  for(int i=0;i<2*this.n;++i){   t[i] = -1;  }  }   public void setMax(int p, int val){  p+=n;  while(p>1){   t[p] = Math.max(t[p], val);   p>>=1;  }  }   public int getMax(int p, int q){  p+=n;  q+=n;  int ret = -1;  while(p<q){   if((p&1)==1){   ret=Math.max(t[p++], ret);   }   if((q&1)==1){   ret=Math.max(t[--q], ret);   }   p = p>>1;   q = q>>1;  }  return ret;  } }  }
0,public class A235 {  public static void main(String args[]) throws Exception{   BufferedReader ip = new BufferedReader(new InputStreamReader(System.in));   int n = Integer.parseInt(ip.readLine());   int a,b,c;   int x = 0,y = 0,z = 0;   BigInteger l,t;     if(n-2 > 1)   {    a = n;    b = n-1;    c = n-2;   }   else   {    a = n;    if(n-1 > 1)     b = n-1;    else     b = 1;    c = 1;       System.out.println(a*b);    return;   }    if(n-3 > 1)   {    x = n-1;    y = n-2;    z = n-3;   }     if(n % 2 == 0)    if(n % 3 == 0)     l = BigInteger.valueOf(x).multiply(BigInteger.valueOf(y).multiply(BigInteger.valueOf(z)));    else    {     l = BigInteger.valueOf(a).multiply(BigInteger.valueOf(b).multiply(BigInteger.valueOf(c-1)));     t = BigInteger.valueOf(x).multiply(BigInteger.valueOf(y).multiply(BigInteger.valueOf(z)));     if(l.compareTo(t) < 0)      l = t;    }   else    l = BigInteger.valueOf(a).multiply(BigInteger.valueOf(b).multiply(BigInteger.valueOf(c)));     System.out.println(l);  } }
3,public class Solution {  public static void main(String[] args) throws Exception {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  int n = Integer.parseInt(br.readLine());  StringTokenizer st = new StringTokenizer(br.readLine());  long[] a = new long[n];  for (int i = 0; i < a.length; i++) {  a[i] = Long.parseLong(st.nextToken());  }  long[] sum = new long[n];  sum[0] = a[0];  for (int i = 1; i < sum.length; i++) {  sum[i] = sum[i - 1] + a[i];  }  solve(a, sum);  }  private static void solve(long[] a, long[] sum) {  int n = a.length;  Map<Long, List<Pair>> map = new HashMap<>();  for (int j = 0; j < sum.length; j++) {  for (int i = 0; i <= j; i++) {   long k = getSum(sum, i, j);   if (map.containsKey(k)) {   map.get(k).add(new Pair(i, j));   } else {   List<Pair> arr = new ArrayList<>();   arr.add(new Pair(i, j));   map.put(k, arr);   }  }  }  int max = -1;  List<Pair> ans = null;  for (Map.Entry<Long, List<Pair>> entry : map.entrySet()) {  List<Pair> pairs = entry.getValue();   int prev = -1;  int count = 0;  List<Pair> temp = new ArrayList<Pair>();  for (Pair p : pairs) {   if (p.x > prev) {   prev = p.y;   temp.add(p);   count++;   }  }   if (count > max) {   ans = temp;   max = count;  }  }  if (max != -1) {  System.out.println(ans.size());  for (Pair p : ans) {   System.out.println((p.x + 1) + " " + (p.y + 1));  }  } }  private static long getSum(long[] sum, int l, int r) {  if (l == 0) {  return sum[r];  }  return sum[r] - sum[l - 1]; } } class Pair {  int x; int y;  Pair(int x, int y) {  this.x = x;  this.y = y; }  @Override public int hashCode() {  int h = 171 << 4;  h = h * x;  h = h * y;  return h; }  @Override public boolean equals(Object o) {  if (o instanceof Pair) {  Pair other = (Pair) o;  return this.x == other.x && this.y == other.y;  }  return false; }  @Override public String toString() {  return "Pair [x=" + x + ", y=" + y + "]"; } }
5,public class A {   public static void main(String[] args) throws IOException {  Scanner sc = new Scanner(System.in);      int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();  int pl[] = new int[n];  if (k >= m) {  System.out.println(0);  System.exit(0);  }  m -= k;  for (int i = 0; i < n; i++) {  pl[i] = sc.nextInt() - 1;  }  Arrays.sort(pl);  int out = 0;  for (int i = n - 1; i >= 0; i--) {  m -= pl[i];  out++;  if (m <= 0)   break;  }  if (m <= 0)  System.out.println(out);  else  System.out.println(-1); } }
3,public class Main2 {  static long mod = 998244353;  static FastScanner scanner;  static Set<Long> second = new HashSet<>();  static boolean applied = false;  public static void main(String[] args) {   scanner = new FastScanner();   int n = scanner.nextInt();   int[] a = scanner.nextIntArray(n);   int[] colors = new int[n];   ADUtils.sort(a);   int color = 0;   for (int i = 0; i < n; i++) {    if (colors[i] != 0) continue;    color++;    for (int j = i; j < n; j++) {     if (a[j] % a[i] == 0) colors[j] = color;    }   }   System.out.println(color);  }  static class WithIdx implements Comparable<WithIdx>{   int val, idx;   public WithIdx(int val, int idx) {    this.val = val;    this.idx = idx;   }   @Override   public int compareTo(WithIdx o) {    return Integer.compare(val, o.val);   }  }  public static class FastScanner {   BufferedReader br;   StringTokenizer st;   public FastScanner() {    br = new BufferedReader(new InputStreamReader(System.in));   }   String nextToken() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {           e.printStackTrace();     }    }    return st.nextToken();   }   String nextLine() {    try {     return br.readLine();    } catch (Exception e) {     e.printStackTrace();     throw new RuntimeException();    }   }   int nextInt() {    return Integer.parseInt(nextToken());   }   long nextLong() {    return Long.parseLong(nextToken());   }   double nextDouble() {    return Double.parseDouble(nextToken());   }   int[] nextIntArray(int n) {    int[] res = new int[n];    for (int i = 0; i < n; i++) res[i] = nextInt();    return res;   }   long[] nextLongArray(int n) {    long[] res = new long[n];    for (int i = 0; i < n; i++) res[i] = nextLong();    return res;   }   String[] nextStringArray(int n) {    String[] res = new String[n];    for (int i = 0; i < n; i++) res[i] = nextToken();    return res;   }  }  static class PrefixSums {   long[] sums;   public PrefixSums(long[] sums) {    this.sums = sums;   }   public long sum(int fromInclusive, int toExclusive) {    if (fromInclusive > toExclusive) throw new IllegalArgumentException("Wrong value");    return sums[toExclusive] - sums[fromInclusive];   }   public static PrefixSums of(int[] ar) {    long[] sums = new long[ar.length + 1];    for (int i = 1; i <= ar.length; i++) {     sums[i] = sums[i - 1] + ar[i - 1];    }    return new PrefixSums(sums);   }   public static PrefixSums of(long[] ar) {    long[] sums = new long[ar.length + 1];    for (int i = 1; i <= ar.length; i++) {     sums[i] = sums[i - 1] + ar[i - 1];    }    return new PrefixSums(sums);   }  }  static class ADUtils {   static void sort(int[] ar) {    Random rnd = ThreadLocalRandom.current();    for (int i = ar.length - 1; i > 0; i--)    {     int index = rnd.nextInt(i + 1);         int a = ar[index];     ar[index] = ar[i];     ar[i] = a;    }    Arrays.sort(ar);   }   static void reverse(int[] arr) {    int last = arr.length / 2;    for (int i = 0; i < last; i++) {     int tmp = arr[i];     arr[i] = arr[arr.length - 1 - i];     arr[arr.length - 1 - i] = tmp;    }   }   static void sort(long[] ar) {    Random rnd = ThreadLocalRandom.current();    for (int i = ar.length - 1; i > 0; i--)    {     int index = rnd.nextInt(i + 1);         long a = ar[index];     ar[index] = ar[i];     ar[i] = a;    }    Arrays.sort(ar);   }  }  static class MathUtils {   static long[] FIRST_PRIMES = {     2,  3,  5,  7,  11,  13,  17,  19,  23,  29,     31,  37,  41,  43,  47,  53,  59,  61,  67,  71,     73,  79,  83,  89 , 97 , 101, 103, 107, 109, 113,     127, 131, 137, 139, 149, 151, 157, 163, 167, 173,     179, 181, 191, 193, 197, 199, 211, 223, 227, 229,     233, 239, 241, 251, 257, 263, 269, 271, 277, 281,     283, 293, 307, 311, 313, 317, 331, 337, 347, 349,     353, 359, 367, 373, 379, 383, 389, 397, 401, 409,     419, 421, 431, 433, 439, 443, 449, 457, 461, 463,     467, 479, 487, 491, 499, 503, 509, 521, 523, 541,     547, 557, 563, 569, 571, 577, 587, 593, 599, 601,     607, 613, 617, 619, 631, 641, 643, 647, 653, 659,     661, 673, 677, 683, 691, 701, 709, 719, 727, 733,     739, 743, 751, 757, 761, 769, 773, 787, 797, 809,     811, 821, 823, 827, 829, 839, 853, 857, 859, 863,     877, 881, 883, 887, 907, 911, 919, 929, 937, 941,     947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013,     1019, 1021, 1031, 1033, 1039, 1049, 1051};   static long[] primes(int to) {    long[] all = new long[to + 1];    long[] primes = new long[to + 1];    all[1] = 1;    int primesLength = 0;    for (int i = 2; i <= to; i ++) {     if (all[i] == 0) {      primes[primesLength++] = i;      all[i] = i;     }     for (int j = 0; j < primesLength && i * primes[j] <= to && all[i] >= primes[j]; j++) {      all[(int) (i * primes[j])] = primes[j];     }    }    return Arrays.copyOf(primes, primesLength);   }   static long modpow(long b, long e, long m) {    long result = 1;    while (e > 0) {     if ((e & 1) == 1) {           result = (result * b) % m;     }     b = (b * b) % m;     e >>= 1;    }    return result;   }   static long submod(long x, long y, long m) {    return (x - y + m) % m;   }  } }
6,public class F { static Scanner in = new Scanner(System.in); static PrintWriter out = new PrintWriter(System.out);  static int n,m,res=0; static int[][] a=new int[20][10005],Min=new int[20][20],Min1=new int[20][20]; static int[][][] f=new int[1<<16][20][20];  static int GetBit(int x,int k) {  return (x>>k)&1; }  static int TurnBit(int x,int k) {  return x^(1<<k); }  public static void main(String[] args)  {  n=in.nextInt();  m=in.nextInt();  for(int i=0;i<n;i++)  for(int j=1;j<=m;j++)   a[i][j]=in.nextInt();  if(n==1)  {  res=(int)1e9;  for(int i=1;i<m;i++)   res=Math.min(res,Math.abs(a[0][i]-a[0][i+1]));  out.print(res);  out.close();  return;  }  for(int i=0;i<n;i++)  for(int j=0;j<n;j++)  {   Min[i][j]=Min1[i][j]=(int)1e9;   for(int t=1;t<=m;t++)   Min[i][j]=Math.min(Min[i][j],Math.abs(a[i][t]-a[j][t]));   for(int t=1;t<m;t++)   Min1[i][j]=Math.min(Min1[i][j],Math.abs(a[i][t]-a[j][t+1]));  }  for(int i=0;i<n;i++)  f[1<<i][i][i]=(int)1e9;  for(int mask=0;mask<(1<<n);mask++)  if(Integer.bitCount(mask)>1)   for(int i=0;i<n;i++)   if(GetBit(mask,i)==1)    for(int j=0;j<n;j++)    if(i!=j&&GetBit(mask,j)==1)    {     for(int t=0;t<n;t++)     if(j!=t&&GetBit(mask,t)==1)      f[mask][i][j]=Math.max(f[mask][i][j],Math.min(f[TurnBit(mask,j)][i][t],Min[j][t]));     if(mask==(1<<n)-1)          res=Math.max(res,Math.min(f[mask][i][j],Min1[j][i]));    }  out.print(res);  out.close(); } }
3,public class Mainm {  static int mod1 = (int) (1e9 + 7);  static class Reader {   final private int BUFFER_SIZE = 1 << 16;   Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));   private DataInputStream din;   private byte[] buffer;   private int bufferPointer, bytesRead;   public Reader() {    din = new DataInputStream(System.in);    buffer = new byte[BUFFER_SIZE];    bufferPointer = bytesRead = 0;   }   public Reader(String file_name) throws IOException {    din = new DataInputStream(new FileInputStream(file_name));    buffer = new byte[BUFFER_SIZE];    bufferPointer = bytesRead = 0;   }   public String nextString() throws IOException {    String str00 = scan.next();    return str00;   }   public String readLine() throws IOException {    byte[] buf = new byte[64];    int cnt = 0, c;    while ((c = read()) != -1) {     if (c == '\n')      break;     buf[cnt++] = (byte) c;    }    return new String(buf, 0, cnt);   }   String next() throws IOException {    int c;    for (c = read(); c <= 32; c = read());    StringBuilder sb = new StringBuilder();    for (; c > 32; c = read()) {     sb.append((char) c);    }    return sb.toString();   }   public int nextInt() throws IOException {    int ret = 0;    byte c = read();    while (c <= ' ')     c = read();    boolean neg = (c == '-');    if (neg)     c = read();    do {     ret = ret * 10 + c - '0';    } while ((c = read()) >= '0' && c <= '9');    if (neg)     return -ret;    return ret;   }   public long nextLong() throws IOException {    long ret = 0;    byte c = read();    while (c <= ' ')     c = read();    boolean neg = (c == '-');    if (neg)     c = read();    do {     ret = ret * 10 + c - '0';    }    while ((c = read()) >= '0' && c <= '9');    if (neg)     return -ret;    return ret;   }   public double nextDouble() throws IOException {    double ret = 0, div = 1;    byte c = read();    while (c <= ' ')     c = read();    boolean neg = (c == '-');    if (neg)     c = read();    do {     ret = ret * 10 + c - '0';    }    while ((c = read()) >= '0' && c <= '9');    if (c == '.') {     while ((c = read()) >= '0' && c <= '9') {      ret += (c - '0') / (div *= 10);     }    }    if (neg)     return -ret;    return ret;   }   private void fillBuffer() throws IOException {    bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);    if (bytesRead == -1)     buffer[0] = -1;   }   private byte read() throws IOException {    if (bufferPointer == bytesRead)     fillBuffer();    return buffer[bufferPointer++];   }   public void close() throws IOException {    if (din == null)     return;    din.close();   }   public int[] nextArray(int n) throws IOException {    int[] a = new int[n];    for (int i = 0; i < n; i++) {     a[i] = nextInt();    }    return a;   }  }   static int GCD(int a, int b)  {   if (b == 0)    return a;   return GCD(b, a % b);  }   static long power(long x, long y, long p)  {   int res = 1;     return res;  }   static boolean primeCheck(long num0) {   boolean b1 = true;   if (num0 == 1) {    b1 = false;   } else {    int num01 = (int) (Math.sqrt(num0)) + 1;    me1:    for (int i = 2; i < num01; i++) {     if (num0 % i == 0) {      b1 = false;      break me1;     }    }   }   return b1;  }  public static int dev(long num1)  {   int count00=0;   while (num1%2==0)   {    count00++;    num1/=2;   }   HashMap<Long,Long> hashMap=new HashMap<>();   if(count00!=0)   {    hashMap.put(2L,(long)count00);   }   for (int i = 3; i <= (int)Math.sqrt(num1); i = i + 2)   {       if(num1%i==0) {     int count01 = 0;     while (num1 % i == 0) {      num1 /= i;      count01++;     }     hashMap.put((long)i,(long)count01);    }   }   if(num1>2)   {    hashMap.put((long)num1,1L);   }   long numOfDiv=1;   for(long num00:hashMap.keySet())   {    long cDiv0=hashMap.get(num00);    numOfDiv*=(cDiv0+1);   }   return (int)(numOfDiv);  }   public static long solve(long[] arr1, long N)  {   int n=(int)N;   HashMap<Long,Integer> hm=new HashMap<>();   for(int i=0;i<n;i++)   {    if(hm.containsKey(arr1[i]))    {    }    else    {     hm.put(arr1[i],1);    }   }   long count1=0;   for(int i=0;i<n;i++)   {    long num1=arr1[i]*arr1[i];    if(hm.containsKey(num1))    {     count1+=hm.get(num1);     if(arr1[i]==1)     {      count1--;     }    }   }   return count1;  }    public static void main(String[] args) throws IOException {   Reader r = new Reader();          OutputWriter770 out77 = new OutputWriter770(System.out);   int num1=r.nextInt();   int[] arr1=r.nextArray(num1);   Arrays.sort(arr1);   int res1=0;   for(int i=0;i<num1;i++)   {    if(arr1[i]!=-1)    {     res1++;     int num2=arr1[i];     arr1[i]=-1;     for(int j=i+1;j<num1;j++)     {      if(arr1[j]%num2==0)      {       arr1[j]=-1;      }     }    }   }   out77.print(res1+"");   r.close();   out77.close();  } }   class OutputWriter770 {  BufferedWriter writer;  public OutputWriter770(OutputStream stream)  {   writer = new BufferedWriter(new OutputStreamWriter(stream));  }  public void print(int i) throws IOException  {   writer.write(i + "");  }  public void println(int i) throws IOException  {   writer.write(i + "\n");  }  public void print(String s) throws IOException  {   writer.write(s + "");  }  public void println(String s) throws IOException  {   writer.write(s + "\n");  }  public void print(char[] c) throws IOException  {   writer.write(c);  }  public void close() throws IOException  {   writer.flush();   writer.close();  } } class node {  int source,dest;  long difDist;  node(int source,int dest,long tDst, long hDst)  {   this.source=source;   this.dest=dest;   this.difDist=hDst-tDst;  } }
2,public class Example {  BufferedReader in;  PrintWriter out;  StringTokenizer st;  String next() {   while (st == null || !st.hasMoreTokens()) {    try {     st = new StringTokenizer(in.readLine());    } catch (Exception e) {    }   }   return st.nextToken();  }  int nextInt() {   return Integer.parseInt(next());  }  long nextLong() {   return Long.parseLong(next());  }  double nextDouble() {   return Double.parseDouble(next());  }  public void run() throws Exception {        in = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);   solve();   out.flush();   out.close();   in.close();  }  long n, x, y, c;  boolean check(long z) {   long res = 1 + 2 * z * (z + 1);   long bx1 = z - x + 1;   long by1 = z - y + 1;   long bxn = z - n + x;   long byn = z - n + y;   if (bx1 > 0) {    res -= bx1 * bx1;   }   if (bxn > 0) {    res -= bxn * bxn;   }   if (by1 > 0) {    res -= by1 * by1;   }   if (byn > 0) {    res -= byn * byn;   }   if (z > x + y - 1) {    long m = z - x - y + 1;    res += m * (m + 1) / 2;   }   if (z > x + n - y) {    long m = z - x - n + y;    res += m * (m + 1) / 2;   }   if (z > n - x + y) {    long m = z - n - y + x;    res += m * (m + 1) / 2;   }   if (z > n - x + n - y + 1) {    long m = z - 2 * n + x + y - 1;    res += m * (m + 1) / 2;   }     return res >= c;  }  public void solve() throws Exception {   n = nextLong();   x = nextLong();   y = nextLong();   c = nextLong();   long l = 0;   long r = 2 * n;   while (r > l) {    long mid = (r + l) / 2;    if (check(mid)) {     r = mid;    } else {     l = mid + 1;    }   }   out.println(r);  }  public static void main(String[] args) throws Exception {   new Example().run();  } }
0,public class A {  static class Scanner{  BufferedReader br=null;  StringTokenizer tk=null;  public Scanner(){  br=new BufferedReader(new InputStreamReader(System.in));  }  public String next() throws IOException{  while(tk==null || !tk.hasMoreTokens())   tk=new StringTokenizer(br.readLine());  return tk.nextToken();  }  public int nextInt() throws NumberFormatException, IOException{  return Integer.valueOf(next());  }  public double nextDouble() throws NumberFormatException, IOException{  return Double.valueOf(next());  } }  public static void main(String args[]) throws NumberFormatException, IOException{  Scanner sc = new Scanner();  int T = sc.nextInt();  if ( T > 0)  System.out.println(T);  else{  String cad = (T + "");  int min = Math.min(cad.charAt(cad.length() - 1) - '0', cad.charAt(cad.length() - 2) - '0');  if (min == 0 && cad.length() == 3)   System.out.println(0);  else   System.out.println(cad.substring(0, cad.length() - 2) + "" + min);  } }  }
5,public class CodeForces {  public void solve() throws IOException {  int n=nextInt();  int t=nextInt();  double larr[]=new double [n];  double rarr[]=new double [n];   for(int i=0;i<n;i++){  double x=nextDouble();  double r=nextDouble();  larr[i]=x-r/2;  rarr[i]=x+r/2;  }  Arrays.sort(larr);  Arrays.sort(rarr);   int counter=2;  for(int i=1;i<n;i++){  if(larr[i]-rarr[i-1]>t){   counter+=2;  } else if(larr[i]-rarr[i-1]==t){   counter++;  }  }   writer.print(counter); }  public static void main(String[] args) {  new CodeForces().run(); }  BufferedReader reader; StringTokenizer tokenizer; PrintWriter writer;  public void run() {  try {  reader = new BufferedReader(new InputStreamReader(System.in));    tokenizer = null;  writer = new PrintWriter(System.out);      solve();    reader.close();  writer.close();  } catch (Exception e) {  e.printStackTrace();  System.exit(1);  } }  int nextInt() throws IOException {  return Integer.parseInt(nextToken()); }  long nextLong() throws IOException {  return Long.parseLong(nextToken()); }  double nextDouble() throws IOException {  return Double.parseDouble(nextToken()); }  String nextToken() throws IOException {  while (tokenizer == null || !tokenizer.hasMoreTokens()) {  tokenizer = new StringTokenizer(reader.readLine());  }  return tokenizer.nextToken(); } }
0,public class Main {  Scanner in;  PrintWriter out;    void solve() {  out.print("25");  }    void run() {    in = new Scanner(System.in);    out = new PrintWriter(System.out);      solve();    out.close();  }   public static void main(String[] args) {   new Main().run();     } }
6,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   MyInput in = new MyInput(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskE solver = new TaskE();   solver.solve(1, in, out);   out.close();  }  static class TaskE {   int n;   int k;   long[] neigibor;   Random random = new Random();   long maxClique;   public void solve(int testNumber, MyInput in, PrintWriter out) {    n = in.nextInt();    k = in.nextInt();    neigibor = new long[n];    for (int i = 0; i < n; i++) {     for (int j = 0; j < n; j++) {      neigibor[i] |= in.nextLong() << j;     }    }    long maxClique = bronKerbosch();    long a = Long.bitCount(maxClique);    dump(a);    out.printf("%.12f\n", a * (a - 1.0) / 2 * k / a * k / a);   }   static void dump(Object... o) {    System.err.println(Arrays.deepToString(o));   }   long bronKerbosch() {    maxClique = 0;    bronKerbosch2(0, (1L << n) - 1, 0);    return maxClique;   }   void bronKerbosch2(long r, long p, long x) {    long px = p | x;    if (px == 0) {     if (Long.bitCount(maxClique) < Long.bitCount(r)) {      maxClique = r;     }     return;    }    int cnt = Long.bitCount(px);    int choice = random.nextInt(cnt);    int u;    for (int i = 0; ; i++) {     if ((px >>> i & 1) != 0 && choice-- == 0) {      u = i;      break;     }    }    long ne = p & ~neigibor[u];    for (int v = 0; v < n; v++)     if ((ne >>> v & 1) != 0) {      bronKerbosch2(r | 1L << v, p & neigibor[v], x & neigibor[v]);      p &= ~(1L << v);      x |= 1L << v;     }   }  }  static class MyInput {   private final BufferedReader in;   private static int pos;   private static int readLen;   private static final char[] buffer = new char[1024 * 8];   private static char[] str = new char[500 * 8 * 2];   private static boolean[] isDigit = new boolean[256];   private static boolean[] isSpace = new boolean[256];   private static boolean[] isLineSep = new boolean[256];   static {    for (int i = 0; i < 10; i++) {     isDigit['0' + i] = true;    }    isDigit['-'] = true;    isSpace[' '] = isSpace['\r'] = isSpace['\n'] = isSpace['\t'] = true;    isLineSep['\r'] = isLineSep['\n'] = true;   }   public MyInput(InputStream is) {    in = new BufferedReader(new InputStreamReader(is));   }   public int read() {    if (pos >= readLen) {     pos = 0;     try {      readLen = in.read(buffer);     } catch (IOException e) {      throw new RuntimeException();     }     if (readLen <= 0) {      throw new MyInput.EndOfFileRuntimeException();     }    }    return buffer[pos++];   }   public int nextInt() {    int len = 0;    str[len++] = nextChar();    len = reads(len, isSpace);    int i = 0;    int ret = 0;    if (str[0] == '-') {     i = 1;    }    for (; i < len; i++) ret = ret * 10 + str[i] - '0';    if (str[0] == '-') {     ret = -ret;    }    return ret;   }   public long nextLong() {    int len = 0;    str[len++] = nextChar();    len = reads(len, isSpace);    int i = 0;    long ret = 0;    if (str[0] == '-') {     i = 1;    }    for (; i < len; i++) ret = ret * 10 + str[i] - '0';    if (str[0] == '-') {     ret = -ret;    }    return ret;   }   public char nextChar() {    while (true) {     final int c = read();     if (!isSpace[c]) {      return (char) c;     }    }   }   int reads(int len, boolean[] accept) {    try {     while (true) {      final int c = read();      if (accept[c]) {       break;      }      if (str.length == len) {       char[] rep = new char[str.length * 3 / 2];       System.arraycopy(str, 0, rep, 0, str.length);       str = rep;      }      str[len++] = (char) c;     }    } catch (MyInput.EndOfFileRuntimeException e) {    }    return len;   }   static class EndOfFileRuntimeException extends RuntimeException {   }  } }
6,public class CF85E {  public static void main(String[] args) {   reader = new BufferedReader(new InputStreamReader(System.in));   int height = nextInt(), width = nextInt();   if (width > height) {    int t = width;    width = height;    height = t;   }   final int INF = height * width + 10;   int[][][] dp = new int[height + 1][1 << width][1 << width];   for (int[][] ints : dp) {    for (int[] anInt : ints) {     Arrays.fill(anInt, INF);    }   }   dp[0][0][0] = 0;   for(int r = 0; r < height; ++r) {    for(int uncovered = 0; uncovered < (1 << width); ++uncovered) {     for(int mask = 0; mask < (1 << width); ++mask) {      if (dp[r][uncovered][mask] == INF) {       continue;      }      for(int curMask = uncovered; curMask < (1 << width); curMask = (curMask + 1) | uncovered) {       int curUncovered = (1 << width) - 1;       for(int i = 0; i < width; ++i) {        if (hasBit(mask, i) || hasBit(curMask, i)) {         curUncovered &= ~(1 << i);        }        if (i > 0 && hasBit(curMask, i-1)) {         curUncovered &= ~(1 << i);        }        if (i < width-1 && hasBit(curMask, i+1)) {         curUncovered &= ~(1 << i);        }       }       dp[r+1][curUncovered][curMask] = Math.min(dp[r+1][curUncovered][curMask], dp[r][uncovered][mask] + Integer.bitCount(curMask));      }     }    }   }   int res = INF;   for(int x: dp[height][0]) res = Math.min(res, x);   System.out.println(height * width - res);  }  private static boolean hasBit(int mask, int bit) {   return (((mask >> bit) & 1) == 1);  }  public static BufferedReader reader;  public static StringTokenizer tokenizer = null;  static String nextToken() {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    try {     tokenizer = new StringTokenizer(reader.readLine());    } catch (IOException e) {     throw new RuntimeException(e);    }   }   return tokenizer.nextToken();  }  static public int nextInt() {   return Integer.parseInt(nextToken());  }  static public long nextLong() {   return Long.parseLong(nextToken());  }  static public String next() {   return nextToken();  }  static public String nextLine() {   try {    return reader.readLine();   } catch (IOException e) {    e.printStackTrace();   }   return null;  } }
0,public class A_Toy_Army {   public static void main(String[] args) {   Scanner entrada = new Scanner(System.in);  while(entrada.hasNextInt())  {  int n = entrada.nextInt();  System.out.println(n+(n/2));  } } }
3,public class C { public static void main(String[] args) throws IOException {  FastScanner in= new FastScanner(System.in);  PrintWriter out= new PrintWriter(System.out);   int n= in.nextInt();  int r= in.nextInt();  int [] x= new int[n];  for (int i = 0; i < x.length; i++) {  x[i]= in.nextInt();  }  double [] res= new double[n];  res[0]= r;  for (int i = 1; i < x.length; i++) {  boolean found = false;  for (int j = 0; j < i; j++) {   double dis= Math.abs(x[i]-x[j]);   double rr= 4.0*r*r-1.0*dis*dis;   if(rr>=0) {   double del= Math.sqrt(rr);   res[i]= Math.max(res[i], res[j]+del);   found= true;   }  }  if(!found) {   res[i]= r;  }  }  for (int i = 0; i < res.length; i++) {  out.print(res[i]+" ");  }  out.close();   } static class FastScanner {  BufferedReader br;  StringTokenizer st;  public FastScanner(InputStream in) {  br = new BufferedReader(new InputStreamReader(in));  st = new StringTokenizer("");  }  public String next() throws IOException {  if (!st.hasMoreTokens()) {   st = new StringTokenizer(br.readLine());   return next();  }  return st.nextToken();  }  public int nextInt() throws IOException {  return Integer.parseInt(next());  }  public double nextDouble() throws NumberFormatException, IOException {  return Double.parseDouble(next());  }  public long nextLong() throws IOException {  return Long.parseLong(next());  } } }
1,public class Code implements Runnable {  public static void main(String[] args) throws IOException {   new Thread(new Code()).start();  }  private void solve() throws IOException {   taskB();  }  private void taskB() throws IOException {   int n = nextInt(), k = nextInt();   int[] arr = new int[n];   for(int i = 0; i < n; ++i) arr[i] = nextInt();   int i = 0;   while(i < n - 1 && arr[i] == arr[i + 1]) ++i;   if(k == 1)    writer.println(1 + " " + 1);   else if(k == 2 && i == n - 2)    writer.println(n - 1 + " " + n);   else {    if(i == n - 1)     writer.println(-1 + " " + -1);    else {     int l = i;     Map<Integer, Integer> set = new HashMap<Integer, Integer>(n);     while(i < n && set.size() < k) {      if(set.containsKey(arr[i])) set.put(arr[i], set.get(arr[i]) + 1);      else set.put(arr[i], 1);      i += 1;     }     if(set.size() < k) writer.println(-1 + " " + -1);     else {      while(l < i && i - l > k && set.get(arr[l]) > 1) {       set.put(arr[l], set.get(arr[l]) - 1);       l += 1;      }      writer.println((l + 1) + " " + i);     }    }   }  }  private class Pair<E extends Comparable, V extends Comparable> implements Comparable<Pair<E, V>> {   public Pair(E first, V second) {    this.first = first;    this.second = second;   }   @Override   public int compareTo(Pair<E, V> obj) {    if(first.equals(obj.first)) return second.compareTo(obj.second);    return first.compareTo(obj.first);   }   @Override   public boolean equals(Object obj) {    Pair other = (Pair)obj;    return first.equals(other.first) && second.equals(other.second);   }   public E first;   public V second;  }  @Override  public void run() {   try {    if(in.equals("")) reader = new BufferedReader(new InputStreamReader(System.in));    else reader = new BufferedReader(new FileReader(in));    if(out.equals("")) writer = new PrintWriter(new OutputStreamWriter(System.out));    else writer = new PrintWriter(new FileWriter(out));    solve();   } catch(IOException e) {    e.printStackTrace();   } finally {    try {     reader.close();     writer.close();    } catch(IOException e) {     e.printStackTrace();    }   }  }  private int nextInt() throws IOException {   return Integer.parseInt(nextToken());  }  private long nextLong() throws IOException {   return Long.parseLong(nextToken());  }  private double nextDouble() throws IOException {   return Double.parseDouble(nextToken());  }  private float nextFloat() throws IOException {   return Float.parseFloat(nextToken());  }  private String nextToken() throws IOException {   while(st == null || !st.hasMoreTokens()) st = new StringTokenizer(reader.readLine());   return st.nextToken();  }  private String in = "", out = "";  private BufferedReader reader;  private PrintWriter writer;  private StringTokenizer st; }
2,public class Main { public static void main (String[] args) throws java.lang.Exception {  Scanner scan=new Scanner(System.in);  long x=scan.nextLong();  long k=scan.nextLong();  long MOD=1000000007;  if(x==0){System.out.println(0);return;}  x%=MOD;  long a=(new Num()).pow(2L,k+1);  long b=(new Num()).pow(2L,k);  long res=(a*x)%MOD-b+1;  if(res<0){res+=MOD;}  System.out.println(res%MOD); } } class Num{ long MOD=1000000007; long pow(long x,long k){  long base=x%MOD;  long res=1;  while(k>0){  if((k&1)==1){   res=(res*base)%MOD;  }  base=(base*base)%MOD;  k>>=1;  }  return res; } }
5,public class VKRound2Div2Task1 {   public static void main(String[] args) throws IOException {   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  String str = br.readLine();  String[] strs = str.split(" ");  int n = Integer.parseInt(strs[0]);  int a = Integer.parseInt(strs[1]);  int b = Integer.parseInt(strs[2]);  str = br.readLine();  String[] hs = str.split(" ");  int[] h = new int[hs.length];  for(int i=0;i<hs.length;i++){  h[i] = Integer.parseInt(hs[i]);  }  Arrays.sort(h);  if(h[b-1]==h[b]){  System.out.println(0);  }else{  System.out.println(h[b]-h[b-1]);  }   } }
6,public class CF1185G2 { static final int MD = 1000000007; static int[][] solve1(int[] aa, int t, int n) {  int[][] da = new int[t + 1][n + 1];  da[0][0] = 1;  for (int i = 0; i < n; i++) {  int a = aa[i];  for (int s = t - 1; s >= 0; s--)   for (int m = 0; m < n; m++) {   int x = da[s][m];   if (x != 0) {    int s_ = s + a;    if (s_ <= t)    da[s_][m + 1] = (da[s_][m + 1] + x) % MD;   }   }  }  return da; } static int[][][] solve2(int[] aa, int[] bb, int t, int na, int nb) {  int[][] da = solve1(aa, t, na);  int[][][] dab = new int[t + 1][na + 1][nb + 1];  for (int s = 0; s <= t; s++)  for (int ma = 0; ma <= na; ma++)   dab[s][ma][0] = da[s][ma];  for (int i = 0; i < nb; i++) {  int b = bb[i];  for (int s = t - 1; s >= 0; s--)   for (int ma = 0; ma <= na; ma++)   for (int mb = 0; mb < nb; mb++) {    int x = dab[s][ma][mb];    if (x != 0) {    int s_ = s + b;    if (s_ <= t)     dab[s_][ma][mb + 1] = (dab[s_][ma][mb + 1] + x) % MD;    }   }  }  return dab; } static long power(int a, int k) {  if (k == 0)  return 1;  long p = power(a, k / 2);  p = p * p % MD;  if (k % 2 == 1)  p = p * a % MD;  return p; } static int[] ff, gg; static int ch(int n, int k) {  return (int) ((long) ff[n] * gg[n - k] % MD * gg[k] % MD); } static int[][][] init(int n, int na, int nb, int nc) {  ff = new int[n + 1];  gg = new int[n + 1];  for (int i = 0, f = 1; i <= n; i++) {  ff[i] = f;  gg[i] = (int) power(f, MD - 2);  f = (int) ((long) f * (i + 1) % MD);  }  int[][][] dp = new int[na + 1][nb + 1][nc + 1];  for (int ma = 0; ma <= na; ma++)  for (int mb = 0; mb <= nb; mb++)   for (int mc = 0; mc <= nc; mc++) {   int x = (int) ((long) ff[ma + mb + mc] * gg[ma] % MD * gg[mb] % MD * gg[mc] % MD);   for (int ma_ = ma == 0 ? 0 : 1; ma_ <= ma; ma_++) {    int cha = ma == 0 ? 1 : ch(ma - 1, ma_ - 1);    for (int mb_ = mb == 0 ? 0 : 1; mb_ <= mb; mb_++) {    int chb = mb == 0 ? 1 : ch(mb - 1, mb_ - 1);    for (int mc_ = mc == 0 ? 0 : 1; mc_ <= mc; mc_++) {     int chc = mc == 0 ? 1 : ch(mc - 1, mc_ - 1);     int y = dp[ma_][mb_][mc_];     if (y == 0)     continue;     x = (int) ((x - (long) y * cha % MD * chb % MD * chc) % MD);    }    }   }   if (x < 0)    x += MD;   dp[ma][mb][mc] = x;   }  for (int ma = 0; ma <= na; ma++)  for (int mb = 0; mb <= nb; mb++)   for (int mc = 0; mc <= nc; mc++)   dp[ma][mb][mc] = (int) ((long) dp[ma][mb][mc] * ff[ma] % MD * ff[mb] % MD * ff[mc] % MD);  return dp; } public static void main(String[] args) throws IOException {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer(br.readLine());  int n = Integer.parseInt(st.nextToken());  int t = Integer.parseInt(st.nextToken());  int[] aa = new int[n];  int[] bb = new int[n];  int[] cc = new int[n];  int na = 0, nb = 0, nc = 0;  for (int i = 0; i < n; i++) {  st = new StringTokenizer(br.readLine());  int a = Integer.parseInt(st.nextToken());  int g = Integer.parseInt(st.nextToken());  if (g == 1)   aa[na++] = a;  else if (g == 2)   bb[nb++] = a;  else   cc[nc++] = a;  }  int[][][] dp = init(n, na, nb, nc);  int[][][] dab = solve2(aa, bb, t, na, nb);  int[][] dc = solve1(cc, t, nc);  int ans = 0;  for (int tab = 0; tab <= t; tab++) {  int tc = t - tab;  for (int ma = 0; ma <= na; ma++)   for (int mb = 0; mb <= nb; mb++) {   int xab = dab[tab][ma][mb];   if (xab == 0)    continue;   for (int mc = 0; mc <= nc; mc++) {    int xc = dc[tc][mc];    if (xc == 0)    continue;    ans = (int) ((ans + (long) xab * xc * dp[ma][mb][mc]) % MD);   }   }  }  System.out.println(ans); } }
6,public class Main { static int a[][],n; static boolean isClique[]; static int maxClique[]; static void DFS1(int p,int n,int S) {  if(p>n)  {  isClique[S]=true;  return ;  }  DFS1(p+1,n,S);  boolean mark=true;  for(int i=1;i<p;++i)  if((S>>(i-1)&1)==1&&a[p][i]==0)   mark=false;  if(mark)  DFS1(p+1,n,1<<(p-1)|S); } static void DFS2(int p,int n,int m,int S) {  if(p>n)  {  int cnt=0;  for(int i=m;i<=n;++i)   if((S>>(i-m)&1)==1)   ++cnt;  maxClique[S]=cnt;  return ;  }  DFS2(p+1,n,m,S);  boolean mark=true;  for(int i=m;i<p;++i)  if((S>>(i-m)&1)==1&&a[p][i]==0)   mark=false;  if(mark)  DFS2(p+1,n,m,1<<(p-m)|S); } public static void main(String[] args) {  Scanner sc=new Scanner(System.in);  n=Integer.parseInt(sc.next());  a=new int [n+10][n+10];  int cap=Integer.parseInt(sc.next());  for(int i=1;i<=n;++i)  for(int j=1;j<=n;++j)   a[i][j]=Integer.parseInt(sc.next());  int m=(n+1)>>1;  isClique=new boolean [1<<m];  Arrays.fill(isClique,false);  DFS1(1,m,0);  maxClique=new int [1<<(n-m)];  Arrays.fill(maxClique,0);  DFS2(m+1,n,m+1,0);  for(int i=1;i<1<<(n-m);++i)  for(int j=m+1;j<=n;++j)   if((i>>(j-m-1)&1)==1)   maxClique[i]=Math.max(maxClique[i],maxClique[i-(1<<(j-m-1))]);  int ans=0,tmp[]=new int [m+10];  for(int i=0;i<1<<m;++i)  if(isClique[i])  {   int mask=0,cnt=0;   for(int j=1;j<=m;++j)   if((i>>(j-1)&1)==1)    tmp[++cnt]=j;   for(int j=m+1;j<=n;++j)   {   boolean mark=true;   for(int k=1;k<=cnt;++k)    if(a[j][tmp[k]]==0)    mark=false;   if(mark)    mask|=1<<(j-m-1);   }   ans=Math.max(ans,cnt+maxClique[mask]);  }  System.out.printf("%.9f\n",cap*cap*(ans-1)/2.0/ans); } }
4,public class Solution {  public static void main(String[] args)throws IOException {   FastReader in=new FastReader(System.in);   int t=in.nextInt();   StringBuilder sb=new StringBuilder();   int i,j,tc=0;   while(tc++<t) {    int n=in.nextInt();    int arr[]=new int[n];    for(i=0;i<n;i++)     arr[i]=in.nextInt();    int ans[]=new int[n+4];    ans[0]=1;    int pos=0;    sb.append("1\n");    for(i=1;i<n;i++){     if(arr[i]==arr[i-1]+1){      ans[pos]=ans[pos]+1;     }     else if(arr[i]==1){      pos++;      ans[pos]=1;     }     else{      while(ans[pos]!=arr[i]-1)       pos--;      ans[pos]=ans[pos]+1;     }     for(j=0;j<=pos;j++){      if(j<pos)       sb.append(ans[j]).append(".");      else       sb.append(ans[j]).append("\n");     }    }   }   System.out.println(sb);  } } class Node {  int setroot, dist;  public Node(int setroot, int dist){   this.setroot = setroot;   this.dist = dist;  }  @Override  public String toString() {   return String.format(setroot + ", " + dist);  } } class FastReader {  byte[] buf = new byte[2048];  int index, total;  InputStream in;  FastReader(InputStream is) {   in = is;  }  int scan() throws IOException {   if (index >= total) {    index = 0;    total = in.read(buf);    if (total <= 0) {     return -1;    }   }   return buf[index++];  }  String next() throws IOException {   int c;   for (c = scan(); c <= 32; c = scan()) ;   StringBuilder sb = new StringBuilder();   for (; c > 32; c = scan()) {    sb.append((char) c);   }   return sb.toString();  }  int nextInt() throws IOException {   int c, val = 0;   for (c = scan(); c <= 32; c = scan()) ;   boolean neg = c == '-';   if (c == '-' || c == '+') {    c = scan();   }   for (; c >= '0' && c <= '9'; c = scan()) {    val = (val << 3) + (val << 1) + (c & 15);   }   return neg ? -val : val;  }  long nextLong() throws IOException {   int c;   long val = 0;   for (c = scan(); c <= 32; c = scan()) ;   boolean neg = c == '-';   if (c == '-' || c == '+') {    c = scan();   }   for (; c >= '0' && c <= '9'; c = scan()) {    val = (val << 3) + (val << 1) + (c & 15);   }   return neg ? -val : val;  } }
5,public class Abra {  void solve() throws IOException {  int n = nextInt(), t = nextInt();  TreeMap<Integer, Integer> tm = new TreeMap<Integer, Integer>();  for (int i = 0; i < n; i++)   tm.put(nextInt(), nextInt());  double tx = -1e9;  int c = 2;  for (Map.Entry<Integer, Integer> m : tm.entrySet()) {   if (tx == -1e9) {   tx = m.getKey() + m.getValue() / 2.0 + t;   continue;   }   if (m.getKey() - m.getValue() / 2.0 >= tx) c++;   if (m.getKey() - m.getValue() / 2.0 > tx) c++;   tx = m.getKey() + m.getValue() / 2.0 + t;  }  out.print(c); }  public static void main(String[] args) throws IOException {  new Abra().run(); }  StreamTokenizer in; PrintWriter out; boolean oj; BufferedReader br;  void init() throws IOException {  oj = System.getProperty("ONLINE_JUDGE") != null;  Reader reader = oj ? new InputStreamReader(System.in) : new FileReader("input.txt");  Writer writer = oj ? new OutputStreamWriter(System.out) : new FileWriter("output.txt");  br = new BufferedReader(reader);  in = new StreamTokenizer(br);  out = new PrintWriter(writer); }  long beginTime;  void run() throws IOException {  beginTime = System.currentTimeMillis();  long beginMem = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();  init();  solve();  long endMem = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();  long endTime = System.currentTimeMillis();  if (!oj) {  System.out.println("Memory used = " + (endMem - beginMem));  System.out.println("Total memory = " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()));  System.out.println("Running time = " + (endTime - beginTime));  }  out.flush(); }  int nextInt() throws IOException {  in.nextToken();  return (int) in.nval; }  long nextLong() throws IOException {  in.nextToken();  return (long) in.nval; }  String nextString() throws IOException {  in.nextToken();  return in.sval; }  double nextDouble() throws IOException {  in.nextToken();  return in.nval; }  myLib lib = new myLib();  void time() {  System.out.print("It's ");  System.out.println(System.currentTimeMillis() - beginTime); }  static class myLib {  long fact(long x) {  long a = 1;  for (long i = 2; i <= x; i++) {   a *= i;  }  return a;  }  long digitSum(String x) {  long a = 0;  for (int i = 0; i < x.length(); i++) {   a += x.charAt(i) - '0';  }  return a;  }  long digitSum(long x) {  long a = 0;  while (x > 0) {   a += x % 10;   x /= 10;  }  return a;  }  long digitMul(long x) {  long a = 1;  while (x > 0) {   a *= x % 10;   x /= 10;  }  return a;  }  int digitCubesSum(int x) {  int a = 0;  while (x > 0) {   a += (x % 10) * (x % 10) * (x % 10);   x /= 10;  }  return a;  }  double pif(double ax, double ay, double bx, double by) {  return Math.sqrt((ax - bx) * (ax - bx) + (ay - by) * (ay - by));  }  double pif3D(double ax, double ay, double az, double bx, double by, double bz) {  return Math.sqrt((ax - bx) * (ax - bx) + (ay - by) * (ay - by) + (az - bz) * (az - bz));  }  double pif3D(double[] a, double[] b) {  return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]) + (a[2] - b[2]) * (a[2] - b[2]));  }  long gcd(long a, long b) {  if (a == 0 || b == 0) return 1;  if (a < b) {   long c = b;   b = a;   a = c;  }  while (a % b != 0) {   a = a % b;   if (a < b) {   long c = b;   b = a;   a = c;   }  }  return b;  }  int gcd(int a, int b) {  if (a == 0 || b == 0) return 1;  if (a < b) {   int c = b;   b = a;   a = c;  }  while (a % b != 0) {   a = a % b;   if (a < b) {   int c = b;   b = a;   a = c;   }  }  return b;  }  long lcm(long a, long b) {  return a * b / gcd(a, b);  }  int lcm(int a, int b) {  return a * b / gcd(a, b);  }  int countOccurences(String x, String y) {  int a = 0, i = 0;  while (true) {   i = y.indexOf(x);   if (i == -1) break;   a++;   y = y.substring(i + 1);  }  return a;  }  int[] findPrimes(int x) {  boolean[] forErato = new boolean[x - 1];  List<Integer> t = new Vector<Integer>();  int l = 0, j = 0;  for (int i = 2; i < x; i++) {   if (forErato[i - 2]) continue;   t.add(i);   l++;   j = i * 2;   while (j < x) {   forErato[j - 2] = true;   j += i;   }  }  int[] primes = new int[l];  Iterator<Integer> iterator = t.iterator();  for (int i = 0; iterator.hasNext(); i++) {   primes[i] = iterator.next().intValue();  }  return primes;  }  int rev(int x) {  int a = 0;  while (x > 0) {   a = a * 10 + x % 10;   x /= 10;  }  return a;  }  class myDate {  int d, m, y;   int[] ml = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };   public myDate(int da, int ma, int ya) {   d = da;   m = ma;   y = ya;   if ((ma > 12 || ma < 1 || da > ml[ma - 1] || da < 1) && !(d == 29 && m == 2 && y % 4 == 0)) {   d = 1;   m = 1;   y = 9999999;   }  }   void incYear(int x) {   for (int i = 0; i < x; i++) {   y++;   if (m == 2 && d == 29) {    m = 3;    d = 1;    return;   }   if (m == 3 && d == 1) {    if (((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0)) {    m = 2;    d = 29;    }    return;   }   }  }   boolean less(myDate x) {   if (y < x.y) return true;   if (y > x.y) return false;   if (m < x.m) return true;   if (m > x.m) return false;   if (d < x.d) return true;   if (d > x.d) return false;   return true;  }   void inc() {   if ((d == 31) && (m == 12)) {   y++;   d = 1;   m = 1;   } else {   if (((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0)) {    ml[1] = 29;   }   if (d == ml[m - 1]) {    m++;    d = 1;   } else    d++;   }  }  }  int partition(int n, int l, int m) {          if (n < l) return 0;  if (n < l + 2) return 1;  if (l == 1) return 1;  int c = 0;  for (int i = Math.min(n - l + 1, m); i >= (n + l - 1) / l; i--) {   c += partition(n - i, l - 1, i);  }  return c;  }  int rifmQuality(String a, String b) {  if (a.length() > b.length()) {   String c = a;   a = b;   b = c;  }  int c = 0, d = b.length() - a.length();  for (int i = a.length() - 1; i >= 0; i--) {   if (a.charAt(i) == b.charAt(i + d)) c++;   else   break;  }  return c;  }  String numSym = "0123456789ABCDEF";  String ZFromXToYNotation(int x, int y, String z) {  if (z.equals("0")) return "0";  String a = "";    BigInteger q = BigInteger.ZERO, t = BigInteger.ONE;  for (int i = z.length() - 1; i >= 0; i--) {   q = q.add(t.multiply(BigInteger.valueOf(z.charAt(i) - 48)));   t = t.multiply(BigInteger.valueOf(x));  }  while (q.compareTo(BigInteger.ZERO) == 1) {   a = numSym.charAt((int) (q.mod(BigInteger.valueOf(y)).intValue())) + a;   q = q.divide(BigInteger.valueOf(y));  }  return a;  }  double angleFromXY(int x, int y) {  if ((x == 0) && (y > 0)) return Math.PI / 2;  if ((x == 0) && (y < 0)) return -Math.PI / 2;  if ((y == 0) && (x > 0)) return 0;  if ((y == 0) && (x < 0)) return Math.PI;  if (x > 0) return Math.atan((double) y / x);  else {   if (y > 0) return Math.atan((double) y / x) + Math.PI;   else   return Math.atan((double) y / x) - Math.PI;  }  }  static boolean isNumber(String x) {  try {   Integer.parseInt(x);  } catch (NumberFormatException ex) {   return false;  }  return true;  }  static boolean stringContainsOf(String x, String c) {  for (int i = 0; i < x.length(); i++) {   if (c.indexOf(x.charAt(i)) == -1) return false;  }  return true;  }  long pow(long a, long n) {   if (n == 0) return 1;  long k = n, b = 1, c = a;  while (k != 0) {   if (k % 2 == 0) {   k /= 2;   c *= c;   } else {   k--;   b *= c;   }  }  return b;  }  int pow(int a, int n) {   if (n == 0) return 1;  int k = n, b = 1, c = a;  while (k != 0) {   if (k % 2 == 0) {   k /= 2;   c *= c;   } else {   k--;   b *= c;   }  }  return b;  }  double pow(double a, int n) {   if (n == 0) return 1;  double k = n, b = 1, c = a;  while (k != 0) {   if (k % 2 == 0) {   k /= 2;   c *= c;   } else {   k--;   b *= c;   }  }  return b;  }  double log2(double x) {  return Math.log(x) / Math.log(2);  }  int lpd(int[] primes, int x) {  int i;  for (i = 0; primes[i] <= x / 2; i++) {   if (x % primes[i] == 0) {   return primes[i];   }  }  ;  return x;  }  int np(int[] primes, int x) {  for (int i = 0; true; i++) {   if (primes[i] == x) return i;  }  }  int[] dijkstra(int[][] map, int n, int s) {  int[] p = new int[n];  boolean[] b = new boolean[n];  Arrays.fill(p, Integer.MAX_VALUE);  p[s] = 0;  b[s] = true;  for (int i = 0; i < n; i++) {   if (i != s) p[i] = map[s][i];  }  while (true) {   int m = Integer.MAX_VALUE, mi = -1;   for (int i = 0; i < n; i++) {   if (!b[i] && (p[i] < m)) {    mi = i;    m = p[i];   }   }   if (mi == -1) break;   b[mi] = true;   for (int i = 0; i < n; i++)   if (p[mi] + map[mi][i] < p[i]) p[i] = p[mi] + map[mi][i];  }  return p;  }  boolean isLatinChar(char x) {  if (((x >= 'a') && (x <= 'z')) || ((x >= 'A') && (x <= 'Z'))) return true;  else   return false;  }  boolean isBigLatinChar(char x) {  if (x >= 'A' && x <= 'Z') return true;  else   return false;  }  boolean isSmallLatinChar(char x) {  if (x >= 'a' && x <= 'z') return true;  else   return false;  }  boolean isDigitChar(char x) {  if (x >= '0' && x <= '9') return true;  else   return false;  }  class NotANumberException extends Exception {  private static final long serialVersionUID = 1L;  String mistake;   NotANumberException() {   mistake = "Unknown.";  }   NotANumberException(String message) {   mistake = message;  }  }  class Real {  String num = "0";  long exp = 0;  boolean pos = true;   long length() {   return num.length();  }   void check(String x) throws NotANumberException {   if (!stringContainsOf(x, "0123456789+-.eE")) throw new NotANumberException("Illegal character.");   long j = 0;   for (long i = 0; i < x.length(); i++) {   if ((x.charAt((int) i) == '-') || (x.charAt((int) i) == '+')) {    if (j == 0) j = 1;    else    if (j == 5) j = 6;    else     throw new NotANumberException("Unexpected sign.");   } else    if ("0123456789".indexOf(x.charAt((int) i)) != -1) {    if (j == 0) j = 2;    else     if (j == 1) j = 2;     else     if (j == 2)     ;     else      if (j == 3) j = 4;      else      if (j == 4)      ;      else       if (j == 5) j = 6;       else       if (j == 6)       ;       else        throw new NotANumberException("Unexpected digit.");    } else    if (x.charAt((int) i) == '.') {     if (j == 0) j = 3;     else     if (j == 1) j = 3;     else      if (j == 2) j = 3;      else      throw new NotANumberException("Unexpected dot.");    } else     if ((x.charAt((int) i) == 'e') || (x.charAt((int) i) == 'E')) {     if (j == 2) j = 5;     else      if (j == 4) j = 5;      else      throw new NotANumberException("Unexpected exponent.");     } else     throw new NotANumberException("O_o.");   }   if ((j == 0) || (j == 1) || (j == 3) || (j == 5)) throw new NotANumberException("Unexpected end.");  }   public Real(String x) throws NotANumberException {   check(x);   if (x.charAt(0) == '-') pos = false;   long j = 0;   String e = "";   boolean epos = true;   for (long i = 0; i < x.length(); i++) {   if ("0123456789".indexOf(x.charAt((int) i)) != -1) {    if (j == 0) num += x.charAt((int) i);    if (j == 1) {    num += x.charAt((int) i);    exp--;    }    if (j == 2) e += x.charAt((int) i);   }   if (x.charAt((int) i) == '.') {    if (j == 0) j = 1;   }   if ((x.charAt((int) i) == 'e') || (x.charAt((int) i) == 'E')) {    j = 2;    if (x.charAt((int) (i + 1)) == '-') epos = false;   }   }   while ((num.length() > 1) && (num.charAt(0) == '0'))   num = num.substring(1);   while ((num.length() > 1) && (num.charAt(num.length() - 1) == '0')) {   num = num.substring(0, num.length() - 1);   exp++;   }   if (num.equals("0")) {   exp = 0;   pos = true;   return;   }   while ((e.length() > 1) && (e.charAt(0) == '0'))   e = e.substring(1);   try {   if (e != "") if (epos) exp += Long.parseLong(e);   else    exp -= Long.parseLong(e);   } catch (NumberFormatException exc) {   if (!epos) {    num = "0";    exp = 0;    pos = true;   } else {    throw new NotANumberException("Too long exponent");   }   }  }   public Real() {  }   String toString(long mantissa) {   String a = "", b = "";   if (exp >= 0) {   a = num;   if (!pos) a = '-' + a;   for (long i = 0; i < exp; i++)    a += '0';   for (long i = 0; i < mantissa; i++)    b += '0';   if (mantissa == 0) return a;   else    return a + "." + b;   } else {   if (exp + length() <= 0) {    a = "0";    if (mantissa == 0) {    return a;    }    if (mantissa < -(exp + length() - 1)) {    for (long i = 0; i < mantissa; i++)     b += '0';    return a + "." + b;    } else {    if (!pos) a = '-' + a;    for (long i = 0; i < mantissa; i++)     if (i < -(exp + length())) b += '0';     else     if (i + exp >= 0) b += '0';     else      b += num.charAt((int) (i + exp + length()));    return a + "." + b;    }   } else {    if (!pos) a = "-";    for (long i = 0; i < exp + length(); i++)    a += num.charAt((int) i);    if (mantissa == 0) return a;    for (long i = exp + length(); i < exp + length() + mantissa; i++)    if (i < length()) b += num.charAt((int) i);    else     b += '0';    return a + "." + b;   }   }  }  }  boolean containsRepeats(int... num) {  Set<Integer> s = new TreeSet<Integer>();  for (int d : num)   if (!s.contains(d)) s.add(d);   else   return true;  return false;  }  int[] rotateDice(int[] a, int n) {  int[] c = new int[6];  if (n == 0) {   c[0] = a[1];   c[1] = a[5];   c[2] = a[2];   c[3] = a[0];   c[4] = a[4];   c[5] = a[3];  }  if (n == 1) {   c[0] = a[2];   c[1] = a[1];   c[2] = a[5];   c[3] = a[3];   c[4] = a[0];   c[5] = a[4];  }  if (n == 2) {   c[0] = a[3];   c[1] = a[0];   c[2] = a[2];   c[3] = a[5];   c[4] = a[4];   c[5] = a[1];  }  if (n == 3) {   c[0] = a[4];   c[1] = a[1];   c[2] = a[0];   c[3] = a[3];   c[4] = a[5];   c[5] = a[2];  }  if (n == 4) {   c[0] = a[0];   c[1] = a[2];   c[2] = a[3];   c[3] = a[4];   c[4] = a[1];   c[5] = a[5];  }  if (n == 5) {   c[0] = a[0];   c[1] = a[4];   c[2] = a[1];   c[3] = a[2];   c[4] = a[3];   c[5] = a[5];  }  return c;  }  int min(int... a) {  int c = Integer.MAX_VALUE;  for (int d : a)   if (d < c) c = d;  return c;  }  int max(int... a) {  int c = Integer.MIN_VALUE;  for (int d : a)   if (d > c) c = d;  return c;  }  int pos(int x) {  if (x > 0) return x;  else   return 0;  }  long pos(long x) {  if (x > 0) return x;  else   return 0;  }  double maxD(double... a) {  double c = Double.MIN_VALUE;  for (double d : a)   if (d > c) c = d;  return c;  }  double minD(double... a) {  double c = Double.MAX_VALUE;  for (double d : a)   if (d < c) c = d;  return c;  }  int[] normalizeDice(int[] a) {  int[] c = a.clone();  if (c[0] != 0) if (c[1] == 0) c = rotateDice(c, 0);  else   if (c[2] == 0) c = rotateDice(c, 1);   else   if (c[3] == 0) c = rotateDice(c, 2);   else    if (c[4] == 0) c = rotateDice(c, 3);    else    if (c[5] == 0) c = rotateDice(rotateDice(c, 0), 0);  while (c[1] != min(c[1], c[2], c[3], c[4]))   c = rotateDice(c, 4);  return c;  }  boolean sameDice(int[] a, int[] b) {  for (int i = 0; i < 6; i++)   if (a[i] != b[i]) return false;  return true;  }  final double goldenRatio = (1 + Math.sqrt(5)) / 2;  final double aGoldenRatio = (1 - Math.sqrt(5)) / 2;  long Fib(int n) {  if (n < 0) if (n % 2 == 0) return -Math.round((pow(goldenRatio, -n) - pow(aGoldenRatio, -n)) / Math.sqrt(5));  else   return -Math.round((pow(goldenRatio, -n) - pow(aGoldenRatio, -n)) / Math.sqrt(5));  return Math.round((pow(goldenRatio, n) - pow(aGoldenRatio, n)) / Math.sqrt(5));  }  class japaneeseComparator implements Comparator<String> {  @Override  public int compare(String a, String b) {   int ai = 0, bi = 0;   boolean m = false, ns = false;   if (a.charAt(ai) <= '9' && a.charAt(ai) >= '0') {   if (b.charAt(bi) <= '9' && b.charAt(bi) >= '0') m = true;   else    return -1;   }   if (b.charAt(bi) <= '9' && b.charAt(bi) >= '0') {   if (a.charAt(ai) <= '9' && a.charAt(ai) >= '0') m = true;   else    return 1;   }   a += "!";   b += "!";   int na = 0, nb = 0;   while (true) {   if (a.charAt(ai) == '!') {    if (b.charAt(bi) == '!') break;    return -1;   }   if (b.charAt(bi) == '!') {    return 1;   }   if (m) {    int ab = -1, bb = -1;    while (a.charAt(ai) <= '9' && a.charAt(ai) >= '0') {    if (ab == -1) ab = ai;    ai++;    }    while (b.charAt(bi) <= '9' && b.charAt(bi) >= '0') {    if (bb == -1) bb = bi;    bi++;    }    m = !m;    if (ab == -1) {    if (bb == -1) continue;    else     return 1;    }    if (bb == -1) return -1;    while (a.charAt(ab) == '0' && ab + 1 != ai) {    ab++;    if (!ns) na++;    }    while (b.charAt(bb) == '0' && bb + 1 != bi) {    bb++;    if (!ns) nb++;    }    if (na != nb) ns = true;    if (ai - ab < bi - bb) return -1;    if (ai - ab > bi - bb) return 1;    for (int i = 0; i < ai - ab; i++) {    if (a.charAt(ab + i) < b.charAt(bb + i)) return -1;    if (a.charAt(ab + i) > b.charAt(bb + i)) return 1;    }   } else {    m = !m;    while (true) {    if (a.charAt(ai) <= 'z' && a.charAt(ai) >= 'a' && b.charAt(bi) <= 'z' && b.charAt(bi) >= 'a') {     if (a.charAt(ai) < b.charAt(bi)) return -1;     if (a.charAt(ai) > b.charAt(bi)) return 1;     ai++;     bi++;    } else     if (a.charAt(ai) <= 'z' && a.charAt(ai) >= 'a') return 1;     else     if (b.charAt(bi) <= 'z' && b.charAt(bi) >= 'a') return -1;     else      break;    }   }   }   if (na < nb) return 1;   if (na > nb) return -1;   return 0;  }  }  Random random = new Random(); }  void readIntArray(int[] a) throws IOException {  for (int i = 0; i < a.length; i++)  a[i] = nextInt(); }  String readChars(int l) throws IOException {  String r = "";  for (int i = 0; i < l; i++)  r += (char) br.read();  return r; }  class myFraction {  long num = 0, den = 1;  void reduce() {  long d = lib.gcd(num, den);  num /= d;  den /= d;  }  myFraction(long ch, long zn) {  num = ch;  den = zn;  reduce();  }  myFraction add(myFraction t) {  long nd = lib.lcm(den, t.den);  myFraction r = new myFraction(nd / den * num + nd / t.den * t.num, nd);  r.reduce();  return r;  }  public String toString() {  return num + "/" + den;  } }  class myPoint {  myPoint(int a, int b) {  x = a;  y = b;  }  int x, y;  boolean equals(myPoint a) {  if (x == a.x && y == a.y) return true;  else   return false;  }  public String toString() {  return x + ":" + y;  } }   }
4,public class A {  public void run() {   Scanner sc = new Scanner(System.in);   String s = sc.next();   int n = s.length();   String[] ss = new String[n];   for (int i = 0; i < n; i++)    ss[i] = s.substring(i);   sort(ss);   int res = 0;   for (int i = 1; i < n; i++)    res = max(res, count(ss[i - 1], ss[i]));   System.out.println(res);  }  int count(String s, String t) {   int ret = 0;   for (int i = 0; i < min(s.length(), t.length()); i++)    if (s.charAt(i) != t.charAt(i))     return ret;    else     ret++;   return ret;  }  void debug(Object... os) {   System.err.println(Arrays.deepToString(os));  }  public static void main(String... args) {   new A().run();  } }
0,public class Main {  StreamTokenizer in;  BufferedReader inb;  PrintWriter out;  public static void main(String[] args) throws Exception {   new Main().run();  }  public void run() throws Exception {   in = new StreamTokenizer(new BufferedReader(new InputStreamReader(     System.in)));   inb = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(new OutputStreamWriter(System.out));   solve();   out.flush();  }  public int nextInt() throws Exception {   in.nextToken();   return (int) in.nval;  }  public int parseInt() throws Exception {   return Integer.parseInt(inb.readLine());  }  public String nextLine() throws Exception {   return inb.readLine();  }    public void solve() throws Exception {   int n = nextInt();   if ((n%4==0)||(n%44==0)||(n%47==0)||(n%74==0)     ||(n%744==0)||(n%747==0)||(n%774==0)||(n%777==0)     ||(n%7==0)||(n%444==0)||(n%447==0)||(n%474==0)||(n%477==0)||(n%77==0))   {    out.print("YES");   }   else   {    out.print("NO");   }  } }
1,public class Main {  public static void main(String[] args) throws IOException {  try {  if (new File("input.txt").exists())   System.setIn(new FileInputStream("input.txt"));  } catch (SecurityException e) {  }  new Main().run(); }  BufferedReader in; PrintWriter out; StringTokenizer st = new StringTokenizer("");  int MAXDEG = 5;  void gen() throws FileNotFoundException {  PrintWriter out = new PrintWriter("input.txt");  int n = 100000;  Random rnd = new Random();  out.println(n);  for (int i = 0; i < n; i++) {  out.println("R" + (rnd.nextInt(1000000) + 1) + "C" + (rnd.nextInt(1000000) + 1));  }  out.close(); }  void gen2() throws FileNotFoundException {  PrintWriter out = new PrintWriter("input.txt");  int n = 100000;  Random rnd = new Random();  out.println(n);  for (int i = 0; i < n; i++) {  int len = rnd.nextInt(MAXDEG) + 1;  String pref = "";  for (int j = 0; j < len; j++)   pref += (char) (rnd.nextInt(26) + 'A');  out.println(pref + (rnd.nextInt(1000000) + 1));  }  out.close(); }  private void run() throws IOException {   in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);  int n = nextInt();  int[] sumDegs = new int[MAXDEG + 1];  sumDegs[0] = 1;  int deg = 1;  for (int i = 1; i <= MAXDEG; i++) {  deg *= 26;  sumDegs[i] = sumDegs[i - 1] + deg;  }  for (int i = 0; i < n; i++) {  String s = nextLine();  String pref = "";  int endPos = -1;  for (int j = 0; j < s.length(); j++) {   if (!isLet(s.charAt(j))) {   endPos = j;   break;   }   pref += s.charAt(j);  }  int num = -1;  try {   num = Integer.parseInt(s.substring(endPos));  } catch (Exception e) {  }  if (num != -1) {   int col = sumDegs[pref.length() - 1];   int val = 0;   for (int j = 0; j < pref.length(); j++) {   val = val * 26 + (pref.charAt(j) - 'A');   }   col += val;   out.println("R" + num + "C" + col);  } else {   int row = Integer.parseInt(s.substring(1, s.indexOf('C')));   int col = Integer.parseInt(s.substring(s.indexOf('C') + 1));   int len = MAXDEG;   while (col < sumDegs[len])   len--;   len++;   col -= sumDegs[len - 1];   String res = "";   while (col > 0) {   res = (char) (col % 26 + 'A') + res;   col /= 26;   }   while (res.length() < len)   res = "A" + res;   out.println(res + row);  }  }  in.close();  out.close(); }  private boolean isLet(char c) {  return c >= 'A' && c <= 'Z'; }  void chk(boolean b) {  if (b)  return;  System.out.println(new Error().getStackTrace()[1]);  exit(999); } void deb(String fmt, Object... args) {  System.out.printf(Locale.US, fmt + "%n", args); } String nextToken() throws IOException {  while (!st.hasMoreTokens())  st = new StringTokenizer(in.readLine());  return st.nextToken(); } int nextInt() throws IOException {  return Integer.parseInt(nextToken()); } long nextLong() throws IOException {  return Long.parseLong(nextToken()); } double nextDouble() throws IOException {  return Double.parseDouble(nextToken()); } String nextLine() throws IOException {  st = new StringTokenizer("");  return in.readLine(); } boolean EOF() throws IOException {  while (!st.hasMoreTokens()) {  String s = in.readLine();  if (s == null)   return true;  st = new StringTokenizer(s);  }  return false; } }
6,public class F531 {  public static void main(String[] args) {   MyScanner sc = new MyScanner();   PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));   int n = sc.nextInt(); int m = sc.nextInt();   long [][] mn1 = new long[n][n];   long [][] mn2 = new long[n][n];   long [][] grid = new long[n][m];   for (int i = 0; i < n; i++) {    for (int j = 0; j < m; j++) grid[i][j] = sc.nextInt();   }   if (n == 1) {    long ans = Integer.MAX_VALUE;    for (int i = 0; i < m - 1; i++) ans = Math.min(ans, Math.abs(grid[0][i] - grid[0][i + 1]));    out.println(ans);    out.close();    return;   }   for (int i = 0; i < n; i++) {    for (int j = 0; j < n; j++) {     if (i == j) continue;     long min = Long.MAX_VALUE;     for (int k = 0; k < m; k++) min = Math.min(min, Math.abs(grid[i][k] - grid[j][k]));     mn1[i][j] = min;    }   }   for (int i = 0; i < n; i++) {    for (int j = 0; j < n; j++) {     if (i == j) continue;     long min = Long.MAX_VALUE;     for (int k = 0; k < m - 1; k++) min = Math.min(min, Math.abs(grid[i][k] - grid[j][k + 1]));     mn2[i][j] = min;    }   }   long [][] dp = new long[1 << n][n];      long ans = 0;   for (int i = 0; i < n; i++) {    for (long [] a: dp) Arrays.fill(a, -1);    for (int j = 0; j < n; j++) {     if (j == i) dp[1 << j][j] = Long.MAX_VALUE;     else dp[1 << j][j] = 0;    }    for (int mask = 1; mask < (1 << n); mask++) {     for (int last = 0; last < n; last++) {      if (dp[mask][last] != -1) continue;      for (int prev = 0; prev < n; prev++) {       if (prev == last) continue;       if (((mask >> prev) & 1) == 1) {        dp[mask][last] = Math.max(dp[mask][last], Math.min(mn1[prev][last], dp[mask ^ (1 << last)][prev]));       }      }     }    }       for (int j = 0; j < n; j++) {         long end = mn2[j][i];     ans = Math.max(ans, Math.min(dp[(1 << n) - 1][j], end));    }   }   out.println(ans);   out.close();  }    public static class MyScanner {   BufferedReader br;   StringTokenizer st;   public MyScanner() {    br = new BufferedReader(new InputStreamReader(System.in));   }   String next() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }   int nextInt() {    return Integer.parseInt(next());   }   long nextLong() {    return Long.parseLong(next());   }   double nextDouble() {    return Double.parseDouble(next());   }   String nextLine() {    String str = "";    try {     str = br.readLine();    } catch (IOException e) {     e.printStackTrace();    }    return str;   }   } }
6,public class Solution { private BufferedReader in; private PrintWriter out; private StringTokenizer st; private Random rnd;  int[] levels; int[] loyal; int n, k; double A;  int[] choices; int[] new_loyal; double[] koef;  double ans = 0.0; int total;  void rec(int step, int start) {  if(step == k) {  for(int i = 0; i < n; i++) {   new_loyal[i] = loyal[i];  }  for(int i = 0; i < k; i++) {   new_loyal[choices[i]] = Math.min(100, new_loyal[choices[i]] + 10);  }    int full = 0;   for(int i = 0; i < n; i++) {   if(new_loyal[i] == 100) {   ++full;   }  }    if(full > (n / 2)) {   ans = 1.0;   return;  }    for(int i = 0; i < n; i++) {   koef[i] = (double) new_loyal[i] / 100.0;  }     int bits_needed = (n / 2) + 1;    double total_win = 0.0;  double total_fights = 0.0;    for(int mask = 0; mask < total; mask++) {   int bits = 0;     double win = 1.0;   double loose = 1.0;   double b = 0.0;     for(int bit = 0; bit < n; bit++) {   if((mask & (1 << bit)) != 0) {    ++bits;    win *= koef[bit];   } else {    loose *= (1.0 - koef[bit]);    b += levels[bit];   }     }     double prob = win * loose;     if(bits >= bits_needed) {   total_win += prob;   } else {   total_fights += prob * (A / (A + b));   }  }     ans = Math.max(ans, total_win + total_fights);  } else {  for(int i = start; i < n; i++) {   choices[step] = i;   rec(step + 1, i);  }  } }  public void solve() throws IOException {  n = nextInt();  k = nextInt();  A = nextInt();   levels = new int[n];  loyal = new int[n];  new_loyal = new int[n];  choices = new int[k];  koef = new double[n];   for(int i = 0; i < n; i++) {  levels[i] = nextInt();  loyal[i] = nextInt();  }   total = 1 << n;   rec(0, 0);   out.println(ans); }   public static void main(String[] args) {  new Solution().run(); }  public void run() {  try {  in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);  st = null;  rnd = new Random();    solve();    out.close();  } catch(IOException e) {  e.printStackTrace();  } }  private String nextToken() throws IOException, NullPointerException {  while(st == null || !st.hasMoreTokens()) {  st = new StringTokenizer(in.readLine());  }   return st.nextToken(); }  private int nextInt() throws IOException {  return Integer.parseInt(nextToken()); }  private long nextLong() throws IOException {  return Long.parseLong(nextToken()); }  private double nextDouble() throws IOException {  return Double.parseDouble(nextToken()); } }
6,public class Main implements Runnable {  static class InputReader {   private InputStream stream;   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   private SpaceCharFilter filter;   private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));   public InputReader(InputStream stream) {    this.stream = stream;   }   public int read() {    if (numChars==-1)     throw new InputMismatchException();    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     }     catch (IOException e) {      throw new InputMismatchException();     }     if(numChars <= 0)      return -1;    }    return buf[curChar++];   }   public String nextLine() {    String str = "";    try {     str = br.readLine();    }    catch (IOException e) {     e.printStackTrace();    }    return str;   }   public int nextInt() {    int c = read();    while(isSpaceChar(c))     c = read();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if(c<'0'||c>'9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    }    while (!isSpaceChar(c));    return res * sgn;   }   public long nextLong() {    int c = read();    while (isSpaceChar(c))     c = read();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    long res = 0;    do {     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    }    while (!isSpaceChar(c));    return res * sgn;   }   public double nextDouble() {    int c = read();    while (isSpaceChar(c))     c = read();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    double res = 0;    while (!isSpaceChar(c) && c != '.') {     if (c == 'e' || c == 'E')      return res * Math.pow(10, nextInt());     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    }    if (c == '.') {     c = read();     double m = 1;     while (!isSpaceChar(c)) {      if (c == 'e' || c == 'E')       return res * Math.pow(10, nextInt());      if (c < '0' || c > '9')       throw new InputMismatchException();      m /= 10;      res += (c - '0') * m;      c = read();     }    }    return res * sgn;   }   public String readString() {    int c = read();    while (isSpaceChar(c))     c = read();    StringBuilder res = new StringBuilder();    do {     res.appendCodePoint(c);     c = read();    }    while (!isSpaceChar(c));    return res.toString();   }   public boolean isSpaceChar(int c) {    if (filter != null)     return filter.isSpaceChar(c);    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   public String next() {    return readString();   }   public interface SpaceCharFilter {    public boolean isSpaceChar(int ch);   }  }  public static void main(String args[]) throws Exception {   new Thread(null, new Main(),"Main",1<<26).start();  }  static long gcd(long a,long b){ if(b==0)return a;return gcd(b,a%b); }  static long modPow(long a,long p,long m){ if(a==1)return 1;long ans=1;while (p>0){ if(p%2==1)ans=(ans*a)%m;a=(a*a)%m;p>>=1; }return ans; }  static long modInv(long a,long m){return modPow(a,m-2,m);}  static long sol_x,sol_y,gcd_a_b;  static void extendedEuclid(long a,long b){ if(b==0){gcd_a_b=a;sol_x=1;sol_y=0; } else{ extendedEuclid(b,a%b);long temp = sol_x;sol_x=sol_y;sol_y = temp - (a/b)*sol_y; } }  static class Bhavansort{ Random random;Bhavansort(int a[]){ randomArray(a); sort(a);}Bhavansort(long a[]){ randomArray(a); sort(a);}static int[] sort(int a[]){ Arrays.sort(a);return a;}static long[] sort(long a[]){ Arrays.sort(a);return a; }void randomArray(long a[]){ int n=a.length;for(int i=0;i<n;i++){ int p=random.nextInt(n)%n;long tm=a[i];a[i]=a[p];a[p]=tm; } }void randomArray(int a[]){ int n=a.length;for(int i=0;i<n;i++){ int p=random.nextInt(n)%n;int tm=a[i];a[i]=a[p];a[p]=tm; } }}   public void run() {   InputReader sc = new InputReader(System.in);   PrintWriter out = new PrintWriter(System.out);   int n=sc.nextInt();   int m=sc.nextInt();   int a[][]=new int[n][m];   for (int i = 0; i <n ; i++) {    for (int j = 0; j <m ; j++) {     a[i][j]=sc.nextInt();    }   }   int cost[][]=new int[n][n];   for (int i = 0; i < n; i++) {    for (int j = 0; j <n ; j++) {     cost[i][j]=Integer.MAX_VALUE;     for (int k = 0; k <m ; k++) {      cost[i][j]=Math.min(cost[i][j],Math.abs(a[i][k]-a[j][k]));     }    }   }   int costRight[][]=new int[n][n];   for (int i = 0; i <n ; i++) {    for (int j = 0; j <n ; j++) {     costRight[i][j]=Integer.MAX_VALUE;     for (int k = 0; k <m-1 ; k++) {      costRight[i][j]=Math.min(Math.abs(a[i][k+1]-a[j][k]),costRight[i][j]);     }    }   }      if(n==1){    int ans=Integer.MAX_VALUE;    for (int i = 0; i <m-1 ; i++) {     ans=Math.min(ans,Math.abs(a[0][i]-a[0][i+1]));    }    out.println(ans);    out.close();    return;   }   Long dp[][][]=new Long[n+1][n+1][1<<n];   long max=0;   for (int i = 0; i <n ; i++) {       max=Math.max(max,f(i,i,1<<i,dp,n,cost,costRight));   }   out.println(max);   out.close();  }  long f(int start,int end,int mask,Long dp[][][],int n,int cost[][],int costRight[][]){   if(dp[start][end][mask]!=null)return dp[start][end][mask];   long ans=Integer.MIN_VALUE;   for (int i = 0; i <n ; i++) {    if((mask&(1<<i))==0){     int newMask=mask|(1<<i);     if((1<<n)-1!=(mask|(1<<i))){      ans = Math.max(ans, Math.min(cost[end][i], f(start, i, newMask, dp, n, cost, costRight)));     }     else{      ans=Math.max(ans,Math.min(cost[end][i],costRight[start][i]));     }    }   }   return dp[start][end][mask]=ans;  } }
4,@SuppressWarnings("unchecked") public class P35C {  final static int SHIFT = 11; final static int MASK = (1 << SHIFT) - 1; final static int [] DX = {-1, 1, 0, 0}; final static int [] DY = { 0, 0, -1, 1};  public void run() throws Exception {  int m = nextInt();  int n = nextInt();  boolean [][] burned = new boolean [n][m];  List<Integer> burn = new ArrayList();  for (int k = nextInt(); k > 0; k--) {  int x = nextInt() - 1;  int y = nextInt() - 1;  burned[y][x] = true;  burn.add((x << SHIFT) | y);  }  int lastXY = 0;  List<Integer> newBurn = null;  do {  lastXY = burn.get(0);  newBurn = new ArrayList();   for (int xy : burn) {   int x = xy >> SHIFT;   int y = xy & MASK;   for (int i = 0; i < 4; i++) {   int nx = x + DX[i];   int ny = y + DY[i];    if ((ny >= 0) && (ny < n) && (nx >= 0) && (nx < m) && (!burned[ny][nx])) {    burned[ny][nx] = true;    newBurn.add((nx << SHIFT) | ny);   }   }  }   burn = newBurn;  } while (newBurn.size() > 0);  println(((lastXY >> SHIFT) + 1) + " " + ((lastXY & MASK) + 1)); }  public static void main(String... args) throws Exception {  br = new BufferedReader(new InputStreamReader(new FileInputStream("input.txt")));  pw = new PrintWriter(new BufferedOutputStream(new FileOutputStream("output.txt")));  new P35C().run();  br.close();  pw.close();  System.err.println("\n[Time : " + (System.currentTimeMillis() - startTime) + " ms]"); }  static long startTime = System.currentTimeMillis(); static BufferedReader br; static PrintWriter pw; StringTokenizer stok;  String nextToken() throws IOException {  while (stok == null || !stok.hasMoreTokens()) {  String s = br.readLine();  if (s == null) { return null; }  stok = new StringTokenizer(s);  }  return stok.nextToken(); }  void print(byte b) { print("" + b); } void print(int i) { print("" + i); } void print(long l) { print("" + l); } void print(double d) { print("" + d); } void print(char c) { print("" + c); } void print(Object o) {  if (o instanceof int[]) { print(Arrays.toString((int [])o));  } else if (o instanceof long[]) { print(Arrays.toString((long [])o));  } else if (o instanceof char[]) { print(Arrays.toString((char [])o));  } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));  } else if (o instanceof short[]) { print(Arrays.toString((short [])o));  } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));  } else if (o instanceof float[]) { print(Arrays.toString((float [])o));  } else if (o instanceof double[]) { print(Arrays.toString((double [])o));  } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));  } else { print("" + o); } } void print(String s) { pw.print(s); } void println() { println(""); } void println(byte b) { println("" + b); } void println(int i) { println("" + i); } void println(long l) { println("" + l); } void println(double d) { println("" + d); } void println(char c) { println("" + c); } void println(Object o) { print(o); println(); } void println(String s) { pw.println(s); } int nextInt() throws IOException { return Integer.parseInt(nextToken()); } long nextLong() throws IOException { return Long.parseLong(nextToken()); } double nextDouble() throws IOException { return Double.parseDouble(nextToken()); } char nextChar() throws IOException { return (char) (br.read()); } String next() throws IOException { return nextToken(); } String nextLine() throws IOException { return br.readLine(); } int [] readInt(int size) throws IOException {  int [] array = new int [size];  for (int i = 0; i < size; i++) { array[i] = nextInt(); }  return array; } long [] readLong(int size) throws IOException {  long [] array = new long [size];  for (int i = 0; i < size; i++) { array[i] = nextLong(); }  return array; } double [] readDouble(int size) throws IOException {  double [] array = new double [size];  for (int i = 0; i < size; i++) { array[i] = nextDouble(); }  return array; } String [] readLines(int size) throws IOException {  String [] array = new String [size];  for (int i = 0; i < size; i++) { array[i] = nextLine(); }  return array; } }
6,public class D {  public static long [][]dp;  public static boolean [][]map;  public static void main(String[] args) {   Scanner in = new Scanner();   PrintWriter out = new PrintWriter(System.out);       int n = in.nextInt();   int m = in.nextInt();   dp = new long[n][1 << n + 1] ;   map = new boolean[n][n];   for (int i = 0; i < m; i++) {    int a = in.nextInt() - 1;    int b = in.nextInt() - 1;    map[a][b] = true;    map[b][a] = true;      }   for(long []temp : dp){    Arrays.fill(temp, -1);   }   long result = 0;   for(int i = 0; i < n; i++){    result += cal((1<<i),i,i,1);   }   out.println((result/2));   out.close();  }  public static long cal(int mask, int from, int to, int len){   if(dp[to][mask]!= -1){    return dp[to][mask];   }   long result = 0;   if(len > 2 && map[from][to]){    result++;   }   for(int i = from+1; i< map.length; i++){    if(map[to][i] && (mask & (1<<i)) == 0){     result += cal(mask|(1<<i), from,i,len + 1);    }   }   dp[to][mask] = result;   return result;    }    public static class FT {   int[] data;   FT(int n) {    data = new int[n];   }   public void update(int index, int value) {    while (index < data.length) {     data[index] += value;     index += (index & (-index));    }   }   public int get(int index) {    int result = 0;    while (index > 0) {     result += data[index];     index -= (index & (-index));    }    return result;   }  }  public static long gcd(long a, long b) {   if (b == 0) {    return a;   }   return gcd(b, a % b);  }  public static long pow(long a, long b) {   if (b == 0) {    return 1;   }   if (b == 1) {    return a;   }   long val = pow(a, b / 2);   if (b % 2 == 0) {    return val * val ;   } else {    return val * (val * a) ;   }  }  static class Scanner {   BufferedReader br;   StringTokenizer st;   public Scanner() {       br = new BufferedReader(new InputStreamReader(System.in));   }   public String next() {    while (st == null || !st.hasMoreTokens()) {     try {      st = new StringTokenizer(br.readLine());     } catch (Exception e) {      throw new RuntimeException();     }    }    return st.nextToken();   }   public long nextLong() {    return Long.parseLong(next());   }   public int nextInt() {    return Integer.parseInt(next());   }   public double nextDouble() {    return Double.parseDouble(next());   }   public String nextLine() {    st = null;    try {     return br.readLine();    } catch (Exception e) {     throw new RuntimeException();    }   }   public boolean endLine() {    try {     String next = br.readLine();     while (next != null && next.trim().isEmpty()) {      next = br.readLine();     }     if (next == null) {      return true;     }     st = new StringTokenizer(next);     return st.hasMoreTokens();    } catch (Exception e) {     throw new RuntimeException();    }   }  } }
5,public class Main implements Runnable {  class Home implements Comparable<Home> {   @Override   public int compareTo(Home arg0) {    return st - arg0.st;   }   int st, end;    }   public void solve() throws IOException {   int n = nextInt(), t = nextInt() * 2;   Home[] h = new Home[n];   for(int i = 0; i < n; ++i) {    int x = nextInt() * 2, a = nextInt() * 2;    h[i] = new Home();    h[i].st = x - a / 2;    h[i].end = x + a / 2;      }      Arrays.sort(h);   int ans = 2;   for(int i = 0; i + 1 < n; ++i) {    int delta = h[i + 1].st - h[i].end;    if (delta == t)     ans++;    if (delta > t)     ans += 2;   }   pw.println(ans);  }   static final String filename = "A";  static final boolean fromConsole = true;  public void run() {   try {    if (!fromConsole) {     in = new BufferedReader(new FileReader(filename + ".in"));     pw = new PrintWriter(filename + ".out");    } else {     in = new BufferedReader(new InputStreamReader(System.in));     pw = new PrintWriter(System.out);    }    st = new StringTokenizer("");    long st = System.currentTimeMillis();    solve();          pw.close();   } catch (Exception e) {    e.printStackTrace();    System.exit(-1);   }  }   private StringTokenizer st;  private BufferedReader in;  private PrintWriter pw;    boolean hasNext() throws IOException {   while (!st.hasMoreTokens()) {    String line = in.readLine();    if (line == null) {     return false;    }    st = new StringTokenizer(line);   }   return st.hasMoreTokens();  }   String next() throws IOException {   return hasNext() ? st.nextToken() : null;  }   int nextInt() throws IOException {   return Integer.parseInt(next());  }   BigInteger nextBigInteger() throws IOException {   return new BigInteger(next());  }   long nextLong() throws IOException {   return Long.parseLong(next());  }   double nextDouble() throws IOException {   return Double.parseDouble(next());  }   public static void main(String[] args) {   new Thread(new Main()).start();  }  }
2,public class C{ public static void main (String[] args) throws java.lang.Exception{  Scanner scan=new Scanner(System.in);  long x=scan.nextLong(), k=scan.nextLong();  long MOD = 1000000007;  if(x==0){  System.out.println("0");  return;  }  x %= MOD;  long ans= (((new myC()).fastPow(2L, k+1)*x)%MOD - (new myC()).fastPow(2L, k) + MOD + 1)% MOD;  ans %= MOD;  System.out.println(ans); } } class myC{ long MOD = 1000000007; long fastPow(long x, long k){  long bb=x%MOD, ans=1;  while(k > 0){  if((k&1)==1){   ans=(ans*bb)%MOD;  }  bb=(bb*bb)%MOD;  k>>=1;  }  return ans; } }
0,public class Main { static int mod = 1000000007; static int size = 200000; static long[] fac = new long[size]; static long[] finv = new long[size]; static long[] inv = new long[size]; static int INF = Integer.MAX_VALUE;  public static void main(String[] args){  Scanner scanner = new Scanner(System.in);  String[] s = new String[2];  for(int i = 0; i < 2; i++){  s[i] = scanner.next();  }  int n = s[0].length();  char[][] c = new char[2][n];  for(int i = 0; i < 2; i++){  for(int j = 0; j < n; j++){   c[i][j] = s[i].charAt(j);  }  }  int count = 0;  for(int i = 0; i < n-1; i++){  if(c[0][i] == '0' && c[1][i] == '0' && c[0][i+1] == '0'){   c[0][i] = 'X';   c[1][i] = 'X';   c[0][i+1] = 'X';   count++;  }  if(c[0][i] == '0' && c[1][i] == '0' && c[1][i+1] == '0'){   c[0][i] = 'X';   c[1][i] = 'X';   c[1][i+1] = 'X';   count++;  }  if(c[0][i] == '0' && c[0][i+1] == '0' && c[1][i+1] == '0'){   c[0][i] = 'X';   c[0][i+1] = 'X';   c[1][i+1] = 'X';   count++;  }  if(c[0][i+1] == '0' && c[1][i+1] == '0' && c[1][i] == '0'){   c[1][i] = 'X';   c[0][i+1] = 'X';   c[1][i+1] = 'X';   count++;  }  }  System.out.println(count); } public static boolean isPrime(int n){  if(n == 1) return false;  if(n == 2 || n == 3) return true;  for(int i = 2; i <= Math.sqrt(n); i++){  if(n % i == 0) return false;  }  return true; }  static boolean compare(String tar, String src) {  if (src == null) return true;  if (src.length() == tar.length()) {  int len = tar.length();  for (int i = 0; i < len; i++) {   if (src.charAt(i) > tar.charAt(i)) {   return false;   } else if (src.charAt(i) < tar.charAt(i)) {   return true;   }  }  return tar.compareTo(src) > 0 ? true : false;  } else if (src.length() < tar.length()) {  return true;  } else if (src.length() > tar.length()) {  return false;  }  return false; } public static class Edge{  int to;  Edge(int to){  this.to = to;  } } public static void swap(long a, long b){  long tmp = 0;  if(a > b){  tmp = a;  a = b;  b = tmp;  } } static class Pair implements Comparable<Pair>{  int first, second;  Pair(int a, int b){   first = a;   second = b;  }  @Override  public boolean equals(Object o){   if (this == o) return true;   if (!(o instanceof Pair)) return false;   Pair p = (Pair) o;   return first == p.first && second == p.second;  }  @Override  public int compareTo(Pair p){   return first == p.first ? second - p.second : first - p.first;          } }   public static long pow(long x, long n){  long ans = 1;  while(n > 0){  if((n & 1) == 1){   ans = ans * x;   ans %= mod;  }  x = x * x % mod;  n >>= 1;  }  return ans; }  public static long div(long x, long y){  return (x*pow(y, mod-2))%mod; }   public static void initComb(){  fac[0] = finv[0] = inv[0] = fac[1] = finv[1] = inv[1] = 1;  for (int i = 2; i < size; ++i) {  fac[i] = fac[i - 1] * i % mod;  inv[i] = mod - (mod / i) * inv[(int) (mod % i)] % mod;  finv[i] = finv[i - 1] * inv[i] % mod;  } }   public static long comb(int n, int k){  return fac[n] * finv[k] % mod * finv[n - k] % mod; }   public static long fact(int n){  return fac[n]; }   public static long finv(int n){  return finv[n]; }  static class UnionFind {  int[] parent;  public UnionFind(int size) {  parent = new int[size];  Arrays.fill(parent, -1);  }  public boolean unite(int x, int y) {  x = root(x);  y = root(y);  if (x != y) {   if (parent[y] < parent[x]) {   int tmp = y;   y = x;   x = tmp;   }   parent[x] += parent[y];   parent[y] = x;   return true;  }  return false;  }  public boolean same(int x, int y) {  return root(x) == root(y);  }  public int root(int x) {  return parent[x] < 0 ? x : (parent[x] = root(parent[x]));  }  public int size(int x) {  return -parent[root(x)];  } } public static int upperBound(int[] array, int value) {   int low = 0;   int high = array.length;   int mid;   while( low < high ) {    mid = ((high - low) >>> 1) + low;    if( array[mid] <= value ) {     low = mid + 1;    } else {     high = mid;    }   }   return low;  }  public static final int lowerBound(final int[] arr, final int value) {  int low = 0;  int high = arr.length;  int mid;  while (low < high){   mid = ((high - low) >>> 1) + low;    if (arr[mid] < value) {    low = mid + 1;   } else {    high = mid;   }  }  return low;  }  public static long gcd(long n, long m){  if(m > n) return gcd(m,n);  if(m == 0) return n;  return gcd(m, n%m); }  private class Pair2 implements Comparable<Pair2> {  String s;  int p;  int index;  public Pair2(String s, int p, int index) {   this.s = s;   this.p = p;   this.index = index;  }  public int compareTo(Pair2 other) {   if (s.equals(other.s)) {    return other.p - this.p;   }   return this.s.compareTo(other.s);  } }  public static int c2i(char c){ if('A' <= c && c <= 'Z'){  return c - 'A'; }else{  return c - 'a' + 26; } } public static char i2c(int i){ if(0 <= i && i < 26){  return (char)(i + 'A'); }else{  return (char)(i + 'a' - 26); } } }
2,public class C { InputStream is; PrintWriter out; String INPUT = "";  void solve() {  int[][] M = {   {2, mod-1},   {0, 1}  };  long n = nl();  if(n == 0){  out.println(0);  return;  }   n = n*2%mod;  long K = nl();  int[] v = new int[]{(int)n, 1};  out.println(pow(M, v, K)[0]); }   public static final int mod = 1000000007; public static final long m2 = (long)mod*mod; public static final long BIG = 8L*m2;   public static int[] pow(int[][] A, int[] v, long e) {  for(int i = 0;i < v.length;i++){  if(v[i] >= mod)v[i] %= mod;  }  int[][] MUL = A;  for(;e > 0;e>>>=1) {  if((e&1)==1)v = mul(MUL, v);  MUL = p2(MUL);  }  return v; }   public static int[] mul(int[][] A, int[] v) {  int m = A.length;  int n = v.length;  int[] w = new int[m];  for(int i = 0;i < m;i++){  long sum = 0;  for(int k = 0;k < n;k++){   sum += (long)A[i][k] * v[k];   if(sum >= BIG)sum -= BIG;  }  w[i] = (int)(sum % mod);  }  return w; }   public static int[][] p2(int[][] A) {  int n = A.length;  int[][] C = new int[n][n];  for(int i = 0;i < n;i++){  long[] sum = new long[n];  for(int k = 0;k < n;k++){   for(int j = 0;j < n;j++){   sum[j] += (long)A[i][k] * A[k][j];   if(sum[j] >= BIG)sum[j] -= BIG;   }  }  for(int j = 0;j < n;j++){   C[i][j] = (int)(sum[j] % mod);  }  }  return C; }   void run() throws Exception {  is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());  out = new PrintWriter(System.out);   long s = System.currentTimeMillis();  solve();  out.flush();  tr(System.currentTimeMillis()-s+"ms"); }  public static void main(String[] args) throws Exception { new C().run(); }  private byte[] inbuf = new byte[1024]; public int lenbuf = 0, ptrbuf = 0;  private int readByte() {  if(lenbuf == -1)throw new InputMismatchException();  if(ptrbuf >= lenbuf){  ptrbuf = 0;  try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }  if(lenbuf <= 0)return -1;  }  return inbuf[ptrbuf++]; }  private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }  private double nd() { return Double.parseDouble(ns()); } private char nc() { return (char)skip(); }  private String ns() {  int b = skip();  StringBuilder sb = new StringBuilder();  while(!(isSpaceChar(b))){   sb.appendCodePoint(b);  b = readByte();  }  return sb.toString(); }  private char[] ns(int n) {  char[] buf = new char[n];  int b = skip(), p = 0;  while(p < n && !(isSpaceChar(b))){  buf[p++] = (char)b;  b = readByte();  }  return n == p ? buf : Arrays.copyOf(buf, p); }  private char[][] nm(int n, int m) {  char[][] map = new char[n][];  for(int i = 0;i < n;i++)map[i] = ns(m);  return map; }  private int[] na(int n) {  int[] a = new int[n];  for(int i = 0;i < n;i++)a[i] = ni();  return a; }  private int ni() {  int num = 0, b;  boolean minus = false;  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));  if(b == '-'){  minus = true;  b = readByte();  }   while(true){  if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');  }else{   return minus ? -num : num;  }  b = readByte();  } }  private long nl() {  long num = 0;  int b;  boolean minus = false;  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));  if(b == '-'){  minus = true;  b = readByte();  }   while(true){  if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');  }else{   return minus ? -num : num;  }  b = readByte();  } }  private boolean oj = System.getProperty("ONLINE_JUDGE") != null; private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); } }
5,public class A { InputStream is; PrintWriter out; String INPUT = "";  void solve() {  int n = ni(), K = ni();  int[] a = na(n);  if(K == 1){  out.println(n);  return;  }  a = radixSort(a);  boolean[] dead = new boolean[n];  int ct = 0;  for(int i = 0;i < n;i++){  if(!dead[i]){   ct++;   if((long)a[i]*K<=1000000000){   int ind = Arrays.binarySearch(a, a[i]*K);   if(ind >= 0){    dead[ind] = true;   }   }  }  }  out.println(ct); }  public static int[] radixSort(int[] f) {  int[] to = new int[f.length];  {  int[] b = new int[65537];  for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;  for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];  for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];  int[] d = f; f = to;to = d;  }  {  int[] b = new int[65537];  for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;  for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];  for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];  int[] d = f; f = to;to = d;  }  return f; }  void run() throws Exception {  is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());  out = new PrintWriter(System.out);   long s = System.currentTimeMillis();  solve();  out.flush();  tr(System.currentTimeMillis()-s+"ms"); }  public static void main(String[] args) throws Exception { new A().run(); }  private byte[] inbuf = new byte[1024]; private int lenbuf = 0, ptrbuf = 0;  private int readByte() {  if(lenbuf == -1)throw new InputMismatchException();  if(ptrbuf >= lenbuf){  ptrbuf = 0;  try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }  if(lenbuf <= 0)return -1;  }  return inbuf[ptrbuf++]; }  private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }  private double nd() { return Double.parseDouble(ns()); } private char nc() { return (char)skip(); }  private String ns() {  int b = skip();  StringBuilder sb = new StringBuilder();  while(!(isSpaceChar(b))){   sb.appendCodePoint(b);  b = readByte();  }  return sb.toString(); }  private char[] ns(int n) {  char[] buf = new char[n];  int b = skip(), p = 0;  while(p < n && !(isSpaceChar(b))){  buf[p++] = (char)b;  b = readByte();  }  return n == p ? buf : Arrays.copyOf(buf, p); }  private char[][] nm(int n, int m) {  char[][] map = new char[n][];  for(int i = 0;i < n;i++)map[i] = ns(m);  return map; }  private int[] na(int n) {  int[] a = new int[n];  for(int i = 0;i < n;i++)a[i] = ni();  return a; }  private int ni() {  int num = 0, b;  boolean minus = false;  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));  if(b == '-'){  minus = true;  b = readByte();  }   while(true){  if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');  }else{   return minus ? -num : num;  }  b = readByte();  } }  private long nl() {  long num = 0;  int b;  boolean minus = false;  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));  if(b == '-'){  minus = true;  b = readByte();  }   while(true){  if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');  }else{   return minus ? -num : num;  }  b = readByte();  } }  private boolean oj = System.getProperty("ONLINE_JUDGE") != null; private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); } }
0,public class A125D2 {  public static void main(String[] args) throws Exception {  InputReader in = new InputReader(System.in);  System.out.println(0 + " " + 0 + " " + in.nextInt()); }  static class InputReader {  private BufferedReader reader;  private StringTokenizer tokenizer;  public InputReader(InputStream stream) {  reader = new BufferedReader(new InputStreamReader(stream));  tokenizer = null;  }  public String next() {  while (tokenizer == null || !tokenizer.hasMoreTokens()) {   try {   tokenizer = new StringTokenizer(reader.readLine());   } catch (IOException e) {   throw new RuntimeException(e);   }  }  return tokenizer.nextToken();  }  public int nextInt() {  return Integer.parseInt(next());  } } }
5,public class A implements Runnable { public static void main(String [] args) throws IOException {  new Thread(null, new A(), "", 1 << 20).start(); }  String file = "input"; BufferedReader input; PrintWriter out;  public void run()  {  try  {    input = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(new BufferedOutputStream(System.out));  solve();  input.close();  out.close();  }  catch(Exception e)  {  e.printStackTrace();  System.exit(1);  } } int N, T; void solve() throws IOException {  StringTokenizer st = tokens();  N = nextInt(st); T = nextInt(st);  T *= 2;  ArrayList<Pair> list = new ArrayList<Pair>();  for(int i = 0; i < N; i++)  {  st = tokens();  int c = nextInt(st), L = nextInt(st);  c *= 2; L *= 2;  list.add(new Pair(c - L / 2, c + L / 2));  }  Collections.sort(list);  HashSet<Integer> set = new HashSet<Integer>();  for(int i = 0; i < list.size(); i++)  {  if(i == 0 || list.get(i).x - list.get(i - 1).y >= T)  {   set.add(list.get(i).x - T / 2);  }  if(i == list.size() - 1 || list.get(i + 1).x - list.get(i).y >= T)  {   set.add(list.get(i).y + T / 2);  }  }  System.out.println(set.size()); } class Pair implements Comparable<Pair> {  int x, y;  public Pair(int x, int y)  {  this.x = x;  this.y = y;  }  public int compareTo(Pair p)  {  if(x != p.x) return x - p.x;  return y - p.y;  } }  StringTokenizer tokens() throws IOException {  return new StringTokenizer(input.readLine()); }  String next(StringTokenizer st) {  return st.nextToken(); }  int nextInt() throws IOException {  return Integer.parseInt(input.readLine()); }  int nextInt(StringTokenizer st) {  return Integer.parseInt(st.nextToken()); }  double nextDouble() throws IOException {  return Double.parseDouble(input.readLine()); }  double nextDouble(StringTokenizer st) {  return Double.parseDouble(st.nextToken()); }  void print(Object... o) {  out.println(deepToString(o)); } }
6,public class Main { static final long MOD = 998244353;  static boolean[] visited;  public static void main(String[] args) throws IOException {   FastScanner sc = new FastScanner();   int Q = sc.nextInt();   for (int q = 0; q < Q; q++) {   int N = sc.nextInt();   int M = sc.nextInt();   int[][] grid = new int[N][M];   int[][] maxes = new int[M][2];   for (int i = 0; i < M; i++)    maxes[i][1] = i;   for (int i = 0; i < N; i++) {    for (int j = 0; j < M; j++) {    grid[i][j] = sc.nextInt();    maxes[j][0] = Math.max(maxes[j][0],grid[i][j]);    }   }   maxes = sort(maxes);   int[] keyCols = new int[Math.min(M, N)];   for (int i = 0; i < keyCols.length; i++)    keyCols[i] = maxes[i][1];      int ans = 0;   for (int x = 0; x < (int)Math.pow(N,N); x++) {    int[] base = baseN(keyCols.length,x);    int ansx = 0;    for (int i = 0; i < N; i++) {     int r = 0;     for (int j = 0; j < keyCols.length; j++) {     r = Math.max(r,grid[(i+base[j])%N][keyCols[j]]);     }     ansx += r;    }    ans = Math.max(ans,ansx);   }   System.out.println(ans);   }  }   public static int[] baseN(int N, int num) {  int[] ans = new int[N];  for (int i = N-1; i >= 0; i--) {   int pow = (int)Math.pow(N,i);   ans[i] = num/pow;   num -= ans[i]*pow;  }  return ans;  }   public static int[][] sort(int[][] array) {    Random rgen = new Random();  for (int i = 0; i< array.length; i++) {   int randomPosition = rgen.nextInt(array.length);   int[] temp = array[i];   array[i] = array[randomPosition];   array[randomPosition] = temp;  }  Arrays.sort(array, new Comparator<int[]>() {   @Override   public int compare(int[] arr1, int[] arr2) {      return arr2[0]-arr1[0];   }  });  return array; }   static class FastScanner {   BufferedReader br;   StringTokenizer st;    public FastScanner() {    br = new BufferedReader(new InputStreamReader(System.in));   }    String next() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }    int nextInt() {    return Integer.parseInt(next());   }    long nextLong() {    return Long.parseLong(next());   }    double nextDouble() {    return Double.parseDouble(next());   }    String nextLine() {    String str = "";    try {     str = br.readLine();    } catch (IOException e) {     e.printStackTrace();    }    return str;   }  } }
0,public class HexadecimalsTheorem {  public static void main(String[] args) {   Scanner in = new Scanner(System.in);   int num = in.nextInt();   LinkedList<Integer> result = new LinkedList<Integer>();   int temp0 = 1;   int temp1 = 1;   int temp2 = 0;   result.add(0);   result.add(0);   result.add(0);   result.add(temp0);   result.add(temp1);   if (num == 2) {    System.out.println(0 + " " + 1 + " " + 1);   } else if (num == 0) {    System.out.println(0 + " " + 0 + " " + 0);   } else {    while (temp2 < num) {     temp2 = temp1 + temp0;     result.add(temp2);     temp0 = temp1;     temp1 = temp2;    }    int length = result.size();    System.out.println(result.get(length - 5) + " "      + result.get(length - 4) + " " + result.get(length - 2));   }  } }
2,public class A {  private static final int mod = (int)1e9+9;  final IOFast io = new IOFast();   long k;   long rec(long n, long m, long cur) {   long pow = 1;   long margin = 10;   long p = 1000;   for(int i = 0; i < p; i++) pow = pow * 2 % mod;   while(true) {    if(n + 1 >= (m / (k - 1) * k + m % (k - 1)) || m < k) { return (m + cur) % mod; }    long q = (p + margin) * k;    if(n - q + 1 < ((m - q) / (k - 1) * k + (m - q) % (k - 1)) && m >= q) {     n -= p * k;     m -= p * k;     cur = cur * pow % mod;     cur += (pow - 1) * 2 * k % mod;     cur %= mod;     continue;    }    n -= k;    m -= k;    cur += k;    cur = cur * 2 % mod;   }  }   public void run() throws IOException {   long n = io.nextLong();   long m = io.nextLong();   k = io.nextLong();      long low = -1, high = m / k + 1;   while(high - low > 1) {    long mid = (low + high) / 2;    long u = mid * k;    if(m < u) { high = mid; continue; }    long val = u;    val += (m - u) / (k - 1) * k;    if((m - u) % (k - 1) == 0) val -= 1;    else val += (m - u) % (k - 1);       if(val > n) {     low = mid;    }    else {     high = mid;    }   }   long pow = powmod(2, high, mod);   long score = m - high * k;   score = (score + (pow - 1) * 2 * k) % mod;   io.out.println(score);  }    static long powmod(long n, long r, int m) {   long res = 1;   for(; r != 0; r >>>= 1, n = n * n % m) {    if((r&1) == 1) {     res = res * n;     if(res >= m) {      res %= m;     }    }   }   return res;  }  void main() throws IOException {     try {    run();   }   catch (EndOfFileRuntimeException e) { }   io.out.flush();  }  public static void main(String[] args) throws IOException {   new A().main();  }   static class EndOfFileRuntimeException extends RuntimeException {   private static final long serialVersionUID = -8565341110209207657L; }  static  public class IOFast {   private BufferedReader in = new BufferedReader(new InputStreamReader(System.in));   private PrintWriter out = new PrintWriter(System.out);   void setFileIO(String ins, String outs) throws IOException {    in = new BufferedReader(new FileReader(ins));    out = new PrintWriter(new FileWriter(outs));   }      private static int pos, readLen;   private static final char[] buffer = new char[1024 * 8];   private static final char[] str = new char[500000*8*2];   private static boolean[] isDigit = new boolean[256];   private static boolean[] isSpace = new boolean[256];   private static boolean[] isLineSep = new boolean[256];   static {    for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; }    isDigit['-'] = true;    isSpace[' '] = isSpace['\r'] = isSpace['\n'] = isSpace['\t'] = true;    isLineSep['\r'] = isLineSep['\n'] = true;   }   public int read() throws IOException {    if(pos >= readLen) {     pos = 0;     readLen = in.read(buffer);     if(readLen <= 0) { throw new EndOfFileRuntimeException(); }    }    return buffer[pos++];   }   public int nextInt() throws IOException {    return Integer.parseInt(nextString());   }   public long nextLong() throws IOException {    return Long.parseLong(nextString());   }   public char nextChar() throws IOException {    while(true) {     final int c = read();     if(!isSpace[c]) { return (char)c; }    }   }     int reads(char[] cs, int len, boolean[] accept) throws IOException {    try {     while(true) {      final int c = read();      if(accept[c]) { break; }      str[len++] = (char)c;     }    }    catch(EndOfFileRuntimeException e) { ; }       return len;   }   public char[] nextLine() throws IOException {    int len = 0;    str[len++] = nextChar();    len = reads(str, len, isLineSep);       try {     if(str[len-1] == '\r') { len--; read(); }    }    catch(EndOfFileRuntimeException e) { ; }       return Arrays.copyOf(str, len);   }   public String nextString() throws IOException {    return new String(next());   }   public char[] next() throws IOException {    int len = 0;    str[len++] = nextChar();    len = reads(str, len, isSpace);    return Arrays.copyOf(str, len);   }   public double nextDouble() throws IOException {    return Double.parseDouble(nextString());   }  } }
5,final public class Main implements Runnable { private static String[] args;  public static void main(String[] args) {  Main.args = args;  new Thread(null, new Main(), "MyRunThread", 1 << 27).start(); }   public void run() {  long time_beg = -1;  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  if (args.length > 0 && args[0].equals("outside")) {  time_beg = System.currentTimeMillis();  try {   inputStream = new FileInputStream("IO/in.txt");   } catch (Exception e) {   System.err.println(e);   System.exit(1);  }  } else {  try {   } catch (Exception e) {   System.err.println(e);   System.exit(1);  }  }  Solver s = new Solver();  s.in = new InputReader(inputStream);  s.out = new OutputWriter(outputStream);  if (args.length > 0 && args[0].equals("outside")) {  s.dout = new DebugWriter(s.out);  }  s.solve();  if (args.length > 0 && args[0].equals("outside")) {  s.dout.printFormat("*** Total time: %.3f ***\n", (System.currentTimeMillis() - time_beg) / 1000.0);  }  s.out.close(); } }  final class Solver { InputReader in; OutputWriter out; DebugWriter dout;  public void solve() {  int n = in.readInt();  int k = in.readInt();   TreeSet<Integer> q = new TreeSet<Integer>();  int[] mas = new int[n];  for (int i = 0; i < n; ++i) {  mas[i] = in.readInt();  if (mas[i] % k != 0)   q.add(mas[i]);  }   Arrays.sort(mas);  for (int i = 0; i < n; ++i)  if (mas[i] % k == 0 && !q.contains(mas[i] / k))   q.add(mas[i]);  out.printLine(q.size()); } }  final class InputReader { private boolean finished = false;  private InputStream stream; private byte[] buf = new byte[1 << 10]; private int curChar; private int numChars;  public InputReader(InputStream stream) {  this.stream = stream; }  private int read() {  if (numChars == -1)  throw new InputMismatchException();  if (curChar >= numChars) {  curChar = 0;  try {   numChars = stream.read(buf);  } catch (IOException e) {   throw new InputMismatchException();  }  if (numChars <= 0)   return -1;  }  return buf[curChar++]; }  public int peek() {  if (numChars == -1)  return -1;  if (curChar >= numChars) {  curChar = 0;  try {   numChars = stream.read(buf);  } catch (IOException e) {   return -1;  }  if (numChars <= 0)   return -1;  }  return buf[curChar]; }  public int readInt() {  int c = read();  while (isSpaceChar(c))  c = read();  int sgn = 1;  if (c == '-') {  sgn = -1;  c = read();  }  int res = 0;  do {  if (c < '0' || c > '9')   throw new InputMismatchException();  res *= 10;  res += c - '0';  c = read();  } while (!isSpaceChar(c));  return res * sgn; }  public long readLong() {  int c = read();  while (isSpaceChar(c))  c = read();  int sgn = 1;  if (c == '-') {  sgn = -1;  c = read();  }  long res = 0;  do {  if (c < '0' || c > '9')   throw new InputMismatchException();  res *= 10;  res += c - '0';  c = read();  } while (!isSpaceChar(c));  return res * sgn; }  public String readString() {  int c = read();  while (isSpaceChar(c))  c = read();  StringBuilder res = new StringBuilder();  do {  res.appendCodePoint(c);  c = read();  } while (!isSpaceChar(c));  return res.toString(); }  public static boolean isSpaceChar(int c) {  return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; }  private String readLine0() {  StringBuilder buf = new StringBuilder();  int c = read();  while (c != '\n' && c != -1) {  if (c != '\r')   buf.appendCodePoint(c);  c = read();  }  return buf.toString(); }  public String readLine() {  String s = readLine0();  while (s.trim().length() == 0)  s = readLine0();  return s; }  public String readLine(boolean ignoreEmptyLines) {  if (ignoreEmptyLines)  return readLine();  else  return readLine0(); }  public BigInteger readBigInteger() {  try {  return new BigInteger(readString());  } catch (NumberFormatException e) {  throw new InputMismatchException();  } }  public char readCharacter() {  int c = read();  while (isSpaceChar(c))  c = read();  return (char) c; }  public double readDouble() {  int c = read();  while (isSpaceChar(c))  c = read();  int sgn = 1;  if (c == '-') {  sgn = -1;  c = read();  }  double res = 0;  while (!isSpaceChar(c) && c != '.') {  if (c == 'e' || c == 'E')   return res * Math.pow(10, readInt());  if (c < '0' || c > '9')   throw new InputMismatchException();  res *= 10;  res += c - '0';  c = read();  }  if (c == '.') {  c = read();  double m = 1;  while (!isSpaceChar(c)) {   if (c == 'e' || c == 'E')   return res * Math.pow(10, readInt());   if (c < '0' || c > '9')   throw new InputMismatchException();   m /= 10;   res += (c - '0') * m;   c = read();  }  }  return res * sgn; }  public boolean isExhausted() {  int value;  while (isSpaceChar(value = peek()) && value != -1)  read();  return value == -1; } } final class OutputWriter { private final PrintWriter writer;  public OutputWriter(OutputStream outputStream) {  writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream), 1 << 10)); }  public OutputWriter(Writer writer) {  this.writer = new PrintWriter(writer); }  public void print(Object... objects) {  for (int i = 0; i < objects.length; i++) {  if (i != 0)   writer.print(' ');  writer.print(objects[i]);  } }  public void printLine(Object... objects) {  print(objects);  writer.println(); }  public void printFormat(String format, Object... objects) {  writer.printf(format, objects); }  public void print(char[] objects) {  writer.print(objects); }  public void printLine(char[] objects) {  writer.println(objects); }  public void printLine(char[][] objects) {  for (int i = 0; i < objects.length; ++i)  printLine(objects[i]); }  public void print(int[] objects) {  for (int i = 0; i < objects.length; i++) {  if (i != 0)   writer.print(' ');  writer.print(objects[i]);  } }  public void printLine(int[] objects) {  print(objects);  writer.println(); }  public void printLine(int[][] objects) {  for (int i = 0; i < objects.length; ++i)  printLine(objects[i]); }  public void print(short[] objects) {  for (int i = 0; i < objects.length; i++) {  if (i != 0)   writer.print(' ');  writer.print(objects[i]);  } }  public void printLine(short[] objects) {  print(objects);  writer.println(); }  public void printLine(short[][] objects) {  for (int i = 0; i < objects.length; ++i)  printLine(objects[i]); }  public void print(long[] objects) {  for (int i = 0; i < objects.length; i++) {  if (i != 0)   writer.print(' ');  writer.print(objects[i]);  } }  public void printLine(long[] objects) {  print(objects);  writer.println(); }  public void printLine(long[][] objects) {  for (int i = 0; i < objects.length; ++i)  printLine(objects[i]); }  public void print(double[] objects) {  for (int i = 0; i < objects.length; i++) {  if (i != 0)   writer.print(' ');  writer.print(objects[i]);  } }  public void printLine(double[] objects) {  print(objects);  writer.println(); }  public void printLine(double[][] objects) {  for (int i = 0; i < objects.length; ++i)  printLine(objects[i]); }  public void print(byte[] objects) {  for (int i = 0; i < objects.length; i++) {  if (i != 0)   writer.print(' ');  writer.print(objects[i]);  } }  public void printLine(byte[] objects) {  print(objects);  writer.println(); }  public void printLine(byte[][] objects) {  for (int i = 0; i < objects.length; ++i)  printLine(objects[i]); }  public void print(boolean[] objects) {  for (int i = 0; i < objects.length; i++) {  if (i != 0)   writer.print(' ');  writer.print(objects[i]);  } }  public void printLine(boolean[] objects) {  print(objects);  writer.println(); }  public void printLine(boolean[][] objects) {  for (int i = 0; i < objects.length; ++i)  printLine(objects[i]); }  public void close() {  writer.close(); }  public void flush() {  writer.flush(); } } final class DebugWriter { private final OutputWriter writer;  public DebugWriter(OutputWriter writer) {  this.writer = writer; }  private void printDebugMessage() {  writer.print("DEBUG:\t"); }  public void printLine(Object... objects) {  flush();  printDebugMessage();  writer.printLine(objects);  flush(); }  public void printFormat(String format, Object... objects) {  flush();  printDebugMessage();  writer.printFormat(format, objects);  flush(); }  public void printLine(char[] objects) {  flush();  printDebugMessage();  writer.printLine(objects);  flush(); }  public void printLine(char[][] objects) {  flush();  for (int i = 0; i < objects.length; ++i)  printLine(objects[i]);  flush(); }  public void printLine(double[] objects) {  flush();  printDebugMessage();  writer.printLine(objects);  flush(); }  public void printLine(double[][] objects) {  flush();  for (int i = 0; i < objects.length; ++i)  printLine(objects[i]);  flush(); }  public void printLine(int[] objects) {  flush();  printDebugMessage();  writer.printLine(objects);  flush(); }  public void printLine(int[][] objects) {  flush();  for (int i = 0; i < objects.length; ++i)  printLine(objects[i]);  flush(); }  public void printLine(short[] objects) {  flush();  printDebugMessage();  writer.printLine(objects);  flush(); }  public void printLine(short[][] objects) {  flush();  for (int i = 0; i < objects.length; ++i)  printLine(objects[i]);  flush(); }  public void printLine(long[] objects) {  flush();  printDebugMessage();  writer.printLine(objects);  flush(); }  public void printLine(long[][] objects) {  flush();  for (int i = 0; i < objects.length; ++i)  printLine(objects[i]);  flush(); }  public void printLine(byte[] objects) {  flush();  printDebugMessage();  writer.printLine(objects);  flush(); }  public void printLine(byte[][] objects) {  flush();  for (int i = 0; i < objects.length; ++i)  printLine(objects[i]);  flush(); }  public void printLine(boolean[] objects) {  flush();  printDebugMessage();  writer.printLine(objects);  flush(); }  public void printLine(boolean[][] objects) {  flush();  for (int i = 0; i < objects.length; ++i)  printLine(objects[i]);  flush(); }  public void flush() {  writer.flush(); } }  interface Graph {  public void addVertexes(int amount);   public void addEdge(int source, int destination, boolean directed);  public void addEdge(int source, int destination, boolean directed, long weight);  public void addEdge(int source, int destination, long capacity);  public void addEdge(int source, int destination, long weight, long capacity);   public int getFirstEdge(int source);  public boolean hasNextEdge(int id);  public int getNextEdge(int id);   public int getVertexCount();  public int getEdgeCount();  public void show(DebugWriter writer);   public int getSource(int id);  public int getDestination(int id);  public int getColor(int id);  public void setColor(int id, int color);  public boolean hasReverseEdge(int id);  public int getReverseEdge(int id);  public String edgeToString(int id);   public long getWeight(int id);  public void setWeight(int id, long weight);   public long getCapacity(int id);  public void addCapacity(int id, long capacity);  public long getFlow(int id);  public void pushFlow(int id, long flow); } class GraphSimple implements Graph { protected int[] firstEdge; protected int[] nextEdge; protected int vertexCount = 0; protected int edgeCount = 0;  protected int[] reverseEdge; protected int[] source; protected int[] destination; protected int[] color;  public GraphSimple() {  this(16, 16); }  public GraphSimple(int vertexCapacity, int edgeCapacity) {  firstEdge = new int[vertexCapacity];  nextEdge = new int[edgeCapacity];  reverseEdge = new int[edgeCapacity];  source = new int[edgeCapacity];  destination = new int[edgeCapacity];  color = new int[edgeCapacity]; }  protected void ensureVertexCapacity(int size) { }  protected void ensureEdgeCapacity(int size) { }   @Override public void addVertexes(int amount) {  ensureVertexCapacity(vertexCount + amount);  for (int i = 0; i < amount; ++i)  firstEdge[i + vertexCount] = -1;  vertexCount += amount; }   @Override public void addEdge(int source, int destination, boolean directed) {  if (source >= vertexCount || destination >= vertexCount)  throw new ArrayIndexOutOfBoundsException("wrong vertex's number");  ensureEdgeCapacity(edgeCount + 2);  nextEdge[edgeCount] = firstEdge[source];  firstEdge[source] = edgeCount;  this.source[edgeCount] = source;  this.destination[edgeCount] = destination;  this.color[edgeCount] = -1;  if (directed) reverseEdge[edgeCount++] = -1;  else {  reverseEdge[edgeCount] = edgeCount + 1;  ++edgeCount;   nextEdge[edgeCount] = firstEdge[destination];  firstEdge[destination] = edgeCount;   this.source[edgeCount] = destination;  this.destination[edgeCount] = source;  this.color[edgeCount] = -1;   reverseEdge[edgeCount] = edgeCount - 1;  ++edgeCount;  } }  @Override public void addEdge(int source, int destination, boolean directed, long weight) {  throw new UnsupportedOperationException(); }  @Override public void addEdge(int source, int destination, long capacity) {  throw new UnsupportedOperationException(); }  @Override public void addEdge(int source, int destination, long weight, long capacity) {  throw new UnsupportedOperationException(); }   @Override public int getFirstEdge(int source) {  if (source >= vertexCount)  throw new ArrayIndexOutOfBoundsException("wrong vertex's number");  return firstEdge[source]; }  @Override public boolean hasNextEdge(int id) {  return id != -1; }  @Override public int getNextEdge(int id) {  return nextEdge[id]; }   @Override public int getVertexCount() {  return vertexCount; }  @Override public int getEdgeCount() {  return edgeCount; }  @Override public void show(DebugWriter writer) {  writer.printLine("Graph:");  for (int i = 0; i < getVertexCount(); ++i) {  writer.printLine("\tincident to vertex [" + i + "]: ");  for (int id = getFirstEdge(i); hasNextEdge(id); id = getNextEdge(id))   writer.printLine("\t\t" + edgeToString(id));  } }   @Override public int getSource(int id) {  return source[id]; }  @Override public int getDestination(int id) {  return destination[id]; }  @Override public int getColor(int id) {  return color[id]; }  @Override public void setColor(int id, int color) {  this.color[id] = color; }  @Override public boolean hasReverseEdge(int id) {  return reverseEdge[id] != -1; }  @Override public int getReverseEdge(int id) {  if (reverseEdge[id] == -1)  throw new NoSuchFieldError();  return reverseEdge[id]; }  @Override public String edgeToString(int id) {  return "<(" + getSource(id) + " -> " + getDestination(id) + ") color : " + getColor(id) + ">"; }   @Override public long getWeight(int id) {  throw new UnsupportedOperationException(); }  @Override public void setWeight(int id, long weight) {  throw new UnsupportedOperationException(); }   @Override public long getCapacity(int id) {  throw new UnsupportedOperationException(); }  @Override public void addCapacity(int id, long capacity) {  throw new UnsupportedOperationException(); }  @Override public long getFlow(int id) {  throw new UnsupportedOperationException(); }  @Override public void pushFlow(int id, long flow) {  throw new UnsupportedOperationException(); } }  abstract class SequenceUtils {  public final static <T> void swap(List<T> sequence, int j, int i) {  T tmp = sequence.get(j);  sequence.set(j, sequence.get(i));  sequence.set(i, tmp); }  public final static <T> void swap(T[] sequence, int j, int i) {  T tmp = sequence[j];  sequence[j] = sequence[i];  sequence[i] = tmp; }  public final static void swap(int[] sequence, int j, int i) {  int tmp = sequence[j];  sequence[j] = sequence[i];  sequence[i] = tmp; }  public final static void swap(long[] sequence, int j, int i) {  long tmp = sequence[j];  sequence[j] = sequence[i];  sequence[i] = tmp; }  public final static void swap(char[] sequence, int j, int i) {  char tmp = sequence[j];  sequence[j] = sequence[i];  sequence[i] = tmp; }  public final static void swap(double[] sequence, int j, int i) {  double tmp = sequence[j];  sequence[j] = sequence[i];  sequence[i] = tmp; }  public final static void swap(boolean[] sequence, int j, int i) {  boolean tmp = sequence[j];  sequence[j] = sequence[i];  sequence[i] = tmp; }  public final static void swap(short[] sequence, int j, int i) {  short tmp = sequence[j];  sequence[j] = sequence[i];  sequence[i] = tmp; }  public final static void swap(byte[] sequence, int j, int i) {  byte tmp = sequence[j];  sequence[j] = sequence[i];  sequence[i] = tmp; }   public final static <T> void reverse(List<T> sequence) {  for (int left = 0, right = sequence.size() - 1; left < right; ++left, --right)  swap(sequence, left, right); }  public final static <T> void reverse(T[] sequence) {  for (int left = 0, right = sequence.length - 1; left < right; ++left, --right)  swap(sequence, left, right); }  public final static void reverse(int[] sequence) {  for (int left = 0, right = sequence.length - 1; left < right; ++left, --right)  swap(sequence, left, right); }  public final static void reverse(long[] sequence) {  for (int left = 0, right = sequence.length - 1; left < right; ++left, --right)  swap(sequence, left, right); }  public final static void reverse(char[] sequence) {  for (int left = 0, right = sequence.length - 1; left < right; ++left, --right)  swap(sequence, left, right); }  public final static void reverse(double[] sequence) {  for (int left = 0, right = sequence.length - 1; left < right; ++left, --right)  swap(sequence, left, right); }  public final static void reverse(boolean[] sequence) {  for (int left = 0, right = sequence.length - 1; left < right; ++left, --right)  swap(sequence, left, right); }  public final static void reverse(short[] sequence) {  for (int left = 0, right = sequence.length - 1; left < right; ++left, --right)  swap(sequence, left, right); }  public final static void reverse(byte[] sequence) {  for (int left = 0, right = sequence.length - 1; left < right; ++left, --right)  swap(sequence, left, right); }   public final static <T extends Comparable<T>> boolean nextPermutation(List<T> sequence) {  for (int j = sequence.size() - 2; j >= 0; --j) {  if (sequence.get(j).compareTo(sequence.get(j + 1)) < 0) {   reverse(sequence.subList(j + 1, sequence.size()));   for (int i = j + 1; i < sequence.size(); ++i)   if (sequence.get(j).compareTo(sequence.get(i)) < 0) {    swap(sequence, j, i);    return true;   }  }  }  return false; }  public final static <T> boolean nextPermutation(List<T> sequence, Comparator<T> comparator) {  for (int j = sequence.size() - 2; j >= 0; --j) {  if (comparator.compare(sequence.get(j), sequence.get(j + 1)) < 0) {   reverse(sequence.subList(j + 1, sequence.size()));   for (int i = j + 1; i < sequence.size(); ++i)   if (comparator.compare(sequence.get(j), sequence.get(i)) < 0) {    swap(sequence, j, i);    return true;   }  }  }  return false; }   public final static <T> void shuffle(List<T> sequence) {  Random random = new Random(System.nanoTime());  for (int i = 1; i < sequence.size(); ++i)  swap(sequence, random.nextInt(i + 1), i); }  public final static <T> void shuffle(T[] sequence) {  Random random = new Random(System.nanoTime());  for (int i = 1; i < sequence.length; ++i)  swap(sequence, random.nextInt(i + 1), i); }  public final static void shuffle(int[] sequence) {  Random random = new Random(System.nanoTime());  for (int i = 1; i < sequence.length; ++i)  swap(sequence, random.nextInt(i + 1), i); }  public final static void shuffle(long[] sequence) {  Random random = new Random(System.nanoTime());  for (int i = 1; i < sequence.length; ++i)  swap(sequence, random.nextInt(i + 1), i); }  public final static void shuffle(char[] sequence) {  Random random = new Random(System.nanoTime());  for (int i = 1; i < sequence.length; ++i)  swap(sequence, random.nextInt(i + 1), i); }  public final static void shuffle(double[] sequence) {  Random random = new Random(System.nanoTime());  for (int i = 1; i < sequence.length; ++i)  swap(sequence, random.nextInt(i + 1), i); }  public final static void shuffle(boolean[] sequence) {  Random random = new Random(System.nanoTime());  for (int i = 1; i < sequence.length; ++i)  swap(sequence, random.nextInt(i + 1), i); }  public final static void shuffle(short[] sequence) {  Random random = new Random(System.nanoTime());  for (int i = 1; i < sequence.length; ++i)  swap(sequence, random.nextInt(i + 1), i); }  public final static void shuffle(byte[] sequence) {  Random random = new Random(System.nanoTime());  for (int i = 1; i < sequence.length; ++i)  swap(sequence, random.nextInt(i + 1), i); }   public final static <T extends Comparable<T>> void mergeSort(List<T> sequence) {  int n = sequence.size();  T[] tmp = (T[]) new Object[n];  for (int step = 1; step < n; step *= 2) {  for (int i = 0; i < n; ++i)   tmp[i] = sequence.get(i);  for (int i = 0; i + step < n; i += 2 * step)   merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));  } }  private final static <T extends Comparable<T>> void merge(List<T> sequence, T[] tmp, int left, int mid, int right) {  int pLeft = left;  int pRight = mid + 1;  for (int i = left; i <= right; ++i)  if (pLeft > mid) sequence.set(i, tmp[pRight++]);  else if (pRight > right) sequence.set(i, tmp[pLeft++]);  else if (tmp[pLeft].compareTo(tmp[pRight]) <= 0) sequence.set(i, tmp[pLeft++]);  else sequence.set(i, tmp[pRight++]); }  public final static <T> void mergeSort(List<T> sequence, Comparator<T> comparator) {  int n = sequence.size();  T[] tmp = (T[]) new Object[n];  for (int step = 1; step < n; step *= 2) {  for (int i = 0; i < n; ++i)   tmp[i] = sequence.get(i);  for (int i = 0; i + step < n; i += 2 * step)   merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1), comparator);  } }  private final static <T> void merge(List<T> sequence, T[] tmp, int left, int mid, int right, Comparator<T> comparator) {  int pLeft = left;  int pRight = mid + 1;  for (int i = left; i <= right; ++i)  if (pLeft > mid) sequence.set(i, tmp[pRight++]);  else if (pRight > right) sequence.set(i, tmp[pLeft++]);  else if (comparator.compare(tmp[pLeft], tmp[pRight]) <= 0) sequence.set(i, tmp[pLeft++]);  else sequence.set(i, tmp[pRight++]); }  public final static void mergeSort(int[] sequence) {  int n = sequence.length;  int[] tmp = new int[n];  for (int step = 1; step < n; step *= 2) {  for (int i = 0; i < n; ++i)   tmp[i] = sequence[i];  for (int i = 0; i + step < n; i += 2 * step)   merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));  } }  private final static void merge(int[] sequence, int[] tmp, int left, int mid, int right) {  int pLeft = left;  int pRight = mid + 1;  for (int i = left; i <= right; ++i)  if (pLeft > mid) sequence[i] = tmp[pRight++];  else if (pRight > right) sequence[i] = tmp[pLeft++];  else if (tmp[pLeft] <= tmp[pRight]) sequence[i] = tmp[pLeft++];  else sequence[i] = tmp[pRight++]; }  public final static void mergeSort(long[] sequence) {  int n = sequence.length;  long[] tmp = new long[n];  for (int step = 1; step < n; step *= 2) {  for (int i = 0; i < n; ++i)   tmp[i] = sequence[i];  for (int i = 0; i + step < n; i += 2 * step)   merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));  } }  private final static void merge(long[] sequence, long[] tmp, int left, int mid, int right) {  int pLeft = left;  int pRight = mid + 1;  for (int i = left; i <= right; ++i)  if (pLeft > mid) sequence[i] = tmp[pRight++];  else if (pRight > right) sequence[i] = tmp[pLeft++];  else if (tmp[pLeft] <= tmp[pRight]) sequence[i] = tmp[pLeft++];  else sequence[i] = tmp[pRight++]; }  public final static void mergeSort(char[] sequence) {  int n = sequence.length;  char[] tmp = new char[n];  for (int step = 1; step < n; step *= 2) {  for (int i = 0; i < n; ++i)   tmp[i] = sequence[i];  for (int i = 0; i + step < n; i += 2 * step)   merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));  } }  private final static void merge(char[] sequence, char[] tmp, int left, int mid, int right) {  int pLeft = left;  int pRight = mid + 1;  for (int i = left; i <= right; ++i)  if (pLeft > mid) sequence[i] = tmp[pRight++];  else if (pRight > right) sequence[i] = tmp[pLeft++];  else if (tmp[pLeft] <= tmp[pRight]) sequence[i] = tmp[pLeft++];  else sequence[i] = tmp[pRight++]; }  public final static void mergeSort(double[] sequence) {  int n = sequence.length;  double[] tmp = new double[n];  for (int step = 1; step < n; step *= 2) {  for (int i = 0; i < n; ++i)   tmp[i] = sequence[i];  for (int i = 0; i + step < n; i += 2 * step)   merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));  } }  private final static void merge(double[] sequence, double[] tmp, int left, int mid, int right) {  int pLeft = left;  int pRight = mid + 1;  for (int i = left; i <= right; ++i)  if (pLeft > mid) sequence[i] = tmp[pRight++];  else if (pRight > right) sequence[i] = tmp[pLeft++];  else if (tmp[pLeft] <= tmp[pRight]) sequence[i] = tmp[pLeft++];  else sequence[i] = tmp[pRight++]; }  public final static void mergeSort(boolean[] sequence) {  int n = sequence.length;  boolean[] tmp = new boolean[n];  for (int step = 1; step < n; step *= 2) {  for (int i = 0; i < n; ++i)   tmp[i] = sequence[i];  for (int i = 0; i + step < n; i += 2 * step)   merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));  } }  private final static void merge(boolean[] sequence, boolean[] tmp, int left, int mid, int right) {  int pLeft = left;  int pRight = mid + 1;  for (int i = left; i <= right; ++i)  if (pLeft > mid) sequence[i] = tmp[pRight++];  else if (pRight > right) sequence[i] = tmp[pLeft++];  else if (!tmp[pLeft] || tmp[pRight]) sequence[i] = tmp[pLeft++];  else sequence[i] = tmp[pRight++]; }  public final static void mergeSort(short[] sequence) {  int n = sequence.length;  short[] tmp = new short[n];  for (int step = 1; step < n; step *= 2) {  for (int i = 0; i < n; ++i)   tmp[i] = sequence[i];  for (int i = 0; i + step < n; i += 2 * step)   merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));  } }  private final static void merge(short[] sequence, short[] tmp, int left, int mid, int right) {  int pLeft = left;  int pRight = mid + 1;  for (int i = left; i <= right; ++i)  if (pLeft > mid) sequence[i] = tmp[pRight++];  else if (pRight > right) sequence[i] = tmp[pLeft++];  else if (tmp[pLeft] <= tmp[pRight]) sequence[i] = tmp[pLeft++];  else sequence[i] = tmp[pRight++]; }  public final static void mergeSort(byte[] sequence) {  int n = sequence.length;  byte[] tmp = new byte[n];  for (int step = 1; step < n; step *= 2) {  for (int i = 0; i < n; ++i)   tmp[i] = sequence[i];  for (int i = 0; i + step < n; i += 2 * step)   merge(sequence, tmp, i, i + step - 1, Math.min(i + step * 2 - 1, n - 1));  } }  private final static void merge(byte[] sequence, byte[] tmp, int left, int mid, int right) {  int pLeft = left;  int pRight = mid + 1;  for (int i = left; i <= right; ++i)  if (pLeft > mid) sequence[i] = tmp[pRight++];  else if (pRight > right) sequence[i] = tmp[pLeft++];  else if (tmp[pLeft] <= tmp[pRight]) sequence[i] = tmp[pLeft++];  else sequence[i] = tmp[pRight++]; }   public final static <T> void quickSort(List<T> sequence, Comparator<T> comparator) {  shuffle(sequence);  quickSortImplementation(sequence, 0, sequence.size() - 1, comparator); }  private final static <T> void quickSortImplementation(List<T> sequence, int left, int right, Comparator<T> comparator) {  if (left >= right) return;  int lessThen = left;  int greaterThen = right;  int i = left;  T value = sequence.get(left);  while (i <= greaterThen) {  int cmp = comparator.compare(sequence.get(i), value);  if (cmp < 0) swap(sequence, i++, lessThen++);  else if (cmp > 0) swap(sequence, i, greaterThen--);  else ++i;  }  quickSortImplementation(sequence, left, lessThen - 1, comparator);  quickSortImplementation(sequence, greaterThen + 1, right, comparator); }  public final static <T extends Comparable<T>> void quickSort(List<T> sequence) {  shuffle(sequence);  quickSortImplementation(sequence, 0, sequence.size() - 1); }  private final static <T extends Comparable<T>> void quickSortImplementation(List<T> sequence, int left, int right) {  if (left >= right) return;  int lessThen = left;  int greaterThen = right;  int i = left;  T value = sequence.get(left);  while (i <= greaterThen) {  int cmp = sequence.get(i).compareTo(value);  if (cmp < 0) swap(sequence, i++, lessThen++);  else if (cmp > 0) swap(sequence, i, greaterThen--);  else ++i;  }  quickSortImplementation(sequence, left, lessThen - 1);  quickSortImplementation(sequence, greaterThen + 1, right); }  public final static void quickSort(int[] sequence) {  shuffle(sequence);  quickSortImplementation(sequence, 0, sequence.length - 1); }  private final static void quickSortImplementation(int[] sequence, int left, int right) {  if (left >= right) return;  int lessThen = left;  int greaterThen = right;  int i = left;  int value = sequence[left];  while (i <= greaterThen) {  if (sequence[i] < value) swap(sequence, i++, lessThen++);  else if (sequence[i] > value) swap(sequence, i, greaterThen--);  else ++i;  }  quickSortImplementation(sequence, left, lessThen - 1);  quickSortImplementation(sequence, greaterThen + 1, right); }  public final static void quickSort(long[] sequence) {  shuffle(sequence);  quickSortImplementation(sequence, 0, sequence.length - 1); }  private final static void quickSortImplementation(long[] sequence, int left, int right) {  if (left >= right) return;  int lessThen = left;  int greaterThen = right;  int i = left;  long value = sequence[left];  while (i <= greaterThen) {  if (sequence[i] < value) swap(sequence, i++, lessThen++);  else if (sequence[i] > value) swap(sequence, i, greaterThen--);  else ++i;  }  quickSortImplementation(sequence, left, lessThen - 1);  quickSortImplementation(sequence, greaterThen + 1, right); }  public final static void quickSort(char[] sequence) {  shuffle(sequence);  quickSortImplementation(sequence, 0, sequence.length - 1); }  private final static void quickSortImplementation(char[] sequence, int left, int right) {  if (left >= right) return;  int lessThen = left;  int greaterThen = right;  int i = left;  char value = sequence[left];  while (i <= greaterThen) {  if (sequence[i] < value) swap(sequence, i++, lessThen++);  else if (sequence[i] > value) swap(sequence, i, greaterThen--);  else ++i;  }  quickSortImplementation(sequence, left, lessThen - 1);  quickSortImplementation(sequence, greaterThen + 1, right); }  public final static void quickSort(double[] sequence) {  shuffle(sequence);  quickSortImplementation(sequence, 0, sequence.length - 1); }  private final static void quickSortImplementation(double[] sequence, int left, int right) {  if (left >= right) return;  int lessThen = left;  int greaterThen = right;  int i = left;  double value = sequence[left];  while (i <= greaterThen) {  if (sequence[i] < value) swap(sequence, i++, lessThen++);  else if (sequence[i] > value) swap(sequence, i, greaterThen--);  else ++i;  }  quickSortImplementation(sequence, left, lessThen - 1);  quickSortImplementation(sequence, greaterThen + 1, right); }  public final static void quickSort(boolean[] sequence) {  shuffle(sequence);  quickSortImplementation(sequence, 0, sequence.length - 1); }  private final static void quickSortImplementation(boolean[] sequence, int left, int right) {  if (left >= right) return;  int lessThen = left;  int greaterThen = right;  int i = left;  boolean value = sequence[left];  while (i <= greaterThen) {  if (!sequence[i] && value) swap(sequence, i++, lessThen++);  else if (sequence[i] && !value) swap(sequence, i, greaterThen--);  else ++i;  }  quickSortImplementation(sequence, left, lessThen - 1);  quickSortImplementation(sequence, greaterThen + 1, right); }  public final static void quickSort(short[] sequence) {  shuffle(sequence);  quickSortImplementation(sequence, 0, sequence.length - 1); }  private final static void quickSortImplementation(short[] sequence, int left, int right) {  if (left >= right) return;  int lessThen = left;  int greaterThen = right;  int i = left;  short value = sequence[left];  while (i <= greaterThen) {  if (sequence[i] < value) swap(sequence, i++, lessThen++);  else if (sequence[i] > value) swap(sequence, i, greaterThen--);  else ++i;  }  quickSortImplementation(sequence, left, lessThen - 1);  quickSortImplementation(sequence, greaterThen + 1, right); }  public final static void quickSort(byte[] sequence) {  shuffle(sequence);  quickSortImplementation(sequence, 0, sequence.length - 1); }  private final static void quickSortImplementation(byte[] sequence, int left, int right) {  if (left >= right) return;  int lessThen = left;  int greaterThen = right;  int i = left;  byte value = sequence[left];  while (i <= greaterThen) {  if (sequence[i] < value) swap(sequence, i++, lessThen++);  else if (sequence[i] > value) swap(sequence, i, greaterThen--);  else ++i;  }  quickSortImplementation(sequence, left, lessThen - 1);  quickSortImplementation(sequence, greaterThen + 1, right); }   public static <T> ArrayList<T> unique(ArrayList<T> sequence) {  int size = 1;  for (int i = 1; i < sequence.size(); ++i)  if (!sequence.get(i).equals(sequence.get(i - 1)))   ++size;  ArrayList<T> newSequence = new ArrayList<T>(size);  newSequence.add(sequence.get(0));  for (int i = 1; i < sequence.size(); ++i)  if (!sequence.get(i).equals(sequence.get(i - 1)))   newSequence.add(sequence.get(i));  return newSequence; }  public static <T> T[] unique(T[] sequence) {  int size = 1;  for (int i = 1; i < sequence.length; ++i)  if (!sequence[i].equals(sequence[i - 1]))   ++size;  T[] newSequence = (T[]) new Object[size];  newSequence[0] = sequence[0];  size = 0;  for (int i = 1; i < sequence.length; ++i)  if (!sequence[i].equals(sequence[i - 1]))   newSequence[++size] = sequence[i];  return newSequence; }  public static int[] unique(int[] sequence) {  int size = 1;  for (int i = 1; i < sequence.length; ++i)  if (sequence[i] != sequence[i - 1])   ++size;  int[] newSequence = new int[size];  newSequence[0] = sequence[0];  size = 0;  for (int i = 1; i < sequence.length; ++i)  if (sequence[i] != sequence[i - 1])   newSequence[++size] = sequence[i];  return newSequence; }  public static long[] unique(long[] sequence) {  int size = 1;  for (int i = 1; i < sequence.length; ++i)  if (sequence[i] != sequence[i - 1])   ++size;  long[] newSequence = new long[size];  newSequence[0] = sequence[0];  size = 0;  for (int i = 1; i < sequence.length; ++i)  if (sequence[i] != sequence[i - 1])   newSequence[++size] = sequence[i];  return newSequence; }  public static char[] unique(char[] sequence) {  int size = 1;  for (int i = 1; i < sequence.length; ++i)  if (sequence[i] != sequence[i - 1])   ++size;  char[] newSequence = new char[size];  newSequence[0] = sequence[0];  size = 0;  for (int i = 1; i < sequence.length; ++i)  if (sequence[i] != sequence[i - 1])   newSequence[++size] = sequence[i];  return newSequence; }  public static double[] unique(double[] sequence) {  int size = 1;  for (int i = 1; i < sequence.length; ++i)  if (sequence[i] != sequence[i - 1])   ++size;  double[] newSequence = new double[size];  newSequence[0] = sequence[0];  size = 0;  for (int i = 1; i < sequence.length; ++i)  if (sequence[i] != sequence[i - 1])   newSequence[++size] = sequence[i];  return newSequence; }  public static boolean[] unique(boolean[] sequence) {  int size = 1;  for (int i = 1; i < sequence.length; ++i)  if (sequence[i] != sequence[i - 1])   ++size;  boolean[] newSequence = new boolean[size];  newSequence[0] = sequence[0];  size = 0;  for (int i = 1; i < sequence.length; ++i)  if (sequence[i] != sequence[i - 1])   newSequence[++size] = sequence[i];  return newSequence; }  public static short[] unique(short[] sequence) {  int size = 1;  for (int i = 1; i < sequence.length; ++i)  if (sequence[i] != sequence[i - 1])   ++size;  short[] newSequence = new short[size];  newSequence[0] = sequence[0];  size = 0;  for (int i = 1; i < sequence.length; ++i)  if (sequence[i] != sequence[i - 1])   newSequence[++size] = sequence[i];  return newSequence; }  public static byte[] unique(byte[] sequence) {  int size = 1;  for (int i = 1; i < sequence.length; ++i)  if (sequence[i] != sequence[i - 1])   ++size;  byte[] newSequence = new byte[size];  newSequence[0] = sequence[0];  size = 0;  for (int i = 1; i < sequence.length; ++i)  if (sequence[i] != sequence[i - 1])   newSequence[++size] = sequence[i];  return newSequence; } }
5,public class c { public static void main(String[] args)  throws IOException {  BufferedReader r =   new BufferedReader(new InputStreamReader(System.in), 1);  String s = r.readLine();  int n = Integer.parseInt(s);  String s2 = r.readLine();  StringTokenizer st = new StringTokenizer(s2," ");  int a[] = new int[n];  for (int i = 0; i < n; i++)  a[i] = Integer.parseInt(st.nextToken());  Arrays.sort(a);  if (a[n - 1] == 1) a[n - 1] = 2;  else {a[n - 1] = 1; Arrays.sort(a);}  for (int i = 0; i < n; i++)  System.out.println(a[i]); } }
2,public class B {  public static void main(String[] args) throws IOException {  MyScanner sc = new MyScanner();  PrintWriter out = new PrintWriter(System.out);  int N = sc.nextInt();  if (N / 2 % 2 == 1) {  output(-1, out);  } else {  int half = N / 2;  int l = 1, r = half;  int first = query(half, out, sc);  int next = query(2 * half, out, sc);  if (first == next) {   output(half, out);   return;  }  boolean less = first < next;  while (l + 1 < r) {   int med = (l + r) / 2;   first = query(med, out, sc);   next = query(med + half, out, sc);   if (first == next) {   output(med, out);   return;   } else if (first < next == less) {   r = med;   } else {   l = med + 1;   }  }  output(l, out);  } }  static int query(int pos, PrintWriter out, MyScanner sc) {  out.println("? " + pos);  out.flush();  return sc.nextInt(); }  static void output(int pos, PrintWriter out) {  out.println("! " + pos);  out.flush(); }  static class MyScanner {  private BufferedReader br;  private StringTokenizer tokenizer;   public MyScanner() {  br = new BufferedReader(new InputStreamReader(System.in));  }   public String next() {  while (tokenizer == null || !tokenizer.hasMoreTokens()) {   try {   tokenizer = new StringTokenizer(br.readLine());   } catch (IOException e) {   throw new RuntimeException(e);   }  }  return tokenizer.nextToken();  }   public int nextInt() {  return Integer.parseInt(next());  }   public long nextLong() {  return Long.parseLong(next());  } } }
6,public class B {  BufferedReader br;  PrintWriter out;  StringTokenizer st;  boolean eof;   int[] level;  int[] loyal;  double ans;  int n, k, plLev, needVotes;   double check() {        double res = 0;   for (int mask = 0; mask < (1 << n); mask++) {    double prob = 1;    int vote = 0;    int kill = 0;    for (int i = 0; i < n; i++)     if (((mask >> i) & 1) == 1) {      prob *= loyal[i] / 100.0;      vote++;     }     else {      prob *= 1 - loyal[i] / 100.0;      kill += level[i];     }    if (vote >= needVotes)     res += prob;    else     res += prob * plLev / (kill + plLev);   }     return res;  }   void go(int ind, int candy) {   if (ind == n) {    ans = Math.max(ans, check());    return;   }     for (int i = 0; i <= candy; i++) {    loyal[ind] += 10 * i;    if (loyal[ind] > 100) {     loyal[ind] -= 10 * i;     break;    }    go(ind + 1, candy - i);    loyal[ind] -= 10 * i;   }    }    void solve() throws IOException {     n = nextInt();   k = nextInt();   plLev = nextInt();   needVotes = n / 2 + 1;   ans = 0;     level = new int[n];   loyal = new int[n];     for (int i = 0; i < n; i++) {    level[i] = nextInt();    loyal[i] = nextInt();   }     go(0, k);     out.printf("%.12f", ans);  }  void inp() throws IOException {   Locale.setDefault(Locale.US);   br = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);   solve();   out.close();  }  public static void main(String[] args) throws IOException {   new B().inp();  }  String nextToken() {   while (st == null || !st.hasMoreTokens()) {    try {     st = new StringTokenizer(br.readLine());    } catch (Exception e) {     eof = true;     return "0";    }   }   return st.nextToken();  }  String nextString() {   while (st == null || !st.hasMoreTokens()) {    try {     st = new StringTokenizer(br.readLine());    } catch (Exception e) {     eof = true;     return "0";    }   }   return st.nextToken("\n");  }  int nextInt() throws IOException {   return Integer.parseInt(nextToken());  }  long nextLong() throws IOException {   return Long.parseLong(nextToken());  }  double nextDouble() throws IOException {   return Double.parseDouble(nextToken());  } }
6,public class ProblemE_16 {   final boolean ONLINE_JUDGE = System.getProperty("ONLINE_JUDGE")!=null;  BufferedReader in;  PrintWriter out;  StringTokenizer tok = new StringTokenizer("");   void init() throws FileNotFoundException{   if (ONLINE_JUDGE){    in = new BufferedReader(new InputStreamReader(System.in));    out = new PrintWriter(System.out);   }else{    in = new BufferedReader(new FileReader("input.txt"));    out = new PrintWriter("output.txt");   }  }   String readString() throws IOException{   while(!tok.hasMoreTokens()){    tok = new StringTokenizer(in.readLine());   }   return tok.nextToken();  }   int readInt() throws IOException{   return Integer.parseInt(readString());  }   long readLong() throws IOException{   return Long.parseLong(readString());  }   double readDouble() throws IOException{   return Double.parseDouble(readString());  }   public static void main(String[] args){   new ProblemE_16().run();  }   public void run(){   try{    long t1 = System.currentTimeMillis();    init();    solve();    out.close();    long t2 = System.currentTimeMillis();    System.err.println("Time = "+(t2-t1));   }catch (Exception e){    e.printStackTrace(System.err);    System.exit(-1);   }  }   void solve() throws IOException{   int n = readInt();   double[][] a = new double[n][n];   for (int i = 0; i < n; i++){    for (int j = 0; j < n; j++){     a[i][j] = readDouble();    }   }   double[] d = new double[1<<n];   d[(1 << n) - 1] = 1;   for (int i = (1 << n) - 1; i > 0; i--){    ArrayList<Integer> list = new ArrayList<Integer>();    for (int j = 0; j < n; j++){     if ((i & (1 << j)) != 0) list.add(j);    }    double s = 0;    for (int j = 0; j < list.size(); j++){     s = 0;     for (int k = 0; k < list.size(); k++){      s += a[list.get(k)][list.get(j)];     }     d[i ^ (1 << list.get(j))] += s * d[i] * 2 / list.size() / (list.size() - 1);    }   }   for (int i = 0; i < n; i++){    out.printf(Locale.US, "%.9f", d[1 << i]);    out.print(" ");   }  }   static int[][] step8 = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {1, -1}, {-1, 1}, {1, 1}};   static int[][] stepKnight = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};   static long gcd(long a, long b){   if (a == 0) return b;   return gcd(b % a, a);  }   static long lcm(long a, long b){   return a / gcd(a, b)*b;  }  static long[] gcdPlus(long a, long b){   long[] d = new long[3];   if (a == 0){    d[0] = b;    d[1] = 0;    d[2] = 1;   }else{    d = gcdPlus(b % a, a);    long r = d[1];    d[1] = d[2] - b/a*d[1];    d[2] = r;   }   return d;  }   static long binpow(long a, int n){   if (n == 0) return 1;   if ((n & 1) == 0){    long b = binpow(a, n/2);    return b*b;   }else return binpow(a, n - 1)*a;  }   static long binpowmod(long a, int n, long m){   if (m == 1) return 0;   if (n == 0) return 1;   if ((n & 1) == 0){    long b = binpowmod(a, n/2, m);    return (b*b) % m;   }else return binpowmod(a, n - 1, m)*a % m;  }   static long phi(long n){   int[] p = Sieve((int)ceil(sqrt(n)) + 2);   long phi = 1;   for (int i = 0; i < p.length; i++){    long x = 1;    while (n % p[i] == 0){     n /= p[i];     x *= p[i];    }    phi *= x - x/p[i];   }   if (n != 1) phi *= n - 1;   return phi;  }   static long f(long n, int x, int k){   if (n == 0) return 1;   long b = binpow(10, x - 1);   long c = n / b;   return (c < k? c: k)*binpow(k, x - 1) + (c < k? 1: 0)*f(n % b, x - 1, k);  }   static long fib(int n){   if (n == 0) return 0;   if ((n & 1) == 0){    long f1 = fib(n/2 - 1);    long f2 = fib(n/2 + 1);    return f2*f2 - f1*f1;   }else{    long f1 = fib(n/2);    long f2 = fib(n/2 + 1);    return f1*f1 + f2*f2;   }  }   static BigInteger BigFib(int n){   if (n == 0) return BigInteger.ZERO;   if ((n & 1) == 0){    BigInteger f1 = BigFib(n/2 - 1);    f1 = f1.multiply(f1);    BigInteger f2 = BigFib(n/2 + 1);    f2 = f2.multiply(f2);    return f2.subtract(f1);   }else{    BigInteger f1 = BigFib(n/2);    f1 = f1.multiply(f1);    BigInteger f2 = BigFib(n/2 + 1);    f2 = f2.multiply(f2);    return f2.add(f1);   }  }   static public class PointD{     double x, y;     public PointD(double x, double y){    this.x = x;    this.y = y;   }  }   static double d(Point p1, Point p2){   return sqrt(d2(p1, p2));  }   static public double d(PointD p1, PointD p2){   return sqrt(d2(p1, p2));  }   static double d2(Point p1, Point p2){   return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);  }   static public double d2(PointD p1, PointD p2){   return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);  }   static boolean IsProbablyPrime(long n){   if (n == 1) return false;   if ((n & 1) == 0) return false;   for (int j = 3; j < sqrt(n) + 1; j += 2){    if (n % j == 0) return false;   }   return true;  }  static int[] Sieve(int n){   boolean[] b = new boolean[n+1];   Arrays.fill(b, true);   b[0] = false;   b[1] = false;   long nLong = n;   int j=0;   for (int i = 1; i <= n; i++) {    if (b[i]){     j++;     if (((long)i)*i <= nLong) {      for (int k = i*i; k <= n; k += i) {       b[k] = false;      }     }    }   }   int[] p = new int[j];   Arrays.fill(p, 0);   j=0;   for (int i = 2; i <= n; i++) {    if (b[i]){     p[j]=i;     j++;    }   }   return p;  }   static int[][] Palindromes(String s){   char[] c = s.toCharArray();   int n = c.length;   int[][] d = new int[2][n];   int l = 0, r = -1;   for (int i = 0; i < n; i++){    int j = (i > r? 0: min(d[0][l+r-i+1], r-i+1)) + 1;    for (; i - j >= 0 && i + j - 1< n && c[i-j] == c[i+j-1]; j++);    d[0][i] = --j;    if (i + d[0][i] - 1 > r){     r = i + d[0][i] - 1;     l = i - d[0][i];    }   }   l = 0;   r = -1;   for (int i = 0; i < n; i++){    int j = (i > r? 0: min(d[1][l+r-i], r-i)) + 1;    for (; i - j >= 0 && i + j < n && c[i-j] == c[i+j]; j++);    d[1][i] = --j;    if (i + d[1][i] > r){     r = i + d[1][i];     l = i - d[1][i];    }   }   return d;  }   static public class Permutation {     int[] a;   int n;     public Permutation(int n){    this.n=n;    a=new int[n];    for (int i=0; i<n; i++){     a[i]=i;    }   }     public boolean nextPermutation(){    int i=n-1;    for (i=n-2; i>=0; i--){     if (a[i]<a[i+1]){      break;     }    }    if (i==-1){     return false;    }    int jMin=i+1;    for (int j=n-1; j>i; j--){     if (a[i]<a[j]&&a[j]<a[jMin]){      jMin=j;     }    }    swap(i, jMin);    for (int j=1; j<=(n-i)/2; j++){     swap(i+j, n-j);    }    return true;   }        public int get(int i){    return a[i];   }     void swap(int i, int j){    int r=a[i];    a[i]=a[j];    a[j]=r;   }  }   static public class Fraction implements Comparable<Fraction>, Cloneable{     public final Fraction FRACTION_ZERO = new Fraction();   public final Fraction FRACTION_ONE = new Fraction(1);   public long numerator = 0;   public long denominator = 1;     public Fraction(){    numerator = 0;    denominator = 1;   }     public Fraction(long numerator){    this.numerator = numerator;    denominator = 1;   }     public Fraction(long numerator, long denominator){    this.numerator = numerator;    this.denominator = denominator;    Cancellation();   }     public Fraction(double numerator, double denominator, int accuracy){    this.numerator = (long)(numerator*pow(10,accuracy));    this.denominator = (long)(denominator*pow(10,accuracy));    Cancellation();   }     public Fraction(String s){    if (s.charAt(0) == '-'){     denominator = -1;     s = s.substring(1);    }    if (s.indexOf("/") != -1){     denominator *= Integer.parseInt(s.substring(s.indexOf("/") + 1));    }    if (s.indexOf(" ") != -1){     numerator = Integer.parseInt(s.substring(0, s.indexOf(" "))) * abs(denominator) + Integer.parseInt(s.substring(s.indexOf(" ") + 1, s.indexOf("/")));    }else{     if (s.indexOf("/") != -1){      numerator = Integer.parseInt(s.substring(0, s.indexOf("/")));     }else{      numerator = Integer.parseInt(s)*abs(denominator);     }    }    this.Cancellation();   }     void Cancellation(){    long g = gcd(abs(numerator), abs(denominator));    numerator /= g;    denominator /= g;    if (denominator < 0){     numerator *= -1;     denominator *= -1;    }   }     public String toString(){    String s = "";    if (numerator == 0){     return "0";    }    if (numerator < 0){     s += "-";    }    if (abs(numerator) >= denominator){     s += Long.toString(abs(numerator) / denominator) + " ";    }    if (abs(numerator) % denominator != 0){     s += Long.toString(abs(numerator) % denominator);    }else{     s = s.substring(0, s.length()-1);    }    if (denominator != 1){     s += "/" + Long.toString(denominator);    }    return s;   }     public Fraction add(Fraction f){    Fraction fResult = new Fraction();    fResult.denominator = lcm(denominator, f.denominator);    fResult.numerator = numerator * fResult.denominator / denominator + f.numerator * fResult.denominator / f.denominator;    fResult.Cancellation();    return fResult;   }     public Fraction subtract(Fraction f){    Fraction fResult = new Fraction();    fResult.denominator = lcm(denominator, f.denominator);    fResult.numerator = numerator * fResult.denominator / denominator - f.numerator * fResult.denominator / f.denominator;    fResult.Cancellation();    return fResult;   }     public Fraction multiply(Fraction f){    Fraction fResult = new Fraction();    fResult.numerator = numerator * f.numerator;    fResult.denominator = denominator * f.denominator;    fResult.Cancellation();    return fResult;   }     public Fraction divide(Fraction f){    Fraction fResult = new Fraction();    fResult.numerator = numerator * f.denominator;    fResult.denominator = denominator * f.numerator;    fResult.Cancellation();    return fResult;   }     @Override   public int compareTo(Fraction f){    long g = gcd(denominator, f.denominator);    long res = numerator * (f.denominator / g) - f.numerator * (denominator / g);    if (res < 0){     return -1;    }    if (res > 0){     return 1;    }    return 0;   }     public Fraction clone(){    Fraction fResult = new Fraction(numerator, denominator);    return fResult;   }     public Fraction floor(){    Fraction fResult = this.clone();    fResult.numerator = (fResult.numerator / fResult.denominator) * fResult.denominator;    return fResult;   }     public Fraction ceil(){    Fraction fResult = this.clone();    fResult.numerator = (fResult.numerator/fResult.denominator + 1) * fResult.denominator;    return fResult;   }     public Fraction binpow(int n){    if (n==0) return FRACTION_ONE;    if ((n&1)==0){     Fraction f=this.binpow(n/2);     return f.multiply(f);    }else return binpow(n-1).multiply(this);   }  }   static public class FenwickTree_1{      int n;   long[] t;     public FenwickTree_1(int n){    this.n = n;    t = new long[n];   }     public long sum(int xl, int xr){    return sum(xr) - sum(xl);   }     public long sum(int x){    long result = 0;    for (int i = x; i >= 0; i = (i & (i + 1)) - 1){     result += t[i];    }    return result;   }     public void update(int x, long delta){    for (int i = x; i < n; i = (i | (i + 1))){     t[i] += delta;    }   }  }   static public class FenwickTree_2{      int n, m;   long[][] t;     public FenwickTree_2(int n, int m){    this.n = n;    this.m = m;    t = new long[n][m];   }     public long sum(int xl, int yl, int xr, int yr){    return sum(xr, yr) - sum(xl - 1, yr) - sum(xr, yl - 1) + sum(xl - 1, yl - 1);   }     public long sum(int x, int y){    long result = 0;    for (int i = x; i >= 0; i = (i & (i + 1)) - 1){     for (int j = y; j >= 0; j = (j & (j + 1)) - 1){      result+=t[i][j];     }    }    return result;   }     public void update(int x, int y, long delta){    for (int i = x; i < n; i = (i | (i + 1))){     for (int j = y; j < m; j = (j | (j + 1))){      t[i][j] += delta;     }    }   }  }   static public class FenwickTree_3{      int n, m, l;   long[][][] t;     public FenwickTree_3(int n, int m, int l){    this.n = n;    this.m = m;    this.l = l;    t = new long[n][m][l];   }     public long sum(int xl, int yl, int zl, int xr, int yr, int zr){    return sum(xr, yr, zr) - sum(xl - 1, yr, zr)    + sum(xl - 1, yr, zl - 1) - sum(xr, yr, zl - 1)    - sum(xr, yl - 1, zr) + sum(xl - 1, yl - 1, zr)    - sum(xl - 1, yl - 1, zl - 1) + sum(xr, yl - 1, zl - 1);   }     public long sum(int x, int y, int z){    long result = 0;    for (int i = x; i >= 0; i = (i & (i + 1)) - 1){     for (int j = y; j >= 0; j = (j & (j + 1)) - 1){      for (int k = z; k >= 0; k = (k & (k + 1)) - 1){       result += t[i][j][k];      }     }    }    return result;   }     public void update(int x, int y, int z, long delta){    for (int i = x; i < n; i = (i | (i + 1))){     for (int j = y; j < n; j = (j | (j + 1))){      for (int k = z; k < n; k = (k | (k + 1))){       t[i][j][k] += delta;      }     }    }   }  } }
5,public class Main implements Runnable { class House implements Comparable<House> {  int x;  int a;  public House(int x, int a) {  this.x = x;  this.a = a;  }  @Override  public int compareTo(House other) {  return x - other.x;  } }              private void solution() throws IOException {  int n = in.nextInt();  int t = in.nextInt();  House[] h = new House[n];  for (int i = 0; i < h.length; ++i) {  h[i] = new House(in.nextInt(), in.nextInt());  }  Arrays.sort(h);  int res = 2;  for (int i = 0; i < h.length - 1; ++i) {  double dist = h[i + 1].x - h[i + 1].a / 2.0 - (h[i].x + h[i].a / 2.0);  if (dist >= t) {   if (dist == t) {   ++res;   } else {   res += 2;   }  }  }  out.println(res); }  public void run() {  try {  solution();  in.reader.close();  out.close();  } catch (Exception e) {  e.printStackTrace();  System.exit(-1);  } }  private class Scanner {  private BufferedReader reader;  private StringTokenizer tokenizer;  public Scanner(Reader reader) {  this.reader = new BufferedReader(reader);  this.tokenizer = new StringTokenizer("");  }  public boolean hasNext() throws IOException {  while (!tokenizer.hasMoreTokens()) {   String next = reader.readLine();   if (next == null) {   return false;   }   tokenizer = new StringTokenizer(next);  }  return true;  }  public String next() throws IOException {  hasNext();  return tokenizer.nextToken();  }  public int nextInt() throws IOException {  return Integer.parseInt(next());  }  public String nextLine() throws IOException {  tokenizer = new StringTokenizer("");  return reader.readLine();  } }  public static void main(String[] args) throws IOException {  new Thread(null, new Main(), "", 1 << 28).start(); } PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out))); Scanner in = new Scanner(new InputStreamReader(System.in)); }
5,public class CFA {  BufferedReader br;  PrintWriter out;  StringTokenizer st;  boolean eof;  private static long MOD = 1000L * 1000L * 1000L + 7;  private static final int[] dx = {0, -1, 0, 1};  private static final int[] dy = {1, 0, -1, 0};  private static final String yes = "Yes";  private static final String no = "No";  int n;  int m;  char[][] mat;  long base = 397;  void solve() throws IOException {   n = nextInt();   m = nextInt();   mat = new char[n][m];   for (int i = 0; i < n; i++) {    mat[i] = nextString().toCharArray();   }   int alpha = 26;   long[] pow = new long[alpha];   pow[0] = 1;   for (int i = 1; i < alpha; i++) {    pow[i] = pow[i - 1] * base % MOD;   }   long res = 0;   for (int l = 0; l < m; l++) {       long[] hash = new long[n];    long[] mask = new long[n];    for (int r = l; r < m; r++) {     for (int i = 0; i < n; i++) {      hash[i] += pow[mat[i][r] - 'a'];      hash[i] %= MOD;      mask[i] = mask[i] ^ (1L << (mat[i][r] - 'a'));     }     int start = 0;     while (start < n) {      if ((mask[start] & (mask[start] - 1)) != 0) {       start++;       continue;      }      int end = start;      List<Long> l1 = new ArrayList<>();      while (end < n && (mask[end] & (mask[end] - 1)) == 0) {       l1.add(hash[end]);       end++;      }      start = end;      res += manacher(l1);     }    }   }   outln(res);  }  long manacher(List<Long> arr) {   int len = arr.size();   long[] t = new long[len * 2 + 3];   t[0] = -1;   t[len * 2 + 2] = -2;   for (int i = 0; i < len; i++) {    t[2 * i + 1] = -3;    t[2 * i + 2] = arr.get(i);   }   t[len * 2 + 1] = -3;   int[] p = new int[t.length];   int center = 0, right = 0;   for (int i = 1; i < t.length - 1; i++) {    int mirror = 2 * center - i;    if (right > i) {     p[i] = Math.min(right - i, p[mirror]);    }        while (t[i + (1 + p[i])] == t[i - (1 + p[i])]) {     p[i]++;    }           if (i + p[i] > right) {     center = i;     right = i + p[i];    }   }   long res = 0;   for (int i = 0; i < 2 * len; i++) {    int parLength = p[i + 2];    if (i % 2 == 0) {     res += (parLength + 1) / 2;    }    else {     res += parLength / 2;    }   }   return res;  }  void shuffle(int[] a) {   int n = a.length;   for(int i = 0; i < n; i++) {    int r = i + (int) (Math.random() * (n - i));    int tmp = a[i];    a[i] = a[r];    a[r] = tmp;   }  }  long gcd(long a, long b) {   while(a != 0 && b != 0) {    long c = b;    b = a % b;    a = c;   }   return a + b;  }  private void outln(Object o) {   out.println(o);  }  private void out(Object o) {   out.print(o);  }  private void formatPrint(double val) {   outln(String.format("%.9f%n", val));  }  public CFA() throws IOException {   br = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);   solve();   out.close();  }  public static void main(String[] args) throws IOException {   new CFA();  }  public long[] nextLongArr(int n) throws IOException{   long[] res = new long[n];   for(int i = 0; i < n; i++)    res[i] = nextLong();   return res;  }  public int[] nextIntArr(int n) throws IOException {   int[] res = new int[n];   for(int i = 0; i < n; i++)    res[i] = nextInt();   return res;  }  public String nextToken() {   while (st == null || !st.hasMoreTokens()) {    try {     st = new StringTokenizer(br.readLine());    } catch (Exception e) {     eof = true;     return null;    }   }   return st.nextToken();  }  public String nextString() {   try {    return br.readLine();   } catch (IOException e) {    eof = true;    return null;   }  }  public int nextInt() throws IOException {   return Integer.parseInt(nextToken());  }  public long nextLong() throws IOException {   return Long.parseLong(nextToken());  }  public double nextDouble() throws IOException {   return Double.parseDouble(nextToken());  } }
4,public class CF1187G extends PrintWriter { CF1187G() { super(System.out); } static class Scanner {  Scanner(InputStream in) { this.in = in; } InputStream in;  int k, l; byte[] bb = new byte[1 << 15];  byte getc() {  if (k >= l) {   k = 0;   try { l = in.read(bb); } catch (IOException e) { l = 0; }   if (l <= 0) return -1;  }  return bb[k++];  }  int nextInt() {  byte c = 0; while (c <= 32) c = getc();  int a = 0;  while (c > 32) { a = a * 10 + c - '0'; c = getc(); }  return a;  } } Scanner sc = new Scanner(System.in); public static void main(String[] $) {  CF1187G o = new CF1187G(); o.main(); o.flush(); }  static final int INF = 0x3f3f3f3f; ArrayList[] aa_; int n_, m_; int[] pi, dd, bb; int[] uu, vv, uv, cost; int[] cc; void init() {  aa_ = new ArrayList[n_];  for (int u = 0; u < n_; u++)  aa_[u] = new ArrayList<Integer>();  pi = new int[n_];  dd = new int[n_];  bb = new int[n_];  qq = new int[nq];  iq = new boolean[n_];  uu = new int[m_];  vv = new int[m_];  uv = new int[m_];  cost = new int[m_];  cc = new int[m_ * 2];  m_ = 0; } void link(int u, int v, int cap, int cos) {  int h = m_++;  uu[h] = u;  vv[h] = v;  uv[h] = u ^ v;  cost[h] = cos;  cc[h << 1 ^ 0] = cap;  aa_[u].add(h << 1 ^ 0);  aa_[v].add(h << 1 ^ 1); } int[] qq; int nq = 1 << 20, head, cnt; boolean[] iq; void enqueue(int v) {  if (iq[v])  return;  if (head + cnt == nq) {  if (cnt * 4 <= nq)   System.arraycopy(qq, head, qq, 0, cnt);  else {   int[] qq_ = new int[nq *= 2];   System.arraycopy(qq, head, qq_, 0, cnt);   qq = qq_;  }  head = 0;  }  qq[head + cnt++] = v; iq[v] = true; } int dequeue() {  int u = qq[head++]; cnt--; iq[u] = false;  return u; } boolean spfa(int s, int t) {  Arrays.fill(pi, INF);  pi[s] = 0;  head = cnt = 0;  enqueue(s);  while (cnt > 0) {  int u = dequeue();  int d = dd[u] + 1;  ArrayList<Integer> adj = aa_[u];  for (int h_ : adj)   if (cc[h_] > 0) {   int h = h_ >> 1;   int p = pi[u] + ((h_ & 1) == 0 ? cost[h] : -cost[h]);   int v = u ^ uv[h];   if (pi[v] > p || pi[v] == p && dd[v] > d) {    pi[v] = p;    dd[v] = d;    bb[v] = h_;    enqueue(v);   }   }  }  return pi[t] != INF; } void push(int s, int t) {  int c = INF;  for (int u = t, h_, h; u != s; u ^= uv[h]) {  h = (h_ = bb[u]) >> 1;  c = Math.min(c, cc[h_]);  }  for (int u = t, h_, h; u != s; u ^= uv[h]) {  h = (h_ = bb[u]) >> 1;  cc[h_] -= c; cc[h_ ^ 1] += c;  } } void push1(int s, int t) {  for (int u = t, h_, h; u != s; u ^= uv[h]) {  h = (h_ = bb[u]) >> 1;  cc[h_]--; cc[h_ ^ 1]++;  } } int edmonds_karp(int s, int t) {  while (spfa(s, t))  push1(s, t);  int c = 0;  for (int h = 0; h < m_; h++)  c += cost[h] * cc[h << 1 ^ 1];  return c; } void main() {  int n = sc.nextInt();  int m = sc.nextInt();  int k = sc.nextInt();  int c = sc.nextInt();  int d = sc.nextInt();  int[] ii = new int[k];  for (int h = 0; h < k; h++)  ii[h] = sc.nextInt() - 1;  ArrayList[] aa = new ArrayList[n];  for (int i = 0; i < n; i++)  aa[i] = new ArrayList<Integer>();  for (int h = 0; h < m; h++) {  int i = sc.nextInt() - 1;  int j = sc.nextInt() - 1;  aa[i].add(j);  aa[j].add(i);  }  int t = n + k + 1;  n_ = n * t + 1;  m_ = k + (m * 2 * k + n) * (t - 1);  init();  for (int i = 0; i < n; i++) {  ArrayList<Integer> adj = aa[i];  for (int s = 0; s < t - 1; s++) {   int u = i * t + s;   for (int j : adj) {   int v = j * t + s + 1;   for (int x = 1; x <= k; x++)    link(u, v, 1, c + (x * 2 - 1) * d);   }  }  }  for (int i = 0; i < n; i++)  for (int s = 0; s < t - 1; s++) {   int u = i * t + s, v = u + 1;   link(u, v, k, i == 0 ? 0 : c);  }  for (int h = 0; h < k; h++)  link(n_ - 1, ii[h] * t + 0, 1, 0);  println(edmonds_karp(n_ - 1, 0 * t + t - 1)); } }
4,public class R227_2_D {  static ArrayList<Integer>[] graph;  static int[] right, left;  static boolean vis[];  public static boolean dfs(int node) {   if (vis[node])    return false;   vis[node] = true;   for (int i = 0; i < graph[node].size(); i++) {    int tmp = graph[node].get(i);    if (right[tmp] == -1) {     left[node] = tmp;     right[tmp] = node;     return true;    }   }   for (int i = 0; i < graph[node].size(); i++) {    int tmp = graph[node].get(i);    if (dfs(right[tmp])) {     left[node] = tmp;     right[tmp] = node;     return true;    }   }   return false;  }  public static int getMaxMatch() {   Arrays.fill(left, -1);   Arrays.fill(right, -1);   boolean done = false;   while (!done) {    done = true;    Arrays.fill(vis, false);    for (int i = 0; i < graph.length; i++) {     if (left[i] == -1 && dfs(i)) {      done = false;     }    }   }   int res = 0;   for (int i = 0; i < left.length; i++) {    res += (left[i] != -1 ? 1 : 0);   }   return res;  }  public static void main(String[] args) {   InputReader in = new InputReader(System.in);   PrintWriter out = new PrintWriter(System.out);   int V = in.readInt();   int E = in.readInt();   Point[] edges = new Point[E];   for (int i = 0; i < edges.length; i++) {    edges[i] = new Point(in.readInt() - 1, in.readInt() - 1);   }   int best = Integer.MAX_VALUE;   for (int k = 0; k < V; k++) {    int n = V - 1;    graph = new ArrayList[n];    left = new int[n];    vis = new boolean[n];    right = new int[n];    for (int i = 0; i < graph.length; i++) {     graph[i] = new ArrayList<Integer>();    }    int center = 0;    for (int i = 0; i < E; i++) {     if (edges[i].x == k || edges[i].y == k) {      center++;      continue;     }     int src = edges[i].x > k ? edges[i].x - 1 : edges[i].x;     int dst = edges[i].y > k ? edges[i].y - 1 : edges[i].y;     graph[src].add(dst);    }    int matching = getMaxMatch();    int addToCenterEdges = 2 * V - 1 - center;    int removed = E - center - matching;    int added = n - matching;    best = Math.min(best, added + removed + addToCenterEdges);   }   System.out.println(best);  }  static class InputReader {   private InputStream stream;   private byte[] buf = new byte[1000];   private int curChar, numChars;   public InputReader(InputStream stream) {    this.stream = stream;   }   private int read() {    if (numChars == -1)     throw new InputMismatchException();    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (numChars <= 0)      return -1;    }    return buf[curChar++];   }   public int readInt() {    int c = read();    while (isSpaceChar(c))     c = read();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   public long readLong() {    int c = read();    while (isSpaceChar(c))     c = read();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    long res = 0;    do {     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   public String readString() {    int c = read();    while (isSpaceChar(c))     c = read();    StringBuffer res = new StringBuffer();    do {     res.appendCodePoint(c);     c = read();    } while (!isSpaceChar(c));    return res.toString();   }   private boolean isSpaceChar(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   private String readLine0() {    StringBuffer buf = new StringBuffer();    int c = read();    while (c != '\n' && c != -1) {     buf.appendCodePoint(c);     c = read();    }    return buf.toString();   }   public String readLine() {    String s = readLine0();    while (s.trim().length() == 0)     s = readLine0();    return s;   }   public String readLine(boolean ignoreEmptyLines) {    if (ignoreEmptyLines)     return readLine();    else     return readLine0();   }   public char readCharacter() {    int c = read();    while (isSpaceChar(c))     c = read();    return (char) c;   }   public double readDouble() {    int c = read();    while (isSpaceChar(c))     c = read();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    double res = 0;    while (!isSpaceChar(c) && c != '.') {     if (c == 'e' || c == 'E')      return res * Math.pow(10, readInt());     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    }    if (c == '.') {     c = read();     double m = 1;     while (!isSpaceChar(c)) {      if (c == 'e' || c == 'E')       return res * Math.pow(10, readInt());      if (c < '0' || c > '9')       throw new InputMismatchException();      m /= 10;      res += (c - '0') * m;      c = read();     }    }    return res * sgn;   }  } }
5,public class Sockets {  public static void main(String[] args) {   Scanner in = new Scanner(System.in);   PrintWriter out = new PrintWriter(System.out);   int n = in.nextInt(), m = in.nextInt(), socket = in.nextInt();   int[] filters = new int[n];   for (int i = 0; i < n; i++ ) {    filters[i] = in.nextInt();   }   Arrays.sort(filters);   int result = 0, index = n - 1;   while ( m > socket && index >= 0) {    socket += filters[index] - 1;    result += 1;    index -= 1;   }   out.println(m > socket ? -1 : result);   out.close();  } }
6,public class C{  Scanner sc=new Scanner(System.in);  int INF=1<<28;  double EPS=1e-9;  int n, m;  void run(){   n=sc.nextInt();   m=sc.nextInt();   solve();  }  void solve(){   if(n<m){    int t=n;    n=m;    m=t;   }   int full=(1<<m)-1;   int[][] dp=new int[1<<m][1<<m];   int[][] tmp=new int[1<<m][1<<m];   for(int i=0; i<1<<m; i++){    fill(dp[i], INF);   }   for(int i=0; i<1<<m; i++){    int b1=(i|(i>>1)|(i<<1))&full;    int b2=i;    dp[b1][b2]=Integer.bitCount(i);    debug(Integer.toBinaryString(b1), dp[b1]);   }   debug();   for(int j=0; j<n-1; j++){    for(int i=0; i<1<<m; i++){     System.arraycopy(dp[i], 0, tmp[i], 0, 1<<m);     fill(dp[i], INF);    }    for(int b1=0; b1<1<<m; b1++){     for(int b2=0; b2<1<<m; b2++){      for(int i=0; i<1<<m; i++){       if((b1|i)!=full){        continue;       }       if(false)        debug(Integer.toBinaryString(b1),          Integer.toBinaryString(b2),          Integer.toBinaryString(i));       int b=(i|(i>>1)|(i<<1))&full;       dp[b2|b][i]=min(dp[b2|b][i],         tmp[b1][b2]+Integer.bitCount(i));      }     }    }    debug(j);    for(int i=0; i<1<<m; i++){     debug(Integer.toBinaryString(i), dp[i]);    }   }   int min=INF;   for(int i=0; i<1<<m; i++){    min=min(min, dp[full][i]);   }   debug(min);   int ans=m*n-min;   debug("ans",ans);   println(ans+"");  }  void println(String s){   System.out.println(s);  }  void print(String s){   System.out.print(s);  }  void debug(Object... os){    }  public static void main(String[] args){   new C().run();  } }
3,public class TaskD {  public static void main(String[] args) {  Scanner s = new Scanner(System.in);  int n = s.nextInt();  int[] a = new int[n];  for (int i = 0; i < n; i++) {  a[i] = s.nextInt();  }  int m = s.nextInt();  int inv = 0;   for (int i = 0; i < n; i++) {  for (int j = i + 1; j < n; j++) {   if (a[i] > a[j]) {   inv++;   }  }  }  boolean odd = (inv % 2 == 1);  for (int i = 0; i < m; i++) {  int l = s.nextInt();  int r = s.nextInt() + 1;   int num = (r - l)*(r - l - 1)/2;  if (num % 2 == 1) {   odd = !odd;  }  System.out.println((odd) ? "odd" : "even");  } } }
4,public class Main {  public static void main(String args[])  {   FastReader input=new FastReader();   PrintWriter out=new PrintWriter(System.out);   int T=1;   while(T-->0)   {    int n=input.nextInt();    int m=input.nextInt();    int k=input.nextInt();    int arr1[][]=new int[n+1][m];    for(int i=1;i<=n;i++)    {     for(int j=1;j<m;j++)     {      arr1[i][j]=input.nextInt();     }    }    int arr2[][]=new int[n][m+1];    for(int i=1;i<n;i++)    {     for(int j=1;j<=m;j++)     {      arr2[i][j]=input.nextInt();     }    }    if(k%2==0)    {     int dp[][][]=new int[n+1][m+1][k+1];     for(int l=2;l<=k;l+=2)     {      for(int i=1;i<=n;i++)      {       for(int j=1;j<=m;j++)       {        int min=Integer.MAX_VALUE;        if(j+1<=m)        {         min=Math.min(min,dp[i][j+1][l-2]+2*arr1[i][j]);        }        if(i+1<=n)        {         min=Math.min(min,dp[i+1][j][l-2]+2*arr2[i][j]);        }        if(j-1>=1)        {         min=Math.min(min,dp[i][j-1][l-2]+2*arr1[i][j-1]);        }        if(i-1>=1)        {         min=Math.min(min,dp[i-1][j][l-2]+2*arr2[i-1][j]);        }        dp[i][j][l]=min;       }      }     }     for(int i=1;i<=n;i++)     {      for(int j=1;j<=m;j++)      {       out.print(dp[i][j][k]+" ");      }      out.println();     }    }    else    {     for(int i=1;i<=n;i++)     {      for(int j=1;j<=m;j++)      {       out.print(-1+" ");      }      out.println();     }    }   }   out.close();  }  static class FastReader  {   BufferedReader br;   StringTokenizer st;   public FastReader()   {    br = new BufferedReader(new InputStreamReader(System.in));   }   String next()   {    while (st == null || !st.hasMoreElements())    {     try     {      st = new StringTokenizer(br.readLine());     }     catch (IOException e)     {      e.printStackTrace();     }    }    return st.nextToken();   }   int nextInt()   {    return Integer.parseInt(next());   }   long nextLong()   {    return Long.parseLong(next());   }   double nextDouble()   {    return Double.parseDouble(next());   }   String nextLine()   {    String str="";    try    {     str=br.readLine();    }    catch (IOException e)    {     e.printStackTrace();    }    return str;   }  } }
3,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskF2 solver = new TaskF2();   solver.solve(1, in, out);   out.close();  }  static class TaskF2 {   public void solve(int testNumber, InputReader in, PrintWriter out) {    int n = in.nextInt();    int[] a = new int[n];    for (int i = 0; i < n; i++) {     a[i] = in.nextInt();    }    HashMap<Integer, ArrayList<Interval>> map = new HashMap<>();    for (int i = 0; i < n; i++) {     int sum = 0;     for (int j = i; j < n; j++) {      sum += a[j];      if (map.containsKey(sum) == false) {       map.put(sum, new ArrayList<>());      }      ArrayList<Interval> arr = map.get(sum);      if (arr.isEmpty() || arr.get(arr.size() - 1).r < i) {       arr.add(new Interval(i, j));      } else if (arr.get(arr.size() - 1).r >= j) {       arr.set(arr.size() - 1, new Interval(i, j));      }     }    }    ArrayList<Interval> best = new ArrayList<>();    for (ArrayList<Interval> arr : map.values()) {     if (best.size() < arr.size()) {      best = arr;     }    }    out.println(best.size());    for (Interval i : best) {     out.println((i.l + 1) + " " + (i.r + 1));    }   }   class Interval {    int l;    int r;    Interval(int l, int r) {     this.l = l;     this.r = r;    }   }  }  static class InputReader {   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   private InputStream stream;   public InputReader(InputStream stream) {    this.stream = stream;   }   private boolean isWhitespace(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   private int read() {    if (numChars == -1)     throw new InputMismatchException();    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (numChars <= 0)      return -1;    }    return buf[curChar++];   }   public int nextInt() {    int c = read();    while (isWhitespace(c))     c = read();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    } while (!isWhitespace(c));    return res * sgn;   }  } }
2,public class DigitSeq {  static class FastReader {  BufferedReader br;  StringTokenizer st;   public FastReader()  {   br = new BufferedReader(new   InputStreamReader(System.in));  }   String next()  {   while (st == null || !st.hasMoreElements())   {   try   {    st = new StringTokenizer(br.readLine());   }   catch (IOException e)   {    e.printStackTrace();   }   }   return st.nextToken();  }   int nextInt()  {   return Integer.parseInt(next());  }   long nextLong()  {   return Long.parseLong(next());  }   double nextDouble()  {   return Double.parseDouble(next());  }   String nextLine()  {   String str = "";   try  {   str = br.readLine();   }   catch (IOException e)   {   e.printStackTrace();   }   return str;  }  }  public static void main(String[] args) {  FastReader sc = new FastReader();  OutputStream outputstream = System.out;  PrintWriter out = new PrintWriter(outputstream);  long n = sc.nextLong();  long[] arr = new long[14];  for(int i = 1; i <= 13; i++){  arr[i] = (long)Math.pow(10, i)-(long)Math.pow(10, i-1);  }  long total = 0;  for(int i = 1; i <= 13; i++){  if(total+(long)i*arr[i]>=n){   long ans = n-total;   long rest = ans;   if(ans%i!=0){   ans /= i;   ans++;   } else {   ans /= i;   }   ans += (long)Math.pow(10, i-1)-1;   String str = Long.toString(ans);   int ind = (rest%i==0) ? i-1 : (int)(rest%i)-1;   out.println(str.charAt(ind));   break;  }  total = total+(long)i*arr[i];  }  out.close(); } }
1,public class IQ { public static void main(String[] args) {  Scanner scan = new Scanner(System.in);  int n = scan.nextInt();  int[] a = new int[n];  for(int i = 0; i < n; i++)  a[i] = scan.nextInt();  for(int i = 0; i < n; i++) {  boolean x = a[i] % 2 == 0;  int c = 0;  for(int j = 0; j < n; j++) {   if(x != (a[j] % 2 == 0))   c++;  }  if(c == n-1) {   System.out.println(i+1);   break;  }  } } }
5,public class C{  public static void main(String args[]) {  Scanner in = new Scanner(System.in);  int n=in.nextInt(),key=in.nextInt(),ans=0;  int[] a = new int[101], b = new int[101];  for (int i=1;i<=n;i++) {a[i]=in.nextInt();b[i]=in.nextInt();}  for (int i=1;i<n;i++)  for (int j=i+1;j<=n;j++)   if (a[i]<a[j] || (a[i]==a[j] && b[i]>b[j])) {  int yed = a[i];a[i]=a[j];  a[j]=yed;  yed = b[i];b[i]=b[j];b[j]=yed;   }  int k=0;     for (int i=1;i<=n;i++) {  if (a[i]==a[i-1] && b[i]==b[i-1]) k++; else   {if (i>key && ans==0) ans = k;k=1;}    }  if (ans == 0) ans = k;  System.out.println(ans);   } }
0,public class Counterexample {  public static void main(String[] args) {   System.out.println(new Counterexample().solve());  }  String solve() {   Scanner sc = new Scanner(System.in);   final long l = sc.nextLong();   final long r = sc.nextLong();   if ((r - l) > 1) {    long a = l;    long b = l + 1;    long c = l + 2;    while (a < (r - 1)) {     while (b < r) {      while (c <= r) {       if (gcd(a,b) == 1         && gcd(b,c) == 1         && gcd(a,c) > 1) {        return Long.toString(a)         + " "         + Long.toString(b)         + " "         + Long.toString(c);         }       c += 1;      }      c = b + 1;      b += 1;     }     b = a + 1;     a += 1;    }   }   return "-1";  }  long gcd(long a, long b) {   while (b != 0) {    long t = b;    b = a % b;    a = t;   }   return a;  } }
0,public class TA {  public void solve(long n) {  long a = 0, b = 0;  if (n % 2 == 0) {  if (n % 4 == 0) {   a = n / 2;   b = n/ 2;  } else {   a = n / 2 - 1;   b = n / 2 + 1;  }  } else {  a = 4;  b = n - a;  while (b > 0 && (b % 3 != 0)) {   a += 2;   b = n - a;  }    }  System.out.println(a + " " + b); } public static void main(String[] args) {  FastScanner in = new FastScanner();   new TA().solve(in.nextLong()); } static class FastScanner {  BufferedReader br;  StringTokenizer st;  public FastScanner(String s) {  try {   br = new BufferedReader(new FileReader(s));  } catch (FileNotFoundException e) {   e.printStackTrace();  }  }  public FastScanner() {  br = new BufferedReader(new InputStreamReader(System.in));  }  String nextToken() {  while (st == null || !st.hasMoreElements()) {   try {   st = new StringTokenizer(br.readLine());   } catch (IOException e) {   e.printStackTrace();   }  }  return st.nextToken();  }  int nextInt() {  return Integer.parseInt(nextToken());  }  long nextLong() {  return Long.parseLong(nextToken());  }  double nextDouble() {  return Double.parseDouble(nextToken());  }  } }
6,public class Main {  static final long MOD = 1_000_000_007, INF = 1_000_000_000_000_000_000L;  static final int INf = 1_000_000_000;  static FastReader reader;  static PrintWriter writer;  public static void main(String[] args) {   Thread t = new Thread(null, new O(), "Integer.MAX_VALUE", 100000000);   t.start();  }  static class O implements Runnable {   public void run() {    try {     magic();    }    catch (Exception e) {     e.printStackTrace();     System.exit(1);    }   }  }  static class FastReader {   final private int BUFFER_SIZE = 1 << 16;   private DataInputStream din;   private byte[] buffer;   private int bufferPointer, bytesRead;   public FastReader() {    din = new DataInputStream(System.in);    buffer = new byte[BUFFER_SIZE];    bufferPointer = bytesRead = 0;   }   public FastReader(String file_name) throws IOException {    din = new DataInputStream(new FileInputStream(file_name));    buffer = new byte[BUFFER_SIZE];    bufferPointer = bytesRead = 0;   }   public String readLine() throws IOException {    byte[] buf = new byte[1000000];    int cnt = 0, c;    while ((c = read()) != -1) {     if (c == '\n') break;     buf[cnt++] = (byte) c;    }    return new String(buf, 0, cnt);   }   public int nextInt() throws IOException {    int ret = 0;    byte c = read();    while (c <= ' ') c = read();    boolean neg = (c == '-');    if (neg) c = read();    do {     ret = ret * 10 + c - '0';    } while ((c = read()) >= '0' && c <= '9');    if (neg) return -ret;    return ret;   }   public long nextLong() throws IOException {    long ret = 0;    byte c = read();    while (c <= ' ') c = read();    boolean neg = (c == '-');    if (neg) c = read();    do {     ret = ret * 10 + c - '0';    } while ((c = read()) >= '0' && c <= '9');    if (neg) return -ret;    return ret;   }   public double nextDouble() throws IOException {    double ret = 0, div = 1;    byte c = read();    while (c <= ' ') c = read();    boolean neg = (c == '-');    if (neg) c = read();    do {     ret = ret * 10 + c - '0';    } while ((c = read()) >= '0' && c <= '9');    if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') / (div *= 10);    if (neg) return -ret;    return ret;   }   private void fillBuffer() throws IOException {    bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);    if (bytesRead == -1) buffer[0] = -1;   }   private byte read() throws IOException {    if (bufferPointer == bytesRead) fillBuffer();    return buffer[bufferPointer++];   }   public void close() throws IOException {    if (din == null) return;    din.close();   }  }  static int n,m,pre[][], pre_stop_and_start[][],mat[][], dp[][][];  static void magic() throws IOException {   reader = new FastReader();   writer = new PrintWriter(System.out, true);   n = reader.nextInt();   m = reader.nextInt();   mat = new int[n][m];   for(int i=0;i<n;++i) {    for(int j=0;j<m;++j) {     mat[i][j] = reader.nextInt();    }   }   if(n==1) {    int ans = Integer.MAX_VALUE;    for(int i=0;i+1<m;++i) {     ans = min(ans, abs(mat[0][i] - mat[0][i+1]));    }    writer.println(ans);    System.exit(0);   }   pre = new int[n][n];   pre_stop_and_start = new int[n][n];   for(int i=0;i<n;++i) {    for(int j=i+1;j<n;++j) {     int min = Integer.MAX_VALUE;     for(int k=0;k<m;++k) {      min = min(min, abs(mat[i][k] - mat[j][k]));     }     pre[i][j] = pre[j][i] = min;    }   }   for(int i=0;i<n;++i) {    for(int j=0;j<n;++j) {     if(j==i) {      continue;     }     int min = Integer.MAX_VALUE;     for(int k=0;k+1<m;++k) {      min = min(min, abs(mat[j][k+1] - mat[i][k]));     }     pre_stop_and_start[i][j] = min;    }   }           dp = new int[1<<n][n][n];   for(int i=0;i<(1<<n);++i) {    for(int j=0;j<n;++j) {     for(int k=0;k<n;++k) {      dp[i][j][k] = -1;     }    }   }   int ans = 0;   for(int i=0;i<n;++i) {    ans = max(ans, f((1<<i), i, i));   }   writer.println(ans);  }  static int f(int mask_already, int prev, int first) {   if(mask_already==(1<<n) - 1) {    return pre_stop_and_start[prev][first];   }   if(dp[mask_already][prev][first] != -1) {    return dp[mask_already][prev][first];   }   int max = 0;   for(int i=0;i<n;++i) {    if((mask_already&(1<<i)) == 0) {     max = max(max, min(pre[prev][i], f(mask_already|(1<<i), i, first)));    }   }   return dp[mask_already][prev][first] = max;  } }
2,public class TaskB {  void run() {   FastReader in = new FastReader(System.in);   PrintWriter out = new PrintWriter(System.out);    long n = in.nextLong();   long k = in.nextLong();   long a = 1;   long b = -(2 * n + 3);   long c = n * n + n - 2 * k;   long d = b * b - 4 * a * c;   long ans1 = (-b + (long) Math.sqrt(d)) / 2;   long ans2 = (-b - (long) Math.sqrt(d)) / 2;   if (ans1 >= 0 && ans1 <= n) {    out.println(ans1);   } else {    out.println(ans2);   }    out.close();  }  class FastReader {   BufferedReader br;   StringTokenizer st;   FastReader(InputStream is) {    br = new BufferedReader(new InputStreamReader(is));   }   Integer nextInt() {    return Integer.parseInt(next());   }   Long nextLong() {    return Long.parseLong(next());   }   Double nextDouble() {    return Double.parseDouble(next());   }   String next() {    while (st == null || !st.hasMoreTokens())     st = new StringTokenizer(nextLine());    return st.nextToken();   }   String nextLine() {    String s = "";    try {     s = br.readLine();    } catch (IOException e) {     e.printStackTrace();    }    return s;   }  }   public static void main(String[] args) {   new TaskB().run();  } }
0,public class C344C {  public static void main(String[] args) {  Scanner sc = new Scanner(System.in);  long a = sc.nextLong();  long b = sc.nextLong();  long count = a / b, c;  a = a % b;  while(true){  if (a <= 1 || b <= 1) break;  c = b - a;  b = a;  a = c;  count++;  if (a > b) count += a / b;  a = a % b;  }  if (b > 1) count += b;  System.out.println(count);  sc.close(); } }
6,public class task { public static void main(String args[]) {  Scanner a = new Scanner(System.in);   while(a.hasNext())  {  int n = a.nextInt();  int m = a.nextInt();  if(n == 0 && m == 0) break;     boolean[][] adj = new boolean[n][n];  long res = 0;    for (int i = 0; i < m; ++i) {   int x = a.nextInt();   int y = a.nextInt();   adj[x - 1][y - 1] = true;   adj[y - 1][x - 1] = true;  }    for (int i = 0; i < n; ++i)   for (int j = i + 1; j < n; ++j)    if (adj[i][j])    --res;      for (int i = 0; i < n; ++i)   {   long[][] dp = new long[n - i][1 << (n - i)];   dp[0][0] = 1;   for (int mask = 0; mask < (1 << (n - i)); ++mask)   {   for (int j = 0; j < n - i; ++j)    {    if (dp[j][mask] != 0)    {    for (int k = 0; k < n - i; ++k)     {     if (((mask >> k) & 1) == 0 && adj[j + i][k + i])      dp[k][mask | (1 << k)] += dp[j][mask];         }    }   }   if (((mask >> 0) & 1) != 0) {    res += dp[0][mask];   }   }  }  System.out.println(res/2);  } } }
0,public class A483 {  public static void main(String[] args) {   Scanner sc = new Scanner(System.in);   BigInteger l = sc.nextBigInteger();   BigInteger r = sc.nextBigInteger();     if (r.subtract(l).compareTo(new BigInteger("2")) == -1) {    System.out.println("-1");   } else if (r.subtract(l).compareTo(new BigInteger("2")) == 0 && l.mod(new BigInteger("2")) != BigInteger.ZERO) {    System.out.println("-1");   } else if (l.mod(new BigInteger("2")) != BigInteger.ZERO) {    System.out.println(l.add(BigInteger.ONE) + " " + l.add(BigInteger.ONE).add(BigInteger.ONE) + " " + l.add(BigInteger.ONE).add(BigInteger.ONE).add(BigInteger.ONE));   } else {    System.out.println(l + " " + l.add(BigInteger.ONE) + " " + l.add(BigInteger.ONE).add(BigInteger.ONE));   }  } }
5,public class Main {  public static void main (String [] args) throws IOException {   BufferedReader br = new BufferedReader (new InputStreamReader(System.in));   int n = Integer.parseInt(br.readLine());   int [] nums = new int[n];   args = br.readLine().split(" ");   for (int i = 0; i < n; i++) {    nums[i] = Integer.parseInt(args[i]);   }   Arrays.sort(nums);   int min = nums[0];   for (int i = 1; i < n; i++) {    if (nums[i]>min) {     System.out.println(nums[i]); return;    }   }   System.out.println("NO");  } }
1,public class A {  public static void main(String[] args)throws Throwable {   MyScanner sc=new MyScanner();   PrintWriter pw=new PrintWriter(System.out);   int n=sc.nextInt();   String [] s={"M","L","S","XL","XS","XXL","XXS","XXXL","XXXS"};   int [] cnt=new int [9];   for(int i=0;i<n;i++){    String t=sc.next();    for(int j=0;j<9;j++)     if(t.equals(s[j]))      cnt[j]++;   }   for(int i=0;i<n;i++){    String t=sc.next();    for(int j=0;j<9;j++)     if(t.equals(s[j]))      cnt[j]--;   }   for(int i=0;i<9;i++)    cnt[i]=Math.abs(cnt[i]);   int ans=0;   for(int i=0;i<9;i++)    ans+=cnt[i];   pw.println(ans/2);   pw.flush();   pw.close();  }  static class MyScanner {   BufferedReader br;   StringTokenizer st;   public MyScanner() {    br = new BufferedReader(new InputStreamReader(System.in));   }   String next() {while (st == null || !st.hasMoreElements()) {    try {st = new StringTokenizer(br.readLine());}    catch (IOException e) {e.printStackTrace();}}    return st.nextToken();}   int nextInt() {return Integer.parseInt(next());}   long nextLong() {return Long.parseLong(next());}   double nextDouble() {return Double.parseDouble(next());}   String nextLine(){String str = "";    try {str = br.readLine();}    catch (IOException e) {e.printStackTrace();}    return str;}  } }
3,public class c {  public static void main(String[] args) {   Scanner in = new Scanner(System.in);  int numbOfStatements = in.nextInt();  long[] dp = new long[numbOfStatements];  dp[0] = 1L;  boolean priorFor = in.next().equals("f");   for(int i=0; i<numbOfStatements-1; i++)  {  String type = in.next();  if (priorFor) {   for(int j=numbOfStatements-1;j>0;j--) {   dp[j] = dp[j-1];   }   dp[0] = 0L;  } else {   long sum = 0;   for(int j = numbOfStatements - 1; j >= 0; --j) {   sum = (sum + dp[j]) % 1000000007;   dp[j] = sum;   }  }  priorFor = type.equals("f");  }  long ans = 0;  for(int j=0; j<numbOfStatements; j++) {  ans = (ans + dp[j]) % 1000000007;  }  System.out.println(ans); } }
3,public class algo_2701 {  public static void main(String args[])  {   Scanner ex=new Scanner(System.in);   int n=ex.nextInt();   int arr[]=new int[n];   for(int i=0;i<n;i++)   arr[i]=ex.nextInt();   Arrays.sort(arr);   int ans=0;   int check[]=new int[n];   for(int i=0;i<n;i++)   {    if(check[i]==0)    {     ans++;     for(int j=i;j<n;j++)     {      if(arr[j]%arr[i]==0)      check[j]=1;     }    }   }   System.out.println(ans);  } }
6,public class A {  public static int n;  public static double[] masks;  public static double[][] matrix;  public static void main(String[] args) {   Scanner scan = new Scanner(System.in);   n = scan.nextInt();   matrix = new double[n][n];   for (int i = 0; i < n; i++)    for (int j = 0; j < n; j++)     matrix[i][j] = scan.nextDouble();   masks = new double[1 << n];   masks[(1 << n) - 1] = 1;   for (int i = 0; (1 << i) < (1 << n); i++)    fillDP(1 << i);   for (int i = 0; (1 << i) < (1 << n); i++)    System.out.printf("%.6f ", masks[1 << i]);   }  public static double fillDP(int mask) {   int bitCount = Integer.bitCount(mask);   if (masks[mask] != 0)    return masks[mask];   double matchProba = 2.0 / (((double) (bitCount)) * ((double) (bitCount + 1)));   double totalProba = 0;   for (int i = 0; i < n; i++) {    int iPower = 1 << i;    if ((mask & iPower) != iPower)     continue;    for (int j = 0; j < n; j++) {     int jPower = 1 << j;     if ((mask & jPower) == jPower || i == j)      continue;          totalProba += (matchProba * matrix[i][j] * fillDP(mask | jPower));    }   }   return masks[mask] = totalProba;  } }
3,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   OutputWriter out = new OutputWriter(outputStream);   TaskA solver = new TaskA();   solver.solve(1, in, out);   out.close();  }  static class TaskA {   public void solve(int testNumber, InputReader in, OutputWriter out) {    int N = in.nextInt();    Integer a[] = in.nextIntArray(N);    Arrays.sort(a);    int colors = 0;    for (int i = 0; i < N; i++) {     if (a[i] == -1) continue;     colors++;     for (int j = i + 1; j < N; j++) {      if (a[j] % a[i] == 0) {       a[j] = -1;      }     }    }    out.printLine(colors);   }  }  static class InputReader {   BufferedReader in;   StringTokenizer tokenizer = null;   public InputReader(InputStream inputStream) {    in = new BufferedReader(new InputStreamReader(inputStream));   }   public String next() {    try {     while (tokenizer == null || !tokenizer.hasMoreTokens()) {      tokenizer = new StringTokenizer(in.readLine());     }     return tokenizer.nextToken();    } catch (IOException e) {     return null;    }   }   public int nextInt() {    return Integer.parseInt(next());   }   public Integer[] nextIntArray(int size) {    Integer array[] = new Integer[size];    for (int i = 0; i < size; i++) {     array[i] = nextInt();    }    return array;   }  }  static class OutputWriter {   PrintWriter writer;   public OutputWriter(OutputStream outputStream) {    writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));   }   public OutputWriter(Writer writer) {    this.writer = new PrintWriter(writer);   }   public void print(Object... objects) {    for (int i = 0; i < objects.length; i++) {     if (i != 0) {      writer.print(' ');     }     writer.print(objects[i]);    }   }   public void printLine(Object... objects) {    print(objects);    writer.println();   }   public void close() {    writer.close();   }  } }
4,public class CF1517D extends PrintWriter { CF1517D() { super(System.out); } Scanner sc = new Scanner(System.in); public static void main(String[] $) {  CF1517D o = new CF1517D(); o.main(); o.flush(); }  static final int INF = 0x3f3f3f3f; void main() {  int n = sc.nextInt();  int m = sc.nextInt();  int k = sc.nextInt();  if (k % 2 == 1) {  for (int i = 0; i < n; i++) {   for (int j = 0; j < m; j++)   print("-1 ");   println();  }  return;  }  k /= 2;  int[][] hh = new int[n][m - 1];  for (int i = 0; i < n; i++)  for (int j = 0; j < m - 1; j++)   hh[i][j] = sc.nextInt();  int[][] vv = new int[n - 1][m];  for (int i = 0; i < n - 1; i++)  for (int j = 0; j < m; j++)   vv[i][j] = sc.nextInt();  int[][] dp = new int[n][m];  int[][] dq = new int[n][m];  while (k-- > 0) {  for (int i = 0; i < n; i++)   for (int j = 0; j < m; j++) {   int x = INF;   if (i > 0)    x = Math.min(x, dp[i - 1][j] + vv[i - 1][j]);   if (j > 0)    x = Math.min(x, dp[i][j - 1] + hh[i][j - 1]);   if (i + 1 < n)    x = Math.min(x, dp[i + 1][j] + vv[i][j]);   if (j + 1 < m)    x = Math.min(x, dp[i][j + 1] + hh[i][j]);   dq[i][j] = x;   }  int[][] tmp = dp; dp = dq; dq = tmp;  }  for (int i = 0; i < n; i++) {  for (int j = 0; j < m; j++)   print(dp[i][j] * 2 + " ");  println();  } } }
5,public class Round113_A {  public static void main(String[] args) {   Scanner in = new Scanner(System.in);   int n = in.nextInt();   int k = in.nextInt() - 1;   Obe[] a = new Obe[n];   for (int i = 0; i < n; i++)    a[i] = new Obe(in.nextInt(), in.nextInt());   Arrays.sort(a);   int c = 0;   int p = 0, d = 0;   if (k > -1 && k < n) {    c = 1;    p = a[k].p;    d = a[k].d;   } else {    System.out.println(c);    return;   }   for (int i = k + 1; i < n; i++) {    if (a[i].p == p && a[i].d == d)     c++;   }   for (int i = k - 1; i > -1; i--) {    if (a[i].p == p && a[i].d == d)     c++;   }   System.out.println(c);  } } class Obe implements Comparable<Obe> {  int p, d;  public Obe(int pe, int de) {   p = pe;   d = de;  }  @Override  public int compareTo(Obe o) {   int x = new Integer(o.p).compareTo(this.p);   if (x != 0)    return x;   return new Integer(this.d).compareTo(o.d);  } }
3,public class Main{ static HashMap<Integer,ArrayList<seg>> ma; static class seg{  seg(int a,int b){  l=a;r=b;  }  int l,r; } static int n,sum,dex; static int arr[]=new int[1600]; public static void main(String argas[]){  Scanner cin=new Scanner(System.in);  ma=new HashMap();  n=cin.nextInt();  for(int i=1;i<=n;i++){  arr[i]=cin.nextInt();  sum=0;  for(int j=i;j>0;j--){   sum+=arr[j];   if(ma.containsKey(sum)) ma.get(sum).add(new seg(j,i));   else {   ma.put(sum, new ArrayList<seg>());   ma.get(sum).add(new seg(j,i));   }  }  }  int ans=0,te;  ArrayList<seg> best=new ArrayList(),now,temp;  Iterator it=ma.entrySet().iterator();  while(it.hasNext()){  now=new ArrayList();  te=0;  Map.Entry entry=(Map.Entry) it.next();  temp=(ArrayList<seg>) entry.getValue();  dex=0;  for(int i=0;i<temp.size();i++){   if(temp.get(i).l>dex){   dex=temp.get(i).r;   te++;   now.add(new seg(temp.get(i).l,temp.get(i).r));   }  }  if(te>ans){   ans=te;   best=now;  }  }  System.out.println(ans);  for(int i=0;i<best.size();i++){  System.out.println(best.get(i).l+" "+best.get(i).r);  } } }
4,public class Main {     static class Reader {   final private int BUFFER_SIZE = 1 << 16;   private DataInputStream din;   private byte[] buffer;   private int bufferPointer, bytesRead;    public Reader()   {    din = new DataInputStream(System.in);    buffer = new byte[BUFFER_SIZE];    bufferPointer = bytesRead = 0;   }    public Reader(String file_name) throws IOException   {    din = new DataInputStream(     new FileInputStream(file_name));    buffer = new byte[BUFFER_SIZE];    bufferPointer = bytesRead = 0;   }    public String readLine() throws IOException   {    byte[] buf = new byte[64];    int cnt = 0, c;    while ((c = read()) != -1) {     if (c == '\n') {      if (cnt != 0) {       break;      }      else {       continue;      }     }     buf[cnt++] = (byte)c;    }    return new String(buf, 0, cnt);   }    public int nextInt() throws IOException   {    int ret = 0;    byte c = read();    while (c <= ' ') {     c = read();    }    boolean neg = (c == '-');    if (neg)     c = read();    do {     ret = ret * 10 + c - '0';    } while ((c = read()) >= '0' && c <= '9');     if (neg)     return -ret;    return ret;   }    public long nextLong() throws IOException   {    long ret = 0;    byte c = read();    while (c <= ' ')     c = read();    boolean neg = (c == '-');    if (neg)     c = read();    do {     ret = ret * 10 + c - '0';    } while ((c = read()) >= '0' && c <= '9');    if (neg)     return -ret;    return ret;   }    public double nextDouble() throws IOException   {    double ret = 0, div = 1;    byte c = read();    while (c <= ' ')     c = read();    boolean neg = (c == '-');    if (neg)     c = read();     do {     ret = ret * 10 + c - '0';    } while ((c = read()) >= '0' && c <= '9');     if (c == '.') {     while ((c = read()) >= '0' && c <= '9') {      ret += (c - '0') / (div *= 10);     }    }     if (neg)     return -ret;    return ret;   }    private void fillBuffer() throws IOException   {    bytesRead = din.read(buffer, bufferPointer = 0,         BUFFER_SIZE);    if (bytesRead == -1)     buffer[0] = -1;   }    private byte read() throws IOException   {    if (bufferPointer == bytesRead)     fillBuffer();    return buffer[bufferPointer++];   }    public void close() throws IOException   {    if (din == null)     return;    din.close();   }  }               public static void main(String[] args) throws IOException{   Scanner sc=new Scanner(System.in);     PrintWriter out=new PrintWriter(System.out);   int t = sc.nextInt();  while(t-->0) {   int n=sc.nextInt();   ArrayList<Integer> al[]=new ArrayList[n+1];      for(int i=0;i<=n;i++)   al[i]=new ArrayList<>();     al[0].add(1);     int y;   y=sc.nextInt();   boolean flag=true;   for(int i=1;i<=n-1;i++) {    int x=sc.nextInt();    int idx=al[i-1].size()-1;    if(x!=1) {     while(flag) {      int ans=x-1;      if(al[i-1].get(idx)==ans) {       idx--;       break;      }      idx--;     }    }    for(int j=0;j<=idx;j++) {     al[i].add(al[i-1].get(j));    }    al[i].add(x);   }     for(int i=0;i<=n-1;i++) {    out.print(al[i].get(0));    for(int j=1;j<=al[i].size()-1;j++) {     out.print("."+al[i].get(j));    }    out.println();   }     }    out.flush();  out.close();          }      }
5,public class Solution {  public static void main(String[] args) throws IOException  {   new Solution().run();  }  StreamTokenizer in;  Scanner ins;  PrintWriter out;   int nextInt() throws IOException  {   in.nextToken();    return (int)in.nval;  }    void run() throws IOException  {   if(System.getProperty("ONLINE_JUDGE")!=null)   {    in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));    ins = new Scanner(System.in);    out = new PrintWriter(System.out);   }   else   {       in = new StreamTokenizer(new BufferedReader(new FileReader("input.txt")));       ins = new Scanner(new FileReader("input.txt"));    out = new PrintWriter(new FileWriter("output.txt"));   }   int n = nextInt(),a = nextInt(),b = nextInt();   b--;   int [] A = new int[n];   for(int i = 0; i < n ;i++)   {    A[i] = nextInt();   }   Arrays.sort(A);   if(A[b] == A[b+1])    out.print(0);   else    out.print(A[b+1]- A[b]);   out.close();  }     class Team implements Comparable  {   public int p,t;   public int compareTo(Object obj)   {    Team a = (Team) obj;    if(p>a.p || p==a.p && t<a.t)           return -1;    else         if(p==a.p && t==a.t)      return 0;     else      return 1;   }    } }
3,public class Main { public static void main(String[] args) throws Exception {  MScanner sc=new MScanner(System.in);  PrintWriter pw=new PrintWriter(System.out);  int n=sc.nextInt();HashSet<Integer>nums=new HashSet<Integer>();  int[]in=new int[n];for(int i=0;i<n;i++)in[i]=sc.nextInt();  Arrays.sort(in);  int ans=0;  boolean vis[]=new boolean[n];  for(int i=0;i<n;i++) {  if(vis[i])continue;  for(int j=i+1;j<n;j++) {   if(in[j]%in[i]==0) {   vis[j]=true;   }  }  ans++;  }  pw.println(ans);   pw.flush(); }  static class MScanner {  StringTokenizer st;  BufferedReader br;   public MScanner(InputStream system) {  br = new BufferedReader(new InputStreamReader(system));  }   public MScanner(String file) throws Exception {  br = new BufferedReader(new FileReader(file));  }   public String next() throws IOException {  while (st == null || !st.hasMoreTokens())   st = new StringTokenizer(br.readLine());  return st.nextToken();  }   public String nextLine() throws IOException {  return br.readLine();  }   public int nextInt() throws IOException {  return Integer.parseInt(next());  }   public double nextDouble() throws IOException {  return Double.parseDouble(next());  }   public char nextChar() throws IOException {  return next().charAt(0);  }   public Long nextLong() throws IOException {  return Long.parseLong(next());  }   public boolean ready() throws IOException {  return br.ready();  }   public void waitForInput() throws InterruptedException {  Thread.sleep(3000);  } } }
5,public class ProblemA {  InputReader in; PrintWriter out;  void solve() {   int n = in.nextInt();   int m = in.nextInt();   int k = in.nextInt();   int[] a = new int[n];   for (int i = 0; i < n; i++)    a[i] = in.nextInt();   Arrays.sort(a);   int d = k;   int cur = n - 1;   int ans = 0;   while (d < m && cur >= 0) {    d += a[cur] - 1;    cur--;    ans++;   }   if (d >= m)    out.println(ans);   else    out.println("-1");  }   ProblemA(){   boolean oj = System.getProperty("ONLINE_JUDGE") != null;   try {    if (oj) {     in = new InputReader(System.in);     out = new PrintWriter(System.out);    }    else {     Writer w = new FileWriter("output.txt");     in = new InputReader(new FileReader("input.txt"));     out = new PrintWriter(w);    }   } catch(Exception e) {    throw new RuntimeException(e);   }   solve();   out.close();  }  public static void main(String[] args){   new ProblemA();  } } class InputReader {  private BufferedReader reader;  private StringTokenizer tokenizer;  public InputReader(InputStream stream) {   reader = new BufferedReader(new InputStreamReader(stream));   tokenizer = null;  }   public InputReader(FileReader fr) {   reader = new BufferedReader(fr);   tokenizer = null;  }  public String next() {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    try {     tokenizer = new StringTokenizer(reader.readLine());    } catch (IOException e) {     throw new RuntimeException(e);    }   }   return tokenizer.nextToken();  }  public int nextInt() {   return Integer.parseInt(next());  }  public long nextLong() {   return Long.parseLong(next());  }  public double nextDouble() {   return Double.parseDouble(next());  } }
2,public class D {  public static void main(String [] args){  Scanner cin = new Scanner(System.in);  PrintWriter cout = new PrintWriter(System.out);  long l = cin.nextLong(), r = cin.nextLong(), k = 1;  if (l == r)cout.println(0);  else {  while (((r>>k)<<k)>l)k++;k--;  cout.println(((r>>k)<<k)^(((r>>k)<<k)-1));  }  cout.flush(); } }
4,@SuppressWarnings("unchecked") public class P35C {  final static int [] DX = {-1, 1, 0, 0}; final static int [] DY = { 0, 0, -1, 1};  public void run() throws Exception {  int m = nextInt();  int n = nextInt();  boolean [][] burned = new boolean [n][m];  List<Integer> burn = new ArrayList();  for (int k = nextInt(); k > 0; k--) {  int x = nextInt() - 1;  int y = nextInt() - 1;  burned[y][x] = true;  burn.add(x * 10000 + y);  }  int lastXY = 0;  List<Integer> newBurn = null;  do {  lastXY = burn.get(0);  newBurn = new ArrayList();   for (int xy : burn) {   int x = xy / 10000;   int y = xy % 10000;   for (int i = 0; i < 4; i++) {   int nx = x + DX[i];   int ny = y + DY[i];    if ((ny >= 0) && (ny < n) && (nx >= 0) && (nx < m) && (!burned[ny][nx])) {    burned[ny][nx] = true;    newBurn.add(nx * 10000 + ny);   }   }  }   burn = newBurn;  } while (newBurn.size() > 0);  println((lastXY / 10000 + 1) + " " + (lastXY % 10000 + 1)); }  public static void main(String... args) throws Exception {  br = new BufferedReader(new InputStreamReader(new FileInputStream("input.txt")));  pw = new PrintWriter(new BufferedOutputStream(new FileOutputStream("output.txt")));  new P35C().run();  br.close();  pw.close();  System.err.println("\n[Time : " + (System.currentTimeMillis() - startTime) + " ms]"); }  static long startTime = System.currentTimeMillis(); static BufferedReader br; static PrintWriter pw; StringTokenizer stok;  String nextToken() throws IOException {  while (stok == null || !stok.hasMoreTokens()) {  String s = br.readLine();  if (s == null) { return null; }  stok = new StringTokenizer(s);  }  return stok.nextToken(); }  void print(byte b) { print("" + b); } void print(int i) { print("" + i); } void print(long l) { print("" + l); } void print(double d) { print("" + d); } void print(char c) { print("" + c); } void print(Object o) {  if (o instanceof int[]) { print(Arrays.toString((int [])o));  } else if (o instanceof long[]) { print(Arrays.toString((long [])o));  } else if (o instanceof char[]) { print(Arrays.toString((char [])o));  } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));  } else if (o instanceof short[]) { print(Arrays.toString((short [])o));  } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));  } else if (o instanceof float[]) { print(Arrays.toString((float [])o));  } else if (o instanceof double[]) { print(Arrays.toString((double [])o));  } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));  } else { print("" + o); } } void print(String s) { pw.print(s); } void println() { println(""); } void println(byte b) { println("" + b); } void println(int i) { println("" + i); } void println(long l) { println("" + l); } void println(double d) { println("" + d); } void println(char c) { println("" + c); } void println(Object o) { print(o); println(); } void println(String s) { pw.println(s); } int nextInt() throws IOException { return Integer.parseInt(nextToken()); } long nextLong() throws IOException { return Long.parseLong(nextToken()); } double nextDouble() throws IOException { return Double.parseDouble(nextToken()); } char nextChar() throws IOException { return (char) (br.read()); } String next() throws IOException { return nextToken(); } String nextLine() throws IOException { return br.readLine(); } int [] readInt(int size) throws IOException {  int [] array = new int [size];  for (int i = 0; i < size; i++) { array[i] = nextInt(); }  return array; } long [] readLong(int size) throws IOException {  long [] array = new long [size];  for (int i = 0; i < size; i++) { array[i] = nextLong(); }  return array; } double [] readDouble(int size) throws IOException {  double [] array = new double [size];  for (int i = 0; i < size; i++) { array[i] = nextDouble(); }  return array; } String [] readLines(int size) throws IOException {  String [] array = new String [size];  for (int i = 0; i < size; i++) { array[i] = nextLine(); }  return array; } }
5,public class A {  BufferedReader in;  StringTokenizer st;  PrintWriter out;  static class House implements Comparable<House> {   final int x, a;   House(int x, int a) {    this.x = x;    this.a = a;   }   public int compareTo(House h) {    return x - h.x;   }  }  void solve() throws IOException {   int n = nextInt();   int t = nextInt();   House[] h = new House[n];   for (int i = 0; i < n; ++i) {    h[i] = new House(2 * nextInt(), nextInt());   }   Arrays.sort(h);   int ans = 2;   for (int i = 1; i < n; ++i) {    House prev = h[i - 1];    House curr = h[i];    int diff = 2 * t + curr.a + prev.a;    if (curr.x - prev.x == diff) {     ++ans;    } else if (curr.x - prev.x > diff) {     ans += 2;    }   }   out.println(ans);  }  public void run() throws IOException {   in = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);   eat("");   solve();   out.close();   in.close();  }  void eat(String s) {   st = new StringTokenizer(s);  }  String next() throws IOException {   while (!st.hasMoreTokens()) {    String line = in.readLine();    if (line == null) {     return null;    }    eat(line);   }   return st.nextToken();  }  int nextInt() throws IOException {   return Integer.parseInt(next());  }  long nextLong() throws IOException {   return Long.parseLong(next());  }  double nextDouble() throws IOException {   return Double.parseDouble(next());  }  public static void main(String[] args) throws IOException {   new A().run();  } }
5,public class Beta15PA {   public static void main(String[] args) {   Beta15PA temp = new Beta15PA();  temp.solve(); }  public void solve() {  Scanner scan = new Scanner(System.in);  int n = scan.nextInt(), t = scan.nextInt();  House[] houses = new House[n];  for(int i=0; i<n; i++) {  houses[i] = new House(scan.nextInt(), scan.nextInt());  }  Arrays.sort(houses);  int res = 2;  for(int i=0; i<n-1; i++) {  double cnt = houses[i+1].coordinate - houses[i].coordinate;  cnt -= 1.0*(houses[i+1].side+houses[i].side)/2;  if(cnt>t) res += 2;  else if(Math.abs(cnt-t)<1e-7) res += 1;  }  System.out.println(res); }  public class House implements Comparable<House> {  public int coordinate, side;  public House(int coordinate, int side) {  this.coordinate = coordinate;  this.side = side;  }  @Override  public int compareTo(House arg0) {    return this.coordinate - arg0.coordinate;  }   } }
6,public class A {  static double[][] a; static int N; static double[] memo;  static double dp(int alive) {  int count = Integer.bitCount(alive);  if(count == N)  return 1;  if(memo[alive] > -5)  return memo[alive];   double ret = 0;  for(int j = 0; j < N; ++j)  if((alive & (1<<j)) == 0)   ret += die[j][alive | 1<<j] * dp(alive | 1<<j);    return memo[alive] = ret; }  static double[][] die; static void f() {  die = new double[N][1<<N];  for(int i = 0; i < N; ++i)  for(int j = 0; j < 1<<N; ++j)  {   int count = Integer.bitCount(j);   if(count <= 1)   continue;   double prop = 1.0 / (count * (count - 1) >> 1);   for(int k = 0; k < N; ++k)   if((j & (1<<k)) != 0)    die[i][j] += prop * a[k][i];   }  }  public static void main(String[] args) throws IOException {   Scanner sc = new Scanner(System.in);  PrintWriter out = new PrintWriter(System.out);   N = sc.nextInt();   a = new double[N][N];  for(int i = 0; i < N; ++i)  for(int j = 0; j < N; ++j)   a[i][j] = sc.nextDouble();  memo = new double[1<<N];  f();  Arrays.fill(memo, -10);   for(int i = 0; i < N - 1; ++i)  out.printf("%.8f ", dp(1 << i));  out.printf("%.8f\n", dp(1 << N - 1));   out.flush();  out.close(); }  static class Scanner  {  StringTokenizer st;  BufferedReader br;  public Scanner(InputStream s){ br = new BufferedReader(new InputStreamReader(s));}  public String next() throws IOException  {  while (st == null || !st.hasMoreTokens())   st = new StringTokenizer(br.readLine());  return st.nextToken();  }  public double nextDouble() throws NumberFormatException, IOException  {  return Double.parseDouble(next());  }  public int nextInt() throws IOException {return Integer.parseInt(next());}  public long nextLong() throws IOException {return Long.parseLong(next());}  public String nextLine() throws IOException {return br.readLine();}  public boolean ready() throws IOException {return br.ready();}  } }
3,public class Main {  static class Node implements Comparable<Node>{   public int l,r;   public long s;   Node(int l,int r,long s){    this.l=l;    this.r=r;    this.s=s;   }   public int compareTo(Node o) {    if(o.s==s){     if(r>o.r) return 1;     else if(r==o.r) {      return 0;     }     else return -1;    } else if(s>o.s){     return 1;    } else {     return -1;    }   }  }  static long[] sum=new long[1550];  public static void main(String[] args) {   TreeMap<Long, ArrayList<Node> > mp = new TreeMap<>();   Scanner cin = new Scanner(System.in);   int N=cin.nextInt();   for(int i=1;i<=N;i++){    int x=cin.nextInt();    sum[i]=sum[i-1]+x;   }     ArrayList<Node> arr = new ArrayList<>();   for(int l=1;l<=N;l++){    for(int r=l;r<=N;r++){     arr.add(new Node(l,r,sum[r]-sum[l-1]));    }   }   Collections.sort(arr);   for(int i=0;i<arr.size();i++){    ArrayList<Node> a=mp.get(arr.get(i).s);    if(a==null) {     a=new ArrayList<>();     mp.put(arr.get(i).s,a);    }    a.add(arr.get(i));   }   int mx=-1;   long mxv=-1;   Iterator<Long> it=mp.keySet().iterator();   while(it.hasNext()){    int ans=0,t=0;    long v=it.next();    ArrayList<Node> vec= mp.get(v);    for(int i=0;i<vec.size();i++){     if(t<vec.get(i).l){      ans++;      t=vec.get(i).r;     }    }       if(ans>mx){     mx=ans;     mxv=v;        }   }   ArrayList<Node> vec=mp.get(mxv);   System.out.println(mx);   int t=0;   for(int i=0;i<vec.size();i++){           if(t<vec.get(i).l){     System.out.println(vec.get(i).l+" "+vec.get(i).r);     t=vec.get(i).r;    }   }  } }
2,public class Main{   public static void main(String[] args){  Scanner ak=new Scanner(System.in);  long n,k,x;  n=ak.nextLong();  k=ak.nextLong();  x=(long)((-3+Math.sqrt(9+8*(n+k)))/2);  System.out.println(n-x); } }
6,public class ASimpleTask {    static long memo[][]; static int graph[]; static long hamiltonianPath(int mask , int u) {  if(memo[mask][u] != -1)    return memo[mask][u];  else if(u == Integer.numberOfTrailingZeros(mask))    return 0;  else {  long sum = 0;  for(int fromSet = mask ^ (1 << u);fromSet > 0; fromSet ^= Integer.lowestOneBit(fromSet)) {   int v = Integer.numberOfTrailingZeros(fromSet);     if((graph[u] & (1 << v)) != 0)    sum += hamiltonianPath(mask ^ (1 << u), v);  }    return sum;  } }  private static void solveBottomUp(FastScanner s1, PrintWriter out){  int V = s1.nextInt();  int E = s1.nextInt();  graph = new int[V];  long DP[][] = new long[1 << V][V];  while(E-->0) {  int u = s1.nextInt() - 1;  int v = s1.nextInt() - 1;  graph[u] |= (1 << v);  graph[v] |= (1 << u);  }  for(int i=0;i<V;i++)  DP[1 << i][i] = 1;  for(int mask = 1 , end = 1 << V;mask < end;mask++) {  for(int set = mask;Integer.bitCount(set) > 1;set ^= Integer.highestOneBit(set)) {   int u = Integer.numberOfTrailingZeros(Integer.highestOneBit(set));   for(int fromSet = mask ^ (1 << u);fromSet > 0; fromSet ^= Integer.lowestOneBit(fromSet)) {   int v = Integer.numberOfTrailingZeros(fromSet);      if((graph[u] & (1 << v)) != 0)    DP[mask][u] += DP[mask ^ (1 << u)][v];      }  }  }  long totalCycles = 0;  for(int mask = 1 , end = 1 << V;mask < end;mask++) {  if(Integer.bitCount(mask) >= 3) {   int start = Integer.numberOfTrailingZeros(mask);   for(int set = mask;Integer.bitCount(set) > 1;set ^= Integer.highestOneBit(set)) {   int u = Integer.numberOfTrailingZeros(Integer.highestOneBit(set));   if((graph[u] & (1 << start)) != 0)    totalCycles += DP[mask][u];   }  }  }  totalCycles /= 2;  out.println(totalCycles); }  private static void solveTopDown(FastScanner s1, PrintWriter out){  int V = s1.nextInt();  int E = s1.nextInt();  graph = new int[V];  memo = new long[1 << V][V];   for(long l[] : memo)  Arrays.fill(l, -1);   while(E-->0) {  int u = s1.nextInt() - 1;  int v = s1.nextInt() - 1;  graph[u] |= (1 << v);  graph[v] |= (1 << u);  }  for(int i=0;i<V;i++)  memo[1 << i][i] = 1;   long totalCycles = 0;  for(int mask = 1 , end = 1 << V;mask < end;mask++) {  if(Integer.bitCount(mask) >= 3) {   int start = Integer.numberOfTrailingZeros(mask);   for(int set = mask;Integer.bitCount(set) > 1;set ^= Integer.highestOneBit(set)) {   int u = Integer.numberOfTrailingZeros(Integer.highestOneBit(set));   if((graph[u] & (1 << start)) != 0)    totalCycles += hamiltonianPath(mask, u);   }  }  }  totalCycles /= 2;   out.println(totalCycles); }       public static void main(String []args) throws IOException {  FastScanner in = new FastScanner(System.in);  PrintWriter out =   new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)), false);  solveBottomUp(in, out);  in.close();  out.close(); }   static class FastScanner{  BufferedReader reader;  StringTokenizer st;  FastScanner(InputStream stream){reader=new BufferedReader(new InputStreamReader(stream));st=null;}  String next()  {while(st == null || !st.hasMoreTokens()){try{String line = reader.readLine();if(line == null){return null;}    st = new StringTokenizer(line);}catch (Exception e){throw new RuntimeException();}}return st.nextToken();}  String nextLine() {String s=null;try{s=reader.readLine();}catch(IOException e){e.printStackTrace();}return s;}     int nextInt() {return Integer.parseInt(next());}  long nextLong() {return Long.parseLong(next());}   double nextDouble(){return Double.parseDouble(next());}  char nextChar() {return next().charAt(0);}  int[] nextIntArray(int n)   {int[] a= new int[n]; int i=0;while(i<n){a[i++]=nextInt();} return a;}  long[] nextLongArray(int n)  {long[]a= new long[n]; int i=0;while(i<n){a[i++]=nextLong();} return a;}  int[] nextIntArrayOneBased(int n) {int[] a= new int[n+1]; int i=1;while(i<=n){a[i++]=nextInt();} return a;}    long[] nextLongArrayOneBased(int n){long[]a= new long[n+1];int i=1;while(i<=n){a[i++]=nextLong();}return a;}    void close(){try{reader.close();}catch(IOException e){e.printStackTrace();}}   }  }
0,public class A { private static Scanner in;  public void run() {  long a = in.nextLong();  long b = in.nextLong();  long ans = 0;  while (a > 0 && b > 0) {  if (a >= b) {   ans += a / b;   a %= b;   continue;  }  ans += b / a;  b %= a;  }  System.out.println(ans); }  public static void main(String[] args) {  Locale.setDefault(Locale.US);  in = new Scanner(System.in);  new A().run();  in.close(); } }
4,public class Main{  static InputReader sc;  static PrintWriter pw;  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   sc = new InputReader(inputStream);   pw = new PrintWriter(outputStream);   solve();   pw.close();  }      static int time;   static BigInteger min(BigInteger a, BigInteger b){     if(a.compareTo(b)<0)    return a;   return b;  }  public static void solve(){     int t=1;   t=s(0);   u:while(t-->0){    int n=s(0);    int []arr=new int [n];    feedArr(arr);    Stack<Pair> stk=new Stack<>();    stk.push(new Pair("",1));    pln(1);    Pair pr;    for(int i=1;i<n;i++){     if(arr[i]==1){      pr=stk.peek();      stk.push(new Pair(pr.s+(pr.s.length()==0?"":".")+pr.i,1));      pln(stk.peek().s+"."+stk.peek().i);     }     else if(stk.peek().i==arr[i]-1){      pr=stk.pop();      pln(pr.s+(pr.s.length()==0?"":".")+arr[i]);      pr.i++;      stk.push(pr);     }     else{      stk.pop();      i--;     }    }   }    }    static long fact(long p){   long ans=1l;   for(long i=2;i<=p;i++)    ans*=i;   return ans;  }   static int find(int j, List<Integer> B, List<Integer> A, int i){     int l=j,r=B.size()-1,m;     while(l<=r){    m=(r-l)/2+l;    if(A.size()-i-1<=B.size()-m-1)     l=m+1;    else     r=m-1;   }     return r;  }  static int find2(List<Integer> B, int x){   int l=0,r=B.size()-1,m;        while(l<=r){       m=(r-l)/2+l;       if(B.get(m)-x<=0)     l=m+1;    else     r=m-1;   }     return r;    }  static long nPr(long n, long r){   long ans=1;   for(long i=1;i<=r;i++)    ans*=(n-i+1);   return ans;  }  static long nCr(long n, long r){   long ans=1;   for(long i=1;i<=r;i++){    ans*=(n-i+1);    ans/=i;   }   return ans;  }  static void update_DAG(int cur,int val, int []graph, int n)  {   if(val>maxx[cur])   {    int x=graph[cur];    if(x!=-1)     update_DAG(x,val+1,graph,n);    maxx[cur]=val;    update(cur,val,n);   }  }  static int []bit, maxx;  static void update(int i,int val, int n)  {   while(i<=n)   {    bit[i]=Math.max(bit[i],val);    i=i+(i&(-i));   }  }  static int query(int i)  {   int ret=0;   while(i>0)   {    ret=Math.max(ret,bit[i]);    i=i-(i&(-i));   }   return ret;  }   public static int [][]dir=new int [][]{{1,0},{0,1},{-1,0},{0,-1}};    public static int find(List<Integer> list, int x){   int l=0,r=list.size()-1,m;   while(l<=r){    m=(r-l)/2+l;    if(list.get(m)<=x)     l=m+1;    else     r=m-1;   }   return r;  }  static class Node{   int val;   long cost;   Node next;   Node(int v,long c){    val=v;    next=null;    cost=c;   }  }   public static long sum(long n){   long val=0l;   while(n>0){    val+=n%10;    n/=10;   }   return val;  }                              public static int findDiameter(int r, List<List<Integer>>list){   return findFarthest(findFarthest(r,list)[0],list)[1];  }  public static int[] findFarthest(int u, List<List<Integer>>list){   int n=list.size();   boolean []vis=new boolean[n+1];   Queue<Integer>q=new LinkedList<>();   q.offer(u);   vis[u]=true;   int s,pr,cnt=0;   int []ar=new int[]{u,0};   while(q.size()>0){    s=q.size();    while(s-->0){     pr=q.poll();     if(ar[1]<cnt){      ar[1]=cnt;      ar[0]=pr;     }     for(int i:list.get(pr)){      if(!vis[i]){       vis[i]=true;       q.offer(i);      }     }    }    cnt++;   }   return ar;  }  public static long atMostK(char []chrr, int k){   if(k<0)    return 0;   int l=0,cnt=0;   long ans=0l;   for(int i=0;i<chrr.length;i++){    if(chrr[i]=='1')     cnt++;    while(cnt>k){     if(chrr[l++]=='1')      cnt--;    }    ans+=(long)(i-l)+1l;   }   return ans;  }  public static int ask(int l, int r){   System.out.println("? "+l+" "+r);   System.out.flush();   return sc.nextInt();  }  public static void sort(int []arr){   ArrayList<Integer> list=new ArrayList<>();   for(int i=0;i<arr.length;i++)    list.add(arr[i]);   Collections.sort(list);   for(int i=0;i<arr.length;i++)    arr[i]=list.get(i);  }  public static void sort(long []arr){   ArrayList<Long> list=new ArrayList<>();   for(int i=0;i<arr.length;i++)    list.add(arr[i]);   Collections.sort(list);   for(int i=0;i<arr.length;i++)    arr[i]=list.get(i);  }  public static void swap(char []chrr, int i, int j){   char temp=chrr[i];   chrr[i]=chrr[j];   chrr[j]=temp;  }  public static int countSetBits(long n){   int a=0;   while(n>0){    a+=(n&1);    n>>=1;   }   return a;  }  static class Pair{   String s;   int i;   Pair(String S, int I){    s=S;    i=I;   }    }   static boolean isPrime(long n) {   if (n <= 1)    return false;   if (n <= 3)    return true;   if (n % 2 == 0 || n % 3 == 0)    return false;   for (int i = 5; i * i <= n; i = i + 6)    if (n % i == 0 || n % (i + 2) == 0)     return false;   return true;  }  static long gcd(long a, long b) {   if (b == 0)    return a;   return a>b?gcd(b, a % b):gcd(a, b % a);  }  static long fast_pow(long base,long n,long M){   if(n==0)    return 1;   if(n==1)   return base;   long halfn=fast_pow(base,n/2,M);   if(n%2==0)    return ( halfn * halfn ) % M;   else    return ( ( ( halfn * halfn ) % M ) * base ) % M;  }  static long modInverse(long n,long M){   return fast_pow(n,M-2,M);  }  public static int s(int n){   return sc.nextInt();  }  public static long s(long n){   return sc.nextLong();  }  public static String s(String n){   return sc.next();  }  public static double s(double n){   return sc.nextDouble();  }  public static void p(int n){   pw.print(n);  }  public static void p(long n){   pw.print(n);  }  public static void p(String n){   pw.print(n);  }  public static void p(double n){   pw.print(n);  }  public static void pln(int n){   pw.println(n);  }  public static void pln(long n){   pw.println(n);  }  public static void pln(String n){   pw.println(n);  }  public static void pln(double n){   pw.println(n);  }  public static void feedArr(long []arr){   for(int i=0;i<arr.length;i++)    arr[i]=sc.nextLong();  }  public static void feedArr(double []arr){   for(int i=0;i<arr.length;i++)    arr[i]=sc.nextDouble();  }  public static void feedArr(int []arr){   for(int i=0;i<arr.length;i++)    arr[i]=sc.nextInt();  }  public static void feedArr(String []arr){   for(int i=0;i<arr.length;i++)    arr[i]=sc.next();  }  public static String printArr(int []arr){   StringBuilder sbr=new StringBuilder();   for(int i:arr)    sbr.append(i+" ");   return sbr.toString();  }  public static String printArr(long []arr){   StringBuilder sbr=new StringBuilder();   for(long i:arr)    sbr.append(i+" ");   return sbr.toString();  }  public static String printArr(String []arr){   StringBuilder sbr=new StringBuilder();   for(String i:arr)    sbr.append(i+" ");   return sbr.toString();  }  public static String printArr(double []arr){   StringBuilder sbr=new StringBuilder();   for(double i:arr)    sbr.append(i+" ");   return sbr.toString();  }  static class InputReader {   public BufferedReader reader;   public StringTokenizer tokenizer;    public InputReader(InputStream stream) {    reader = new BufferedReader(new InputStreamReader(stream), 32768);    tokenizer = null;   }   public String next() {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      tokenizer = new StringTokenizer(reader.readLine());     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return tokenizer.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }   public long nextLong() {    return Long.parseLong(next());   }   public double nextDouble() {    return Double.parseDouble(next());   }  } } class AncestorQuerier {  int [][]dp;  int N=200001;  int M=22;  int max;   public void preCompute(int []par){   for(int i=0;i<N;i++){    if(i>=2&&i<par.length)     dp[i][0]=par[i];    else     dp[i][0]=-1;   }   for(int j=1;j<M;j++){    for(int i=0;i<N;i++){     if(dp[i][j-1]!=-1)      dp[i][j]=dp[dp[i][j-1]][j-1];    }   }    }   public int getAncestor(int val, int k) {   if(k<0||val>max)    return -1;   if(k==0)    return val;   int t=(1<<(M-1));     for(int i=M-1;i>=0&&val!=-1;i--,t>>=1){    if(t<=k){     val=dp[val][i];     k-=t;    }   }   return val;   } }
4,public class CompressionAndExpansion {  public static void main(String[] args) {   Scanner in = new Scanner(System.in);   int T = in.nextInt();   for (int t = 0; t < T; t++) {    int N = in.nextInt();    List<Integer> list = new ArrayList<>();    for (int i = 0; i < N; i++) {     int n = in.nextInt();     if (n == 1) {      list.add(n);     } else {      for (int j = list.size() - 1; j >= 0; j--) {       if (list.get(j) == n - 1) {        list.set(j, n);        break;       }       list.remove(j);      }     }     for (int j = 0; j < list.size(); j++) {      System.out.print(list.get(j) + (j == list.size() - 1 ? "\n" : "."));     }    }   }  } }
5,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   Scanner in = new Scanner(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskC solver = new TaskC();   solver.solve(1, in, out);   out.close();  }  static class TaskC {   public void solve(int testNumber, Scanner in, PrintWriter out) {    int n = in.nextInt();    int m = in.nextInt();    TaskC.pair[] songs = new TaskC.pair[n];    long sum = 0;    for (int i = 0; i < n; i++) {     songs[i] = new TaskC.pair(in.nextInt(), in.nextInt());     sum += songs[i].a;    }    Arrays.sort(songs);    int res = 0;    int idx = n - 1;    while (sum > m) {     if (idx < 0) {      break;     }     sum -= (songs[idx].a - songs[idx].b);     res++;     idx--;    }    if (sum > m) {     out.println(-1);    } else {     out.println(res);    }   }   static class pair implements Comparable<TaskC.pair> {    int a;    int b;    pair(int a, int b) {     this.a = a;     this.b = b;    }    public int compareTo(TaskC.pair p) {     return (this.a - this.b) - (p.a - p.b);    }   }  }  static class Scanner {   StringTokenizer st;   BufferedReader br;   public Scanner(InputStream s) {    br = new BufferedReader(new InputStreamReader(s));   }   public Scanner(String s) {    try {     br = new BufferedReader(new FileReader(s));    } catch (FileNotFoundException e) {     e.printStackTrace();    }   }   public String next() {    while (st == null || !st.hasMoreTokens()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }  } }
6,public class SimpleTask {  public static void main(String[] args) throws Exception {   InputReader in = new InputReader(System.in);   int n = in.nextInt();   int m = in.nextInt();   int[] g = new int[n];   long[][] dp = new long[1 << n][n];   for (int i = 0; i < m; i++) {    int a = in.nextInt() - 1, b = in.nextInt() - 1;    g[a] |= (1 << b);    g[b] |= (1 << a);   }   int all = (1 << n) - 1;   for (int i = 0; i < n; i++) {    int l = (1 << i);    int left = all ^ (l - 1) ^ l;    for (int j = left; j > 0; j = (j - 1) & left)     if ((j & (j - 1)) != 0) {      dp[j | l][i] = 1;     }   }   for (int i = (1 << n) - 1; i > 0; i--) {    int last = i & -i;    for (int j = 0; j < n; j++) {     if (((1 << j) == last && (i & (i - 1)) != 0)       || ((1 << j) & i) == 0)      continue;     for (int k = 0; k < n; k++) {      if ((1 << k) >= last && ((1 << k) & g[j]) != 0        && ((1 << k) == last || ((1 << k) & i) == 0)) {       dp[i][j] += dp[i | (1 << k)][k];      }     }    }   }   long res = 0;   for (int i = 0; i < n; i++)    res += dp[(1 << i)][i];   System.out.println(res / 2);  }  static class InputReader {   private BufferedReader reader;   private StringTokenizer tokenizer;   public InputReader(InputStream stream) {    reader = new BufferedReader(new InputStreamReader(stream));    tokenizer = null;   }   public String next() {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      tokenizer = new StringTokenizer(reader.readLine());     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return tokenizer.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }  } }
4,public class CodeF { static class Scanner {  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer("");   public String nextLine()  {  try  {   return br.readLine();  }  catch(Exception e)  {   throw(new RuntimeException());  }  }   public String next()  {  while(!st.hasMoreTokens())  {   String l = nextLine();   if(l == null)   return null;   st = new StringTokenizer(l);  }  return st.nextToken();  }   public int nextInt()  {  return Integer.parseInt(next());  }   public long nextLong()  {  return Long.parseLong(next());  }   public double nextDouble()  {  return Double.parseDouble(next());  }   public int[] nextIntArray(int n)  {  int[] res = new int[n];  for(int i = 0; i < res.length; i++)   res[i] = nextInt();  return res;  }   public long[] nextLongArray(int n)  {  long[] res = new long[n];  for(int i = 0; i < res.length; i++)   res[i] = nextLong();  return res;  }   public double[] nextDoubleArray(int n)  {  double[] res = new double[n];  for(int i = 0; i < res.length; i++)   res[i] = nextDouble();  return res;  }  public void sortIntArray(int[] array)  {  Integer[] vals = new Integer[array.length];  for(int i = 0; i < array.length; i++)   vals[i] = array[i];  Arrays.sort(vals);  for(int i = 0; i < array.length; i++)   array[i] = vals[i];  }   public void sortLongArray(long[] array)  {  Long[] vals = new Long[array.length];  for(int i = 0; i < array.length; i++)   vals[i] = array[i];  Arrays.sort(vals);  for(int i = 0; i < array.length; i++)   array[i] = vals[i];  }   public void sortDoubleArray(double[] array)  {  Double[] vals = new Double[array.length];  for(int i = 0; i < array.length; i++)   vals[i] = array[i];  Arrays.sort(vals);  for(int i = 0; i < array.length; i++)   array[i] = vals[i];  }  public String[] nextStringArray(int n)  {   String[] vals = new String[n];  for(int i = 0; i < n; i++)   vals[i] = next();  return vals;  }   Integer nextInteger()  {  String s = next();  if(s == null)   return null;  return Integer.parseInt(s);  }   int[][] nextIntMatrix(int n, int m)  {  int[][] ans = new int[n][];  for(int i = 0; i < n; i++)   ans[i] = nextIntArray(m);  return ans;  } }  static int[] compute_prefix_function(char[] p) {  int[] pi = new int[p.length]; pi[0] = -1; int k = -1;  for (int i = 1; i < p.length; i++) {   while (k >= 0 && p[k + 1] != p[i]) k = pi[k];   if (p[k + 1] == p[i]) k++; pi[i] = k;  }  return pi; }  static boolean KMP_Matcher(String pattern, String text) {  char[] p = pattern.toCharArray(); char[] t = text.toCharArray();  int[] pi = compute_prefix_function(p); int q = -1;  int cuenta = 0;  for (int i = 0; i < text.length(); i++) {   while (q >= 0 && p[q + 1] != t[i]) q = pi[q];   if (p[q + 1] == t[i]) q++;   if (q == p.length - 1) {    cuenta++;    q = pi[q];   }  }  return cuenta >= 2; }  public static void main(String[] args) {  Scanner sc = new Scanner();  String entrada = sc.next();  int mejor = 0;  for(int i = 0; i < entrada.length(); i++)  {  for(int j = i + 1; j <= entrada.length(); j++)  {   String sub = entrada.substring(i, j);   if(KMP_Matcher(sub, entrada))   mejor = Math.max(j - i, mejor);  }  }  System.out.println(mejor); } }
6,public class main{  static int max = 5000+1; static FastReader in = new FastReader(); static PrintWriter out = new PrintWriter(System.out); static int N = 18; static int[][] mn1 = new int[N][N];  static int[][] mn2 = new int[N][N]; static int[][] dp = new int[1<<N][N]; static int n,m;  static void solve(){  n = in.nextInt(); m = in.nextInt();  int[][] a = new int[n][m];  for(int i=0;i<n;i++)for(int j=0;j<m;j++)a[i][j] = in.nextInt();  for(int i=0;i<n;i++){  Arrays.fill(mn1[i],Integer.MAX_VALUE);  Arrays.fill(mn2[i],Integer.MAX_VALUE);  }   for(int i=0;i<n;i++)  for(int j=0;j<n;j++)   for(int k=0;k<m;k++){   mn1[i][j] = Math.min(mn1[i][j],Math.abs(a[i][k]-a[j][k]));   if(k<=m-2)    mn2[i][j] = Math.min(mn2[i][j],Math.abs(a[i][k]-a[j][k+1]));   }  int ans = 0;  for(int i=0;i<n;i++){  for(int x=0;x<1<<n;x++)Arrays.fill(dp[x],-1);  for(int j=0;j<n;j++)dp[1<<j][j] = 0;  dp[1<<i][i] = Integer.MAX_VALUE;  for(int j=0;j<n;j++)   ans = Math.max(ans,Math.min(mn2[j][i],calc((1 << n) - 1, j)));  }  out.println(ans); }  static int calc(int mask, int v){  if (dp[mask][v] != -1)  return dp[mask][v];  dp[mask][v] = 0;  for(int u=0;u<n;u++) if (v != u && (((mask >> u) & 1)>0))  dp[mask][v] = Math.max(dp[mask][v], Math.min(mn1[u][v], calc(mask ^ (1 << v), u)));  return dp[mask][v]; }  public static void main(String[] args){  solve();  out.close(); }  static class FastReader{   BufferedReader br;   StringTokenizer st;   public FastReader(){    br = new BufferedReader(new InputStreamReader(System.in));   }   public FastReader(String s) throws Exception{    br = new BufferedReader(new FileReader(s));   }   String next(){    while (st == null || !st.hasMoreElements()){     try{      st = new StringTokenizer(br.readLine());     }catch (IOException e){      e.printStackTrace();     }    }    return st.nextToken();   }   String nextLine(){    String str = "";    try{      str = br.readLine();    }catch (IOException e){     e.printStackTrace();    }    return str;   }   int nextInt(){return Integer.parseInt(in.next());}  long nextLong(){return Long.parseLong(in.next());}  double nextDouble(){return Double.parseDouble(in.next());}  } }
4,public class Contest35_3 {  public static void main(String[] args) throws IOException {   BufferedReader in = new BufferedReader(new FileReader("input.txt"));   String[] s = in.readLine().split(" ");   int n = Integer.parseInt(s[0]);   int m = Integer.parseInt(s[1]);   int k = Integer.parseInt(in.readLine());   s = in.readLine().split(" ");   Point[] inp = new Point[k];   int p = 0;   for (int i = 0; i < k; i++) {    inp[i] = new Point(Integer.parseInt(s[p++]),      Integer.parseInt(s[p++]));   }   int max = -1;   int maxx = -1;   int maxy = -1;   int i;   int j, dist;   for (i = 1; i <= n; i++) {    for (j = 1; j <= m; j++) {     dist = 1000000;     for (int l = 0; l < inp.length; l++) {      dist = Math.min(        Math.abs(inp[l].x - i) + Math.abs(inp[l].y - j),        dist);     }     if (dist > max) {      max = dist;      maxx = i;      maxy = j;     }    }   }   String res = maxx + " " + maxy + "\n";   FileWriter out = new FileWriter(new File("output.txt"));   out.append(res);   out.flush();   out.close();  } }
2,public class cf3 implements Runnable{   final static long mod = (long)1e9 + 7;   static long modExp(long x, long pow) {   x = x % mod;    long res = 1;     while (pow > 0) {     if (pow % 2 == 1)    res = res * x % mod;     pow = pow / 2;   x = x * x % mod;   }    return res; }  public void run() {    InputReader s = new InputReader(System.in);  PrintWriter w = new PrintWriter(System.out);   int t = 1;    while(t-- > 0) {    long x = s.nextLong(), k = s.nextLong();    if(x == 0) {   w.println(0); continue;  }    x = x % mod;    long res = (modExp(2, k + 1) * x % mod + 1) % mod;  res = (res + mod - modExp(2, k)) % mod;    w.println(res);  }   w.close(); }  static class InputReader {   private InputStream stream;  private byte[] buf = new byte[1024];  private int curChar;  private int numChars;  private SpaceCharFilter filter;   public InputReader(InputStream stream)  {  this.stream = stream;  }   public int read()  {  if (numChars==-1)   throw new InputMismatchException();    if (curChar >= numChars)  {   curChar = 0;   try   {   numChars = stream.read(buf);   }   catch (IOException e)   {   throw new InputMismatchException();   }     if(numChars <= 0)     return -1;  }  return buf[curChar++];  }   public String nextLine()  {  BufferedReader br=new BufferedReader(new InputStreamReader(System.in));  String str = "";    try    {     str = br.readLine();    }    catch (IOException e)    {     e.printStackTrace();    }    return str;  }  public int nextInt()  {  int c = read();    while(isSpaceChar(c))   c = read();    int sgn = 1;    if (c == '-')   {   sgn = -1;   c = read();  }    int res = 0;  do   {   if(c<'0'||c>'9')    throw new InputMismatchException();   res *= 10;   res += c - '0';   c = read();  }  while (!isSpaceChar(c));     return res * sgn;  }   public long nextLong()  {  int c = read();  while (isSpaceChar(c))   c = read();  int sgn = 1;  if (c == '-')   {   sgn = -1;   c = read();  }  long res = 0;    do   {   if (c < '0' || c > '9')   throw new InputMismatchException();   res *= 10;   res += c - '0';   c = read();  }  while (!isSpaceChar(c));   return res * sgn;  }   public double nextDouble()  {  int c = read();  while (isSpaceChar(c))   c = read();  int sgn = 1;  if (c == '-')   {   sgn = -1;   c = read();  }  double res = 0;  while (!isSpaceChar(c) && c != '.')   {   if (c == 'e' || c == 'E')   return res * Math.pow(10, nextInt());   if (c < '0' || c > '9')   throw new InputMismatchException();   res *= 10;   res += c - '0';   c = read();  }  if (c == '.')   {   c = read();   double m = 1;   while (!isSpaceChar(c))   {   if (c == 'e' || c == 'E')    return res * Math.pow(10, nextInt());   if (c < '0' || c > '9')    throw new InputMismatchException();   m /= 10;   res += (c - '0') * m;   c = read();   }  }  return res * sgn;  }   public String readString()  {  int c = read();  while (isSpaceChar(c))   c = read();  StringBuilder res = new StringBuilder();  do   {   res.appendCodePoint(c);   c = read();  }   while (!isSpaceChar(c));    return res.toString();  }   public boolean isSpaceChar(int c)  {  if (filter != null)   return filter.isSpaceChar(c);  return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;  }   public String next()  {  return readString();  }   public interface SpaceCharFilter  {  public boolean isSpaceChar(int ch);  } }   public static void main(String args[]) throws Exception {  new Thread(null, new cf3(),"cf3",1<<26).start(); } }
2,public class Solution {  BufferedReader in; PrintWriter out; StringTokenizer st;  String nextToken() throws Exception {  while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(in.readLine());  return st.nextToken(); }  int nextInt() throws Exception {  return Integer.parseInt(nextToken()); }  long fang(int s, int x, int y) {  if (x > y) { int t = x; x = y; y = t; }  if (s + 1 <= x) {  return (long)(s + 1) * (s + 2) / 2;  }  if (s + 1 <= y) {  return (long)x * (x + 1) / 2 + (long)(s + 1 - x) * x;  }  if (s + 1 >= x + y - 1) {  return (long)x * y;  }  long q = x + y - 1 - s - 1;  return (long)x * y - q * (q + 1) / 2; }  long f(int s, int n, int x, int y) {  long ans = fang(s, n - x + 1, n - y + 1) + fang(s, n - x + 1, y) + fang(s, x, n - y + 1) + fang(s, x, y);  ans -= Math.min(s + 1, n - x + 1) + Math.min(s + 1, x) + Math.min(s + 1, n - y + 1) + Math.min(s + 1, y);  return ans + 1; }  void solve() throws Exception {  int n = nextInt();  int x = nextInt(), y = nextInt();  long c = nextInt();  if (c == 1) {  out.println(0);  return;  }  int bg = 0, ed = 2 * n;  while (ed > bg + 1) {  int mm = (bg + ed) / 2;  if (f(mm, n, x, y) >= c) ed = mm; else bg = mm;  }  out.println(ed); }  void run() {  try {  Locale.setDefault(Locale.US);   in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);  solve();  } catch (Exception e) {  e.printStackTrace();  System.exit(1);  } finally {  out.close();  } }  public static void main(String[] args) {   new Solution().run(); } }
0,public class LuxuriousHouses {   public static void main(String[] args) throws IOException {  System.out.println(25);     }  static class Scanner {  StringTokenizer st;  BufferedReader br;  public Scanner(InputStream s) {  br = new BufferedReader(new InputStreamReader(s));  }  public String next() throws IOException {  while (st == null || !st.hasMoreTokens())   st = new StringTokenizer(br.readLine());  return st.nextToken();  }  public int nextInt() throws IOException {  return Integer.parseInt(next());  }  public long nextLong() throws IOException {  return Long.parseLong(next());  }  public String nextLine() throws IOException {  return br.readLine();  }  public boolean ready() throws IOException {  return br.ready();  }  } }
2,public class Dummy { private static long mod = 1000000007; public static void main(String[] args) throws IOException {  BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));  String[] strs = reader.readLine().split(" ");  long x = Long.parseLong(strs[0]);  long k = Long.parseLong(strs[1]);  long twoPK = modPow(2, k);  long twoPK_1 = (twoPK * 2) % mod;  long res = ((twoPK_1 * (x % mod)) % mod - (twoPK - 1) + mod) % mod;  System.out.println(x == 0? x: res); }  private static long modPow(long base, long pow) {  long res = 1;  while(pow != 0) {  if((pow & 1) != 0) {   res = (res % mod * base % mod)%mod;  }  base = (base % mod * base % mod) % mod;  pow >>= 1;  }  return res; } }
3,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskC solver = new TaskC();   solver.solve(1, in, out);   out.close();  }  static class TaskC {   public void solve(int testNumber, InputReader in, PrintWriter out) {    int n = in.readInt();    int r = in.readInt();    int[] x = in.readIntArray(n);    double[] y = new double[n];    y[0] = r;    for (int i = 1; i < n; i++) {     double max = r;     for (int j = 0; j < i; j++) {      double pow = Math.pow(x[i] - x[j], 2);      if (pow <= 4 * r * r) {       double ty = y[j] + Math.sqrt(4 * r * r - pow);       max = Math.max(max, ty);      }     }     y[i] = max;    }    for (double i : y) out.print(i + " ");   }  }  static class InputReader {   private InputStream stream;   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   private InputReader.SpaceCharFilter filter;   public InputReader(InputStream stream) {    this.stream = stream;   }   public int read() {    if (numChars == -1)     throw new InputMismatchException();    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (numChars <= 0)      return -1;    }    return buf[curChar++];   }   public int readInt() {    int c = read();    while (isSpaceChar(c))     c = read();    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if (c < '0' || c > '9')      throw new InputMismatchException();     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   public boolean isSpaceChar(int c) {    if (filter != null)     return filter.isSpaceChar(c);    return isWhitespace(c);   }   public static boolean isWhitespace(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   public int[] readIntArray(int size) {    int[] ans = new int[size];    for (int i = 0; i < size; i++) ans[i] = readInt();    return ans;   }   public interface SpaceCharFilter {    public boolean isSpaceChar(int ch);   }  } }
0,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  PrintWriter out = new PrintWriter(outputStream);  TaskA solver = new TaskA();  solver.solve(1, in, out);  out.close(); } } class TaskA {  public void solve(int testNumber, InputReader in, PrintWriter out) {   long n = in.readInt();   if(n < 3){    out.print(n);   }   else if(n % 2 != 0) {    out.print(n * (n-1) * (n-2));   }   else if(n % 3 == 0) {    out.print((n-1) * (n-2) * (n-3));   }   else {    out.print(n * (n-1) * (n-3));   }  } } class InputReader {  private InputStream stream; private byte[] buf = new byte[1024]; private int curChar; private int numChars; private SpaceCharFilter filter;  public InputReader(InputStream stream) {  this.stream = stream; }  public int read() {  if (numChars == -1)  throw new InputMismatchException();  if (curChar >= numChars) {  curChar = 0;  try {   numChars = stream.read(buf);  } catch (IOException e) {   throw new InputMismatchException();  }  if (numChars <= 0)   return -1;  }  return buf[curChar++]; }  public int readInt() {  int c = read();  while (isSpaceChar(c))  c = read();  int sgn = 1;  if (c == '-') {  sgn = -1;  c = read();  }  int res = 0;  do {  if (c < '0' || c > '9')   throw new InputMismatchException();  res *= 10;  res += c - '0';  c = read();  } while (!isSpaceChar(c));  return res * sgn; }  public boolean isSpaceChar(int c) {  if (filter != null)  return filter.isSpaceChar(c);  return isWhitespace(c); }  public static boolean isWhitespace(int c) {  return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; }  public interface SpaceCharFilter {  public boolean isSpaceChar(int ch); } }
4,public class C { Scanner in; PrintWriter out;  String INPUT = "";  void solve() {  int n = ni();  int m = ni();  int k = ni();  int[][] f=new int[k][2];       for(int i=0;i<k;i++) {    f[i][0]=ni()-1;    f[i][1]=ni()-1;    }    int mx=-1;    int resx=0;    int resy=0;          for(int i=0;i<n;i++) {    for(int j=0;j<m;j++) {     int min=Integer.MAX_VALUE;     for(int l=0;l<k;l++) {     min=Math.min(min, Math.abs(f[l][0]-i)+Math.abs(f[l][1]-j));     }     if(min>mx) {     mx=min;     resx=i;     resy=j;     }    }        }    out.println((resx+1)+" "+(resy+1));     }  void run() throws Exception {  in = INPUT.isEmpty() ? new Scanner(new File("input.txt")) : new Scanner(INPUT);  out = INPUT.isEmpty() ? new PrintWriter("output.txt") : new PrintWriter(System.out);   solve();  out.flush(); }   public static void main(String[] args) throws Exception {  new C().run(); }  int ni() { return Integer.parseInt(in.next()); } void tr(Object... o) { if(INPUT.length() != 0)System.out.println(o.length > 1 || o[0].getClass().isArray() ? Arrays.deepToString(o) : o[0]); } static String join(int[] a, int d){StringBuilder sb = new StringBuilder();for(int v : a){sb.append(v + d + " ");}return sb.toString();} }
1,public class Solution implements Runnable {  private BufferedReader br = null;  private PrintWriter pw = null;  private StringTokenizer stk = new StringTokenizer("");  public static void main(String[] args) {   new Thread(new Solution()).run();  }  public void run() {     br = new BufferedReader(new InputStreamReader(System.in));   pw = new PrintWriter(new OutputStreamWriter(System.out));   solver();   pw.close();  }  private void nline() {   try {    if (!stk.hasMoreTokens())     stk = new StringTokenizer(br.readLine());   } catch (IOException e) {    throw new RuntimeException("KaVaBUnGO!!!", e);   }  }  private String nstr() {   while (!stk.hasMoreTokens())    nline();   return stk.nextToken();  }  private int ni() {   return Integer.valueOf(nstr());  }  private double nd() {   return Double.valueOf(nstr());  }  String nextLine() {   try {    return br.readLine();   } catch (IOException e) {   }   return null;  }  private void solver() {   int n = ni();   ArrayList<Integer> ar = new ArrayList<Integer>();   int sum = 0;   for (int i = 0; i < n; i++) {    ar.add(ni() % 2);    sum += ar.get(i);   }   int flag = 0;   if(sum==1)flag = 1;    for(int i =0;i<n;i++)if(ar.get(i)==flag)System.out.println(i+1);     }  void exit() {   System.exit(0);  } }
3,public class Main {  public static void main(String[] args) {   Scanner scanner = new Scanner(System.in);   int n = scanner.nextInt();   int[] arr = new int[n];   int chet = 0;   for (int i = 0; i < n; i++) {    arr[i]=scanner.nextInt();    for (int j = 0; j < i; j++) {     if (arr[j]>arr[i]) chet^=1;    }   }   n = scanner.nextInt();   for (int i = 0; i < n; i++) {    int l = scanner.nextInt();    int r = scanner.nextInt();    if ((((r-l+1)/2)&1)!=0){     chet^=1;    }    if (chet==1){     System.out.println("odd");    }else{     System.out.println("even");    }   }  }  }
4,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  MyScanner in = new MyScanner(inputStream);  PrintWriter out = new PrintWriter(outputStream);  EPhoenixAndComputers solver = new EPhoenixAndComputers();  solver.solve(1, in, out);  out.close(); }  static class EPhoenixAndComputers {  public static MyScanner sc;  public static PrintWriter out;  public void solve(int testNumber, MyScanner sc, PrintWriter out) {  EPhoenixAndComputers.sc = sc;  EPhoenixAndComputers.out = out;  int n = sc.nextInt();  long M = sc.nextLong();  MathLib.MOD = M;  long[][] comb = MathLib.getComb(n + 5);  long[] pots2 = MathLib.getPots(2, n + 2);  long[] inv = new long[n + 5];  for (int i = 1; i < inv.length; i++) {   inv[i] = MathLib.inverse(i);  }  long[][] ret = new long[n + 1][n + 1];   for (int size = 0; size <= n; size++) {   if (size <= 1) {   ret[size][size] = 1;   } else if (size == 2) {   ret[size][2] = 2;   } else {   long[] me = ret[size];   me[size] = pots2[size - 1];   for (int i = 1; i + 1 < size; i++) {    int prev = i, next = size - i - 1;    long tmp = pots2[i - 1];    for (int c = 0; c <= next; c++) {    long tot = (ret[next][c] * comb[c][c + prev]) % MathLib.MOD;    tot = (tot * tmp) % MathLib.MOD;    me[prev + c] += tot;    me[prev + c] %= MathLib.MOD;    }   }   }  }  long ans = 0;  for (int i = 0; i <= n; i++) {   ans += ret[n][i];  }  ans %= MathLib.MOD;  out.println(ans);  }  }  static class MathLib {  public static long MOD = 1000000007;  public static long mult(long x, long y) {  return (x * y) % MOD;  }  public static long pow(long base, long exp) {  if (exp == 0) return 1;  if ((exp & 1) == 1) return mult(base, pow(base, exp - 1));  return pow(mult(base, base), exp / 2);  }  public static long inverse(long x) {  return pow(x, MOD - 2);  }  public static long[] getPots(long base, int max) {  long[] ret = new long[max + 1];  ret[0] = 1;  for (int i = 1; i <= max; i++) {   ret[i] = mult(ret[i - 1], base);  }  return ret;  }  public static long[][] getComb(int max) {  long[][] ret = new long[max + 1][max + 1];  for (int n = 0; n <= max; n++) {   ret[0][n] = ret[n][n] = 1;   for (int k = 1; k < n; k++) {   ret[k][n] = (ret[k - 1][n - 1] + ret[k][n - 1]) % MOD;   }  }   return ret;  }  }  static class MyScanner {  private BufferedReader br;  private StringTokenizer tokenizer;  public MyScanner(InputStream is) {  br = new BufferedReader(new InputStreamReader(is));  }  public String next() {  while (tokenizer == null || !tokenizer.hasMoreTokens()) {   try {   tokenizer = new StringTokenizer(br.readLine());   } catch (IOException e) {   throw new RuntimeException(e);   }  }  return tokenizer.nextToken();  }  public int nextInt() {  return Integer.parseInt(next());  }  public long nextLong() {  return Long.parseLong(next());  }  } }
2,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   DOlyaAndMagicalSquare solver = new DOlyaAndMagicalSquare();   int testCount = Integer.parseInt(in.next());   for (int i = 1; i <= testCount; i++)    solver.solve(i, in, out);   out.close();  }  static class DOlyaAndMagicalSquare {   public void solve(int testNumber, InputReader in, PrintWriter out) {    int n = in.NextInt();    long k = in.NextLong();    if (k == 0) {     out.println("YES " + n);     return;    }    long operationTillNow = 0, numberOfCubeOnTheSide = 1;    ArrayList<CubeCount> cubes = new ArrayList<>();    for (int i = n - 1; i >= 0; i--) {     cubes.add(new CubeCount(i, (numberOfCubeOnTheSide - 1) * 2 * 2 + 1));     operationTillNow = operationTillNow + 2 * numberOfCubeOnTheSide - 1;     numberOfCubeOnTheSide *= 2;     long operationLeft = k - operationTillNow;     if (operationLeft == 0) {      out.println("YES " + i);      return;     } else if (operationLeft < 0) {      out.println("NO");      return;     }     for (CubeCount c : cubes) {      if (!c.hasLessThen(operationLeft)) {       out.println("YES " + i);       return;      } else {       operationLeft = c.removeMeFrom(operationLeft);      }     }     if (operationLeft <= 0) {      out.println("YES " + i);      return;     }    }    out.println("NO");    return;   }   class CubeCount {    int sideSizeLogScale;    long repeats;    public CubeCount(int sideSizeLogScale, long repeats) {     this.repeats = repeats;     this.sideSizeLogScale = sideSizeLogScale;    }    public boolean hasLessThen(long k) {     return hasLessThen(k, sideSizeLogScale, repeats);    }    private boolean hasLessThen(long k, int sideLog, long repeats) {     while (true) {      if (k <= 0) return false;      if (sideLog == 0) return true;      k -= repeats;      sideLog--;      repeats *= 4;     }    }    public long removeMeFrom(long k) {     return removeMeFrom(k, sideSizeLogScale, repeats);    }    private long removeMeFrom(long k, int sideLog, long repeats) {     while (true) {      if (sideLog == 0) return k;      k -= repeats;      sideLog--;      repeats *= 4;     }    }   }  }  static class InputReader {   BufferedReader reader;   StringTokenizer tokenizer;   public InputReader(InputStream stream) {    reader = new BufferedReader(new InputStreamReader(stream), 32768);    tokenizer = null;   }   public String next() {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      tokenizer = new StringTokenizer(reader.readLine(), " \t\n\r\f,");     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return tokenizer.nextToken();   }   public int NextInt() {    return Integer.parseInt(next());   }   public long NextLong() {    return Long.parseLong(next());   }  } }
2,public class E extends Thread {  public E(String inputFileName, String outputFileName) {   try {    if (inputFileName != null) {     this.input = new BufferedReader(new FileReader(inputFileName));    } else {     this.input = new BufferedReader(new InputStreamReader(System.in));    }    if (outputFileName != null) {     this.output = new PrintWriter(outputFileName);    } else {     this.output = new PrintWriter(System.out);    }    this.setPriority(Thread.MAX_PRIORITY);   } catch (Throwable e) {    System.err.println(e.getMessage());    e.printStackTrace();    System.exit(666);   }  }    private void solve() throws Throwable {   long l = nextLong(), r = nextLong();   int []bitL = new int[63];   int []bitR = new int[63];   int szL = doit(l, bitL);   int szR = doit(r, bitR);   int ret = szR;   while (ret >= 0 && bitL[ret] == bitR[ret]) --ret;   if (ret < 0) {    output.println(0);   } else {    output.println((1L << (ret + 1)) - 1);   }  }  static final int doit(long q, int []a) {   int sz = 0;   while (q != 0L) {    a[sz++] = (int)(q &1L);    q >>= 1;   }   return sz;  }  public void run() {   try {    solve();   } catch (Throwable e) {    System.err.println(e.getMessage());    e.printStackTrace();    System.exit(666);   } finally {    output.close();   }  }  public static void main(String... args) {   new E(null, null).start();  }  private int nextInt() throws IOException {   return Integer.parseInt(next());  }  private double nextDouble() throws IOException {   return Double.parseDouble(next());  }  private long nextLong() throws IOException {   return Long.parseLong(next());  }  private String next() throws IOException {   while (tokens == null || !tokens.hasMoreTokens()) {    tokens = new StringTokenizer(input.readLine());   }   return tokens.nextToken();  }  private StringTokenizer tokens;  private BufferedReader input;  private PrintWriter output; }
3,public class C {  InputStream in; PrintWriter out;  void solve()  {  int n=ni();  long dp[]=new long[n+1];   dp[0]=1;  for (int i=0;i<n;)  {  i++;  if (nc()=='f')  {     i++;   int k=1;   while (nc()!='s')   {   i++;k++;   }     for (int j=n-1;j>=0;j--)   {   dp[j]=add(dp[j],dp[j+1]);   }     for (int j=n;j>=k;j--)   {   dp[j]=dp[j-k];   }   for (int j=0;j<k;j++)   dp[j]=0;  }  else  {   for (int j=n-1;j>=0;j--)   {   dp[j]=add(dp[j],dp[j+1]);   }  }    }  long sum=0;  for (int i=0;i<=n;i++)  sum=add(sum,dp[i]);  out.println(sum); }  class LazyPropagation  {  long tree[];  long lazy[];  long A[];  public LazyPropagation(int n,long arr[])   {   tree=new long[4*n];   lazy=new long[4*n];   A=arr;   buildSum(1,1,n);  }    public LazyPropagation(int n)   {   tree=new long[4*n];   lazy=new long[4*n];  }    void buildSum(int node,int start,int end)  {   if (start==end)   {   tree[node]=A[start];   }   else   {   int mid=(start+end)>>1;   buildSum(node*2, start, mid);   buildSum(node*2+1, mid+1, end);   tree[node]=tree[node*2]+tree[2*node+1];   }  }    void updateRangeSum(int node, int start, int end,int l,int r,long val)  {   if (lazy[node]!=0)   {   tree[node]=add(tree[node],mul((end-start+1),lazy[node]));   if (start!=end)   {    lazy[2*node]=add(lazy[2*node],lazy[node]);    lazy[node*2+1]=add(lazy[2*node+1],lazy[node]);   }   lazy[node]=0;   }   if (start>end||start>r||end<l)   return;     if (start>=l&&end<=r)   {   tree[node]=add(tree[node],mul((end-start+1),val));   if (start!=end)   {    lazy[2*node]=add(lazy[2*node],val);    lazy[node*2+1]=add(lazy[2*node+1],val);   }   return;   }   int mid=(start+end)>>1;   updateRangeSum(node*2, start, mid, l, r, val);   updateRangeSum(node*2+1, mid+1, end, l, r, val);   tree[node]=add(tree[node*2],tree[node*2+1]);     }    long queryRangeSum(int node,int start,int end,int l,int r)  {   if (start>r||end<l||start>end)   return 0;   if (lazy[node]!=0)   {   tree[node]=add(tree[node],mul((end-start+1),lazy[node]));   if (start!=end)   {    lazy[2*node]=add(lazy[2*node],lazy[node]);    lazy[node*2+1]=add(lazy[2*node+1],lazy[node]);   }   lazy[node]=0;   }     if (start>=l&&end<=r)   return tree[node];     int mid=(start+end)>>1;   return add(queryRangeSum(node*2, start, mid, l, r),queryRangeSum(node*2+1, mid+1, end, l, r));  }  }  long mod=(long)1e9+7; long add(long a,long b) {  long x=(a+b);  while(x>=mod) x-=mod;  return x;   }   long sub(long a,long b) {  long x=(a-b);  while(x<0) x+=mod;  return x;   }   long mul(long a,long b) {  a%=mod;  b%=mod;  long x=(a*b);  return x%mod;   }  void run() throws Exception {  String INPUT = "C:/Users/ayubs/Desktop/input.txt";  in = oj ? System.in : new FileInputStream(INPUT);  out = new PrintWriter(System.out);    long s = System.currentTimeMillis();  solve();  out.flush();  tr(System.currentTimeMillis() - s + "ms"); } public static void main(String[] args) throws Exception {  new C().run(); }  private byte[] inbuf = new byte[1024]; public int lenbuf = 0, ptrbuf = 0;  private int readByte() {  if (lenbuf == -1)  throw new InputMismatchException();  if (ptrbuf >= lenbuf) {  ptrbuf = 0;  try {   lenbuf = in.read(inbuf);  } catch (IOException e) {   throw new InputMismatchException();  }  if (lenbuf <= 0)   return -1;  }  return inbuf[ptrbuf++]; }  private boolean inSpaceChar(int c) {  return !(c >= 33 && c <= 126); }  private int skip() {  int b;  while ((b = readByte()) != -1 && inSpaceChar(b))  ;  return b; }  private double nd() {  return Double.parseDouble(ns()); }  private char nc() {  return (char) skip(); }  private String ns() {  int b = skip();  StringBuilder sb = new StringBuilder();  while (!(inSpaceChar(b))) {   sb.appendCodePoint(b);  b = readByte();  }  return sb.toString(); }  private char[] ns(int n) {  char[] buf = new char[n];  int b = skip(), p = 0;  while (p < n && !(inSpaceChar(b))) {  buf[p++] = (char) b;  b = readByte();  }  return n == p ? buf : Arrays.copyOf(buf, p); }  private char[][] nm(int n, int m) {  char[][] map = new char[n][];  for (int i = 0; i < n; i++)  map[i] = ns(m);  return map; }  private int[] na(int n) {  int[] a = new int[n];  for (int i = 0; i < n; i++)  a[i] = ni();  return a; }  private int ni() {  int num = 0, b;  boolean minus = false;  while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))  ;  if (b == '-') {  minus = true;  b = readByte();  }   while (true) {  if (b >= '0' && b <= '9') {   num = num * 10 + (b - '0');  } else {   return minus ? -num : num;  }  b = readByte();  } }  private long nl() {  long num = 0;  int b;  boolean minus = false;  while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))  ;  if (b == '-') {  minus = true;  b = readByte();  }   while (true) {  if (b >= '0' && b <= '9') {   num = num * 10 + (b - '0');  } else {   return minus ? -num : num;  }  b = readByte();  } }  private boolean oj = System.getProperty("ONLINE_JUDGE") != null;  private void tr(Object... o) {  if (!oj)  System.out.println(Arrays.deepToString(o)); }  }
6,public class main{  static int max = 5000+1; static FastReader in = new FastReader(); static PrintWriter out = new PrintWriter(System.out); static int N = 18; static int[][] mn1 = new int[N][N];  static int[][] mn2 = new int[N][N]; static int[][] dp = new int[1<<N][N]; static int n,m;  static void solve(){  n = in.nextInt(); m = in.nextInt();  int[][] a = new int[n][m];  for(int i=0;i<n;i++)for(int j=0;j<m;j++)a[i][j] = in.nextInt();  for(int i=0;i<n;i++){  Arrays.fill(mn1[i],Integer.MAX_VALUE);  Arrays.fill(mn2[i],Integer.MAX_VALUE);  }   for(int i=0;i<n;i++)  for(int j=0;j<n;j++)   for(int k=0;k<m;k++){   mn1[i][j] = Math.min(mn1[i][j],Math.abs(a[i][k]-a[j][k]));   if(k<=m-2)    mn2[i][j] = Math.min(mn2[i][j],Math.abs(a[i][k]-a[j][k+1]));   }  int ans = 0;  for(int i=0;i<n;i++){  for(int x=0;x<1<<n;x++)Arrays.fill(dp[x],-1);  for(int j=0;j<n;j++)dp[1<<j][j] = 0;  dp[1<<i][i] = Integer.MAX_VALUE;  for(int j=0;j<n;j++)   ans = Math.max(ans,Math.min(mn2[j][i],calc((1 << n) - 1, j)));  }  out.println(ans); }  static int calc(int mask, int v){  if (dp[mask][v] != -1)  return dp[mask][v];  dp[mask][v] = 0;  for(int u=0;u<n;u++) if (v != u && (((mask >> u) & 1)>0))  dp[mask][v] = Math.max(dp[mask][v], Math.min(mn1[u][v], calc(mask ^ (1 << v), u)));  return dp[mask][v]; }  public static void main(String[] args){  solve();  out.flush();  out.close(); }  static class FastReader{   BufferedReader br;   StringTokenizer st;   public FastReader(){    br = new BufferedReader(new InputStreamReader(System.in));   }   public FastReader(String s) throws Exception{    br = new BufferedReader(new FileReader(s));   }   String next(){    while (st == null || !st.hasMoreElements()){     try{      st = new StringTokenizer(br.readLine());     }catch (IOException e){      e.printStackTrace();     }    }    return st.nextToken();   }   String nextLine(){    String str = "";    try{      str = br.readLine();    }catch (IOException e){     e.printStackTrace();    }    return str;   }   int nextInt(){return Integer.parseInt(in.next());}  long nextLong(){return Long.parseLong(in.next());}  double nextDouble(){return Double.parseDouble(in.next());}  } }
1,public class Array {   public static void main(String[] args) {  Scanner in = new Scanner(System.in);  int n = in.nextInt();  int k = in.nextInt();   int last[] = new int[100001];  int distinct = 0;  for ( int i = 0 ; i < n ; ++i ) {  int t = in.nextInt();  if ( last[t] == 0 ) ++distinct;  last[t] = i+1;  if ( distinct == k ) {   int min = i+1;   for ( int j = 0 ; j < last.length ; ++j ) {   if ( last[j] != 0 ) min = min>last[j]?last[j]:min;   }   System.out.println(min+" "+(i+1)); return;  }  }  System.out.println("-1 -1");  }  }
1,public class Edu_46A {  public static void main(String[] args) throws IOException {  BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));  PrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));  int nE = Integer.parseInt(reader.readLine());  int[][] cnt = new int[][] { { 0, 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 } };  for (int i = 0; i < nE; i++) {  String nxt = reader.readLine();  if (nxt.equals("S")) {   cnt[0][0]++;  }  if (nxt.equals("M")) {   cnt[0][1]++;  }  if (nxt.equals("L")) {   cnt[0][2]++;  }  if (nxt.equals("XS")) {   cnt[1][0]++;  }  if (nxt.equals("XL")) {   cnt[1][1]++;  }  if (nxt.equals("XXS")) {   cnt[2][0]++;  }  if (nxt.equals("XXL")) {   cnt[2][1]++;  }  if (nxt.equals("XXXS")) {   cnt[3][0]++;  }  if (nxt.equals("XXXL")) {   cnt[3][1]++;  }  }  for (int i = 0; i < nE; i++) {  String nxt = reader.readLine();  if (nxt.equals("S")) {   cnt[0][0]--;  }  if (nxt.equals("M")) {   cnt[0][1]--;  }  if (nxt.equals("L")) {   cnt[0][2]--;  }  if (nxt.equals("XS")) {   cnt[1][0]--;  }  if (nxt.equals("XL")) {   cnt[1][1]--;  }  if (nxt.equals("XXS")) {   cnt[2][0]--;  }  if (nxt.equals("XXL")) {   cnt[2][1]--;  }  if (nxt.equals("XXXS")) {   cnt[3][0]--;  }  if (nxt.equals("XXXL")) {   cnt[3][1]--;  }  }  int ans = 0;  for (int i = 1; i <= 3; i++) {  ans += Math.abs(cnt[i][0]);  }  int max = 0;  for (int i = 0; i < 3; i++) {  max = Math.max(max, Math.abs(cnt[0][i]));  }  ans += max;  printer.println(ans);  printer.close(); } }
2,public class a {  static long mod = 1000000009;  static ArrayList<Integer>[] g; public static void main(String[] args) throws IOException {    input.init(System.in); PrintWriter out = new PrintWriter((System.out));  int n = input.nextInt(), m = input.nextInt(), k = input.nextInt(); long border = n-n/k; if(m<=border) out.println(m); else {  long count = m- border;  long first = ((pow(2, count+1) + mod - 2)*k)%mod;  first += m - k*count;  out.println(first%mod); }  out.close(); } static long pow(long x, long p) {  if(p==0) return 1;  if((p&1) > 0)  {   return (x*pow(x, p-1))%mod;  }  long sqrt = pow(x, p/2);  return (sqrt*sqrt)%mod; } static long gcd(long a, long b) {  if(b==0) return a;  return gcd(b, a%b); } static class input { static BufferedReader reader; static StringTokenizer tokenizer;   static void init(InputStream input) {  reader = new BufferedReader(      new InputStreamReader(input) );  tokenizer = new StringTokenizer(""); }   static String next() throws IOException {  while ( ! tokenizer.hasMoreTokens() ) {      tokenizer = new StringTokenizer(     reader.readLine() );  }  return tokenizer.nextToken(); }  static int nextInt() throws IOException {  return Integer.parseInt( next() ); }  static double nextDouble() throws IOException {  return Double.parseDouble( next() ); } static long nextLong() throws IOException {  return Long.parseLong( next() ); } static String nextLine() throws IOException {  return reader.readLine(); } } }
3,public class A {  static void solve() throws Exception {  int n = scanInt();  int a[] = new int[n];  for (int i = 0; i < n; i++) {  a[i] = scanInt();  }  sort(a);  int ans = 0;  ans: while (true) {  for (int i = 0;; i++) {   if (i == n) {   break ans;   }   if (a[i] != 0) {   ++ans;   int t = a[i];   a[i] = 0;   for (i++; i < n; i++) {    if (a[i] % t == 0) {    a[i] = 0;    }   }   break;   }  }  }  out.print(ans); }  static int scanInt() throws IOException {  return parseInt(scanString()); }  static long scanLong() throws IOException {  return parseLong(scanString()); }  static String scanString() throws IOException {  while (tok == null || !tok.hasMoreTokens()) {  tok = new StringTokenizer(in.readLine());  }  return tok.nextToken(); }  static BufferedReader in; static PrintWriter out; static StringTokenizer tok;  public static void main(String[] args) {  try {  in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);  solve();  in.close();  out.close();  } catch (Throwable e) {  e.printStackTrace();  exit(1);  } } }
5,public class A { static int [] reverse = new int [257]; public static void main (String [] arg) {  Scanner sc = new Scanner(System.in);  int n = sc.nextInt();  int [] A =new int [n];  for (int i = 0; i<A.length; ++i) A[i] = sc.nextInt();  Arrays.sort(A);  if (n == 1) {  System.out.println( (A[0] == 1) ? "2" : "1");  return;  } else if (A[0] == A[A.length-1] && A[0] == 1) {  System.out.print("1");  for (int i = 1; i<n-1; ++i) System.out.print(" " + A[i]);  System.out.println(" 2");  return;  } else if (A[0] == A[A.length-1]) {  System.out.print("1");  for (int i = 1; i<n; ++i) System.out.print(" " + A[i]);  System.out.println();  return;  }    for (int i = 0; i<A.length; ++i) {  int prev = (i == 0) ? Integer.MAX_VALUE : A[i-1];  int next = (i == A.length-1) ? Integer.MAX_VALUE : A[i+1];  int ans = Math.min(prev, Math.min(next, A[i]));  if (i == 0) ans = 1;    System.out.print((i == 0) ? "" + ans : " " + ans);  }  System.out.println();    }  }
1,public class A25 {  static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); static PrintWriter out = new PrintWriter(System.out);  static int nextInt() throws Exception {  in.nextToken();  return (int)in.nval; }  static String nextString() throws Exception {  in.nextToken();  return in.sval; }  public static void main(String[] args) throws Exception {  int n = nextInt();  int[] c = new int[2];  int[] f = new int[2];  for (int i = 0; i < n; i++) {  int x = nextInt(), p = x%2;  if (c[p]++ == 0) f[p] = i+1;  }  out.println(c[0] == 1 ? f[0] : f[1]);   out.flush(); } }
0,public class Main { public static void main(String[] args) {  Scanner sc=new Scanner(System.in);  int n=sc.nextInt();  while(n-->0){   long a=sc.nextLong(),b=sc.nextLong();   long ans=0,cur=0;   while(a>0 && b>0){    if(b>a)a=a+b-(b=a);    cur=(a/b);    ans+=cur;    a-=(cur*b);   }   System.out.println(ans);  } } }
6,public class Main {  private StreamTokenizer in;  private BufferedWriter out;  public void solve() throws Exception {   int n = nextInt(), m = nextInt();   int[] ss = new int[n];   for (int i=0; i<m; i++)   {    int a = nextInt(), b = nextInt();    a--;b--;    ss[a]|=1<<b;    ss[b]|=1<<a;   }   long[][] res = new long[n][1<<n];   int[] cnt = new int[1<<n], first = new int[1<<n];   for (int i=0; i<n; i++)   {    res[i][1<<i] = 1;    first[1<<i] = i;    cnt[1<<i] = 1;   }   long ans = 0;   for (int mask = 0; mask<1<<n; mask++)   {    for (int last = first[mask]; last<n; last++)    {     if (res[last][mask]==0)      continue;     if (cnt[mask]>2)     {      if ((ss[last]&(1<<first[mask]))!=0)       ans+=res[last][mask];     }     int m2 = (~mask) & ss[last];     for (int next = first[mask]+1; next<n; next++)     {      if ((m2&(1<<next))==0) continue;      int mask2 = mask|1<<next;      res[next][mask2]+=res[last][mask];      cnt[mask2] = cnt[mask]+1;      first[mask2] = first[mask];     }    }   }   ans/=2;   out.write(ans+"\n");  }   public int nextInt() throws Exception  {   in.nextToken();   return (int)in.nval;  }  public void run() {   try {    in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));    out = new BufferedWriter(new OutputStreamWriter(System.out));    solve();    out.flush();   } catch (Exception e) {    e.printStackTrace();    System.exit(1);   }  }  public static void main(String[] args) {   new Main().run();  } }
1,public class CodeChef2 {   static class FastReader  {   BufferedReader br;   StringTokenizer st;    public FastReader()   {    br = new BufferedReader(new      InputStreamReader(System.in));       }    String next()   {    while (st == null || !st.hasMoreElements())    {     try     {      st = new StringTokenizer(br.readLine());     }     catch (IOException e)     {      e.printStackTrace();     }    }    return st.nextToken();   }    int nextInt()   {    return Integer.parseInt(next());   }    long nextLong()   {    return Long.parseLong(next());   }    double nextDouble()   {    return Double.parseDouble(next());   }    String nextLine()   {    String str = "";    try    {     str = br.readLine();    }    catch (IOException e)    {     e.printStackTrace();    }    return str;   }  }                              static class Pair{  int x;  long y;   Pair(int x,long y, Integer integer, int i){  this.y=y;  this.x=x;  }  @Override  public String toString() {  return "(" + x +" "+ y+")";  }     }  static class Edge{  int src;  int dest;  int cost;  int val;   Edge(int src,int dest,int cost,int val){  this.src=src;  this.dest=dest;  this.cost=cost;  this.val=val;  }  public String toString() {  return "(" + src +" "+ dest+": "+ cost +" , "+val+")";  }     }   static class Pair2{  Pair node;  int dist;    Pair2(Pair p,int dist){   node=p;   this.dist=dist;  }  }   static long M=1000000007l;  static HashMap<Character,ArrayList<Character>> dirs;   public static void main(String[] args) throws Exception {   FastReader sc=new FastReader();   BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));      int t=sc.nextInt();   int po=0;     dirs=new HashMap<>();   dirs.put('U', new ArrayList<>());   dirs.get('U').addAll(Arrays.asList('U','R','D','L'));   dirs.put('L', new ArrayList<>());   dirs.get('L').addAll(Arrays.asList('L','U','R','D'));   dirs.put('D', new ArrayList<>());   dirs.get('D').addAll(Arrays.asList('D','L','U','R'));   dirs.put('R', new ArrayList<>());   dirs.get('R').addAll(Arrays.asList('R','D','L','U'));   outer:while(t-- >0) {   po++;   int n=sc.nextInt();   int x=(int) Math.sqrt(n/2);   int y=(int) Math.sqrt(n/4);      if(x*x*2 == n || y*y*4==n)    bw.append("YES\n");   else {    bw.append("NO\n");   }                      }   bw.close();  }      private static int abs(int i) {  if(i<0) {  return -i;  }  return i; }   private static String getRoaring2(String s) {  String res="";  String max="";   for(int i=1;i<=s.length()/2;i++) {    long prev=Long.parseLong(s.substring(0, i));  res=Long.toString(prev);  long prev1=Long.parseLong(res);  long ans=Long.parseLong(s);  long next=prev+1;    while(prev1 <= ans) {   prev1=Long.parseLong(res+Long.toString(next));   res+=Long.toString(next);   next++;  }  if(max.length() == 0) {   max=res;   res="";  }else {   Long a=Long.parseLong(max);   long m=Math.max(a, prev1);   max=Long.toString(m);  }  }  return max; }  private static String getRoaring(String s) {  int val=-1;  for(int i=1;i<=s.length()/2;i++) {  long prev=Long.parseLong(s.substring(0, i));  int j=i,update=i;    while(j<s.length()) {   if(numDigit(prev+1) > numDigit(prev)) {   update++;   }   if(j+update > s.length()) {   break;   }   long cur=Long.parseLong(s.substring(j, j+update));   if(cur != prev+1) {   break;   }   prev=cur;   j+=update;  }    if(j>= s.length()) {   val=i;   break;  }  }  if(val==-1) {  return "";  }else {  String res="";  long prev=Long.parseLong(s.substring(0, val));  res=Long.toString(prev+1);  System.out.println(res+ " ");    long prev1=Long.parseLong(res);    long ans=Long.parseLong(s);    long next=prev+1;    while(prev1 <= ans) {   prev1=Long.parseLong(res+Long.toString(next));   next++;  }  return Long.toString(prev1);  }   }  private static boolean isRoaring(String s) {  for(int i=1;i<=s.length()/2;i++) {  long prev=Long.parseLong(s.substring(0, i));   int j=i,update=i;    while(j<s.length()) {   if(numDigit(prev+1) > numDigit(prev)) {   update++;   }   if(j+update > s.length()) {   break;   }   long cur=Long.parseLong(s.substring(j, j+update));   if(cur != prev+1) {   break;   }   prev=cur;   j+=update;  }    if(j>= s.length()) {   return true;  }  }  return false; }  private static long numDigit(long ans) {  long sum=0;  while(ans > 0) {  sum++;  ans/=10;  }  return sum; }  private static boolean go(int i, int j, long n, long m, Integer k, HashMap<Integer, Boolean>[][] dp) {  if(i==n && j==m && k==0) {  return true;  }  if(i<1 || j<1 || i>n || j>m || k<0) {  return false;  }  if(dp[i][j].containsKey(k)) {  return dp[i][j].get(k);  }   boolean down=go(i+1,j,n,m,k-j,dp);  boolean left=go(i,j+1,n,m,k-i,dp);   dp[i][j].put(k, left||down);  return left||down; }  private static long getDigitSum(long ans) {  long sum=0;  while(ans > 0) {  sum+=ans%10;  ans/=10;  }  return sum; }  private static boolean getAns2(int l, long[] prefix, long x) {   for(int i=l;i<prefix.length-1;i++) {  if((x^prefix[i]) == (prefix[prefix.length-1]^prefix[i])) {   return true;  }  }  return false; }  private static boolean getAns(long[] prefix) {   for(int i=0;i<prefix.length-1;i++) {  if(prefix[i] == (prefix[prefix.length - 1]^prefix[i])) {   return true;  }  }   return false; }  private static void rotate(ArrayList<Integer> arr, int i) {  reverse(arr,0,i-1);  reverse(arr,i,arr.size()-1);  reverse(arr,0,arr.size()-1); }  private static void reverse(ArrayList<Integer> arr, int l, int m) {  while(l<m) {  int temp=arr.get(l);  arr.set(l,arr.get(m));  arr.set(m, temp);  l++;  m--;  } }  static int modInverse(int a, int m)  {   int m0 = m;   int y = 0, x = 1;    if (m == 1)    return 0;    while (a > 1) {    int q = a / m;     int t = m;    m = a % m;    a = t;    t = y;    y = x - q * y;    x = t;   }    if (x < 0)    x += m0;    return x;  }   private static long isPerfectSquare(long num) {  long l=1,h=num;   while(l<=h) {  long mid=l+(h-l)/2;    if(mid*mid == num) {   return mid;  }else if(mid*mid < num) {   l=mid+1;  }else {   h=mid-1;  }  }  return -1; }  private static void rightmax(long[] arr, long n,int[] res,int[] rightmax) {    Deque<Integer> stack=new ArrayDeque<>();   stack.clear();  for(int i=(int) (n-1);i>=0;i--) {  while(!stack.isEmpty() && arr[stack.peek()] <= arr[i]) {   stack.pop();  }    rightmax[i]=(stack.isEmpty()?Integer.MAX_VALUE:stack.peek());  stack.addFirst(i);  } }    private static boolean rotatedSorted(long[] arr, int min) {  reverse(arr,0,min-1);  reverse(arr,min,arr.length-1);  reverse(arr,0,arr.length-1);   if(isSorted(arr)) {  return true;  }  return false; }  private static boolean isSorted(long[] arr) {  for(int i=1;i<arr.length;i++) {  if(arr[i] < arr[i-1]) {   return false;  }  }  return true; }  private static int countDigit(long x) {  int count=0;  while(x > 0) {  x/=10;  count++;  }  return count; }  private static boolean isSub(String s, String c) {  int l=0;   for(int i=0;i<s.length();i++) {  if(l < c.length() && c.charAt(l)==s.charAt(i)) {   l++;  }  if(l==c.length()) {   break;  }  }  if(l==c.length()) {  return true;  }  return false; }  static long power(long a, long d, long n)  {   long res = 1;   a = a % n;   if (a == 0)   return 0;     while (d > 0)   {     if ((d & 1) != 0)    res = (res * a) % n;     d = d >> 1;   a = (a * a) % n;   }   return res;  }  private static void reverse(long[] arr,int l,int m) {  while(l<m) {  long temp=arr[l];  arr[l]=arr[m];  arr[m]=temp;  l++;  m--;  } }   static int UpperBound(ArrayList<Integer> a, int x) {   int l=-1,r=a.size();   while(l+1<r) {    int m=(l+r)>>>1;    if(a.get(m)<=x) l=m;    else r=m;   }   return l+1;  }  private static void printMat(int[][] dp) {    System.out.println("--------------------------------------------------------------------");  for(int i=0;i<dp.length;i++) {   for(int j=0;j<dp[0].length;j++) {   System.out.print(dp[i][j]+" ");   }   System.out.println();  }  System.out.println("--------------------------------------------------------------------"); }   private static int highestOneBit(long n) {  long x=Long.highestOneBit(n);  int c=0;  while(x >0) {  x=x/2;  c++;  }  return c-1; }  private static int bitcount(long l) {  int count=0;    while(l>0) {  l-=(l&(-l));  count++;  }  return count; }  private static void bfs(HashMap<Integer, HashSet<Integer>> tree, int start) {  Queue<Integer> q=new LinkedList<>();  q.offer(start);  HashSet<Integer> visited=new HashSet<>();   System.out.print(q.peek()+"\n");   while(!q.isEmpty()) {  int parent=q.poll();    if(visited.contains(parent)) {   continue;  }  visited.add(parent);  int flag=0;   for(int child:tree.get(parent)) {   if(!visited.contains(child)) {   q.offer(child);   System.out.print(child+" ");   flag=1;   }  }    if(flag==0) {   continue;  }  System.out.println();  } }  static int par; private static HashMap<Integer, HashSet<Integer>> getTreeInputLevel(StringTokenizer st) {  Queue<Integer> q=new LinkedList<>();   HashMap<Integer, HashSet<Integer>> tree=new HashMap<>();  q.offer(Integer.parseInt(st.nextToken()));   par=q.peek();   while(!q.isEmpty()) {  int parent=q.poll();    if(!tree.containsKey(parent)) {   tree.put(parent, new HashSet<Integer>());  }    int left=-1,right=-1;    if(st.hasMoreElements())   left=Integer.parseInt(st.nextToken());    if(st.hasMoreElements())   right=Integer.parseInt(st.nextToken());    if(left != -1) {   tree.get(parent).add(left);   if(!tree.containsKey(left)) {   tree.put(left, new HashSet<Integer>());   }   tree.get(left).add(parent);   q.offer(left);  }    if(right != -1) {   tree.get(parent).add(right);   if(!tree.containsKey(right)) {   tree.put(right, new HashSet<Integer>());   }   tree.get(right).add(parent);   q.offer(right);  }    }  tree.remove(-1);  return tree; }    private static int containsString(String s1,String s2) {  String s=s1+"#"+s2;  int[] z=getZfunc(s);   boolean flag=false;  for(int i=0;i<s.length();i++) {  if(z[i]==s1.length()) {   flag=true;  }  }  int count=0;   for(int i=s1.length();i<z.length;i++) {   if(z[i]==s1.length()) {   count++;  }  }  return count; }  private static int[] getZfunc(String s) {  int[] z=new int[s.length()];  int l=0,r=0;    for(int i=1;i<s.length();i++) {     if(i <= r) {   z[i]=Math.min( z[i-l] , r-i+1);   }   while(i+z[i] < s.length() && s.charAt(z[i])==s.charAt(i+z[i])) {   z[i]++;   }   if(i+z[i] -1 > r) {   l=i;   r=i+z[i]-1;   }     }  return z; }   private static long ceil(long n,long k) {  long ans;  if(n%k==0) {  ans=n/k;  }else {  ans=n/k+1;  }  return ans; }  static ArrayList<Integer> getDivisor(int n){  ArrayList<Integer> div=new ArrayList<>();     for (int i=1; i*i <= n; i++)   {    if (n%i==0)    {     if (n/i == i)      div.add(i);     else {      div.add(i);      div.add(n/i);     }    }   }     return div;  }   static long gcd(long x,long y) {  return (y==0?x:gcd(y,x%y));  }   static int MAXN = 1000001; static int[] spf=new int[MAXN];   static void sieveSmallestFactor()  {   spf[1] = 1;     for (int i=2; i<MAXN; i++)    spf[i] = i;     for (int i=4; i<MAXN; i+=2)    spf[i] = 2;        for (int i=3; i*i<MAXN; i++)   {    if (spf[i] == i)    {     for (int j=i*i; j<MAXN; j+=i)      if (spf[j]==j)       spf[j] = i;    }   }  }     private static HashMap<Integer,Integer> PrimeFactorizationmap(long n) {  int count=0;   HashMap<Integer,Integer> factors=new HashMap<>();  if(n==1) {  factors.put( 1,1);  return factors;  }else {  for(long i=2; i*i <= n ;i++) {   long z=n;   if(z%i==0) {   count=0;   while(z%i==0) {    count++;    z=z/i;   }   factors.put((int) (i+0),count);   }  }  if(n>1) {   factors.put((int) (n+0),1);  }  }  return factors; }     static HashMap<Integer,Integer> getprimeFactors(int n)  {   HashMap<Integer,Integer> ret = new HashMap<>();   while (n > 1)   {    if(ret.containsKey(spf[n])) {    ret.put(spf[n],ret.get(spf[n])+1);   }else {    ret.put(spf[(int) n],1);   }    n = n / spf[n];   }     return ret;  }   static ArrayList<Integer> getPrimeSieve(){  int primesieve[]=new int[1000005];   Arrays.fill(primesieve,0);   for(int i=2;i*i<primesieve.length;i++) {  if(primesieve[i]==0)   for(int j=i*i;j<primesieve.length;j+=i) {    primesieve[j]=1;   }  }   ArrayList<Integer> prime=new ArrayList<>();  for(int i=2;i<primesieve.length;i++) {  if(primesieve[i]==0) {   prime.add(i);  }  }  return prime;  }       private static boolean checkPrimeRM(long n,int k) {  if(n<=4) {  return n==2||n==3;  }   int s=0;  long d=n-1;   while((d&1) != 1) {  d=d/2;  s++;  }   for(int i=0;i<k;i++) {  long a=2+(int)Math.random()*(n-4);  if(isComposite(a,s,d,n)) {   return false;  }  }  return true; }  private static boolean isComposite(long a, int s, long d, long n) {  long x=power(a,d,n);   if(x==1 || x==n-1) {  return false;  }   for(int i=0;i<s;i++){  if(x%(n-1)==0) {   return false;  }  x=(x*x)%n;  }   return true; }   public static HashSet<Long> getPrimeLtoR(int l,int r,List<Integer> prime) {  if(l==1) l++;   int[] arr=new int[r-l+1];   Arrays.fill(arr,0);   for(int i: prime ){   if(i*i<=r) {     int j=(l/i)*i;   if(j<l)    j+=i;   for(;j<=r;j+=i) {   if(j!=i)    arr[j-l]=1;   }  }else {   break;  }    }   HashSet<Long> primeLtoR=new HashSet<>();   for(int i=0;i<arr.length;i++) {  if(arr[i]==0) {   primeLtoR.add((i+l+0l));  }  }  return primeLtoR; } }
4,public class B {  static int n, t[], g[], MOD = (int) 1e9 + 7; static int[][][] memo1, memo2[], memo3[];  static int dp1(int idx, int remCnt, int remSum) {  if (idx == n)  return remSum == 0 && remCnt==0 ? 1 : 0;  if(remCnt<0 || remSum<0)  return 0;  if (memo1[idx][remCnt][remSum] != -1)  return memo1[idx][remCnt][remSum];  int ans = dp1(idx + 1, remCnt, remSum);  if (g[idx] == 0) {  ans += dp1(idx + 1, remCnt - 1, remSum - t[idx]);  if (ans >= MOD)   ans -= MOD;  }  return memo1[idx][remCnt][remSum] = ans; }  static int dp2(int idx, int remCnt1, int remCnt2, int remSum) {  int all = remCnt1 + remCnt2;  if (all == 0)  return remSum == 0 ? 1 : 0;  if (idx == n || remSum == 0)  return 0;  if (memo2[idx][remCnt1][remCnt2][remSum] != -1)  return memo2[idx][remCnt1][remCnt2][remSum];  int ans = dp2(idx + 1, remCnt1, remCnt2, remSum);  if (t[idx] <= remSum) {  if (g[idx] == 1 && remCnt1 > 0)   ans += dp2(idx + 1, remCnt1 - 1, remCnt2, remSum - t[idx]);  else if (g[idx] == 2 && remCnt2 > 0)   ans += dp2(idx + 1, remCnt1, remCnt2 - 1, remSum - t[idx]);  }  return memo2[idx][remCnt1][remCnt2][remSum] = ans; }  private static int dp3(int cnt0, int cnt1, int cnt2, int last) {  if (cnt0 + cnt1 + cnt2 == 0)  return 1;  if (memo3[last][cnt0][cnt1][cnt2] != -1)  return memo3[last][cnt0][cnt1][cnt2];  long ans = 0;  if (cnt0 > 0 && last != 0)  ans += dp3(cnt0 - 1, cnt1, cnt2, 0);  if (cnt1 > 0 && last != 1)  ans += dp3(cnt0, cnt1 - 1, cnt2, 1);  if (cnt2 > 0 && last != 2)  ans += dp3(cnt0, cnt1, cnt2 - 1, 2);  return memo3[last][cnt0][cnt1][cnt2] = (int) (ans % MOD);  }  public static void main(String[] args) throws IOException {  Scanner sc = new Scanner();  PrintWriter out = new PrintWriter(System.out);  n = sc.nextInt();  int[] fac = new int[n + 1];  t = new int[n];  g = new int[n];  int[] cnt = new int[3];  fac[0] = 1;  for (int i = 1; i <= n; i++)  fac[i] = (int) (i * 1L * fac[i - 1] % MOD);  int T = sc.nextInt();  for (int i = 0; i < n; i++) {  t[i] = sc.nextInt();  g[i] = sc.nextInt() - 1;  cnt[g[i]]++;  }  memo1 = new int[n][cnt[0] + 1][T + 1];  memo2 = new int[n][cnt[1] + 1][cnt[2] + 1][T + 1];  memo3 = new int[4][cnt[0] + 1][cnt[1] + 1][cnt[2] + 1];  for (int i = 0; i < n; i++) {  for (int j = 0; j <= cnt[0]; j++)   Arrays.fill(memo1[i][j], -1);  for (int j = 0; j <= cnt[1]; j++)   for (int k = 0; k <= cnt[2]; k++)   Arrays.fill(memo2[i][j][k], -1);  }  for (int i = 0; i < 4; i++)  for (int j = 0; j <= cnt[0]; j++)   for (int k = 0; k <= cnt[1]; k++)   Arrays.fill(memo3[i][j][k], -1);  int ans = 0;  for (int cnt0 = 0; cnt0 <= cnt[0]; cnt0++)  for (int sum0 = 0; sum0 <= T; sum0++)   for (int cnt1 = 0; cnt1 <= cnt[1]; cnt1++)   for (int cnt2 = 0; cnt2 <= cnt[2]; cnt2++) {    long ways = dp1(0, cnt0, sum0) * 1L * dp2(0, cnt1, cnt2, T - sum0) % MOD;    ways = ways * dp3(cnt0, cnt1, cnt2, 3) % MOD;    ways *= fac[cnt0];    ways %= MOD;    ways *= fac[cnt1];    ways %= MOD;    ways *= fac[cnt2];    ways %= MOD;    ans += ways;    if (ans >= MOD)    ans -= MOD;   }  out.println(ans);  out.close();  }  static class Scanner {  BufferedReader br;  StringTokenizer st;  Scanner() {  br = new BufferedReader(new InputStreamReader(System.in));  }  Scanner(String fileName) throws FileNotFoundException {  br = new BufferedReader(new FileReader(fileName));  }  String next() throws IOException {  while (st == null || !st.hasMoreTokens())   st = new StringTokenizer(br.readLine());  return st.nextToken();  }  String nextLine() throws IOException {  return br.readLine();  }  int nextInt() throws IOException {  return Integer.parseInt(next());  }  long nextLong() throws NumberFormatException, IOException {  return Long.parseLong(next());  }  double nextDouble() throws NumberFormatException, IOException {  return Double.parseDouble(next());  }  boolean ready() throws IOException {  return br.ready();  }  } }
0,public class A630 {  public static void main(String[] args) {   System.out.println(25);  } }
5,public class Problem111A implements Runnable {  void solve() throws NumberFormatException, IOException {     final int n = nextInt();   final int[] a = new int[n];     long sum = 0;   for (int i = 0; i < n; i++) {    final int nextInt = nextInt();    sum += nextInt;    a[i] = nextInt;   }   Arrays.sort(a);   int currSum = 0;   int maxCoins = 0;   for (int j = a.length - 1; j >= 0; j--) {    currSum += a[j];    maxCoins++;    if (sum - currSum < currSum) {     break;    }   }   System.out.println(maxCoins);  }  StringTokenizer st;  BufferedReader in;  PrintWriter out;  public static void main(String[] args) {     new Problem111A().run();  }  public void run() {   try {    in = new BufferedReader(new InputStreamReader(System.in));    out = new PrintWriter(System.out);    solve();   } catch (Exception e) {    System.exit(9000);   } finally {    out.flush();    out.close();   }  }  String nextToken() throws IOException {   while (st == null || !st.hasMoreTokens()) {    st = new StringTokenizer(in.readLine());   }   return st.nextToken();  }  int nextInt() throws NumberFormatException, IOException {   return Integer.parseInt(nextToken());  }  long nextLong() throws NumberFormatException, IOException {   return Long.parseLong(nextToken());  }  double nextDouble() throws NumberFormatException, IOException {   return Double.parseDouble(nextToken());  } }
6,public class D { static int dp(int i,int start,int msk) {  if(Integer.bitCount(msk)==n)  return s_e[i][start];  if(dp[i][start][msk]!=-1)  return dp[i][start][msk];   int max=0;  for(int k=0;k<n;k++)  {   int min=Integer.MAX_VALUE;  if((msk & (1<<k)) == 0 )  {   min=diff[i][k];   min=Math.min(min, dp(k,start,msk | (1<<k)));   max=Math.max(max, min);  }  }  return dp[i][start][msk]=max; } static int n,m,a[][],dp[][][],diff[][],s_e[][]; public static void main(String[] args) throws IOException {  Scanner sc = new Scanner();  PrintWriter pw = new PrintWriter(System.out);  n=sc.nextInt();  m=sc.nextInt();  a=new int[n][m];  diff=new int[n][n];  s_e=new int[n][n];  for(int i=0;i<n;i++)  for(int j=0;j<m;j++)   a[i][j]=sc.nextInt();   dp=new int[n][n][70000];  int ans=0;  for(int i=0;i<n;i++)  for(int j=0;j<n;j++)  {   Arrays.fill(dp[i][j], -1);   diff[i][j]=Integer.MAX_VALUE;   s_e[i][j]=Integer.MAX_VALUE;   for(int k=0;k<m-1;k++)   {    diff[i][j]=Math.min(Math.abs(a[i][k]-a[j][k]), diff[i][j]);   s_e[i][j]=Math.min(Math.abs(a[i][k]-a[j][k+1]), s_e[i][j]);   }   diff[i][j]=Math.min(Math.abs(a[i][m-1]-a[j][m-1]), diff[i][j]);  }   for(int i=0;i<n;i++)  ans=Math.max(ans, dp(i,i,1<<i));   pw.print(ans);  pw.close(); }  static class Scanner {  BufferedReader br;  StringTokenizer st;  Scanner() {  br = new BufferedReader(new InputStreamReader(System.in));  }  String next() throws IOException {  while (st == null || !st.hasMoreTokens()) {   st = new StringTokenizer(br.readLine());  }  return st.nextToken();  }  int nextInt() throws IOException {  return Integer.parseInt(next());  }  long nextLong() throws IOException {  return Long.parseLong(next());  }  double nextDouble() throws IOException {  return Double.parseDouble(next());  }  String nextLine() throws IOException {  return br.readLine();  }  boolean hasnext() throws IOException {  return br.ready();  }  } }
5,public class Solution implements Runnable {  public static void main(String[] args) {  (new Thread(null, new Solution(), "1", 1l << 28)).start(); }  public void run() {  try {   in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);  solve();  } catch (Exception e) {  e.printStackTrace();  System.exit(1);  } finally {  out.close();  } }  BufferedReader in; PrintWriter out; StringTokenizer st = null;  String nextToken() throws Exception {  while (st == null || !st.hasMoreTokens()) {    st = new StringTokenizer(in.readLine());  }  return st.nextToken(); }  int nextInt() throws Exception {  return Integer.parseInt(nextToken()); }  void solve() throws Exception {  int n = nextInt();  int[] a = new int[n];  int sum = 0;  for (int i = 0; i < n; i++) sum += (a[i] = nextInt());  Arrays.sort(a);  int ans = 0;  int s = 0;  for (int i = n - 1; i >= 0; i--) {  s += a[i]; ans++;  if (2 * s > sum) break;  }  out.println(ans); }  }
4,public class Solution {  BufferedReader in;  StringTokenizer st;  PrintWriter out;  int n, m, k;  int[] x, y;  char[] qx = new char[4000000], qy = new char[4000000];  int b, e;  char[][] d;  int[] dx = { -1, 0, 1, 0 }, dy = { 0, -1, 0, 1 };  void bfs() {   b = e = 0;   for (int i = 0; i < d.length; i++) {    Arrays.fill(d[i], (char)(1 << 14));   }   for (int i = 0; i < k; ++i) {    qx[e] = (char) x[i];    qy[e++] = (char) y[i];    d[x[i]][y[i]] = 0;   }   for (; b < e; ++b) {    int x = qx[b];    int y = qy[b];    for (int i = 0; i < 4; ++i) {     int nx = x + dx[i];     int ny = y + dy[i];     if (nx >= 0 && nx < n && ny >= 0 && ny < m)      if (d[nx][ny] > d[x][y] + 1) {       d[nx][ny] = (char) (d[x][y] + 1);       qx[e] = (char) nx;       qy[e++] = (char) ny;      }    }   }  }  void solve() throws IOException {   n = ni();   m = ni();   k = ni();   x = new int[k];   y = new int[k];   for (int i = 0; i < k; ++i) {    x[i] = ni() - 1;    y[i] = ni() - 1;   }   d = new char[n][m];   bfs();   int x = -1, y = -1, last = -1;   for (int i = 0; i < n; ++i)    for (int j = 0; j < m; ++j)     if (d[i][j] > last) {      last = d[i][j];      x = i;      y = j;     }   ++x;   ++y;   out.println(x + " " + y);  }  public Solution() throws IOException {   Locale.setDefault(Locale.US);   in = new BufferedReader(new FileReader("input.txt"));   out = new PrintWriter("output.txt");   solve();   in.close();   out.close();  }  String nline() throws IOException {   return in.readLine();  }  String ns() throws IOException {   while (st == null || !st.hasMoreTokens()) {    st = new StringTokenizer(nline());   }   return st.nextToken();  }  int ni() throws IOException {   return Integer.valueOf(ns());  }  long nl() throws IOException {   return Long.valueOf(ns());  }  double nd() throws IOException {   return Double.valueOf(ns());  }  public static void main(String[] args) throws IOException {   new Solution();  } }
0,public class Round313A { private static final int LOCAL_ENV = 0;  public static void main(String[] args) {  Scanner in = new Scanner(System.in);  try {  if (LOCAL_ENV == 1) {   in = new Scanner(new File("input.txt"));  }  } catch (FileNotFoundException e) {  in = new Scanner(System.in);  }  long n = in.nextLong();  if (n >= -9) {  System.out.println(n);  } else {  long absN = Math.abs(n);  long m1 = -(absN / 10);  long last = absN % 10;  long m2 = -((absN / 100) * 10 + last);  System.out.println(Math.max(m1, m2));  } } }
3,public class SameSumBlocks {  public static void main(String[] args) throws Exception {   FastScanner sc = new FastScanner();   PrintWriter out = new PrintWriter(System.out);   int N = sc.nextInt();   int[] pre = new int[N + 1];   var ansMap = new HashMap<Integer, ArrayDeque<Pair>>();   for (int j = 1; j <= N; j++) {    pre[j] = pre[j - 1] + sc.nextInt();    for (int i = j; i >= 1; i--) {     int sum = pre[j] - pre[i - 1];         if (!ansMap.containsKey(sum) || ansMap.get(sum).getLast().r < i) {      var dq = ansMap.computeIfAbsent(sum, val -> new ArrayDeque<>());      dq.add(new Pair(i, j, sum));     }    }   }   var ans = new ArrayDeque<Pair>();   for (var group : ansMap.values()) {    if (group.size() > ans.size()) {     ans = group;    }   }   out.println(ans.size());   for (Pair p : ans) {    out.println(p);   }   out.close();  }  static class Pair {   int l, r, sum;   public Pair(int ll, int rr, int ss) {    l = ll; r = rr; sum = ss;   }   public String toString() {    return l + " " + r;   }  }  static class FastScanner {   private int BS = 1<<16;   private char NC = (char)0;   private byte[] buf = new byte[BS];   private int bId = 0, size = 0;   private char c = NC;   private double cnt = 1;   private BufferedInputStream in;   public FastScanner() {    in = new BufferedInputStream(System.in, BS);   }   public FastScanner(String s) {    try {     in = new BufferedInputStream(new FileInputStream(new File(s)), BS);    }    catch (Exception e) {     in = new BufferedInputStream(System.in, BS);    }   }   private char getChar(){    while(bId==size) {     try {      size = in.read(buf);     }catch(Exception e) {      return NC;     }     if(size==-1)return NC;     bId=0;    }    return (char)buf[bId++];   }   public int nextInt() {    return (int)nextLong();   }   public int[] nextInts(int N) {    int[] res = new int[N];    for (int i = 0; i < N; i++) {     res[i] = (int) nextLong();    }    return res;   }   public long[] nextLongs(int N) {    long[] res = new long[N];    for (int i = 0; i < N; i++) {     res[i] = nextLong();    }    return res;   }   public long nextLong() {    cnt=1;    boolean neg = false;    if(c==NC)c=getChar();    for(;(c<'0' || c>'9'); c = getChar()) {     if(c=='-')neg=true;    }    long res = 0;    for(; c>='0' && c <='9'; c=getChar()) {     res = (res<<3)+(res<<1)+c-'0';     cnt*=10;    }    return neg?-res:res;   }   public double nextDouble() {    double cur = nextLong();    return c!='.' ? cur:cur+nextLong()/cnt;   }   public String next() {    StringBuilder res = new StringBuilder();    while(c<=32)c=getChar();    while(c>32) {     res.append(c);     c=getChar();    }    return res.toString();   }   public String nextLine() {    StringBuilder res = new StringBuilder();    while(c<=32)c=getChar();    while(c!='\n') {     res.append(c);     c=getChar();    }    return res.toString();   }   public boolean hasNext() {    if(c>32)return true;    while(true) {     c=getChar();     if(c==NC)return false;     else if(c>32)return true;    }   }  } }
4,public class P1 { public static void main(String[] args) {  String s = null;   try {   Scanner sc = new Scanner(System.in);  s = sc.next();    }  catch (Exception e) {  e.printStackTrace();  }   int n = s.length();   HashSet<String> h = new HashSet<String>();  String t=null;  boolean b;  int lmax = 0;  for (int i=0; i<n; i++) {  for (int j=i+1; j<=n; j++) {   t = s.substring(i, j);   b = h.add(t);   if (b==false) {   if (j-i>lmax) {    lmax = j-i;    }   }  }  }  System.out.println(lmax); } }
4,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   FastScanner in = new FastScanner(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskE solver = new TaskE();   solver.solve(1, in, out);   out.close();  }  static class TaskE {   public void solve(int testNumber, FastScanner in, PrintWriter out) {    int n = in.nextInt();    int MOD = in.nextInt();    int[][] C = new int[n + 1][n + 1];    C[0][0] = 1;    for (int i = 1; i < C.length; i++) {     C[i][0] = 1;     for (int j = 1; j < C.length; j++) {      C[i][j] = C[i - 1][j] + C[i - 1][j - 1];      if (C[i][j] >= MOD) {       C[i][j] -= MOD;      }     }    }    int[] p2 = new int[n + 1];    p2[0] = 1;    for (int i = 1; i < p2.length; i++) {     p2[i] = 2 * p2[i - 1] % MOD;    }    int[][] d = new int[n + 1][n + 1];    d[0][0] = 1;       for (int i = 1; i <= n; i++) {         for (int j = 1; j <= i; j++) {           for (int t = 1; t <= j; t++) {       if (t == i - 1) {        continue;       }       d[i][j] = (int) ((d[i][j] + (long) C[j][t] * p2[t - 1] % MOD * d[i - t - (i == t ? 0 : 1)][j - t]) % MOD);      }     }    }    int ans = 0;    for (int k = 1; k <= n; k++) {     ans += d[n][k];     if (ans >= MOD) {      ans -= MOD;     }    }    out.println(ans);   }  }  static class FastScanner {   private BufferedReader in;   private StringTokenizer st;   public FastScanner(InputStream stream) {    in = new BufferedReader(new InputStreamReader(stream));   }   public String next() {    while (st == null || !st.hasMoreTokens()) {     try {      st = new StringTokenizer(in.readLine());     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return st.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }  } }
1,public class A {   public static void main(String[] args) throws NumberFormatException, IOException {   BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));  int nums = Integer.parseInt(reader.readLine());   String line = reader.readLine();  int[] ar = new int[nums];  String[] par = line.split(" ");   for(int i=0; i<nums; i++){  ar[i] = Integer.parseInt(par[i]);  }  A a = new A();   System.out.print(a.getDif(ar)); }  private int getDif(int[] input){  int odd = 0, even = 0, d = 0;  int p = 0, q = 0;   for(int i=0; i<input.length; i++){  int t = input[i]%2;  if(t==0){   even++;   p = i+1;  }  else{   odd++;   q = i+1;  }     if(odd>0 && even>0 && (odd!=even)){   if(even>odd)   return q;   else   return p;  }    }   return d; } }
4,public class Compute {  public static void main(String[] args) {   Scanner sc = new Scanner(System.in);   int n = sc.nextInt();   long M = sc.nextInt();   long fact[] = new long[n+1];   long inv[] = new long[n+1];   long ifact[] = new long[n+1];   long dp[][] = new long[n+1][n+1];   fact[1] = 1;   ifact[1] = 1;   ifact[0] = 1;   inv[1] = 1;   dp[1][1] = 1;     for(int i = 2; i <= n; i++) {    fact[i] = (i*fact[i-1]) % M;    inv[i] = (inv[(int)(M % i)]*(M - M/i)) % M;    dp[i][i] = (dp[i-1][i-1] * 2) % M;    ifact[i] = (ifact[i-1]*inv[i]) % M;   }      for(int i = 3; i <= n; i++) {    for(int j = i/2 + 1; j <= i-1; j++) {     for(int k = 2; k <= i-1 && j-k+1 > (i-k)/2; k++) {      dp[i][j] = (dp[i][j] + ((((dp[k-1][k-1]*dp[i-k][j-k+1] % M)*fact[j] % M)*ifact[k-1] % M)*ifact[j-k+1] % M)) % M;      }    }    }     long sum = 0;   for(int i = n/2 + 1; i <= n; i++)    sum = (sum + dp[n][i]) % M;     System.out.println(sum % M);  } }
3,public class Main{  public static void main(String[] args) {   Scanner sc=new Scanner(System.in);   PrintWriter out=new PrintWriter(System.out);   int n=sc.nextInt();   int a[]=new int[n];   for (int i = 0; i <n ; i++) {    a[i]=sc.nextInt();   }   HashMap<Integer,ArrayList<Node>> h=new HashMap<>();   for (int i = 0; i <n ; i++) {    int sum=0;    for (int j = i; j <n ; j++) {     sum+=a[j];     if(h.containsKey(sum)){      h.get(sum).add(new Node(i,j));     }     else{      ArrayList<Node> temp=new ArrayList<>();      temp.add(new Node(i,j));      h.put(sum,temp);     }    }   }   long ans=0;   ArrayList<Integer> ansList=new ArrayList<>();   for(int x:h.keySet()){    Collections.sort(h.get(x), new Comparator<Node>() {     @Override     public int compare(Node o1, Node o2) {      return Integer.compare(o1.r,o2.r);     }    });     ArrayList<Node> l=h.get(x);       ArrayList<Integer> temp=new ArrayList<>();    int lasty=Integer.MIN_VALUE;    for (int i = 0; i <l.size() ; i++) {     if(l.get(i).l>lasty){      lasty=l.get(i).r;      temp.add(l.get(i).l);      temp.add(l.get(i).r);     }    }    if(ans<temp.size()){     ansList=temp;     ans=ansList.size();    }   }   out.println(ans/2);   for (int i = 0; i <ansList.size() ; i++) {    out.print((ansList.get(i)+1)+" ");    i++;    out.println((ansList.get(i)+1)+" ");   }    out.close();  }  static class Node{   int l,r;   public Node(int a,int b){    l=a;    r=b;   }  } }
3,public class Task {  public static void solve() throws Exception { int n = nextInt(); int[] S = new int[n]; for(int i=0;i<n;i++) {  S[i] = nextInt();  if(i > 0) {  S[i] += S[i-1];  } } Map<Integer, List<L>> map = new HashMap<>(); for(int j=0;j<n;j++) {  for(int i=j;i>=0;i--) {  int sum = S[j];  if(i > 0) {   sum -= S[i-1];  }  L l = new L();  l.a = i;  l.b = j;  List<L> list = map.get(sum);  if(list == null) {   list = new ArrayList<>();   map.put(sum, list);  }  list.add(l);  } } List<L> longest = null; for(Integer sum: map.keySet()) {  List<L> list = map.get(sum);  Collections.sort(list);  List<L> list2 = new ArrayList<>(list.size());  int from = list.get(0).a;  for(L l: list) {  if(l.a >= from) {   list2.add(l);   from = l.b + 1;  }  }  if(longest == null || longest.size() < list2.size()) {  longest = list2;  } }  println(longest.size()); for(int i=0;i<longest.size();i++) {  L l = longest.get(i);  println((l.a+1) + " " + (l.b+1)); }  }   private static class L implements Comparable<L>{ int a; int b;  @Override public int compareTo(L l2) {  return Integer.valueOf(b).compareTo(l2.b); }  }   public static void main(String[] args) throws Exception { try {  fastReader = new FastReader(System.in);  systemOut = new BufferedOutputStream(System.out);  solve(); } finally {  systemOut.close(); }  }  private static FastReader fastReader = null;  private static BufferedOutputStream systemOut = null;  public static void print(Object obj) { print(obj.toString());  }  public static void print(String str) { try {  systemOut.write(str.getBytes("utf-8")); } catch (Exception ex) {  throw new RuntimeException(ex); }  }  public static void println(Object obj) { println(obj.toString());  }  public static void println(String str) { try {  print(str);  systemOut.write('\n'); } catch (Exception ex) {  throw new RuntimeException(ex); }  }  public static String next() { return fastReader.readNextToken(false);  }  public static String nextLine() { return fastReader.readNextToken(true);  }  public static int nextInt() { return Integer.parseInt(fastReader.readNextToken(false));  }  public static long nextLong() { return Long.parseLong(fastReader.readNextToken(false));  }  public static double nextDouble() { return Double.parseDouble(fastReader.readNextToken(false));  }  static class FastReader { private byte[] buf = new byte[65536]; private int ind = 0; private int maxInd = -1; private InputStream is = null; private boolean eof = false; private boolean lastCharRead = false;  public FastReader(InputStream is) {  this.is = is; }  public String readNextToken(boolean endOfLine) {  try {  StringBuilder sb = new StringBuilder();  boolean found = false;  while (true) {   if (lastCharRead) {  return null;   } else if (ind > maxInd) {  if (eof) {   lastCharRead = true;  } else {   fillBuffer();  }   }   byte b = '\n';   if (!lastCharRead) {  b = buf[ind++];   }   if (b == '\r') {     } else if ((b == '\n' && endOfLine) || (Character.isWhitespace(b) && !endOfLine)) {  if (found) {   break;  }   } else {  sb.append((char) b);  found = true;   }  }  return sb.toString();  } catch (Exception ex) {  throw new RuntimeException(ex);  } }  private void fillBuffer() {  try {  int read = is.read(buf, 0, buf.length);  if (read < buf.length) {   eof = true;  }  ind = 0;  maxInd = read - 1;  } catch (Exception ex) {  throw new RuntimeException(ex);  } }  }  public static class LST { public long[][] set; public int n;  public LST(int n) {  this.n = n;  int d = 1;  for (int m = n; m > 1; m >>>= 6, d++)  ;   set = new long[d][];  for (int i = 0, m = n >>> 6; i < d; i++, m >>>= 6) {  set[i] = new long[m + 1];  } }   public LST setRange(int r) {  for (int i = 0; i < set.length; i++, r = r + 63 >>> 6) {  for (int j = 0; j < r >>> 6; j++) {   set[i][j] = -1L;  }  if ((r & 63) != 0)   set[i][r >>> 6] |= (1L << r) - 1;  }  return this; }   public LST unsetRange(int r) {  if (r >= 0) {  for (int i = 0; i < set.length; i++, r = r + 63 >>> 6) {   for (int j = 0; j < r + 63 >>> 6; j++) {  set[i][j] = 0;   }   if ((r & 63) != 0)  set[i][r >>> 6] &= ~((1L << r) - 1);  }  }  return this; }  public LST set(int pos) {  if (pos >= 0 && pos < n) {  for (int i = 0; i < set.length; i++, pos >>>= 6) {   set[i][pos >>> 6] |= 1L << pos;  }  }  return this; }  public LST unset(int pos) {  if (pos >= 0 && pos < n) {  for (int i = 0; i < set.length && (i == 0 || set[i - 1][pos] == 0L); i++, pos >>>= 6) {   set[i][pos >>> 6] &= ~(1L << pos);  }  }  return this; }  public boolean get(int pos) {  return pos >= 0 && pos < n && set[0][pos >>> 6] << ~pos < 0; }  public LST toggle(int pos) {  return get(pos) ? unset(pos) : set(pos); }  public int prev(int pos) {  for (int i = 0; i < set.length && pos >= 0; i++, pos >>>= 6, pos--) {  int pre = prev(set[i][pos >>> 6], pos & 63);  if (pre != -1) {   pos = pos >>> 6 << 6 | pre;   while (i > 0)  pos = pos << 6 | 63 - Long.numberOfLeadingZeros(set[--i][pos]);   return pos;  }  }  return -1; }  public int next(int pos) {  for (int i = 0; i < set.length && pos >>> 6 < set[i].length; i++, pos >>>= 6, pos++) {  int nex = next(set[i][pos >>> 6], pos & 63);  if (nex != -1) {   pos = pos >>> 6 << 6 | nex;   while (i > 0)  pos = pos << 6 | Long.numberOfTrailingZeros(set[--i][pos]);   return pos;  }  }  return -1; }  private static int prev(long set, int n) {  long h = set << ~n;  if (h == 0L)  return -1;  return -Long.numberOfLeadingZeros(h) + n; }  private static int next(long set, int n) {  long h = set >>> n;  if (h == 0L)  return -1;  return Long.numberOfTrailingZeros(h) + n; }  @Override public String toString() {  List<Integer> list = new ArrayList<Integer>();  for (int pos = next(0); pos != -1; pos = next(pos + 1)) {  list.add(pos);  }  return list.toString(); }  } }
1,public class C{  static PrintWriter out;  static InputReader in;  public static void main(String args[]){   out = new PrintWriter(System.out);   in = new InputReader();   new C();   out.flush(); out.close();  }   C(){   int w = solve();   out.print(w == 0 ? "sjfnb" : "cslnb");  }  int n;  long a[];  int solve(){   n = in.nextInt(); a = new long[n];   long sum = 0;   for(int i = 0; i < n; i++)sum += a[i] = in.nextLong();   if(sum == 0){    return 1;   }   Arrays.sort(a);   int c = 0, c0 = 0; long p = -1, max = 0;   int f = 0;   long t = -1; int pp = -1;   for(int i = 0; i < n; i++){    if(a[i] == p){     c++;    }else{     if(p == 0)c0 = c;     if(c >= 2){f++; t = p; pp = i - 2;}     max = Math.max(max, c);     p = a[i];     c = 1;    }   }   max = Math.max(max, c);   sum = 0;   if(c >= 2){f++; t = p; pp = n - 2;}   if(max > 2 || c0 > 1 || f > 1)return 1;   if(f == 1){    long v = Arrays.binarySearch(a, t - 1);    if(v >= 0)return 1;    a[pp]--; sum = 1;   }   p = -1;   for(int i = 0; i < n; i++){    sum += a[i] - (p + 1);    a[i] = p + 1;    p = a[i];   }   return 1 - (int)(sum % 2);  }  public static class InputReader{   BufferedReader br;   StringTokenizer st;   InputReader(){    br = new BufferedReader(new InputStreamReader(System.in));   }   public int nextInt(){    return Integer.parseInt(next());   }   public long nextLong(){    return Long.parseLong(next());   }   public double nextDouble(){    return Double.parseDouble(next());   }   public String next(){    while(st == null || !st.hasMoreTokens()){     try{      st = new StringTokenizer(br.readLine());     }catch(IOException e){}    }    return st.nextToken();   }  } }
4,public class Main {  static BufferedReader reader   = new BufferedReader(new InputStreamReader(System.in));    static StringBuilder out = new StringBuilder();  public static void main(String[] args){   solve();   return;  }    static int nextInt(){   return Integer.parseInt(nextLine());  }  static long nextLong(){   return Long.parseLong(nextLine());  }  static int[] nextIntArray(){   String[] inp = nextLine().split("\\s+");   int[] ary = new int[inp.length];   for (int i = 0; i < ary.length; i++){    ary[i] = Integer.parseInt(inp[i]);   }   return ary;  }  static int[] nextIntArrayFrom1(){   String[] inp = nextLine().split("\\s+");   int[] ary = new int[inp.length + 1];   for (int i = 0; i < inp.length; i++){    ary[i+1] = Integer.parseInt(inp[i]);   }   return ary;  }  static long[] nextLongArray(){   String[] inp = nextLine().split("\\s+");   long[] ary = new long[inp.length];   for (int i = 0; i < inp.length; i++){    ary[i] = Long.parseLong(inp[i]);   }   return ary;  }  static long[] nextLongArrayFrom1(){   String[] inp = nextLine().split("\\s+");   long[] ary = new long[inp.length + 1];   for (int i = 0; i < inp.length; i++){    ary[i+1] = Long.parseLong(inp[i]);   }   return ary;  }  static String nextLine(){   try {    return reader.readLine().trim();   } catch (Exception e){}   return null;  }  static void solve(){   String str = nextLine();   int max=0;   int index=0;   for(int i=0;i<str.length();i++){    for(int j=i+1;j<str.length();j++){     if(str.charAt(i)==str.charAt(j)){      int count=1;      while(true){       if(str.length()<=i+count || str.length()<=j+count || str.charAt(i+count)!=str.charAt(j+count) )        break;       count++;      }      if(max<count){       max=count;       index=i;      }     }    }   }   System.out.println(max);   return;  } }
0,public class A {  public static void main(String[] args) {   Scanner sc = new Scanner(System.in);   int n = sc.nextInt();   if (n % 2 == 0) {    System.out.printf("%d %d", 4, n - 4);   } else {    System.out.printf("%d %d", 9, n - 9);   }  } }
4,public class GeorgeAndInterestingGraph {  public static void main(String[] args) {   MyScanner sc = new MyScanner();     int N = sc.nextInt();   int M = sc.nextInt();     int[] edgeFrom = new int[M];   int[] edgeTo = new int[M];   for (int i = 0; i < M; i++) {   edgeFrom[i] = sc.nextInt();   edgeTo[i] = sc.nextInt();   }     int best = Integer.MAX_VALUE;  boolean[][] adjMat = makeAdjMat(N, edgeFrom, edgeTo);   for (int i = 0; i < N; i++) {   boolean[][] mat = copyOfArray2d(adjMat);   best = Math.min(best, count(mat, M, i));   }     System.out.println(best);  }   public static boolean[][] copyOfArray2d(boolean[][] arr) {  int N = arr.length;  int M = arr[0].length;  boolean[][] copy = new boolean[N][M];  for (int i = 0; i < N; i++) {   System.arraycopy(arr[i], 0, copy[i], 0, M);  }  return copy;  }   public static int count(boolean[][] mat, int M, int center) {                                      int N = mat.length;     int cntWithI = (mat[center][center]) ? 1 : 0;  for (int i = 0; i < N; i++) {   if (i != center) {   if (mat[i][center]) {    cntWithI++;   }   if (mat[center][i]) {    cntWithI++;   }   }   mat[i][center] = false;   mat[center][i] = false;  }    int other = M - cntWithI;             int matches = bipartiteMatching(mat);    return (2 * N - 1 - cntWithI + other - matches + N - 1 - matches);  }   public static boolean[][] makeAdjMat(int N, int[] edgeFrom, int[] edgeTo) {  boolean[][] mat = new boolean[N][N];  for (int i = 0; i < edgeFrom.length; i++) {   int from = edgeFrom[i] - 1;   int to = edgeTo[i] - 1;   mat[from][to] = true;  }  return mat;  }     public static boolean fordFulkersonHelper(int[][] resid, int s, int t, int[] parent) {  int V = resid.length;  boolean[] visited = new boolean[V];  LinkedList<Integer> q = new LinkedList<Integer>();  q.push(s);  visited[s] = true;  parent[s] = -1;    while (!q.isEmpty()) {   int u = q.pop();   for (int v = 0; v < V; v++) {   if (!visited[v] && resid[u][v] > 0) {    q.push(v);    parent[v] = u;    visited[v] = true;   }   }  }    return visited[t];  }     public static int fordFulkerson(int[][] graph, int s, int t) {  int V = graph.length;  int[][] resid = new int[V][V];  int[] parent = new int[V];  int maxFlow = 0;    for (int u = 0; u < V; u++) {   for (int v = 0; v < V; v++) {   resid[u][v] = graph[u][v];   }  }    while (fordFulkersonHelper(resid, s, t, parent)) {   int pathFlow = Integer.MAX_VALUE;   for (int v = t; v != s; v = parent[v]) {   int u = parent[v];   pathFlow = Math.min(pathFlow, resid[u][v]);   }   for (int v = t; v != s; v = parent[v]) {   int u = parent[v];   resid[u][v] -= pathFlow;   resid[v][u] += pathFlow;   }   maxFlow += pathFlow;  }    return maxFlow;  }     public static boolean bipartiteMatchingHelper(boolean[][] bpGraph, int u, boolean[] seen, int[] matchR) {  int N = bpGraph[0].length;  for (int v = 0; v < N; v++) {   if (bpGraph[u][v] && !seen[v]) {   seen[v] = true;   if (matchR[v] < 0 || bipartiteMatchingHelper(bpGraph, matchR[v], seen, matchR)) {    matchR[v] = u;    return true;   }   }  }  return false;  }     public static int bipartiteMatching(boolean[][] bpGraph, int[] matchIJ, int[] matchJI) {  int ans = bipartiteMatching(bpGraph, matchJI);    for (int i = 0; i < matchJI.length; i++) {   matchIJ[i] = -1;  }    for (int j = 0; j < matchJI.length; j++) {   int i = matchJI[j];   if (i >= 0) {   matchIJ[i] = j;   }  }    return ans;  }     public static int bipartiteMatching(boolean[][] bpGraph, int[] matchJI) {  int M = bpGraph.length;  int N = bpGraph[0].length;    for (int i = 0; i < N; i++) {   matchJI[i] = -1;  }    int ans = 0;  for (int u = 0; u < M; u++) {   boolean[] seen = new boolean[N];   if (bipartiteMatchingHelper(bpGraph, u, seen, matchJI)) {   ans++;   }  }    return ans;  }     public static int bipartiteMatching(boolean[][] bpGraph) {  int N = bpGraph[0].length;  int[] matchJI = new int[N];  return bipartiteMatching(bpGraph, matchJI);  }     public static int bipartiteMatching(int[][] intGraph) {  boolean[][] bpGraph = intToBooleanAdjMat(intGraph);  return bipartiteMatching(bpGraph);  }    public static int bipartiteMatching(int[][] intGraph, int[] matchJI) {  boolean[][] bpGraph = intToBooleanAdjMat(intGraph);  return bipartiteMatching(bpGraph, matchJI);  }    public static int bipartiteMatching(int[][] intGraph, int[] matchIJ, int[] matchJI) {  boolean[][] bpGraph = intToBooleanAdjMat(intGraph);  return bipartiteMatching(bpGraph, matchIJ, matchJI);  }     public static boolean[][] intToBooleanAdjMat(int[][] mat) {  int M = mat.length;  int N = mat[0].length;  boolean[][] bMat = new boolean[M][N];  for (int i = 0; i < M; i++) {   for (int j = 0; j < N; j++) {   bMat[i][j] = (mat[i][j] != 0);   }  }  return bMat;  }  public static class MyScanner {   BufferedReader br;   StringTokenizer st;   public MyScanner() {    br = new BufferedReader(new InputStreamReader(System.in));   }   int nextInt() {    return Integer.parseInt(next());   }   long nextLong() {    return Long.parseLong(next());   }   double nextDouble() {    return Double.parseDouble(next());   }   String next() {    while (st == null || !st.hasMoreElements()) {     try {      st = new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    }    return st.nextToken();   }   String nextLine() {    String str = "";    try { str = br.readLine(); }    catch (IOException e) { e.printStackTrace(); }    return str;   }  } }
2,public class C {                         public static void main(String[] args)  {   Scanner sc = new Scanner(System.in);   BigInteger x = sc.nextBigInteger();   BigInteger k = sc.nextBigInteger();   BigInteger zero = new BigInteger("0");   BigInteger one = new BigInteger("1");   BigInteger two = new BigInteger("2");   BigInteger modulo = new BigInteger("1000000007");   BigInteger ans = two.modPow(k.add(one),modulo);   ans = ans.multiply(x);   ans = ans.subtract(two.modPow(k,modulo));   ans = ans.add(one);   ans = ans.mod(modulo);   if (x.equals(zero))   {   System.out.println(0);   }   else   {   System.out.println(ans);   }  } }
3,public class Main {  static FastScanner fs=new FastScanner();  static class FastScanner {   BufferedReader br=new BufferedReader(new InputStreamReader(System.in));   StringTokenizer st=new StringTokenizer("");   public String next() {    while (!st.hasMoreElements())     try {      st=new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    return st.nextToken();   }   int Int() {    return Integer.parseInt(next());   }   long Long() {    return Long.parseLong(next());   }   String Str(){    return next();   }  }   public static void main (String[] args) throws java.lang.Exception {   PrintWriter out = new PrintWriter(System.out);    int T=1;   for(int t=0;t<T;t++){    int n=Int();    int A[]=new int[n];    for(int i=0;i<n;i++){     A[i]=Int();    }    Solution sol=new Solution();    sol.solution(out,A);   }   out.flush();  }  public static int Int(){   return fs.Int();  }  public static long Long(){   return fs.Long();  }  public static String Str(){   return fs.Str();  } }    class Solution{  public void solution(PrintWriter out,int A[]){   Map<Integer,List<int[]>>f=new HashMap<>();   List<int[]>res=new ArrayList<>();   for(int i=0;i<A.length;i++){    int sum=0;    for(int j=i;j<A.length;j++){     sum+=A[j];     if(!f.containsKey(sum))f.put(sum,new ArrayList<>());     List<int[]>list=f.get(sum);     list.add(new int[]{i,j});    }   }    for(Integer key:f.keySet()){    List<int[]>list=f.get(key);    Collections.sort(list,(a,b)->{     return a[1]-b[1];    });    int pre[]=new int[list.size()];    Arrays.fill(pre,-1);     int dp[][]=new int[list.size()][2];    dp[0][0]=1;    dp[0][1]=0;    for(int i=1;i<list.size();i++){     int pair[]=list.get(i);     int l=0,r=i-1;     int pos=-1;     while(l<=r){      int mid=l+(r-l)/2;      if(list.get(mid)[1]<pair[0]){       pos=mid;       l=mid+1;      }      else{       r=mid-1;      }     }     if(pos!=-1){      int mx=1+dp[pos][0];      if(mx>=dp[i-1][0]){       dp[i][0]=mx;       dp[i][1]=i;       pre[i]=dp[pos][1];      }      else{       dp[i][0]=dp[i-1][0];       dp[i][1]=dp[i-1][1];      }     }     else{      dp[i][0]=dp[i-1][0];      dp[i][1]=dp[i-1][1];     }    }    int n=list.size();    if(dp[n-1][0]>res.size()){     res=new ArrayList<>();     int j=dp[n-1][1];     while(j!=-1){      res.add(list.get(j));      j=pre[j];     }    }       }     out.println(res.size());   for(int p[]:res){    out.println((p[0]+1)+" "+(p[1]+1));   }  }   }
3,public class A {  public static void main(String[] args) throws Exception {   BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));   PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));   int n = Integer.parseInt(bf.readLine());   StringTokenizer st = new StringTokenizer(bf.readLine());   int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());   int counter = 0;   TreeSet<Integer> val = new TreeSet<Integer>();   for(int i : a) val.add(i);   while(!val.isEmpty()) {   int min = val.first();   Set<Integer> toRemove = new HashSet<Integer>();   for(int i : val) if(i % min == 0) toRemove.add(i);   for(int i : toRemove) val.remove(i);   counter++;   }   out.println(counter);      out.close(); System.exit(0);  } }
3,public class MainG { static StdIn in = new StdIn(); static PrintWriter out = new PrintWriter(System.out); static long M=(long)1e9+7; static int n, dig; static int[] x; static long[] p10, s; static long[][][] dp;  public static void main(String[] args) {  char[] cs = in.next().toCharArray();  n=cs.length;  x = new int[n];  for(int i=0; i<n; ++i)  x[i]=cs[i]-'0';  p10 = new long[n];  p10[0]=1;  for(int i=1; i<n; ++i)  p10[i]=p10[i-1]*10%M;  s = new long[n+1];  s[n]=1;  for(int i=n-1; i>=0; --i)  s[i]=(s[i+1]+x[i]*p10[n-1-i])%M;  long ans=0;  dp = new long[2][n][n+1];  for(dig=1; dig<=9; ++dig) {  for(int i=0; i<n; ++i) {   Arrays.fill(dp[0][i], -1);   Arrays.fill(dp[1][i], -1);  }  for(int i=1; i<=n; ++i)   ans=(ans+p10[i-1]*dp(0, 0, i))%M;  }  out.println(ans);  out.close(); }  static long dp(int less, int ignore, int need) {  if(need==0)  return less==1?p10[n-ignore]:s[ignore];  if(ignore==n)  return 0;  if(dp[less][ignore][need]!=-1)  return dp[less][ignore][need];  long res=0;  int lim=less==1?9:x[ignore];  for(int i=0; i<=lim; ++i)  res=(res+dp(less|(i<lim?1:0), ignore+1, need-(i>=dig?1:0)))%M;  return dp[less][ignore][need]=res; }  interface Input {  public String next();  public String nextLine();  public int nextInt();  public long nextLong();  public double nextDouble(); } static class StdIn implements Input {  final private int BUFFER_SIZE = 1 << 16;  private DataInputStream din;  private byte[] buffer;  private int bufferPointer, bytesRead;  public StdIn() {  din = new DataInputStream(System.in);  buffer = new byte[BUFFER_SIZE];  bufferPointer = bytesRead = 0;  }  public StdIn(InputStream in) {  try{   din = new DataInputStream(in);  } catch(Exception e) {   throw new RuntimeException();  }  buffer = new byte[BUFFER_SIZE];  bufferPointer = bytesRead = 0;  }  public String next() {  int c;  while((c=read())!=-1&&(c==' '||c=='\n'||c=='\r'));  StringBuilder s = new StringBuilder();  while (c != -1)  {   if (c == ' ' || c == '\n'||c=='\r')   break;   s.append((char)c);   c=read();  }  return s.toString();  }  public String nextLine() {  int c;  while((c=read())!=-1&&(c==' '||c=='\n'||c=='\r'));  StringBuilder s = new StringBuilder();  while (c != -1)  {   if (c == '\n'||c=='\r')   break;   s.append((char)c);   c = read();  }  return s.toString();  }  public int nextInt() {  int ret = 0;  byte c = read();  while (c <= ' ')   c = read();  boolean neg = (c == '-');  if (neg)   c = read();  do   ret = ret * 10 + c - '0';  while ((c = read()) >= '0' && c <= '9');   if (neg)   return -ret;  return ret;  }  public int[] readIntArray(int n) {  int[] ar = new int[n];  for(int i=0; i<n; ++i)   ar[i]=nextInt();  return ar;  }  public long nextLong() {  long ret = 0;  byte c = read();  while (c <= ' ')   c = read();  boolean neg = (c == '-');  if (neg)   c = read();  do   ret = ret * 10 + c - '0';  while ((c = read()) >= '0' && c <= '9');  if (neg)   return -ret;  return ret;  }  public long[] readLongArray(int n) {  long[] ar = new long[n];  for(int i=0; i<n; ++i)   ar[i]=nextLong();  return ar;  }  public double nextDouble() {  double ret = 0, div = 1;  byte c = read();  while (c <= ' ')   c = read();  boolean neg = (c == '-');  if (neg)   c = read();  do   ret = ret * 10 + c - '0';  while ((c = read()) >= '0' && c <= '9');  if (c == '.')   while ((c = read()) >= '0' && c <= '9')   ret += (c - '0') / (div *= 10);  if (neg)   return -ret;  return ret;  }  private void fillBuffer() throws IOException {  bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);  if (bytesRead == -1)   buffer[0] = -1;  }  private byte read() {  try{   if (bufferPointer == bytesRead)   fillBuffer();   return buffer[bufferPointer++];  } catch(IOException e) {   throw new RuntimeException();  }  }  public void close() throws IOException {  if (din == null)   return;  din.close();  } } }
4,public class E14G {  static int[][] choose;  public static void main(String[] args) throws IOException {   init_io();   int N = nint(), M = nint();   choose = new int[N+1][];   long[] ways = new long[N+1];   ways[0] = 1; ways[1] = 1;   for (int i = 0; i <= N; i++) choose[i] = new int[i+1];   for (int i = 0; i <= N; i++) {    choose[i][0] = choose[i][i] = 1;    for (int j = 1; j < i; j++) {     choose[i][j] = (choose[i-1][j-1] + choose[i-1][j]) % M;    }   }   for (int i = 2; i <= N; i++) {    for (int j = 0; j < i; j++) {     ways[i] = (ways[i] + choose[i-1][j]) % M;    }   }   long[][] dp = new long[(N+1)/2+1][N+1];   dp[0][0] = 1;   for (int i = 1; i <= (N+1)/2; i++) {    for (int j = 1; j <= N; j++) {     for (int k = 1; k <= j; k++) {      dp[i][j] = (dp[i][j] + ways[k] * choose[j][k] % M * dp[i-1][j-k] % M) % M;     }    }   }   long ans = 0;   for (int i = 1; i <= (N+1)/2; i++) {    ans = (ans + dp[i][N-(i-1)]) % M;   }   out.println(ans);   out.close();  }  static StreamTokenizer in;  static PrintWriter out;  static BufferedReader br;  static int nint() throws IOException {   in.nextToken();   return (int) in.nval;  }  static void init_io() throws IOException {   br = new BufferedReader(new InputStreamReader(System.in));   in = new StreamTokenizer(br);   out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));  } }
3,public class Main {  public static void main(String[] args) throws Exception {   new Main().go();  }  PrintWriter out;  Reader in;  BufferedReader br;  Main() throws IOException {   try {           in = new Reader("input.txt");    out = new PrintWriter( new BufferedWriter(new FileWriter("output.txt")) );   }   catch (Exception e) {        in = new Reader();    out = new PrintWriter( new BufferedWriter(new OutputStreamWriter(System.out)) );   }  }  void go() throws Exception {      int t = 1;   while (t > 0) {    solve();    t--;   }   out.flush();   out.close();  }   int inf = 2000000000;  int mod = 1000000007;  double eps = 0.000000001;  int n;  int m;  ArrayList<Integer>[] g;  int[] a;  void solve() throws IOException {   int n = in.nextInt();   int[] a = new int[n];   for (int i = 0; i < n; i++)    a[i] = in.nextInt();   HashMap<Integer, ArrayList<Pair>> segs = new HashMap<>();   for (int i = 0; i < n; i++) {    int sum = 0;    for (int j = i; j < n; j++) {     sum += a[j];     if (!segs.containsKey(sum))      segs.put(sum, new ArrayList<>());     segs.get(sum).add(new Pair(i, j));    }   }   int max = 0;   ArrayList<Pair> ans = new ArrayList<>();   for (Integer k : segs.keySet()) {    ArrayList<Pair> list = segs.get(k);    ArrayList<Pair> blocks = new ArrayList<>();    Collections.reverse(list);    int prev = inf;    for (Pair p : list) {     int l = p.a;     int r = p.b;     if (r < prev) {      blocks.add(p);      prev = l;     }    }    if (blocks.size() > max) {     ans = blocks;     max = blocks.size();    }   }   out.println(ans.size());   for (Pair p : ans)    out.println((p.a+1)+" "+(p.b+1));  }   class Pair implements Comparable<Pair>{   int a;   int b;   Pair(int a, int b) {    this.a = a;    this.b = b;   }   public int compareTo(Pair p) {    if (a != p.a)     return Integer.compare(a, p.a);    else     return Integer.compare(b, p.b);   }  }  class Item {   int a;   int b;   int c;   Item(int a, int b, int c) {    this.a = a;    this.b = b;    this.c = c;   }  }   class Reader {   BufferedReader br;   StringTokenizer tok;   Reader(String file) throws IOException {    br = new BufferedReader( new FileReader(file) );   }   Reader() throws IOException {    br = new BufferedReader( new InputStreamReader(System.in) );   }   String next() throws IOException {    while (tok == null || !tok.hasMoreElements())     tok = new StringTokenizer(br.readLine());    return tok.nextToken();   }   int nextInt() throws NumberFormatException, IOException {    return Integer.valueOf(next());   }   long nextLong() throws NumberFormatException, IOException {    return Long.valueOf(next());   }   double nextDouble() throws NumberFormatException, IOException {    return Double.valueOf(next());   }    String nextLine() throws IOException {    return br.readLine();   }  }  static class InputReader  {   final private int BUFFER_SIZE = 1 << 16;   private DataInputStream din;   private byte[] buffer;   private int bufferPointer, bytesRead;   public InputReader()   {    din = new DataInputStream(System.in);    buffer = new byte[BUFFER_SIZE];    bufferPointer = bytesRead = 0;   }   public InputReader(String file_name) throws IOException   {    din = new DataInputStream(new FileInputStream(file_name));    buffer = new byte[BUFFER_SIZE];    bufferPointer = bytesRead = 0;   }   public String readLine() throws IOException   {    byte[] buf = new byte[64];    int cnt = 0, c;    while ((c = read()) != -1)    {     if (c == '\n')      break;     buf[cnt++] = (byte) c;    }    return new String(buf, 0, cnt);   }   public int nextInt() throws IOException   {    int ret = 0;    byte c = read();    while (c <= ' ')     c = read();    boolean neg = (c == '-');    if (neg)     c = read();    do    {     ret = ret * 10 + c - '0';    } while ((c = read()) >= '0' && c <= '9');    if (neg)     return -ret;    return ret;   }   public long nextLong() throws IOException   {    long ret = 0;    byte c = read();    while (c <= ' ')     c = read();    boolean neg = (c == '-');    if (neg)     c = read();    do {     ret = ret * 10 + c - '0';    }    while ((c = read()) >= '0' && c <= '9');    if (neg)     return -ret;    return ret;   }   public double nextDouble() throws IOException   {    double ret = 0, div = 1;    byte c = read();    while (c <= ' ')     c = read();    boolean neg = (c == '-');    if (neg)     c = read();    do {     ret = ret * 10 + c - '0';    }    while ((c = read()) >= '0' && c <= '9');    if (c == '.')    {     while ((c = read()) >= '0' && c <= '9')     {      ret += (c - '0') / (div *= 10);     }    }    if (neg)     return -ret;    return ret;   }   private void fillBuffer() throws IOException   {    bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);    if (bytesRead == -1)     buffer[0] = -1;   }   private byte read() throws IOException   {    if (bufferPointer == bytesRead)     fillBuffer();    return buffer[bufferPointer++];   }   public void close() throws IOException   {    if (din == null)     return;    din.close();   }  } }
6,public class C { public static void main(String[] args){  Scanner sc = new Scanner(System.in);  hx = sc.nextInt();  hy = sc.nextInt();  N = sc.nextInt();  X = new int[N];  Y = new int[N];  for(int i = 0; i < N;i++){  X[i] = sc.nextInt();  Y[i] = sc.nextInt();  }  DP = new int[1<<N];  Arrays.fill(DP,-1);  int ans = recur(0);  ArrayList<Integer> aa = new ArrayList<Integer>();  int U = 0;  aa.add(0);  int test = 0;  while(U != (1<<N)-1){  int a = 0;  for(int i = 0; i < N;i++)   if(((1<<i)&U) == 0){   a = i;   break;   }   int ans2 = recur(U|(1<<a))+2*(pw(X[a]-hx)+pw(Y[a]-hy));  int temp = 2*(pw(X[a]-hx)+pw(Y[a]-hy));  int best = -1;  for(int i = a+1;i<N;i++){   if(((1<<i)&U) == 0){   int ans3 = pw(X[a]-X[i])+pw(Y[a]-Y[i])+pw(X[a]-hx)+pw(Y[a]-hy)+pw(X[i]-hx)+pw(Y[i]-hy)+recur(U|(1<<a)|(1<<i));   if(ans3 < ans2){    ans2 = ans3;    best = i;    temp = pw(X[a]-X[i])+pw(Y[a]-Y[i])+pw(X[a]-hx)+pw(Y[a]-hy)+pw(X[i]-hx)+pw(Y[i]-hy);   }   }  }  if(best == -1){   aa.add(a+1);   aa.add(0);   U |= (1<<a);  }else{   aa.add(a+1);   aa.add(best+1);   aa.add(0);   U |= (1<<a) | (1<<best);  }  test += temp;  }  if(test != ans)  throw new RuntimeException();  System.out.println(ans);  for(int i = 0; i < aa.size();i++)  System.out.print(aa.get(i)+(i == aa.size()-1?"":" "));  System.out.println(); } private static int recur(int U) {  if(DP[U] != -1)  return DP[U];  if(U == (1<<N)-1)  return 0;  int a = 0;  for(int i = 0; i < N;i++)  if(((1<<i)&U) == 0){   a = i;   break;  }   int ans = recur(U|(1<<a))+2*(pw(X[a]-hx)+pw(Y[a]-hy));  for(int i = a+1;i<N;i++){  if(((1<<i)&U) == 0){   ans = min(ans,pw(X[a]-X[i])+pw(Y[a]-Y[i])+pw(X[a]-hx)+pw(Y[a]-hy)+pw(X[i]-hx)+pw(Y[i]-hy)+recur(U|(1<<a)|(1<<i)));  }  }  DP[U] = ans;  return ans; } static int pw(int a){  return a*a; } static int hx,hy; static int[] X,Y; static int N; static int[] DP; }
2,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   OutputWriter out = new OutputWriter(outputStream);   TaskD solver = new TaskD();   solver.solve(1, in, out);   out.close();  }  static class TaskD {   long maxk = (long) 1e18;   public void solve(int testNumber, InputReader in, OutputWriter out) {    int t = in.nextInt();    long maxn = 1;    long val = 0;    for (long i = 1; ; i++) {     val = 1 + 4 * val;     if (val >= maxk) {      maxn = i;      break;     }    }    long[] vala = new long[(int) maxn + 1];    vala[1] = 1;    for (int i = 2; i <= maxn; i++) {     vala[i] = 1 + 4 * vala[i - 1];    }    o:    while (t-- > 0) {     long n = in.nextInt();     long k = in.nextLong();     if (n - 1 >= maxn) {      out.println("YES " + (n - 1));      continue;     }     k--;     if (k <= vala[(int) n - 1]) {      out.println("YES " + (n - 1));      continue;     }     long cs = n - 1;     long cc = 3;     int ind = 2;     long end = -1;     while (k > 0) {      if (k >= cc && cs > 0) {       k -= cc;       cc += (1l << ind);       cs--;       ind++;      } else {         end = ind;       break;      }     }     long fcs = cs;     if (k == 0) {      out.println("YES " + cs);      continue;     }     k -= vala[(int) n - 1];     cs = n - 1;     cc = 3;     ind = 2;     long rv = 5;     long sind = 3;     while (k > 0 && ind < end) {      k -= rv * vala[(int) cs - 1];      rv += (1l << sind);      sind++;      cs--;      ind++;     }     if (k <= 0) {      out.println("YES " + fcs);     } else {      out.println("NO");     }    }   }  }  static class OutputWriter {   private final PrintWriter writer;   public OutputWriter(OutputStream outputStream) {    writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));   }   public OutputWriter(Writer writer) {    this.writer = new PrintWriter(writer);   }   public void print(Object... objects) {    for (int i = 0; i < objects.length; i++) {     if (i != 0) {      writer.print(' ');     }     writer.print(objects[i]);    }   }   public void println(Object... objects) {    print(objects);    writer.println();   }   public void close() {    writer.close();   }  }  static class InputReader {   private InputStream stream;   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   private InputReader.SpaceCharFilter filter;   public InputReader(InputStream stream) {    this.stream = stream;   }   public static boolean isWhitespace(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   public int read() {    if (numChars == -1) {     throw new InputMismatchException();    }    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (numChars <= 0) {      return -1;     }    }    return buf[curChar++];   }   public int nextInt() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if (c < '0' || c > '9') {      throw new InputMismatchException();     }     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   public long nextLong() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    long res = 0;    do {     if (c < '0' || c > '9') {      throw new InputMismatchException();     }     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   public boolean isSpaceChar(int c) {    if (filter != null) {     return filter.isSpaceChar(c);    }    return isWhitespace(c);   }   public interface SpaceCharFilter {    public boolean isSpaceChar(int ch);   }  } }
2,public class ABC {   public static void main(String[] args){      Scanner sc=new Scanner(System.in);    long k,c,n,d;    c=1;    d=9;    n=1;    k= sc.nextLong();    while(k>(c*d)) {     k-=(c*d);     n*=10;     d*=10;     c++;    }    n+=(k-1)/c;    char[] num = String.valueOf(n).toCharArray();    System.out.println(num[(int)((k-1)%c)]);   }    }
1,public class Main{  public static void main(String[] args) {  Scanner in=new Scanner(new BufferedInputStream(System.in)); int n=in.nextInt(); char b[]=in.next().toCharArray(); int bb[]=new int [b.length];  int Mark[]=new int [26*2+1]; int Mark1[]=new int [26*2+1];  int ans=0; for(int i=0;i<b.length;i++){  char f=b[i];  int a;  if(f>='a'&&f<='z')  a=f-'a';  else a=f-'A'+26;  bb[i]=a;  if(Mark1[a] == 0){  ans++;  Mark1[a]=1;}  }  int i;   int L = 0 ,nowsum = 0 ,Ans = n,R = 0;    for(i = 0 ;i < n ;i ++)  {   if(Mark[bb[i]]==0) nowsum ++;    Mark[bb[i]] ++;    if(nowsum == ans)    {    R = i;    break;    }     }   Ans = R - L + 1;   for(i = L ;i < n ;i ++)  {     if((--Mark[bb[i]])==0)   {    int ok = 0;    for(int j = R + 1 ;j < n ;j ++)    {            Mark[bb[j]] ++;     if(bb[j] == bb[i])     {      ok = 1;      R = j;      break;     }        }    if(ok==0) break;   }   if(Ans > R - i) Ans = R - i;  }   System.out.println(Ans);    } }
3,public class helloWorld { public static void main(String[] args)  {   Scanner in = new Scanner(System.in);  int n = in.nextInt();  int m = in.nextInt();  int l = 1000, r = 0, u = 1000, b = 0;   for(int i = 0; i < n; i++ ) {  String str = in.next();  for(int j = 0; j < m; j++)   if(str.charAt(j) == 'B') {   l = Math.min(j+1, l);   r = Math.max(j+1, r);   u = Math.min(i+1, u);   b = Math.max(i+1, b);   }  }   System.out.println((u+b)/2 + " " + (l+r)/2);   in.close(); } }
2,public class C {  private static BufferedReader in;  private static StringTokenizer st;  private static PrintWriter out;   public static void main(String[] args) throws NumberFormatException, IOException {   in = new BufferedReader(new InputStreamReader(System.in));   st = new StringTokenizer("");   out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));   int n = nextInt();   int m = nextInt();   int k = nextInt();   int mod = (int) (1e9+9);   int correct = n - n / k;   int carry = n % k;   long ans;   if(correct >= m){    ans = m;   }else{    m -= correct;    int block = n / k;    BigInteger pow = BigInteger.valueOf(2).modPow(BigInteger.valueOf(m + 1), BigInteger.valueOf(mod));    ans = (pow.longValue() - 2 + mod) % mod;    ans = (ans * (long) k) % mod;    ans = (ans + (long)(block - m)* (long)(k-1) + carry) % mod;   }   System.out.println(ans);    }  static String next() throws IOException{   while(!st.hasMoreTokens()){    st = new StringTokenizer(in.readLine());   }   return st.nextToken();  }  static int nextInt() throws NumberFormatException, IOException{   return Integer.parseInt(next());  }  static long nextLong() throws NumberFormatException, IOException{   return Long.parseLong(next());  }   static double nextDouble() throws NumberFormatException, IOException{   return Double.parseDouble(next());  } }
2,public class TaskB {  static BufferedReader in = new BufferedReader(new InputStreamReader(    System.in));  static StringTokenizer str;  static String SK;  static String next() throws IOException {   while ((str == null) || (!str.hasMoreTokens())) {    SK = in.readLine();    if (SK == null)     return null;    str = new StringTokenizer(SK);   }   return str.nextToken();  }  static int nextInt() throws IOException {   return Integer.parseInt(next());  }  static long nextLong() throws IOException {   return Long.parseLong(next());  }  static double nextDouble() throws IOException {   return Double.parseDouble(next());  }  public static void main(String[] args) throws IOException {   long n = nextLong();   int k = nextInt();   if (n == 1) {    System.out.println(0);    return;   }   long sum = (((2 + (long) k)) * ((long) k - 1)) / 2 - ((long) k - 2);   if (n > sum) {    System.out.println(-1);    return;   } else if (n <= k) {    System.out.println(1);    return;   }   long cnt = 0;   long sum2 = 0;   int index = binSearch(2, k, k, n);   sum2 = (((long) (index) + k) * (long) (k - index + 1)) / 2 - (long) (k - index);   cnt = k - index + 1;   if (sum2 == n) {    System.out.println(cnt);    return;   }   if (sum2 > n)    for (int kk = index; kk <= k; kk++) {     sum2 = (((long) (kk) + k) * (long) (k - kk + 1)) / 2 - (long) (k - kk);     cnt--;     if (sum2 <= n) {      System.out.println(cnt + 1);      return;     }    }   else {    for (int kk = index - 1; kk >= 2; kk--) {     sum2 = (((long) (kk) + k) * (long) (k - kk + 1)) / 2 - (long) (k - kk);     cnt++;     if (sum2 >= n) {      System.out.println(cnt);      return;     }    }   }   System.out.println(-1);   return;  }  static int binSearch(int l, int r, int k, long n) {   while (true) {    int mid = l + (r - l) / 2;    long sum2 = (((long) (mid) + k) * (long) (k - mid + 1)) / 2 - (long) (k - mid);    if (l >= r || sum2 == n) {     return mid;    } else if (sum2 > n) {     l = mid + 1;    } else if (sum2 < n) {     r = mid;    }   }  } }
2,public class C {  static int mod = (int) (1e9+7);  static InputReader in;  static PrintWriter out;   public static void main(String[] args)  {   in = new InputReader(System.in);   out = new PrintWriter(System.out);      long x = in.nextLong();   long k = in.nextLong();     if(x == 0){    out.println(0);   }   else{     long mul = pow(2, k + 1, mod);   x %= mod;   mul = (mul * x) % mod;   long sub = pow(2, k, mod);   sub = (sub - 1 + mod) % mod;   mul = (mul - sub + mod) % mod;   out.println(mul);   }     out.close();  }   static class Pair implements Comparable<Pair>  {   int x,y;   int i;     Pair (int x,int y)   {     this.x = x;     this.y = y;   }   Pair (int x,int y, int i)   {     this.x = x;     this.y = y;     this.i = i;   }   public int compareTo(Pair o)   {    return Integer.compare(this.x, o.x);   }   public boolean equals(Object o)   {    if (o instanceof Pair)    {     Pair p = (Pair)o;     return p.x == x && p.y==y;    }    return false;   }   @Override   public String toString()   {    return x + " "+ y + " "+i;   }     }    static String rev(String s){   StringBuilder sb=new StringBuilder(s);   sb.reverse();   return sb.toString();  }   static long gcd(long x,long y)  {   if(y==0)     return x;   else     return gcd(y,x%y);  }  static int gcd(int x,int y)  {   if(y==0)     return x;   else     return gcd(y,x%y);  }  static long pow(long n,long p,long m)  {   long result = 1;   if(p==0){    return 1;   }      while(p!=0)   {    if(p%2==1)     result *= n;    if(result >= m)     result %= m;    p >>=1;    n*=n;    if(n >= m)     n%=m;   }     return result;  }  static long pow(long n,long p)  {   long result = 1;   if(p==0)    return 1;   while(p!=0)   {    if(p%2==1)     result *= n;     p >>=1;    n*=n;    }   return result;  }  static void debug(Object... o)  {    System.out.println(Arrays.deepToString(o));  }  static class InputReader  {   private final InputStream stream;   private final byte[] buf = new byte[8192];   private int curChar, snumChars;   private SpaceCharFilter filter;   public InputReader(InputStream stream)   {     this.stream = stream;   }   public int snext()   {     if (snumChars == -1)       throw new InputMismatchException();     if (curChar >= snumChars)     {       curChar = 0;       try       {         snumChars = stream.read(buf);       } catch (IOException e)       {         throw new InputMismatchException();       }       if (snumChars <= 0)         return -1;     }     return buf[curChar++];   }   public int nextInt()   {     int c = snext();     while (isSpaceChar(c))     {       c = snext();     }     int sgn = 1;     if (c == '-')     {       sgn = -1;       c = snext();     }     int res = 0;     do     {       if (c < '0' || c > '9')         throw new InputMismatchException();       res *= 10;       res += c - '0';       c = snext();     } while (!isSpaceChar(c));     return res * sgn;   }   public long nextLong()   {     int c = snext();     while (isSpaceChar(c))     {       c = snext();     }     int sgn = 1;     if (c == '-')     {       sgn = -1;       c = snext();     }     long res = 0;     do     {       if (c < '0' || c > '9')         throw new InputMismatchException();       res *= 10;       res += c - '0';       c = snext();     } while (!isSpaceChar(c));     return res * sgn;   }   public int[] nextIntArray(int n)   {     int a[] = new int[n];     for (int i = 0; i < n; i++)     {       a[i] = nextInt();     }     return a;   }   public long[] nextLongArray(int n)   {     long a[] = new long[n];     for (int i = 0; i < n; i++)     {       a[i] = nextLong();     }     return a;   }   public String readString()   {     int c = snext();     while (isSpaceChar(c))     {       c = snext();     }     StringBuilder res = new StringBuilder();     do     {       res.appendCodePoint(c);       c = snext();     } while (!isSpaceChar(c));     return res.toString();   }   public String nextLine()   {     int c = snext();     while (isSpaceChar(c))       c = snext();     StringBuilder res = new StringBuilder();     do     {       res.appendCodePoint(c);       c = snext();     } while (!isEndOfLine(c));     return res.toString();   }   public boolean isSpaceChar(int c)   {     if (filter != null)       return filter.isSpaceChar(c);     return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   private boolean isEndOfLine(int c)   {     return c == '\n' || c == '\r' || c == -1;   }   public interface SpaceCharFilter   {     public boolean isSpaceChar(int ch);   }  } }
0,public class A {  private void solve() throws IOException {   int n = nextInt();   int r = n;   n *= 2;   n -= (0.5*r);   System.out.println(n);  }  public static void main(String[] args) {   new A().run();  }  BufferedReader reader;  StringTokenizer tokenizer;  PrintWriter writer;  public void run() {   try {    reader = new BufferedReader(new InputStreamReader(System.in));    tokenizer = null;    writer = new PrintWriter(System.out);    solve();    reader.close();    writer.close();   } catch (Exception e) {    e.printStackTrace();    System.exit(1);   }  }  int[] readIntArray(int size) throws IOException {   int[] res = new int[size];   for (int i = 0; i < size; i++) {    res[i] = nextInt();   }   return res;  }  long[] readLongArray(int size) throws IOException {   long[] res = new long[size];   for (int i = 0; i < size; i++) {    res[i] = nextLong();   }   return res;  }  double[] readDoubleArray(int size) throws IOException {   double[] res = new double[size];   for (int i = 0; i < size; i++) {    res[i] = nextDouble();   }   return res;  }  int nextInt() throws IOException {   return Integer.parseInt(nextToken());  }  long nextLong() throws IOException {   return Long.parseLong(nextToken());  }  double nextDouble() throws IOException {   return Double.parseDouble(nextToken());  }  BigInteger nextBigInteger() throws IOException {   return new BigInteger(nextToken());  }  String nextToken() throws IOException {   while (tokenizer == null || !tokenizer.hasMoreTokens()) {    tokenizer = new StringTokenizer(reader.readLine());   }   return tokenizer.nextToken();  } }
1,public class JavaApplication2 {    public static void main(String[] args) throws IOException {     BufferedReader sc= new BufferedReader(new InputStreamReader(System.in));   int n = Integer.parseInt(sc.readLine().split(" ")[0]);   ArrayList<String> tshr = new ArrayList<>(n);   for (int i = 0; i < n; i++) {    tshr.add(sc.readLine());   }   for (int i = 0; i < n; i++) {    tshr.remove(sc.readLine());   }   System.out.println(tshr.size());                 }  }
4,public class Main {  public static void main(String[] args) {   InputStream inputStream;   try {    inputStream = new FileInputStream("input.txt");   } catch (IOException e) {    throw new RuntimeException(e);   }   OutputStream outputStream;   try {    outputStream = new FileOutputStream("output.txt");   } catch (IOException e) {    throw new RuntimeException(e);   }   InputReader in = new InputReader(inputStream);   PrintWriter out = new PrintWriter(outputStream);   TaskC solver = new TaskC();   solver.solve(1, in, out);   out.close();  }  static class TaskC {   public void solve(int testNumber, InputReader in, PrintWriter out) {    int N = in.nextInt();    int M = in.nextInt();    int[][] dist = new int[N][M];    for (int[] ini : dist) Arrays.fill(ini, (1 << 30));     int K = in.nextInt();    Queue<Integer> q = new LinkedList<Integer>();    for (int k = 0; k < K; ++k) {     int r = in.nextInt() - 1;     int c = in.nextInt() - 1;     dist[r][c] = 0;     q.offer(r);     q.offer(c);    }    int[] dx = new int[]{1, -1, 0, 0};    int[] dy = new int[]{0, 0, 1, -1};    while (!q.isEmpty()) {     int rr = q.poll();     int cc = q.poll();     for (int a = 0; a < 4; ++a) {      int x = dx[a] + rr;      int y = dy[a] + cc;      if (x >= 0 && x < N && y >= 0 && y < M) {       if (dist[x][y] > dist[rr][cc] + 1) {        dist[x][y] = dist[rr][cc] + 1;        q.offer(x);        q.offer(y);       }      }     }    }    int max = 0;    for (int i = 0; i < N; ++i)     for (int j = 0; j < M; ++j)      max = Math.max(max, dist[i][j]);    for (int i = 0; i < N; ++i) {     for (int j = 0; j < M; ++j) {      if (max == dist[i][j]) {       out.println((i + 1) + " " + (j + 1));       return;      }     }    }   }  }  static class InputReader {   public BufferedReader reader;   public StringTokenizer tokenizer;   public InputReader(InputStream stream) {    reader = new BufferedReader(new InputStreamReader(stream), 32768);    tokenizer = null;   }   public String next() {    while (tokenizer == null || !tokenizer.hasMoreTokens()) {     try {      tokenizer = new StringTokenizer(reader.readLine());     } catch (IOException e) {      throw new RuntimeException(e);     }    }    return tokenizer.nextToken();   }   public int nextInt() {    return Integer.parseInt(next());   }  } }
4,public class j { public static void main(String a[])throws IOException { BufferedReader b = new BufferedReader(new FileReader("input.txt")); PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("output.txt"))); int l=0,x2=0,x=0,y1=0,y=0,max=-1,min=100000,x1=0,n=0,j=0,k=0,p=0,m=0,i=0; String s; s=b.readLine(); StringTokenizer c=new StringTokenizer(s); n=Integer.parseInt(c.nextToken()); m=Integer.parseInt(c.nextToken()); k=Integer.parseInt(b.readLine()); int e[][]=new int[k][2]; s=b.readLine(); StringTokenizer z=new StringTokenizer(s); for(i=0;i<k;i++) { e[i][0]=Integer.parseInt(z.nextToken()); e[i][1]=Integer.parseInt(z.nextToken()); } for(i=1;i<=n;i++) { for(j=1;j<=m;j++) { for(l=0;l<k;l++) { p=(int)Math.abs(e[l][0]-i)+(int)Math.abs(e[l][1]-j); if(p<min) { min=p; x1=i; y1=j; } } if(min>max) { max=min; x=x1; y=y1; } min=100000; } } out.print(x+" "+y); out.close(); } }
2,public class CFEdu66 {  public static void main(String[] args) {  Scanner in = new Scanner(System.in);  long n = in.nextLong();  long k = in.nextLong();  double tmp = Math.sqrt(9 + 8*(n+k));  if(Math.ceil(tmp)-tmp<0.001)  tmp = Math.ceil(tmp);   long root = (long)tmp;  long x = (-3+root)/2;  System.out.println(n-x);   } }
0,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  Scanner in = new Scanner(inputStream);  PrintWriter out = new PrintWriter(outputStream);  TaskD solver = new TaskD();  solver.solve(1, in, out);  out.close(); } } class TaskD {  public void solve(int testNumber, Scanner in, PrintWriter out) {   String[] str = in.nextLine().split(" ");   int a = Integer.parseInt(str[0]);   int v = Integer.parseInt(str[1]);   str = in.nextLine().split(" ");   int l = Integer.parseInt(str[0]);   int d = Integer.parseInt(str[1]);   int w = Integer.parseInt(str[2]);    double minTime = 0.;   if (w >= v) {    minTime = getTimeAfterSign(0, v, l, a);    out.format(Locale.US, "%.6f", minTime);    return;   }   double whenGetSpeedWPath = (w * w) / (2. * a);   if (whenGetSpeedWPath >= d) {    double time = Math.sqrt((2.0 * d) / a);    minTime = time + getTimeAfterSign(a * time, v, l - d, a);   } else {    double stopPath = (v * v - w * w) / (2. * a);    double vMaxPath = (v * v) / (2. * a);    if (stopPath + vMaxPath > d) {      double topSpeed = Math.sqrt((2. * a * d + w * w) / 2);     minTime = (2. * topSpeed - w) / a + getTimeAfterSign(w, v, l - d, a);    } else {     double stopTime = (v - w) / (a + 0.);     double getMaxTime = v / (a + 0.);     double maxTime = (d - (stopPath + vMaxPath)) / v;     minTime = stopTime + getMaxTime + maxTime + getTimeAfterSign(w, v, l - d, a);    }   }   out.format(Locale.US, "%.6f", minTime);  }  double getTimeAfterSign(double startSpeed, double maxSpeed, double path, int a) {   double maxSpeedTime = (maxSpeed - startSpeed) / a;   double maxSpeedPath = startSpeed * maxSpeedTime + (a * maxSpeedTime * maxSpeedTime) / 2;   if (maxSpeedPath > path) {    return (-startSpeed + Math.sqrt(startSpeed * startSpeed + 2 * a * path)) / a;   } else {    return maxSpeedTime + (path - maxSpeedPath) / maxSpeed;   }  } }
5,public class Main {   public static void main(String[] args) {  Scanner s = new Scanner(System.in);  int n = s.nextInt();  int[] a = new int[n];  for(int i=0;i<n;i++)   a[i] = s.nextInt();  Arrays.sort(a);  int min = a[0];  if (a[0] == a[n-1]){   System.out.println("NO");  }else{   for(int i=1;;i++){    if (a[i] > min) {     System.out.println(a[i]);     break;    }   }  } } }
0,public class LuckyDivision {  public LuckyDivision(Scanner in)  {  int n;   n = in.nextInt();   if ( (n % 4 == 0) ||    (n % 7 == 0) ||    (n % 44 == 0) ||    (n % 47 == 0) ||    (n % 74 == 0) ||    (n % 77 == 0) ||    (n % 444 == 0) ||    (n % 447 == 0) ||    (n % 474 == 0) ||    (n % 477 == 0) ||    (n % 744 == 0) ||    (n % 747 == 0) ||    (n % 774 == 0) ||    (n % 777 == 0) )   System.out.printf("YES%n");  else   System.out.printf("NO%n");  }   public static void main(String[] args)  {  new LuckyDivision(new Scanner(System.in));  } }
0,public class luckydivision { public static int i(String s){  return Integer.parseInt(s); } public static boolean solve(String k, int n){  int temp = i(k);  if(temp > n){  return false;  }  if(n % temp == 0)  return true;  if(solve(k + "7", n))  return true;  return solve(k + "4", n); } public static void main(String args[]) throws Exception {  BufferedReader r = new BufferedReader(new InputStreamReader(System.in));  int n = i(r.readLine());  boolean i = solve("7", n);  boolean j = solve("4", n);  if(i || j){  System.out.println("YES");  } else {  System.out.println("NO");  } } }
1,public class A {  BufferedReader in;  StringTokenizer st;  PrintWriter out;  void solve() throws IOException {   int n = nextInt();   int k = nextInt();   boolean[] sieve = new boolean[n + 1];   List<Integer> primes = new ArrayList<Integer>();   for (int i = 2; i <= n; ++i) {    if (!sieve[i]) {     primes.add(i);     for (int j = 2 * i; j <= n; j += i) {      sieve[j] = true;     }    }   }   int count = 0;   for (int i = 0; i + 1 < primes.size(); ++i) {    int v = primes.get(i) + primes.get(i + 1) + 1;    if (v <= n && !sieve[v]) {     ++count;    }   }   out.println(count >= k ? "YES" : "NO");  }  public void run() throws IOException {   in = new BufferedReader(new InputStreamReader(System.in));   out = new PrintWriter(System.out);   eat("");   solve();   out.close();   in.close();  }  void eat(String s) {   st = new StringTokenizer(s);  }  String next() throws IOException {   while (!st.hasMoreTokens()) {    String line = in.readLine();    if (line == null) {     return null;    }    eat(line);   }   return st.nextToken();  }  int nextInt() throws IOException {   return Integer.parseInt(next());  }  long nextLong() throws IOException {   return Long.parseLong(next());  }  double nextDouble() throws IOException {   return Double.parseDouble(next());  }  public static void main(String[] args) throws IOException {   new A().run();  } }
3,public class C {  public static void main(String[] args) {  FastScanner in = new FastScanner();  int n = in.nextInt();  double r = in.nextInt();  double x[] = new double[n];  for(int i = 0; i < n; i++)  x[i] = in.nextDouble();   double y[] = new double[n];  y[0] = r;   for(int i = 1; i < n; i++){  double miny = r;  for(int j = 0; j < i; j++){   double dx = Math.abs(x[i]-x[j]);   if(dx > r*2) continue;   double yy = Math.sqrt(4*r*r-dx*dx);   miny = Math.max(miny, yy+y[j]);  }  y[i] = miny;  }  for(int i = 0; i < n; i++){  System.out.print(y[i]+" ");  }   }    static class FastScanner{  BufferedReader br;  StringTokenizer st;  public FastScanner(String s) {  try{   br = new BufferedReader(new FileReader(s));  }  catch(FileNotFoundException e) {   e.printStackTrace();  }  }  public FastScanner(){  br = new BufferedReader(new InputStreamReader(System.in));  }   String nextToken() {  while(st == null ||!st.hasMoreElements()){   try {   st = new StringTokenizer(br.readLine());}   catch(IOException e) {   e.printStackTrace();   }    }  return st.nextToken();  }   int nextInt() {  return Integer.parseInt(nextToken());  }  long nextLong() {  return Long.parseLong(nextToken());  }  double nextDouble() {  return Double.parseDouble(nextToken());  }  String next() {  return nextToken();  }   } }
5,public class ProblemA {  private final BufferedReader in;  private final PrintStream out;  private StringTokenizer tok = new StringTokenizer("");  private String nextLine = null;  public static void main(String[] args) throws Exception {   new ProblemA();  }  private ProblemA() throws Exception {   in = new BufferedReader(new InputStreamReader(System.in));   out = System.out;   start();   end();  }  private int nextInt() {   return Integer.parseInt(nextWord());  }  private String nextWord() {   if (tok.hasMoreTokens()) {    return tok.nextToken();   } else {    while (!tok.hasMoreTokens()) {     try {      nextLine = in.readLine();      if (nextLine == null) {       return null;      } else {       tok = new StringTokenizer(nextLine);      }     } catch (IOException ex) {      Logger.getLogger(ProblemA.class.getName()).log(Level.SEVERE, null, ex);     }    }    return tok.nextToken();   }  }  private void start() {   int n = nextInt();   int[] a = new int[n];   boolean allOne = true;   for (int i = 0; i < n; i++) {    a[i] = nextInt();    if (a[i] != 1) {     allOne = false;    }   }   Arrays.sort(a);   int[] res = new int[n];   res[0] = 1;   for (int i = 1; i < n; i++) {    res[i] = a[i - 1];   }   if (allOne) {    for (int i = 0; i < n - 1; i++) {     out.print(a[i] + " ");    }    out.print(2);   } else {    for (int i = 0; i < n; i++) {     out.print(res[i] + " ");    }   }  }  private void end() {   out.close();  } }
2,public class Main {  public static void main(String[] args) {   InputStream inputStream = System.in;   OutputStream outputStream = System.out;   InputReader in = new InputReader(inputStream);   OutputWriter out = new OutputWriter(outputStream);   BSportivnayaMafiya solver = new BSportivnayaMafiya();   solver.solve(1, in, out);   out.close();  }  static class BSportivnayaMafiya {   public void solve(int testNumber, InputReader in, OutputWriter out) {    int n = in.readInt();    int k = in.readInt();    int have = 0;    for (int x = 1; ; x++) {     have += x;     if (have < k) {      continue;     }     if (have - (n - x) == k) {      out.print(n - x);      return;     }    }   }  }  static class InputReader {   private InputStream stream;   private byte[] buf = new byte[1024];   private int curChar;   private int numChars;   private InputReader.SpaceCharFilter filter;   public InputReader(InputStream stream) {    this.stream = stream;   }   public int read() {    if (numChars == -1) {     throw new InputMismatchException();    }    if (curChar >= numChars) {     curChar = 0;     try {      numChars = stream.read(buf);     } catch (IOException e) {      throw new InputMismatchException();     }     if (numChars <= 0) {      return -1;     }    }    return buf[curChar++];   }   public int readInt() {    int c = read();    while (isSpaceChar(c)) {     c = read();    }    int sgn = 1;    if (c == '-') {     sgn = -1;     c = read();    }    int res = 0;    do {     if (c < '0' || c > '9') {      throw new InputMismatchException();     }     res *= 10;     res += c - '0';     c = read();    } while (!isSpaceChar(c));    return res * sgn;   }   public boolean isSpaceChar(int c) {    if (filter != null) {     return filter.isSpaceChar(c);    }    return isWhitespace(c);   }   public static boolean isWhitespace(int c) {    return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;   }   public interface SpaceCharFilter {    public boolean isSpaceChar(int ch);   }  }  static class OutputWriter {   private final PrintWriter writer;   public OutputWriter(OutputStream outputStream) {    writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));   }   public OutputWriter(Writer writer) {    this.writer = new PrintWriter(writer);   }   public void close() {    writer.close();   }   public void print(int i) {    writer.print(i);   }  } }
5,public class A {  public static void main(String[] args) {   Scanner in = new Scanner(System.in);   int n = in.nextInt();   int a = in.nextInt();   int b = in.nextInt();   int[] ar = new int[n];   for (int i = 0; i < n; i++)    ar[i] = in.nextInt();   Arrays.sort(ar);   int x1 = ar[b-1];   int x2 = ar[b];   System.out.println(x2-x1);  } }
1,public class R025A { int n; int[] nums; public R025A() {  Scanner scanner = new Scanner(System.in);  n = scanner.nextInt();  nums = new int[n];  for(int i=0; i<n; i++) {  nums[i] = scanner.nextInt();  } }  private void process() {  int[] c = new int[2];  int[] r = new int[2];  for(int i=0; i<n; i++) {  c[nums[i] % 2]++;  if(r[nums[i] %2] == 0) {   r[nums[i] % 2] = i+1;  }  }  System.out.println(r[c[0]==1 ? 0 : 1]); }  public static void main(String[] args) {  new R025A().process(); } }
0,public class LCM { public static void main(String[] args) {  Scanner sc = new Scanner(System.in);  long n=sc.nextLong();  if(n < 3) {  System.out.println(n);  }  else if(n % 2 != 0) {  System.out.println(n * (n-1) * (n-2));  }  else if(n % 3 == 0) {  System.out.println((n-1) * (n-2) * (n-3));  }  else {  System.out.println(n * (n-1) * (n-3));  } } }
2,public class prob {   public static long ans(long x, long y, long p)  {   long r = 1;    x = x % p;   while (y > 0)   {    if((y & 1)==1)     r = (r * x) % p;    y = y >> 1;    x = (x * x) % p;   }   return r;  } public static void main (String[] args) throws java.lang.Exception {  Scanner scan = new Scanner(System.in);  long x = scan.nextLong();  long k = scan.nextLong();  long v = 1000000007L;  if(x>0){  long p = ((2*x)-1)%v;  long a = ans(2L,k,v);  long b = (p*a)%v;  System.out.println((b+1)%v);  }  else{  System.out.println(0);  } } }
6,public class E implements Runnable { public static void main (String[] args) {new Thread(null, new E(), "_cf", 1 << 28).start();}  int n, m; char[] str; int[][] occs, cost; int[] dp;  public void run() {  FastScanner fs = new FastScanner();  PrintWriter out = new PrintWriter(System.out);  System.err.println("");  n = fs.nextInt(); m = fs.nextInt();  byte[] str = fs.next().getBytes();  int[] occs = new int[1<<m];  for(int i = 0; i < n-1; i++) {  int l1 = str[i] - 'a';  int l2 = str[i+1] - 'a';  occs[(1<<l1) | (1<<l2)]++;  occs[(1<<l2) | (1<<l1)]++;  }   int all = (1<<m)-1;  cost = new int[m][1<<m];  for(int i = 0; i < m; i++) {  for(int mask = 1; mask < all; mask++) {   if(((1<<i)&mask) > 0) continue;   int lb = mask & (-mask);   int trail = Integer.numberOfTrailingZeros(lb);   int nmask = mask ^ lb;   cost[i][mask] = cost[i][nmask]+occs[1<<i | 1<<trail];  }  }   dp = new int[1<<m];  for(int mask = dp.length-2; mask >= 0; mask--) {  int addOn = 0;  for(int nxt = 0; nxt < m; nxt++) {   if(((1<<nxt)&mask) > 0) continue;   addOn += cost[nxt][mask];  }  int res = oo;  for(int nxt = 0; nxt < m; nxt++) {   if(((1<<nxt)&mask) > 0) continue;   int ret = addOn+dp[mask | (1<<nxt)];   res = min(res, ret);  }  dp[mask] = res;  }   System.out.println(dp[0]>>1);   out.close(); }  int oo = (int)1e9; int min(int a, int b) {  if(a < b) return a;  return b; }  class FastScanner {  public int BS = 1<<16;  public char NC = (char)0;  byte[] buf = new byte[BS];  int bId = 0, size = 0;  char c = NC;  double num = 1;  BufferedInputStream in;  public FastScanner() {  in = new BufferedInputStream(System.in, BS);  }  public FastScanner(String s) {  try {   in = new BufferedInputStream(new FileInputStream(new File(s)), BS);  }  catch (Exception e) {   in = new BufferedInputStream(System.in, BS);  }  }  public char nextChar(){  while(bId==size) {   try {   size = in.read(buf);   }catch(Exception e) {   return NC;   }       if(size==-1)return NC;   bId=0;  }  return (char)buf[bId++];  }  public int nextInt() {  return (int)nextLong();  }  public long nextLong() {  num=1;  boolean neg = false;  if(c==NC)c=nextChar();  for(;(c<'0' || c>'9'); c = nextChar()) {   if(c=='-')neg=true;  }  long res = 0;  for(; c>='0' && c <='9'; c=nextChar()) {   res = (res<<3)+(res<<1)+c-'0';   num*=10;  }  return neg?-res:res;  }  public double nextDouble() {  double cur = nextLong();  return c!='.' ? cur:cur+nextLong()/num;  }  public String next() {  StringBuilder res = new StringBuilder();  while(c<=32)c=nextChar();  while(c>32) {   res.append(c);   c=nextChar();  }  return res.toString();  }  public String nextLine() {  StringBuilder res = new StringBuilder();  while(c<=32)c=nextChar();  while(c!='\n') {   res.append(c);   c=nextChar();  }  return res.toString();  }  public boolean hasNext() {  if(c>32)return true;  while(true) {   c=nextChar();   if(c==NC)return false;   else if(c>32)return true;  }  }   public int[] nextIntArray(int n) {  int[] res = new int[n];  for(int i = 0; i < n; i++) res[i] = nextInt();  return res;  }   } }
2,public class digits { public static void main(String[] args)  {  long k = (new Scanner(System.in)).nextLong();          long league = 1;  long irrelevancy = 0;  while(true)  {   irrelevancy += league * (Math.pow(10, league) - Math.pow(10, league-1));  if(k > irrelevancy)   league ++;        else   break;  }   irrelevancy = 0;  for(long i=1; i<league; i++)  irrelevancy += i * (Math.pow(10, i) - Math.pow(10, i-1));    long modified_k = k - irrelevancy;     long number = (long)(Math.pow(10, league-1)) - 1 + modified_k / league;    if(modified_k % league == 0)  System.out.println(number % 10);  else  {  number ++;  long position_of_digit = (long)(modified_k % league);        System.out.println((Long.toString(number)).charAt((int)position_of_digit-1));  } }  }
4,public class C {  static HashMap<Integer, ArrayList<Integer>> tree = new HashMap<>();  public static void main(String[] args) throws IOException {   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));   PrintStream out = System.out;   int t = Integer.parseInt(br.readLine());   for (int i = 0; i < t; i++) {    int n = Integer.parseInt(br.readLine());    ArrayList<Integer> depth = new ArrayList<>();    int y = 0;    String[] ans = new String[n];    for (int x = 0; x < n; x++) {     int in = Integer.parseInt(br.readLine());     if (in == 1) {      if (y == depth.size()) depth.add(1);      else depth.set(y, 1);      y++;      StringBuilder curr = new StringBuilder();      curr.append(depth.get(0));      for (int a = 1; a < y; a++) {       curr.append('.');       curr.append(depth.get(a));      }      ans[x] = curr.toString();      continue;     }     for (int d = y-1; d >= 0; d--) {      if (depth.get(d) == in-1) {       y = d+1;       depth.set(d, depth.get(d)+1);       StringBuilder curr = new StringBuilder();       for (int a = 0; a < d; a++) {        curr.append(depth.get(a));        curr.append('.');       }       curr.append(in);       ans[x] = curr.toString();       break;      }     }    }       for (String x : ans) out.println(x);   }   System.out.flush();  } }
3,public class d {  public static void main(String[] args) {  Scanner in = new Scanner(System.in);   int size = in.nextInt();   int[] vals = new int[size];  long[] cum = new long[size];  for(int i=0; i<size; i++){  vals[i] = in.nextInt();    int c = 0;  for(int j=0; j<i; j++)   if(vals[j] > vals[i]) c++;    if(i != 0) cum[i] = cum[i-1]+c;  else cum[i] = c;  }   long tot = cum[size-1];  int q = in.nextInt();  int[] nv = new int[size];  for(int i=0; i<q; i++)  {  int l = in.nextInt()-1;  int r = in.nextInt()-1;  int n = (r-l);    long add = (n*(n+1))/2 - (cum[r] - cum[l]);  tot = tot - (cum[r] - cum[l]) + add;    if(tot%2 == 0)   System.out.println("even");  else   System.out.println("odd");        } } }
0,public class test {  public static void main(String[] args) throws InterruptedException {        try{   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));   br.readLine();   System.out.println(25);     }catch(IOException io){   io.printStackTrace();  }  }    }
0,public class A { public static void main(String[] args) throws IOException {  InputReader sc = new InputReader(System.in);  PrintWriter out = new PrintWriter(System.out);  int n = sc.nextInt();  if(n < 3)  out.println(n);  else  {  if((n & 1) == 1)   out.println(lcm(n, lcm(n - 1, n - 2)));  else   out.println(Math.max(lcm(n - 1, lcm(n - 2, n - 3)), lcm(n, lcm(n - 1, n - 3))));  }  out.flush();  out.close(); }  static long gcd(long a, long b)  {  while(b != 0)  {  a = a%b;  b ^= a;  a ^= b;  b ^= a;  }  return a;  }  static long lcm(long a, long b) { return a / gcd(a,b) * b; } }  class InputReader { private BufferedReader reader; private StringTokenizer tokenizer;  public InputReader(InputStream stream) {  reader = new BufferedReader(new InputStreamReader(stream));  tokenizer = null; }  public String next() {  while (tokenizer == null || !tokenizer.hasMoreTokens()) {  try {   tokenizer = new StringTokenizer(reader.readLine());  } catch (IOException e) {   throw new RuntimeException(e);  }  }  return tokenizer.nextToken(); }  public int nextInt() {  return Integer.parseInt(next()); } }
0,public class maximus { static long GCD(long a,long b){ if(b==0)return a; return GCD(b,a%b);  } public static void main(String [] args){ Scanner in=new Scanner(System.in); long n=in.nextInt(); if(n<=2){ System.out.print(n); return;  } if(n%2==1){ System.out.print((n*(n-1)*(n-2))); return; } if(n%2==0 && n<=6){ System.out.print(n*(n-1)*(n-2)/2); return;  } long temp=(n*(n-1)*(n-3))/GCD(n,n-3); System.out.print(Math.max((n-1)*(n-2)*(n-3),temp)); } }
1,public class Main { public static void main(String[] args) throws IOException {  new Thread(null, new Runnable() {  public void run() {   try {   try {    if (new File("input.txt").exists())    System.setIn(new FileInputStream("input.txt"));   } catch (SecurityException e) {}   new Main().run();   } catch (IOException e) {   e.printStackTrace();   }  }  }, "1", 1L << 24).start();  }  BufferedReader in; PrintWriter out; StringTokenizer st = new StringTokenizer("");  int N; int[] a; int[] b; int[] c;  int T, H;  void run() throws IOException {  in = new BufferedReader(new InputStreamReader(System.in));  out = new PrintWriter(System.out);   N = nextInt();  char[] s = nextToken().toCharArray();  a = new int [N];   H = 0;  T = 0;   for (int i = 0; i < s.length; i++) {  a[i] = s[i] == 'T' ? 1 : 0;  if (s[i] == 'T')   T++;  else   H++;  }   if (T == 1 || H == 1) {  out.println(0);  out.close();  return;  }   b = Arrays.copyOf(a, a.length);  c = Arrays.copyOf(a, a.length);  sort(c);   int ans = 100000000;  for (int o = 0; o < N; o++) {  for (int i = 0; i < N; i++)   b[(i + o) % N] = a[i];  int cur = 0;  for (int i = 0; i < N; i++)   if (b[i] != c[i])   cur++;  ans = min(ans, cur / 2);  }   out.println(ans);   out.close(); }  String nextToken() throws IOException {  while (!st.hasMoreTokens()) {  st = new StringTokenizer(in.readLine());  }   return st.nextToken(); }  int nextInt() throws IOException {  return Integer.parseInt(nextToken()); }  long nextLong() throws IOException {  return Long.parseLong(nextToken()); }  double nextDouble() throws IOException {  return Double.parseDouble(nextToken()); }  String nextLine() throws IOException {  st = new StringTokenizer("");  return in.readLine(); }  boolean EOF() throws IOException {  while (!st.hasMoreTokens()) {  String s = in.readLine();    if (s == null) {   return true;  }    st = new StringTokenizer(s);  }   return false; } }
2,public class Solution { static BufferedReader br; static int[] ans; public static void main(String[] args) throws Exception{  br = new BufferedReader(new InputStreamReader(System.in));  ans = new int[8];  int n = Integer.parseInt(br.readLine());  System.out.println("?"+"1 1 "+n+" "+n);  System.out.flush();  int q = Integer.parseInt(br.readLine());  cut(n);  System.out.print("! ");  for(int i=0 ; i<8 ; i++) System.out.print(ans[i]+" ");  System.out.println(); }  public static void solve(int x1, int y1, int x2, int y2, int t) throws Exception{  int l=x1, r=x2;  int xx1,yy1,xx2,yy2;  while(l<r){  int mid = (l+r)/2;  if(query(x1,y1,mid,y2)==1) r=mid;  else l=mid+1;  }  xx2 = l;  l=x1; r=x2;  while(r>l){  int mid = (l+r+1)/2;  if(query(mid,y1,x2,y2)==1) l = mid;  else r=mid-1;  }  xx1 = l;  l=y1; r=y2;  while(l<r){  int mid = (l+r)/2;  if(query(x1,y1,x2,mid)==1) r=mid;  else l=mid+1;  }  yy2=l;  l=y1;r=y2;  while(r>l){  int mid = (l+r+1)/2;  if(query(x1,mid,x2,y2)==1) l=mid;  else r=mid-1;  }  yy1 = l;  ans[t] = xx1; ans[t+1] = yy1 ; ans[t+2] = xx2; ans[t+3] = yy2;  } public static void cut(int n) throws Exception{  int l=1, r=n;  while(l<r){  int mid = (l+r)/2;  if(query(1,1,n,mid)==0) l=mid+1;  else r = mid;  }  if(query(1,1,n,l)==1 && query(1,l+1,n,n)==1){  solve(1,1,n,l,0);  solve(1,l+1,n,n,4);  return;  }  l=1;r=n;  while(l<r){  int mid = (l+r)/2;  if(query(1,1,mid,n)==0) l=mid+1;  else r=mid;  }  solve(1,1,l,n,0);  solve(l+1,1,n,n,4); } public static int query(int x1, int y1, int x2, int y2) throws Exception{  System.out.println("?"+x1+" "+y1+" "+x2+" "+y2);  System.out.flush();  int q = Integer.parseInt(br.readLine());  return q; } }
0,public class A470 {   public static void main(String[] args) {   Scanner sc = new Scanner(System.in);  int n=sc.nextInt();  int start=4;   while(true){   if((start%2==0||start%3==0)&&((n-start)%2==0||(n-start)%3==0))  {  System.out.println(start+" "+(n-start));  return;  }  else  start++;      }      } }
4,public class Main {  private static final String NO = "NO"; private static final String YES = "YES"; InputStream is; PrintWriter out; String INPUT = "";  private static long MOD = 1000000007; private static final int MAXN = 100000;  void solve() {  int T = 1;  for (int i = 0; i < T; i++) {  solve(i);  } }  static final int N = 405; static long[][] dp = new long[N][N]; static long[] p2 = new long[N]; static long[] fac = new long[N]; static long[] ifac = new long[N];  public static long bino(int n, int k) {  return ((fac[n] * ifac[n - k]) % MOD * ifac[k]) % MOD; }  void solve(int T) {  int n = ni();  MOD = nl();  fac[0] = 1;  ifac[0] = 1;  p2[0] = 1;  for (int i = 1; i <= n; ++i) {  fac[i] = (fac[i - 1] * i) % MOD;  p2[i] = (p2[i - 1] * 2) % MOD;  }  ifac[n] = power(fac[n], MOD - 2);  for (int i = n - 1; i > 0; --i) {  ifac[i] = (ifac[i + 1] * (i + 1)) % MOD;  }  dp[0][0] = 1;  for (int i = 0; i <= n; ++i) {  for (int j = 0; j <= i; ++j) {   for (int k = 1; i + k <= n; ++k) {   dp[i + k + 1][j    + k] = (dp[i + k + 1][j + k] + ((dp[i][j] * p2[k - 1]) % MOD * bino(k + j, k)) % MOD) % MOD;   }  }  }  long ans = 0;  for (int i = 0; i <= n; ++i) {  ans = (ans + dp[n + 1][i]) % MOD;  }  out.println(ans); }   long power(long a, long b) {  long x = 1, y = a;  while (b > 0) {  if (b % 2 != 0) {   x = (x * y) % MOD;  }  y = (y * y) % MOD;  b /= 2;  }  return x % MOD; }  private long gcd(long a, long b) {  while (a != 0) {  long tmp = b % a;  b = a;  a = tmp;  }  return b; }  void run() throws Exception {  is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());  out = new PrintWriter(System.out);  long s = System.currentTimeMillis();  solve();  out.flush();  if (!INPUT.isEmpty())  tr(System.currentTimeMillis() - s + "ms"); }  public static void main(String[] args) throws Exception {  new Main().run(); }  private byte[] inbuf = new byte[1024]; public int lenbuf = 0, ptrbuf = 0;  private int readByte() {  if (lenbuf == -1)  throw new InputMismatchException();  if (ptrbuf >= lenbuf) {  ptrbuf = 0;  try {   lenbuf = is.read(inbuf);  } catch (IOException e) {   throw new InputMismatchException();  }  if (lenbuf <= 0)   return -1;  }  return inbuf[ptrbuf++]; }  private boolean isSpaceChar(int c) {  return !(c >= 33 && c <= 126); }  private int skip() {  int b;  while ((b = readByte()) != -1 && isSpaceChar(b))  ;  return b; }  private double nd() {  return Double.parseDouble(ns()); }  private char nc() {  return (char) skip(); }  private String ns() {  int b = skip();  StringBuilder sb = new StringBuilder();  while (!(isSpaceChar(b))) {        sb.appendCodePoint(b);  b = readByte();  }  return sb.toString(); }  private char[] ns(int n) {  char[] buf = new char[n];  int b = skip(), p = 0;  while (p < n) {  if (!(isSpaceChar(b)))   buf[p++] = (char) b;  b = readByte();  }  return n == p ? buf : Arrays.copyOf(buf, p); }  private char[][] nm(int n, int m) {  char[][] map = new char[n][];  for (int i = 0; i < n; i++)  map[i] = ns(m);  return map; }  private int[] na(int n) {  int[] a = new int[n];  for (int i = 0; i < n; i++)  a[i] = ni();  return a; }  private List<Integer> na2(int n) {  List<Integer> a = new ArrayList<Integer>();  for (int i = 0; i < n; i++)  a.add(ni());  return a; }  private int[][] na(int n, int m) {  int[][] a = new int[n][];  for (int i = 0; i < n; i++)  a[i] = na(m);  return a; }  private int ni() {  int num = 0, b;  boolean minus = false;  while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))  ;  if (b == '-') {  minus = true;  b = readByte();  }  while (true) {  if (b >= '0' && b <= '9') {   num = num * 10 + (b - '0');  } else {   return minus ? -num : num;  }  b = readByte();  } }  private long[] nl(int n) {  long[] a = new long[n];  for (int i = 0; i < n; i++)  a[i] = nl();  return a; }  private long[][] nl(int n, int m) {  long[][] a = new long[n][];  for (int i = 0; i < n; i++)  a[i] = nl(m);  return a; }  private long nl() {  long num = 0;  int b;  boolean minus = false;  while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))  ;  if (b == '-') {  minus = true;  b = readByte();  }  while (true) {  if (b >= '0' && b <= '9') {   num = num * 10 + (b - '0');  } else {   return minus ? -num : num;  }  b = readByte();  } }  private static void tr(Object... o) {  System.out.println(Arrays.deepToString(o)); } }
2,public class Main { public static void main(String[] args) {  InputStream inputStream = System.in;  OutputStream outputStream = System.out;  InputReader in = new InputReader(inputStream);  PrintWriter out = new PrintWriter(outputStream);  TaskB solver = new TaskB();  solver.solve(1, in, out);  out.close(); } } class TaskB {  public void solve(int testNumber, InputReader in, PrintWriter out) {   long N = in.nextLong();   long K = in.nextLong();   if(N == 1) {    out.println(0);    return;   }   if(N <= K) {    out.println(1);    return;   }   long st = 1;   long dr = K - 1;   long m;   long ans = -1;   while(st <= dr) {    m = (st + dr) / 2;    if(get(m, K) <= N) {     ans = m;     st = m + 1;    }    else dr = m - 1;   }   N -= get(ans, K);   if(ans == -1 || (ans == K - 1 && N > 0) ) {    out.println(-1);    return;   }   if(N > 0)    ans++;   out.println(ans);  }  private long get(long p, long K) {   long sum = (K - p + 1 + K) * p / 2;   long extra = p - 1;   return sum - extra;  } } class InputReader {  private InputStream stream;  private byte[] buf = new byte[1024];  private int curChar;  private int numChars;  public InputReader(InputStream stream) {   this.stream = stream;  }  public int read() {   if (numChars == -1)    throw new InputMismatchException();   if (curChar >= numChars) {    curChar = 0;    try {     numChars = stream.read(buf);    } catch (IOException e) {     throw new InputMismatchException();    }    if (numChars <= 0)     return -1;   }   return buf[curChar++];  }  public long nextLong() {   return Long.parseLong(nextString());  }  public String nextString() {   int c = read();   while (isSpaceChar(c))    c = read();   StringBuffer res = new StringBuffer();   do {    res.appendCodePoint(c);    c = read();   } while (!isSpaceChar(c));   return res.toString();  }  private boolean isSpaceChar(int c) {   return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;  }  }
1,public class B { InputStream is; FastWriter out; String INPUT = "";  void solve() {  for(int T = ni();T > 0;T--)go(); }  void go() {  int n = ni();  if(n % 2 == 0){  int u = (int)Math.sqrt(n/2);  if(u*u == n/2){   out.println("YES");   return;  }  }  if(n % 4 == 0){  int u = (int)Math.sqrt(n/4);  if(u*u == n/4){   out.println("YES");   return;  }  }  out.println("NO"); }  void run() throws Exception {  is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());  out = new FastWriter(System.out);   long s = System.currentTimeMillis();  solve();  out.flush();  tr(System.currentTimeMillis()-s+"ms"); }  public static void main(String[] args) throws Exception { new B().run(); }  private byte[] inbuf = new byte[1024]; public int lenbuf = 0, ptrbuf = 0;  private int readByte() {  if(lenbuf == -1)throw new InputMismatchException();  if(ptrbuf >= lenbuf){  ptrbuf = 0;  try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }  if(lenbuf <= 0)return -1;  }  return inbuf[ptrbuf++]; }  private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }  private double nd() { return Double.parseDouble(ns()); } private char nc() { return (char)skip(); }  private String ns() {  int b = skip();  StringBuilder sb = new StringBuilder();  while(!(isSpaceChar(b))){   sb.appendCodePoint(b);  b = readByte();  }  return sb.toString(); }  private char[] ns(int n) {  char[] buf = new char[n];  int b = skip(), p = 0;  while(p < n && !(isSpaceChar(b))){  buf[p++] = (char)b;  b = readByte();  }  return n == p ? buf : Arrays.copyOf(buf, p); }  private int[] na(int n) {  int[] a = new int[n];  for(int i = 0;i < n;i++)a[i] = ni();  return a; }  private long[] nal(int n) {  long[] a = new long[n];  for(int i = 0;i < n;i++)a[i] = nl();  return a; }  private char[][] nm(int n, int m) {  char[][] map = new char[n][];  for(int i = 0;i < n;i++)map[i] = ns(m);  return map; }  private int[][] nmi(int n, int m) {  int[][] map = new int[n][];  for(int i = 0;i < n;i++)map[i] = na(m);  return map; }  private int ni() { return (int)nl(); }  private long nl() {  long num = 0;  int b;  boolean minus = false;  while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));  if(b == '-'){  minus = true;  b = readByte();  }  while(true){  if(b >= '0' && b <= '9'){   num = num * 10 + (b - '0');  }else{   return minus ? -num : num;  }  b = readByte();  } }  public static class FastWriter {  private static final int BUF_SIZE = 1<<13;  private final byte[] buf = new byte[BUF_SIZE];  private final OutputStream out;  private int ptr = 0;  private FastWriter(){out = null;}  public FastWriter(OutputStream os)  {  this.out = os;  }  public FastWriter(String path)  {  try {   this.out = new FileOutputStream(path);  } catch (FileNotFoundException e) {   throw new RuntimeException("FastWriter");  }  }  public FastWriter write(byte b)  {  buf[ptr++] = b;  if(ptr == BUF_SIZE)innerflush();  return this;  }  public FastWriter write(char c)  {  return write((byte)c);  }  public FastWriter write(char[] s)  {  for(char c : s){   buf[ptr++] = (byte)c;   if(ptr == BUF_SIZE)innerflush();  }  return this;  }  public FastWriter write(String s)  {  s.chars().forEach(c -> {   buf[ptr++] = (byte)c;   if(ptr == BUF_SIZE)innerflush();  });  return this;  }  private static int countDigits(int l) {  if (l >= 1000000000) return 10;  if (l >= 100000000) return 9;  if (l >= 10000000) return 8;  if (l >= 1000000) return 7;  if (l >= 100000) return 6;  if (l >= 10000) return 5;  if (l >= 1000) return 4;  if (l >= 100) return 3;  if (l >= 10) return 2;  return 1;  }  public FastWriter write(int x)  {  if(x == Integer.MIN_VALUE){   return write((long)x);  }  if(ptr + 12 >= BUF_SIZE)innerflush();  if(x < 0){   write((byte)'-');   x = -x;  }  int d = countDigits(x);  for(int i = ptr + d - 1;i >= ptr;i--){   buf[i] = (byte)('0'+x%10);   x /= 10;  }  ptr += d;  return this;  }  private static int countDigits(long l) {  if (l >= 1000000000000000000L) return 19;  if (l >= 100000000000000000L) return 18;  if (l >= 10000000000000000L) return 17;  if (l >= 1000000000000000L) return 16;  if (l >= 100000000000000L) return 15;  if (l >= 10000000000000L) return 14;  if (l >= 1000000000000L) return 13;  if (l >= 100000000000L) return 12;  if (l >= 10000000000L) return 11;  if (l >= 1000000000L) return 10;  if (l >= 100000000L) return 9;  if (l >= 10000000L) return 8;  if (l >= 1000000L) return 7;  if (l >= 100000L) return 6;  if (l >= 10000L) return 5;  if (l >= 1000L) return 4;  if (l >= 100L) return 3;  if (l >= 10L) return 2;  return 1;  }  public FastWriter write(long x)  {  if(x == Long.MIN_VALUE){   return write("" + x);  }  if(ptr + 21 >= BUF_SIZE)innerflush();  if(x < 0){   write((byte)'-');   x = -x;  }  int d = countDigits(x);  for(int i = ptr + d - 1;i >= ptr;i--){   buf[i] = (byte)('0'+x%10);   x /= 10;  }  ptr += d;  return this;  }  public FastWriter write(double x, int precision)  {  if(x < 0){   write('-');   x = -x;  }  x += Math.pow(10, -precision)/2;    write((long)x).write(".");  x -= (long)x;  for(int i = 0;i < precision;i++){   x *= 10;   write((char)('0'+(int)x));   x -= (int)x;  }  return this;  }  public FastWriter writeln(char c){  return write(c).writeln();  }  public FastWriter writeln(int x){  return write(x).writeln();  }  public FastWriter writeln(long x){  return write(x).writeln();  }  public FastWriter writeln(double x, int precision){  return write(x, precision).writeln();  }  public FastWriter write(int... xs)  {  boolean first = true;  for(int x : xs) {   if (!first) write(' ');   first = false;   write(x);  }  return this;  }  public FastWriter write(long... xs)  {  boolean first = true;  for(long x : xs) {   if (!first) write(' ');   first = false;   write(x);  }  return this;  }  public FastWriter writeln()  {  return write((byte)'\n');  }  public FastWriter writeln(int... xs)  {  return write(xs).writeln();  }  public FastWriter writeln(long... xs)  {  return write(xs).writeln();  }  public FastWriter writeln(char[] line)  {  return write(line).writeln();  }  public FastWriter writeln(char[]... map)  {  for(char[] line : map)write(line).writeln();  return this;  }  public FastWriter writeln(String s)  {  return write(s).writeln();  }  private void innerflush()  {  try {   out.write(buf, 0, ptr);   ptr = 0;  } catch (IOException e) {   throw new RuntimeException("innerflush");  }  }  public void flush()  {  innerflush();  try {   out.flush();  } catch (IOException e) {   throw new RuntimeException("flush");  }  }  public FastWriter print(byte b) { return write(b); }  public FastWriter print(char c) { return write(c); }  public FastWriter print(char[] s) { return write(s); }  public FastWriter print(String s) { return write(s); }  public FastWriter print(int x) { return write(x); }  public FastWriter print(long x) { return write(x); }  public FastWriter print(double x, int precision) { return write(x, precision); }  public FastWriter println(char c){ return writeln(c); }  public FastWriter println(int x){ return writeln(x); }  public FastWriter println(long x){ return writeln(x); }  public FastWriter println(double x, int precision){ return writeln(x, precision); }  public FastWriter print(int... xs) { return write(xs); }  public FastWriter print(long... xs) { return write(xs); }  public FastWriter println(int... xs) { return writeln(xs); }  public FastWriter println(long... xs) { return writeln(xs); }  public FastWriter println(char[] line) { return writeln(line); }  public FastWriter println(char[]... map) { return writeln(map); }  public FastWriter println(String s) { return writeln(s); }  public FastWriter println() { return writeln(); } }  public void trnz(int... o) {  for(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+":"+o[i]+" ");  System.out.println(); }   public void trt(long... o) {  Queue<Integer> stands = new ArrayDeque<>();  for(int i = 0;i < o.length;i++){  for(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));  }  System.out.println(stands); }  public void tf(boolean... r) {  for(boolean x : r)System.out.print(x?'#':'.');  System.out.println(); }  public void tf(boolean[]... b) {  for(boolean[] r : b) {  for(boolean x : r)System.out.print(x?'#':'.');  System.out.println();  }  System.out.println(); }  public void tf(long[]... b) {  if(INPUT.length() != 0) {  for (long[] r : b) {   for (long x : r) {   for (int i = 0; i < 64; i++) {    System.out.print(x << ~i < 0 ? '#' : '.');   }   }   System.out.println();  }  System.out.println();  } }  public void tf(long... b) {  if(INPUT.length() != 0) {  for (long x : b) {   for (int i = 0; i < 64; i++) {   System.out.print(x << ~i < 0 ? '#' : '.');   }  }  System.out.println();  } }  private boolean oj = System.getProperty("ONLINE_JUDGE") != null; private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); } }
5,public class Main{   static class Run implements Runnable{       final boolean consoleIO = true;    final String inFile = "input.txt";    final String outFile = "output.txt";       Pair<Double,Double>[] p;    int n, t;       int find() {     int count = 2;         for(int i = 0; i < n-1; ++i) {      double dif = p[i+1].a-p[i].b;      int comp = Double.compare(dif,t);           if(comp==0)       count+=1;      else       if(comp>0)        count+=2;     }         return count;    }       @Override    public void run() {     n = nextInt();     t = nextInt();         p = new Pair[n];     for(int i = 0; i < n; ++i) {      int x = nextInt()+1000;      int a = nextInt();           double h = a/(double)2;      p[i] = new Pair<Double,Double>(x-h,x+h);     }         Arrays.sort(p, new PComparator());     print(find());     close();    }       class PComparator implements Comparator<Pair<Double,Double>> {     @Override     public int compare(Pair<Double, Double> o1,       Pair<Double, Double> o2) {           return Double.compare(o1.a, o2.a);     }    }      BufferedReader in;    PrintWriter out;    StringTokenizer strTok;       Run() {     if (consoleIO) {      initConsoleIO();     }     else {      initFileIO();     }    }       void initConsoleIO() {     in = new BufferedReader(new InputStreamReader(System.in));     out = new PrintWriter(new OutputStreamWriter(System.out));    }       void initFileIO() {     try {      in = new BufferedReader(new FileReader(inFile));      out = new PrintWriter(new FileWriter(outFile));     } catch (FileNotFoundException e) {      e.printStackTrace();     } catch (IOException e) {      e.printStackTrace();     }    }       void close() {     try {      in.close();      out.close();     } catch (IOException e) {      e.printStackTrace();     }    }       int nextInt() {     return Integer.parseInt(nextToken());    }       double nextDouble() {     return Double.parseDouble(nextToken());    }       float nextFloat() {     return Float.parseFloat(nextToken());    }       long nextLong() {     return Long.parseLong(nextToken());    }       String nextLine() {     try {      return in.readLine();     } catch (IOException e) {      return "__NULL";     }    }       boolean hasMoreTokens() {     return (strTok == null) || (strTok.hasMoreTokens());    }       String nextToken() {     while (strTok == null || !strTok.hasMoreTokens()) {      String line;      try {       line = in.readLine();       strTok = new StringTokenizer(line);      } catch (IOException e) {       e.printStackTrace();      }     }         return strTok.nextToken();    }       void cout(Object o){     System.out.println(o);    }       void print(Object o) {     out.write(o.toString());    }       void println(Object o) {     out.write(o.toString() + '\n');    }       void printf(String format, Object... args) {     out.printf(format, args);    }       String sprintf(String format, Object... args) {    return MessageFormat.format(format, args);   }   }     static class Pair<A, B> {    A a;    B b;       A f() {     return a;    }       B s() {     return b;    }       Pair(A a, B b) {     this.a = a;     this.b = b;    }       Pair(Pair<A, B> p) {     a = p.f();     b = p.s();    }       @Override    public String toString() {     return a+" "+b;    }   }     public static void main(String[] args) throws IOException {    Run run = new Run();    Thread thread = new Thread(run);    thread.run();   }  }
1,public class Array224B { public static void main(String[] args) throws IOException {  BufferedReader f = new BufferedReader(new InputStreamReader(System.in));  StringTokenizer st = new StringTokenizer(f.readLine());  int n = Integer.parseInt(st.nextToken());  int k = Integer.parseInt(st.nextToken());  int[] array = new int[n];  int[] visited = new int[100002];  st = new StringTokenizer(f.readLine());  for(int i=0;i<n;i++){  array[i] = Integer.parseInt(st.nextToken());  }  int count = 0;  int begin = array[0];  while(count<n && array[count] == begin){  count++;  }  count--;  int kcount = 1;  visited[array[count]]++;  int bindex = count;  boolean good=true;  count++;  while(kcount<k){  if(count==n){   System.out.println("-1 -1");   good=false;   break;  }  if(visited[array[count]]==0){   kcount++;  }  visited[array[count]]++;  count++;  }  if(good&&k!=1){  for(int i=bindex;i<count;i++){  if(visited[array[i]]==1){   break;  }  bindex++;  visited[array[i]]--;  }  for(int i=count-1;i>bindex;i--){  if(visited[array[i]]==1){   break;  }  count--;  visited[array[i]]--;  }  }  if(k==1){  System.out.println("1 1");  }  else if(good){  System.out.println(bindex+1+" "+count);  } } }
2,public class C { FastScanner in; PrintWriter out; boolean systemIO = true;  public static void quickSort(int[] a, int from, int to) {  if (to - from <= 1) {  return;  }  int i = from;  int j = to - 1;  int x = a[from + (new Random()).nextInt(to - from)];  while (i <= j) {  while (a[i] < x) {   i++;  }  while (a[j] > x) {   j--;  }  if (i <= j) {   int t = a[i];   a[i] = a[j];   a[j] = t;   i++;   j--;  }  }  quickSort(a, from, j + 1);  quickSort(a, j + 1, to); }  long mod = 1000000007;  public long pow(long k) {  if (k == 0) {  return 1L;  }  if (k == 1) {  return 2L;  }  if (k % 2 == 1) {  return (2L * pow(k - 1)) % mod;  }  long x = pow(k / 2);  return (x * x) % mod; }  public void solve() {  long x = in.nextLong();  if (x == 0) {  out.println(0);  return;  }  x %= mod;  long k = in.nextLong();  long pow = pow(k);  long ans = 1;  ans = (ans - pow + mod) % mod;  ans = (ans + (((2 * pow) % mod) * x) % mod) % mod;  out.println(ans); }  public void run() {  try {  if (systemIO) {   in = new FastScanner(System.in);   out = new PrintWriter(System.out);  } else {   in = new FastScanner(new File("input.txt"));   out = new PrintWriter(new File("output.txt"));  }  solve();   out.close();  } catch (IOException e) {  e.printStackTrace();  } }  class FastScanner {  BufferedReader br;  StringTokenizer st;  FastScanner(File f) {  try {   br = new BufferedReader(new FileReader(f));  } catch (FileNotFoundException e) {   e.printStackTrace();  }  }  FastScanner(InputStream f) {  br = new BufferedReader(new InputStreamReader(f));  }  String nextLine() {  try {   return br.readLine();  } catch (IOException e) {   return null;  }  }  String next() {  while (st == null || !st.hasMoreTokens()) {   try {   st = new StringTokenizer(br.readLine());   } catch (IOException e) {   e.printStackTrace();   }  }  return st.nextToken();  }  int nextInt() {  return Integer.parseInt(next());  }  long nextLong() {  return Long.parseLong(next());  }  double nextDouble() {  return Double.parseDouble(next());  }  }   public static void main(String[] args) {  new C().run(); } }
4,public class Main {  static FastScanner fs=new FastScanner();  static class FastScanner {   BufferedReader br=new BufferedReader(new InputStreamReader(System.in));   StringTokenizer st=new StringTokenizer("");   public String next() {    while (!st.hasMoreElements())     try {      st=new StringTokenizer(br.readLine());     } catch (IOException e) {      e.printStackTrace();     }    return st.nextToken();   }   int Int() {    return Integer.parseInt(next());   }   long Long() {    return Long.parseLong(next());   }   String Str(){    return next();   }  }   public static void main (String[] args) throws java.lang.Exception {   PrintWriter out = new PrintWriter(System.out);   int primes[]=new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,     73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167,     173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269,     271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,     383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487,     491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,     613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727,     733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607,     1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721,     1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847,     1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973,     1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373,     3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517,     3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999};   int T=Int();   for(int t=0;t<T;t++){    int n=Int();    int k=Int();    int A[]=new int[n];    for(int i=0;i<n;i++){     A[i]=Int();    }    Sol sol=new Sol();    sol.solution(out,A,k,primes);   }   out.flush();  }  public static int Int(){   return fs.Int();  }  public static long Long(){   return fs.Long();  }  public static String Str(){   return fs.Str();  } }  class Sol{  int dp[][];  public void solution(PrintWriter out,int A[],int K,int primes[]){   int n=A.length;   int id=0;   int dp[][]=new int[n+1][K+1];   for(int i=0;i<dp.length;i++){    Arrays.fill(dp[i],n);   }      Map<String,Integer>f=new HashMap<>();   for(int i=0;i<A.length;i++){    String h=hash(A[i],primes);    if(!f.containsKey(h)){     f.put(h,id);     A[i]=id;     id++;    }    else{     A[i]=f.get(h);    }   }    int dis[][]=new int[A.length][K+1];   for(int k=0;k<=K;k++){    int r=n-1;    Map<Integer,Integer>ff=new HashMap<>();    for(int i=n-1;i>=0;i--){     put(ff,A[i]);     while(ff.size()+k<(r-i+1)){      remove(ff,A[r]);      dis[r][k]=i+1;      r--;     }    }   }    for(int i=0;i<n;i++){    for(int j=0;j<=K;j++){     if(j>=i+1){      dp[i][j]=1;      continue;     }     for(int k=0;k<=j;k++){      int reach=dis[i][k];      if(reach==0)dp[i][j]=1;      else dp[i][j]=Math.min(dp[i][j],1+dp[reach-1][j-k]);     }    }   }   out.println(dp[n-1][K]);  }  public void put(Map<Integer,Integer>f,int key){   if(!f.containsKey(key))f.put(key,1);   else f.put(key,f.get(key)+1);  }  public void remove(Map<Integer,Integer>f,int key){   f.put(key,f.get(key)-1);   if(f.get(key)==0)f.remove(key);  }   public String hash(int n,int primes[]){   StringBuilder str=new StringBuilder("a,");   for(int i:primes){    if(i*i>n)break;    int cnt=0;    while(n%i==0){     n/=i;     cnt++;    }    cnt%=2;    if(cnt!=0)str.append(i+",");   }   if(n!=1)str.append(n+",");   return str.toString();  } }
